<!DOCTYPE HTML>
<html lang="vi" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>JS - Kho code của duykhanh471</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../index.html"><strong aria-hidden="true">1.</strong> Trang chủ dự án</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.</strong> HTML/CSS/JS</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../html-css/index.html"><strong aria-hidden="true">2.1.</strong> HTML/CSS</a></li><li class="chapter-item expanded "><a href="../js/index.html" class="active"><strong aria-hidden="true">2.2.</strong> JS</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../js/co-ban.html"><strong aria-hidden="true">2.2.1.</strong> Cơ bản</a></li><li class="chapter-item expanded "><a href="../js/array.html"><strong aria-hidden="true">2.2.2.</strong> Array</a></li><li class="chapter-item expanded "><a href="../js/ngay-gio.html"><strong aria-hidden="true">2.2.3.</strong> Ngày giờ</a></li><li class="chapter-item expanded "><a href="../js/string.html"><strong aria-hidden="true">2.2.4.</strong> String</a></li><li class="chapter-item expanded "><a href="../js/object.html"><strong aria-hidden="true">2.2.5.</strong> Object</a></li></ol></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.</strong> Java</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../java/1.html"><strong aria-hidden="true">3.1.</strong> Giới thiệu Java, JVM</a></li><li class="chapter-item expanded "><a href="../java/2.html"><strong aria-hidden="true">3.2.</strong> Biến, phạm vi, kiểu dữ liệu, toán tử trong Java</a></li><li class="chapter-item expanded "><a href="../java/3.html"><strong aria-hidden="true">3.3.</strong> Hàm và câu lệnh điều kiện</a></li><li class="chapter-item expanded "><a href="../java/4.html"><strong aria-hidden="true">3.4.</strong> Nhập xuất dữ liệu trong Java</a></li><li class="chapter-item expanded "><a href="../java/5.html"><strong aria-hidden="true">3.5.</strong> Vì sao nên sử dụng StringBuffer</a></li><li class="chapter-item expanded "><a href="../java/6.html"><strong aria-hidden="true">3.6.</strong> Hướng dẫn Java Reflection</a></li><li class="chapter-item expanded "><a href="../java/7.html"><strong aria-hidden="true">3.7.</strong> Hướng dẫn tự tạo một Annotations</a></li><li class="chapter-item expanded "><a href="../java/8.html"><strong aria-hidden="true">3.8.</strong> Functional Interfaces & Lambda Expressions cực dễ hiểu</a></li><li class="chapter-item expanded "><a href="../java/9.html"><strong aria-hidden="true">3.9.</strong> Hướng dẫn Stream API</a></li><li class="chapter-item expanded "><a href="../java/10.html"><strong aria-hidden="true">3.10.</strong> Khái niệm ThreadPool và Executor trong Java</a></li><li class="chapter-item expanded "><a href="../java/11.html"><strong aria-hidden="true">3.11.</strong> ThreadPoolExecutor và nguyên tắc quản lý pool size</a></li><li class="chapter-item expanded "><a href="../java/12.html"><strong aria-hidden="true">3.12.</strong> Giới thiệu Reactive Programming với Reactor</a></li><li class="chapter-item expanded "><a href="../java/13.html"><strong aria-hidden="true">3.13.</strong> Giới thiệu Reactor Core</a></li><li class="chapter-item expanded "><a href="../java/14.html"><strong aria-hidden="true">3.14.</strong> Abstract Interface</a></li><li class="chapter-item expanded "><a href="../java/15.html"><strong aria-hidden="true">3.15.</strong> Thread</a></li><li class="chapter-item expanded "><a href="../java/16.html"><strong aria-hidden="true">3.16.</strong> Optional</a></li><li class="chapter-item expanded "><a href="../java/snippets/index.html"><strong aria-hidden="true">3.17.</strong> Kho snippets</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../java/snippets/algorithms.html"><strong aria-hidden="true">3.17.1.</strong> Algorithms</a></li><li class="chapter-item expanded "><a href="../java/snippets/array.html"><strong aria-hidden="true">3.17.2.</strong> Array</a></li><li class="chapter-item expanded "><a href="../java/snippets/cls.html"><strong aria-hidden="true">3.17.3.</strong> CLS</a></li><li class="chapter-item expanded "><a href="../java/snippets/date.html"><strong aria-hidden="true">3.17.4.</strong> Date</a></li><li class="chapter-item expanded "><a href="../java/snippets/encoding.html"><strong aria-hidden="true">3.17.5.</strong> Encoding & Decoding</a></li><li class="chapter-item expanded "><a href="../java/snippets/file.html"><strong aria-hidden="true">3.17.6.</strong> File</a></li><li class="chapter-item expanded "><a href="../java/snippets/io.html"><strong aria-hidden="true">3.17.7.</strong> IO</a></li><li class="chapter-item expanded "><a href="../java/snippets/math.html"><strong aria-hidden="true">3.17.8.</strong> Math</a></li><li class="chapter-item expanded "><a href="../java/snippets/media.html"><strong aria-hidden="true">3.17.9.</strong> Media</a></li><li class="chapter-item expanded "><a href="../java/snippets/network.html"><strong aria-hidden="true">3.17.10.</strong> Network</a></li><li class="chapter-item expanded "><a href="../java/snippets/string.html"><strong aria-hidden="true">3.17.11.</strong> String</a></li><li class="chapter-item expanded "><a href="../java/snippets/thread.html"><strong aria-hidden="true">3.17.12.</strong> Thread</a></li></ol></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.</strong> Spring Boot</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../spring-boot/index.html"><strong aria-hidden="true">4.1.</strong> Trang chủ khóa học</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.2.</strong> Core</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../spring-boot/core1.html"><strong aria-hidden="true">4.2.1.</strong> Khái niệm tight-coupling (liên kết ràng buộc) và cách loosely coupled</a></li><li class="chapter-item expanded "><a href="../spring-boot/core2.html"><strong aria-hidden="true">4.2.2.</strong> Giải thích Dependency Injection (DI) và IoC</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.3.</strong> Spring Boot</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../spring-boot/sb1.html"><strong aria-hidden="true">4.3.1.</strong> Hướng dẫn @Component và @Autowired</a></li><li class="chapter-item expanded "><a href="../spring-boot/sb2.html"><strong aria-hidden="true">4.3.2.</strong> @Autowired - @Primary - @Qualifier</a></li><li class="chapter-item expanded "><a href="../spring-boot/sb3.html"><strong aria-hidden="true">4.3.3.</strong> Spring Bean Life Cycle + @PostConstruct và @PreDestroy</a></li><li class="chapter-item expanded "><a href="../spring-boot/sb4.html"><strong aria-hidden="true">4.3.4.</strong> @Component vs @Service vs @Repository</a></li><li class="chapter-item expanded "><a href="../spring-boot/sb5.html"><strong aria-hidden="true">4.3.5.</strong> Component Scan là gì?</a></li><li class="chapter-item expanded "><a href="../spring-boot/sb6.html"><strong aria-hidden="true">4.3.6.</strong> @Configuration và @Bean</a></li><li class="chapter-item expanded "><a href="../spring-boot/sb7.html"><strong aria-hidden="true">4.3.7.</strong> Spring Boot Application Config và @Value</a></li><li class="chapter-item expanded "><a href="../spring-boot/sb8.html"><strong aria-hidden="true">4.3.8.</strong> Tạo Web Helloworld với @Controller + Thymeleaf</a></li><li class="chapter-item expanded "><a href="../spring-boot/sb9.html"><strong aria-hidden="true">4.3.9.</strong> Giải thích cách Thymeleaf vận hành + Expression + Demo Full</a></li><li class="chapter-item expanded "><a href="../spring-boot/sb10.html"><strong aria-hidden="true">4.3.10.</strong> @RequestMapping + @PostMapping + @ModelAttribute + @RequestParam + Web To-Do với Thymeleaf</a></li><li class="chapter-item expanded "><a href="../spring-boot/sb11.html"><strong aria-hidden="true">4.3.11.</strong> Hướng dẫn Spring Boot JPA + MySQL</a></li><li class="chapter-item expanded "><a href="../spring-boot/sb12.html"><strong aria-hidden="true">4.3.12.</strong> Spring JPA Method + @Query</a></li><li class="chapter-item expanded "><a href="../spring-boot/sb13.html"><strong aria-hidden="true">4.3.13.</strong> Chi tiết Spring Boot + Thymeleaf + MySQL + i18n + Web Demo</a></li><li class="chapter-item expanded "><a href="../spring-boot/sb14.html"><strong aria-hidden="true">4.3.14.</strong> Restful API + @RestController + @PathVariable + @RequestBody</a></li><li class="chapter-item expanded "><a href="../spring-boot/sb15.html"><strong aria-hidden="true">4.3.15.</strong> Exception Handling @ExceptionHandler + @RestControllerAdvice / @ControllerAdvice + @ResponseStatus</a></li><li class="chapter-item expanded "><a href="../spring-boot/sb16.html"><strong aria-hidden="true">4.3.16.</strong> Hướng dẫn sử dụng @ConfigurationPropertie</a></li><li class="chapter-item expanded "><a href="../spring-boot/sb17.html"><strong aria-hidden="true">4.3.17.</strong> Chạy nhiều môi trường với Spring Profile</a></li><li class="chapter-item expanded "><a href="../spring-boot/sb18.html"><strong aria-hidden="true">4.3.18.</strong> Hướng dẫn chi tiết Test Spring Boot</a></li><li class="chapter-item expanded "><a href="../spring-boot/sb19.html"><strong aria-hidden="true">4.3.19.</strong> Hướng dẫn chi tiết Test Spring Boot (Phần 2)</a></li><li class="chapter-item expanded "><a href="../spring-boot/sb20.html"><strong aria-hidden="true">4.3.20.</strong> Hướng dẫn toàn tập Mockito</a></li><li class="chapter-item expanded "><a href="../spring-boot/sb21.html"><strong aria-hidden="true">4.3.21.</strong> Hướng dẫn tạo Bean có điều kiện với @Conditional</a></li><li class="chapter-item expanded "><a href="../spring-boot/sb22.html"><strong aria-hidden="true">4.3.22.</strong> Hướng dẫn tự tạo custom @Conditional</a></li><li class="chapter-item expanded "><a href="../spring-boot/sb23.html"><strong aria-hidden="true">4.3.23.</strong> Xử lý sự kiện với @EventListener + @Async</a></li><li class="chapter-item expanded "><a href="../spring-boot/sb24.html"><strong aria-hidden="true">4.3.24.</strong> RESTful API Document Tạo với Spring Boot + Swagger</a></li><li class="chapter-item expanded "><a href="../spring-boot/sb25.html"><strong aria-hidden="true">4.3.25.</strong> RESTful API Document với Spring Boot + OpenApi 3.0</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.4.</strong> Jpa</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../spring-boot/jpa1.html"><strong aria-hidden="true">4.4.1.</strong> 「Jpa」Hibernate là gì?</a></li><li class="chapter-item expanded "><a href="../spring-boot/jpa2.html"><strong aria-hidden="true">4.4.2.</strong> 「Jpa」Hướng dẫn sử dụng Specification (Phần 1)</a></li><li class="chapter-item expanded "><a href="../spring-boot/jpa3.html"><strong aria-hidden="true">4.4.3.</strong> 「Jpa」Hướng dẫn sử dụng @OneToOne</a></li><li class="chapter-item expanded "><a href="../spring-boot/jpa4.html"><strong aria-hidden="true">4.4.4.</strong> 「Jpa」@OneToMany và @ManyToOne</a></li><li class="chapter-item expanded "><a href="../spring-boot/jpa5.html"><strong aria-hidden="true">4.4.5.</strong> 「Jpa」Hướng dẫn @ManyToMany</a></li><li class="chapter-item expanded "><a href="../spring-boot/jpa6.html"><strong aria-hidden="true">4.4.6.</strong> 「Jpa」Hướng dẫn Query phân trang bằng Pageable (Phần 1)</a></li><li class="chapter-item expanded "><a href="../spring-boot/jpa7.html"><strong aria-hidden="true">4.4.7.</strong> 「Jpa」Hướng dẫn sử dụng Criteria API trong Hibernate</a></li><li class="chapter-item expanded "><a href="../spring-boot/jpa8.html"><strong aria-hidden="true">4.4.8.</strong> 「Jpa」Hướng dẫn sử dụng Criteria API trong Hibernate (Phần 2)</a></li><li class="chapter-item expanded "><a href="../spring-boot/jpa9.html"><strong aria-hidden="true">4.4.9.</strong> 「Jpa」Hướng dẫn tự tạo Validator để kiểm tra Model & Entity</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.5.</strong> Spring Security</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../spring-boot/ss1.html"><strong aria-hidden="true">4.5.1.</strong> 「SS」Hướng dẫn Spring Security cơ bản, dễ hiểu</a></li><li class="chapter-item expanded "><a href="../spring-boot/ss2.html"><strong aria-hidden="true">4.5.2.</strong> 「SS」Hướng dẫn Spring Security + Jpa Hibernate</a></li><li class="chapter-item expanded "><a href="../spring-boot/ss3.html"><strong aria-hidden="true">4.5.3.</strong> 「SS」Hướng dẫn Spring Security + JWT (Json Web Token) + Hibernate</a></li></ol></li><li class="chapter-item expanded "><a href="../spring-boot/redis.html"><strong aria-hidden="true">4.6.</strong> Redis</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.</strong> Rust</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../rust/thuat-toan.html"><strong aria-hidden="true">5.1.</strong> Thuật toán</a></li><li class="chapter-item expanded "><a href="../rust/command-line.html"><strong aria-hidden="true">5.2.</strong> CLI</a></li><li class="chapter-item expanded "><a href="../rust/he-thong.html"><strong aria-hidden="true">5.3.</strong> System</a></li><li class="chapter-item expanded "><a href="../rust/internet.html"><strong aria-hidden="true">5.4.</strong> Internet</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.5.</strong> Tệp</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../rust/tep/epub.html"><strong aria-hidden="true">5.5.1.</strong> EPUB</a></li><li class="chapter-item expanded "><a href="../rust/tep/git.html"><strong aria-hidden="true">5.5.2.</strong> Git</a></li><li class="chapter-item expanded "><a href="../rust/tep/html.html"><strong aria-hidden="true">5.5.3.</strong> HTML</a></li><li class="chapter-item expanded "><a href="../rust/tep/rss.html"><strong aria-hidden="true">5.5.4.</strong> RSS</a></li></ol></li><li class="chapter-item expanded "><a href="../rust/essentials/intro.html"><strong aria-hidden="true">5.6.</strong> Essentials</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../rust/essentials/core-concepts/intro.html"><strong aria-hidden="true">5.6.1.</strong> Core Concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../rust/essentials/core-concepts/function.html"><strong aria-hidden="true">5.6.1.1.</strong> Functions</a></li><li class="chapter-item expanded "><a href="../rust/essentials/core-concepts/flow-control.html"><strong aria-hidden="true">5.6.1.2.</strong> Flow Control</a></li><li class="chapter-item expanded "><a href="../rust/essentials/core-concepts/pattern-matching.html"><strong aria-hidden="true">5.6.1.3.</strong> Pattern Matching</a></li><li class="chapter-item expanded "><a href="../rust/essentials/core-concepts/closure.html"><strong aria-hidden="true">5.6.1.4.</strong> Closures</a></li><li class="chapter-item expanded "><a href="../rust/essentials/core-concepts/ownership.html"><strong aria-hidden="true">5.6.1.5.</strong> Ownership</a></li><li class="chapter-item expanded "><a href="../rust/essentials/core-concepts/borrow.html"><strong aria-hidden="true">5.6.1.6.</strong> Borrow</a></li><li class="chapter-item expanded "><a href="../rust/essentials/core-concepts/macro.html"><strong aria-hidden="true">5.6.1.7.</strong> Macros</a></li><li class="chapter-item expanded "><a href="../rust/essentials/core-concepts/concurency.html"><strong aria-hidden="true">5.6.1.8.</strong> Concurency</a></li><li class="chapter-item expanded "><a href="../rust/essentials/core-concepts/error-handling.html"><strong aria-hidden="true">5.6.1.9.</strong> Error Handling</a></li><li class="chapter-item expanded "><a href="../rust/essentials/core-concepts/lifetime.html"><strong aria-hidden="true">5.6.1.10.</strong> Lifetime</a></li><li class="chapter-item expanded "><a href="../rust/essentials/core-concepts/module.html"><strong aria-hidden="true">5.6.1.11.</strong> Modules</a></li><li class="chapter-item expanded "><a href="../rust/essentials/core-concepts/crate.html"><strong aria-hidden="true">5.6.1.12.</strong> Crates</a></li></ol></li><li class="chapter-item expanded "><a href="../rust/essentials/types/intro.html"><strong aria-hidden="true">5.6.2.</strong> Types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../rust/essentials/types/scalar.html"><strong aria-hidden="true">5.6.2.1.</strong> Scalar Types</a></li><li class="chapter-item expanded "><a href="../rust/essentials/types/compound.html"><strong aria-hidden="true">5.6.2.2.</strong> Compound Types</a></li><li class="chapter-item expanded "><a href="../rust/essentials/types/trait.html"><strong aria-hidden="true">5.6.2.3.</strong> Traits</a></li><li class="chapter-item expanded "><a href="../rust/essentials/types/struct.html"><strong aria-hidden="true">5.6.2.4.</strong> Structs</a></li><li class="chapter-item expanded "><a href="../rust/essentials/types/enum.html"><strong aria-hidden="true">5.6.2.5.</strong> Enums</a></li><li class="chapter-item expanded "><a href="../rust/essentials/types/struct-vs-enum.html"><strong aria-hidden="true">5.6.2.6.</strong> Structs vs Enums</a></li><li class="chapter-item expanded "><a href="../rust/essentials/types/generic.html"><strong aria-hidden="true">5.6.2.7.</strong> Generics</a></li><li class="chapter-item expanded "><a href="../rust/essentials/types/type-alias.html"><strong aria-hidden="true">5.6.2.8.</strong> Type Alias</a></li><li class="chapter-item expanded "><a href="../rust/essentials/types/pointer.html"><strong aria-hidden="true">5.6.2.9.</strong> Pointers</a></li><li class="chapter-item expanded "><a href="../rust/essentials/types/vector.html"><strong aria-hidden="true">5.6.2.10.</strong> Vectors</a></li></ol></li><li class="chapter-item expanded "><a href="../rust/essentials/operators/intro.html"><strong aria-hidden="true">5.6.3.</strong> Operators</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../rust/essentials/operators/arithmetic-operations.html"><strong aria-hidden="true">5.6.3.1.</strong> Arithmetic Operations</a></li><li class="chapter-item expanded "><a href="../rust/essentials/operators/comparison-operations.html"><strong aria-hidden="true">5.6.3.2.</strong> Comparison Operators</a></li><li class="chapter-item expanded "><a href="../rust/essentials/operators/logical-operations.html"><strong aria-hidden="true">5.6.3.3.</strong> Logical Operators</a></li><li class="chapter-item expanded "><a href="../rust/essentials/operators/bitwise-operations.html"><strong aria-hidden="true">5.6.3.4.</strong> Bitwise Operators</a></li><li class="chapter-item expanded "><a href="../rust/essentials/operators/assignement-operations.html"><strong aria-hidden="true">5.6.3.5.</strong> Assignment Operators</a></li></ol></li><li class="chapter-item expanded "><a href="../rust/essentials/packaging/intro.html"><strong aria-hidden="true">5.6.4.</strong> Packaging</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../rust/essentials/packaging/no-std.html"><strong aria-hidden="true">5.6.4.1.</strong> ![no_std] Attribute</a></li><li class="chapter-item expanded "><a href="../rust/essentials/packaging/modules.html"><strong aria-hidden="true">5.6.4.2.</strong> Requiring Modules</a></li><li class="chapter-item expanded "><a href="../rust/essentials/packaging/package-names.html"><strong aria-hidden="true">5.6.4.3.</strong> Package Names</a></li><li class="chapter-item expanded "><a href="../rust/essentials/packaging/crates-tag.html"><strong aria-hidden="true">5.6.4.4.</strong> Tag your Crate</a></li><li class="chapter-item expanded "><a href="../rust/essentials/packaging/feature-attribute.html"><strong aria-hidden="true">5.6.4.5.</strong> Feature Attribute</a></li><li class="chapter-item expanded "><a href="../rust/essentials/packaging/features-compilation.html"><strong aria-hidden="true">5.6.4.6.</strong> Features Compilation</a></li></ol></li><li class="chapter-item expanded "><a href="../rust/essentials/std-lib/intro.html"><strong aria-hidden="true">5.6.5.</strong> Standard Library</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../rust/essentials/std-lib/refcell.html"><strong aria-hidden="true">5.6.5.1.</strong> RefCell Struct</a></li><li class="chapter-item expanded "><a href="../rust/essentials/std-lib/rc.html"><strong aria-hidden="true">5.6.5.2.</strong> Rc Type</a></li><li class="chapter-item expanded "><a href="../rust/essentials/std-lib/self-as-type.html"><strong aria-hidden="true">5.6.5.3.</strong> Self Type</a></li><li class="chapter-item expanded "><a href="../rust/essentials/std-lib/self-vs-self.html"><strong aria-hidden="true">5.6.5.4.</strong> Self vs self</a></li><li class="chapter-item expanded "><a href="../rust/essentials/std-lib/self.html"><strong aria-hidden="true">5.6.5.5.</strong> self Keyword</a></li><li class="chapter-item expanded "><a href="../rust/essentials/std-lib/imp.html"><strong aria-hidden="true">5.6.5.6.</strong> imp Keyword</a></li><li class="chapter-item expanded "><a href="../rust/essentials/std-lib/new.html"><strong aria-hidden="true">5.6.5.7.</strong> new Keyword</a></li><li class="chapter-item expanded "><a href="../rust/essentials/std-lib/some.html"><strong aria-hidden="true">5.6.5.8.</strong> Some Keyword</a></li><li class="chapter-item expanded "><a href="../rust/essentials/std-lib/option.html"><strong aria-hidden="true">5.6.5.9.</strong> Option Enum</a></li><li class="chapter-item expanded "><a href="../rust/essentials/std-lib/drive(debug).html"><strong aria-hidden="true">5.6.5.10.</strong> #[derive(Debug)]</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../rust/patterns/intro.html"><strong aria-hidden="true">5.7.</strong> Patterns</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../rust/patterns/creational/intro.html"><strong aria-hidden="true">5.7.1.</strong> Creational</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../rust/patterns/creational/singleton.html"><strong aria-hidden="true">5.7.1.1.</strong> Singleton</a></li><li class="chapter-item expanded "><a href="../rust/patterns/creational/factory-method.html"><strong aria-hidden="true">5.7.1.2.</strong> Factory Method</a></li><li class="chapter-item expanded "><a href="../rust/patterns/creational/abstract-method.html"><strong aria-hidden="true">5.7.1.3.</strong> Abstract Factory</a></li><li class="chapter-item expanded "><a href="../rust/patterns/creational/builder.html"><strong aria-hidden="true">5.7.1.4.</strong> Builder</a></li><li class="chapter-item expanded "><a href="../rust/patterns/creational/prototype.html"><strong aria-hidden="true">5.7.1.5.</strong> Prototype</a></li></ol></li><li class="chapter-item expanded "><a href="../rust/patterns/behavioral/intro.html"><strong aria-hidden="true">5.7.2.</strong> Behavioral</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../rust/patterns/behavioral/observer.html"><strong aria-hidden="true">5.7.2.1.</strong> Observer</a></li><li class="chapter-item expanded "><a href="../rust/patterns/behavioral/strategy.html"><strong aria-hidden="true">5.7.2.2.</strong> Strategy</a></li><li class="chapter-item expanded "><a href="../rust/patterns/behavioral/command.html"><strong aria-hidden="true">5.7.2.3.</strong> Command</a></li><li class="chapter-item expanded "><a href="../rust/patterns/behavioral/chain-of-responsibility.html"><strong aria-hidden="true">5.7.2.4.</strong> Chain of Responsibility</a></li><li class="chapter-item expanded "><a href="../rust/patterns/behavioral/iterator.html"><strong aria-hidden="true">5.7.2.5.</strong> Iterator</a></li><li class="chapter-item expanded "><a href="../rust/patterns/behavioral/mediator.html"><strong aria-hidden="true">5.7.2.6.</strong> Mediator</a></li><li class="chapter-item expanded "><a href="../rust/patterns/behavioral/visitor.html"><strong aria-hidden="true">5.7.2.7.</strong> Visitor</a></li></ol></li><li class="chapter-item expanded "><a href="../rust/patterns/structural/intro.html"><strong aria-hidden="true">5.7.3.</strong> Structural</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../rust/patterns/structural/adapter.html"><strong aria-hidden="true">5.7.3.1.</strong> Adapter</a></li><li class="chapter-item expanded "><a href="../rust/patterns/structural/bridge.html"><strong aria-hidden="true">5.7.3.2.</strong> Bridge</a></li><li class="chapter-item expanded "><a href="../rust/patterns/structural/composite.html"><strong aria-hidden="true">5.7.3.3.</strong> Composite</a></li><li class="chapter-item expanded "><a href="../rust/patterns/structural/decorator.html"><strong aria-hidden="true">5.7.3.4.</strong> Decorator</a></li><li class="chapter-item expanded "><a href="../rust/patterns/structural/facade.html"><strong aria-hidden="true">5.7.3.5.</strong> Facade</a></li><li class="chapter-item expanded "><a href="../rust/patterns/structural/flyweight.html"><strong aria-hidden="true">5.7.3.6.</strong> Flyweight</a></li><li class="chapter-item expanded "><a href="../rust/patterns/structural/proxy.html"><strong aria-hidden="true">5.7.3.7.</strong> Proxy</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../rust/algorithms/intro.html"><strong aria-hidden="true">5.8.</strong> Algorithms</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../rust/algorithms/sorting/intro.html"><strong aria-hidden="true">5.8.1.</strong> Sorting</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../rust/algorithms/sorting/buble.html"><strong aria-hidden="true">5.8.1.1.</strong> Buble Sort</a></li><li class="chapter-item expanded "><a href="../rust/algorithms/sorting/quick.html"><strong aria-hidden="true">5.8.1.2.</strong> Quick Sort</a></li><li class="chapter-item expanded "><a href="../rust/algorithms/sorting/merge.html"><strong aria-hidden="true">5.8.1.3.</strong> Merge Sort</a></li><li class="chapter-item expanded "><a href="../rust/algorithms/sorting/heap.html"><strong aria-hidden="true">5.8.1.4.</strong> Heap Sort</a></li><li class="chapter-item expanded "><a href="../rust/algorithms/sorting/counting.html"><strong aria-hidden="true">5.8.1.5.</strong> Counting Sort</a></li></ol></li><li class="chapter-item expanded "><a href="../rust/algorithms/searching/intro.html"><strong aria-hidden="true">5.8.2.</strong> Searching</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../rust/algorithms/searching/linear.html"><strong aria-hidden="true">5.8.2.1.</strong> Linear Search</a></li><li class="chapter-item expanded "><a href="../rust/algorithms/searching/binary.html"><strong aria-hidden="true">5.8.2.2.</strong> Binary Search</a></li><li class="chapter-item expanded "><a href="../rust/algorithms/searching/depth-first.html"><strong aria-hidden="true">5.8.2.3.</strong> DFS</a></li><li class="chapter-item expanded "><a href="../rust/algorithms/searching/breadth-first.html"><strong aria-hidden="true">5.8.2.4.</strong> BFS</a></li></ol></li><li class="chapter-item expanded "><a href="../rust/algorithms/graph/intro.html"><strong aria-hidden="true">5.8.3.</strong> Graph</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../rust/algorithms/graph/shortest-path.html"><strong aria-hidden="true">5.8.3.1.</strong> Dijkstra’s Algorithm</a></li><li class="chapter-item expanded "><a href="../rust/algorithms/graph/minimum-spanning-tree.html"><strong aria-hidden="true">5.8.3.2.</strong> Kruskal’s Algorithm </a></li><li class="chapter-item expanded "><a href="../rust/algorithms/graph/a-star.html"><strong aria-hidden="true">5.8.3.3.</strong> A* Algorithm </a></li><li class="chapter-item expanded "><a href="../rust/algorithms/graph/all-pairs-shortest-path.html"><strong aria-hidden="true">5.8.3.4.</strong> Floyd-Warshall Algorithm</a></li></ol></li><li class="chapter-item expanded "><a href="../rust/algorithms/dynamic-programming/intro.html"><strong aria-hidden="true">5.8.4.</strong> Dynamic Programming</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../rust/algorithms/dynamic-programming/knapsack-problem.html"><strong aria-hidden="true">5.8.4.1.</strong> Knapsack Problem</a></li><li class="chapter-item expanded "><a href="../rust/algorithms/dynamic-programming/longest-common-subsequence.html"><strong aria-hidden="true">5.8.4.2.</strong> Longest Common Subsequence</a></li><li class="chapter-item expanded "><a href="../rust/algorithms/dynamic-programming/matrix-chain-multiplication.html"><strong aria-hidden="true">5.8.4.3.</strong> Matrix Chain Multiplication</a></li><li class="chapter-item expanded "><a href="../rust/algorithms/dynamic-programming/fibonacci.html"><strong aria-hidden="true">5.8.4.4.</strong> Fibonacci Sequence</a></li></ol></li><li class="chapter-item expanded "><a href="../rust/algorithms/cryptographic/intro.html"><strong aria-hidden="true">5.8.5.</strong> Cryptography</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../rust/algorithms/cryptographic/rsa.html"><strong aria-hidden="true">5.8.5.1.</strong> RSA</a></li><li class="chapter-item expanded "><a href="../rust/algorithms/cryptographic/aes.html"><strong aria-hidden="true">5.8.5.2.</strong> AES</a></li><li class="chapter-item expanded "><a href="../rust/algorithms/cryptographic/sha-256.html"><strong aria-hidden="true">5.8.5.3.</strong> SHA-256</a></li><li class="chapter-item expanded "><a href="../rust/algorithms/cryptographic/diffie-hellman.html"><strong aria-hidden="true">5.8.5.4.</strong> Diffie-Hellman</a></li><li class="chapter-item expanded "><a href="../rust/algorithms/cryptographic/bcrypt.html"><strong aria-hidden="true">5.8.5.5.</strong> Bcrypt</a></li></ol></li></ol></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.</strong> React</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../react/bai-1.html"><strong aria-hidden="true">6.1.</strong> Bài 1</a></li><li class="chapter-item expanded "><a href="../react/bai-2.html"><strong aria-hidden="true">6.2.</strong> Bài 2</a></li><li class="chapter-item expanded "><a href="../react/bai-3.html"><strong aria-hidden="true">6.3.</strong> Bài 3</a></li></ol></li><li class="chapter-item expanded "><a href="../react-native/index.html"><strong aria-hidden="true">7.</strong> React Native</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.</strong> TypeScript</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../ts/bai-1.html"><strong aria-hidden="true">8.1.</strong> Bài 1</a></li></ol></li><li class="chapter-item expanded "><a href="../bash/tong-hop.html"><strong aria-hidden="true">9.</strong> Bash</a></li><li class="chapter-item expanded "><a href="../regex/tong-hop.html"><strong aria-hidden="true">10.</strong> Regex</a></li><li class="chapter-item expanded "><a href="../khac/yt-dlp.html"><strong aria-hidden="true">11.</strong> yt-dlp</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Kho code của duykhanh471</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="hướng-dẫn-học-js-cực-nhanh"><a class="header" href="#hướng-dẫn-học-js-cực-nhanh">Hướng dẫn học JS cực nhanh</a></h1>
<p>Chắc thế, cái này do Gemini viết dựa trên nội dung khóa học của F8 nha.</p>
<h2 id="phần-1-giới-thiệu-và-cài-đặt"><a class="header" href="#phần-1-giới-thiệu-và-cài-đặt">Phần 1: Giới thiệu và Cài đặt</a></h2>
<h3 id="cài-đặt-môi-trường-công-cụ-phù-hợp-để-học-javascript"><a class="header" href="#cài-đặt-môi-trường-công-cụ-phù-hợp-để-học-javascript">Cài đặt môi trường, công cụ phù hợp để học JavaScript</a></h3>
<p>Để học JavaScript, bạn cần:</p>
<ul>
<li><strong>Trình duyệt web:</strong> Bất kỳ trình duyệt hiện đại nào (Chrome, Firefox, Edge...) đều có thể chạy JavaScript.</li>
<li><strong>Trình soạn thảo code:</strong> VS Code (Visual Studio Code) là lựa chọn tốt, miễn phí, nhiều extension hỗ trợ JavaScript.</li>
<li><strong>Node.js (tùy chọn):</strong>  Để chạy JavaScript ngoài trình duyệt (backend, công cụ...). Cài đặt từ <a href="https://www.google.com/url?sa=E&amp;source=gmail&amp;q=https://nodejs.org/">https://nodejs.org/</a>.</li>
</ul>
<h3 id="cách-sử-dụng-js-trong-file-html"><a class="header" href="#cách-sử-dụng-js-trong-file-html">Cách sử dụng JS trong file HTML</a></h3>
<p>Có 2 cách chính để nhúng JavaScript vào file HTML:</p>
<ul>
<li>
<p><strong>Internal (nội tuyến):</strong> Viết code JS trực tiếp trong thẻ <code>&lt;script&gt;</code> bên trong <code>&lt;head&gt;</code> hoặc <code>&lt;body&gt;</code> của file HTML.</p>
</li>
<li>
<p><strong>External (ngoại tuyến):</strong> Viết code JS trong file riêng (<code>.js</code>), sau đó liên kết đến file HTML bằng thẻ <code>&lt;script src=&quot;path/to/script.js&quot;&gt;&lt;/script&gt;</code>. Cách này tốt hơn cho dự án lớn, dễ quản lý code.</p>
</li>
<li>
<p><strong>Ví dụ (External JS - phổ biến nhất):</strong></p>
</li>
<li>
<p><strong><code>index.html</code>:</strong></p>
</li>
</ul>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Ví dụ External JS&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h1&gt;Xin chào JavaScript!&lt;/h1&gt;
    &lt;script src=&quot;script.js&quot;&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<ul>
<li><strong><code>script.js</code>:</strong></li>
</ul>
<pre><code class="language-javascript">    alert('Chào mừng đến với JavaScript!');
</code></pre>
<h2 id="phần-2-cú-pháp-và-cơ-bản"><a class="header" href="#phần-2-cú-pháp-và-cơ-bản">Phần 2: Cú pháp và Cơ bản</a></h2>
<h3 id="khai-báo-biến"><a class="header" href="#khai-báo-biến">Khai báo biến</a></h3>
<p>Biến dùng để lưu trữ dữ liệu trong chương trình. Trong JavaScript, có 3 từ khóa khai báo biến:</p>
<ul>
<li><code>var</code> (ít dùng hiện nay, phạm vi function-scoped).</li>
<li><code>let</code> (phạm vi block-scoped, có thể gán lại giá trị).</li>
<li><code>const</code> (phạm vi block-scoped, không thể gán lại giá trị sau khi khởi tạo). Nên dùng <code>const</code> khi giá trị không đổi, <code>let</code> khi cần thay đổi.</li>
</ul>
<p><strong>Ví dụ:</strong></p>
<pre><code class="language-javascript">let age = 30; // Khai báo biến age với let, giá trị 30
const name = &quot;Gemini&quot;; // Khai báo biến name với const, giá trị &quot;Gemini&quot;
age = 31; // Có thể gán lại giá trị cho age
// name = &quot;Bard&quot;; // Lỗi! Không thể gán lại giá trị cho const name
console.log(name + &quot; is &quot; + age + &quot; years old.&quot;);
</code></pre>
<h3 id="sử-dụng-comments-trong-javascript"><a class="header" href="#sử-dụng-comments-trong-javascript">Sử dụng Comments trong JavaScript</a></h3>
<p>Comment (chú thích) trong JavaScript giúp ghi chú, giải thích code, hoặc tạm ẩn code mà không ảnh hưởng đến chương trình.</p>
<ul>
<li>
<p><strong>Single-line comment:</strong> <code>// Đây là comment một dòng</code></p>
</li>
<li>
<p><strong>Multi-line comment:</strong></p>
</li>
</ul>
<pre><code class="language-javascript">/*
Đây là
comment
nhiều dòng
*/
</code></pre>
<p><strong>Ví dụ:</strong></p>
<pre><code class="language-javascript">// Đây là comment giải thích biến name
const name = &quot;Gemini&quot;;
/*
Đoạn code này
sẽ in ra lời chào
*/
console.log(&quot;Xin chào, &quot; + name + &quot;!&quot;);
</code></pre>
<h3 id="một-số-hàm-built-in-trong-javascript"><a class="header" href="#một-số-hàm-built-in-trong-javascript">Một số hàm built-in trong JavaScript</a></h3>
<p>Built-in functions (hàm dựng sẵn) là các hàm có sẵn trong JavaScript để thực hiện các tác vụ phổ biến. Ví dụ:</p>
<ul>
<li><code>alert()</code>: Hiển thị hộp thoại thông báo.</li>
<li><code>console.log()</code>: In thông tin ra console (DevTools).</li>
<li><code>prompt()</code>: Hiển thị hộp thoại nhập liệu.</li>
<li><code>parseInt()</code>, <code>parseFloat()</code>: Chuyển đổi chuỗi sang số nguyên, số thực.</li>
<li><code>typeof()</code>: Kiểm tra kiểu dữ liệu của biến.</li>
</ul>
<p><strong>Ví dụ:</strong></p>
<pre><code class="language-javascript">alert(&quot;Đây là thông báo!&quot;); // Hiển thị thông báo
console.log(&quot;Thông tin này in ra console&quot;); // In ra console
let input = prompt(&quot;Nhập tên của bạn:&quot;); // Hiển thị hộp thoại nhập liệu
console.log(&quot;Bạn đã nhập: &quot; + input);
let numberString = &quot;123&quot;;
let number = parseInt(numberString); // Chuyển chuỗi &quot;123&quot; sang số 123
console.log(typeof(number)); // In ra &quot;number&quot;
</code></pre>
<h3 id="làm-quen-với-toán-tử-trong-javascript"><a class="header" href="#làm-quen-với-toán-tử-trong-javascript">Làm quen với toán tử trong JavaScript</a></h3>
<p>Toán tử (operator) là ký hiệu thực hiện phép toán trên các giá trị (toán hạng). JavaScript có nhiều loại toán tử:</p>
<ul>
<li>Toán tử số học (+, -, *, /, %, **, ++, --).</li>
<li>Toán tử gán (=, +=, -=, *=, /=, %=).</li>
<li>Toán tử so sánh (==, ===, !=, !==, &gt;, &lt;, &gt;=, &lt;=).</li>
<li>Toán tử logic (&amp;&amp; - AND, || - OR, ! - NOT).</li>
<li>Toán tử chuỗi (+ - cộng chuỗi).</li>
</ul>
<h3 id="toán-tử-số-học-trong-javascript"><a class="header" href="#toán-tử-số-học-trong-javascript">Toán tử số học trong JavaScript</a></h3>
<p>Toán tử số học thực hiện các phép toán cơ bản:</p>
<ul>
<li><code>+</code> (cộng), <code>-</code> (trừ), <code>*</code> (nhân), <code>/</code> (chia).</li>
<li><code>%</code> (chia lấy dư - modulo).</li>
<li><code>**</code> (lũy thừa - exponentiation).</li>
</ul>
<p><strong>Ví dụ:</strong></p>
<pre><code class="language-javascript">let x = 10;
let y = 5;
console.log(x + y); // 15 (cộng)
console.log(x - y); // 5 (trừ)
console.log(x * y); // 50 (nhân)
console.log(x / y); // 2 (chia)
console.log(x % y); // 0 (chia lấy dư)
console.log(x ** y); // 100000 (10 mũ 5)
</code></pre>
<h3 id="toán-tử------với-tiền-tố--hậu-tố-prefix--postfix-trong-javascript"><a class="header" href="#toán-tử------với-tiền-tố--hậu-tố-prefix--postfix-trong-javascript">Toán tử ++  -- với tiền tố &amp; hậu tố (Prefix &amp; Postfix) trong JavaScript</a></h3>
<p>Toán tử tăng/giảm (<code>++</code>, <code>--</code>) tăng hoặc giảm giá trị biến đi 1.</p>
<ul>
<li><strong>Prefix (++x, --x):</strong> Tăng/giảm giá trị <strong>trước</strong> khi sử dụng giá trị đó trong biểu thức.</li>
<li><strong>Postfix (x++, x--):</strong> Tăng/giảm giá trị <strong>sau</strong> khi sử dụng giá trị đó trong biểu thức.</li>
</ul>
<p><strong>Ví dụ:</strong></p>
<pre><code class="language-javascript">let a = 5;
let b = ++a; // Prefix: a tăng lên 6 trước, sau đó b = 6
console.log(&quot;a:&quot;, a, &quot;b:&quot;, b); // a: 6 b: 6

let c = 5;
let d = c++; // Postfix: d = 5 trước, sau đó c tăng lên 6
console.log(&quot;c:&quot;, c, &quot;d:&quot;, d); // c: 6 d: 5
</code></pre>
<h3 id="toán-tử-gán-trong-javascript"><a class="header" href="#toán-tử-gán-trong-javascript">Toán tử gán trong JavaScript</a></h3>
<p>Toán tử gán gán giá trị cho biến.</p>
<ul>
<li><code>=</code> (gán trực tiếp).</li>
<li><code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code>, <code>%=</code> (gán kết hợp phép toán).</li>
</ul>
<p><strong>Ví dụ:</strong></p>
<pre><code class="language-javascript">let num = 10;
num = 20; // Gán trực tiếp num = 20
num += 5; // num = num + 5 (num = 25)
num -= 3; // num = num - 3 (num = 22)
num *= 2; // num = num * 2 (num = 44)
num /= 4; // num = num / 4 (num = 11)
num %= 3; // num = num % 3 (num = 2 - dư của 11 chia 3)
console.log(num); // 2
</code></pre>
<h3 id="toán-tử-chuỗi-string-operator-trong-javascript"><a class="header" href="#toán-tử-chuỗi-string-operator-trong-javascript">Toán tử chuỗi (String Operator) trong JavaScript</a></h3>
<p>Toán tử chuỗi chính là toán tử <code>+</code> (cộng) dùng để <strong>nối chuỗi</strong> (concatenation).</p>
<p><strong>Ví dụ:</strong></p>
<pre><code class="language-javascript">let firstName = &quot;Gemini&quot;;
let lastName = &quot;AI&quot;;
let fullName = firstName + &quot; &quot; + lastName; // Nối chuỗi
console.log(fullName); // Gemini AI
</code></pre>
<h3 id="toán-tử-so-sánh-trong-javascript-phần-1"><a class="header" href="#toán-tử-so-sánh-trong-javascript-phần-1">Toán tử so sánh trong Javascript (phần 1)</a></h3>
<p>Toán tử so sánh so sánh hai giá trị và trả về giá trị boolean (<code>true</code> hoặc <code>false</code>).</p>
<ul>
<li><code>==</code> (bằng giá trị - loose equality): So sánh giá trị, có thể ép kiểu dữ liệu.</li>
<li><code>===</code> (bằng giá trị và kiểu dữ liệu - strict equality): So sánh cả giá trị và kiểu dữ liệu, không ép kiểu. Nên dùng <code>===</code> để so sánh chính xác.</li>
<li><code>!=</code> (không bằng giá trị - loose inequality).</li>
<li><code>!==</code> (không bằng giá trị hoặc kiểu dữ liệu - strict inequality).</li>
<li><code>&gt;</code> (lớn hơn), <code>&lt;</code> (nhỏ hơn), <code>&gt;=</code> (lớn hơn hoặc bằng), <code>&lt;=</code> (nhỏ hơn hoặc bằng).</li>
</ul>
<h3 id="kiểu-dữ-liệu-boolean-boolean-data-type-trong-javascript"><a class="header" href="#kiểu-dữ-liệu-boolean-boolean-data-type-trong-javascript">Kiểu dữ liệu Boolean (Boolean data type) trong JavaScript</a></h3>
<p>Boolean là kiểu dữ liệu logic chỉ có 2 giá trị: <code>true</code> (đúng) và <code>false</code> (sai). Thường dùng trong câu lệnh điều kiện và toán tử logic.</p>
<p><strong>Ví dụ:</strong></p>
<pre><code class="language-javascript">let isAdult = true;
let isRaining = false;
console.log(typeof(isAdult)); // &quot;boolean&quot;
console.log(isRaining); // false
</code></pre>
<h3 id="câu-lệnh-điều-kiện-if---else-trong-javascript"><a class="header" href="#câu-lệnh-điều-kiện-if---else-trong-javascript">Câu lệnh điều kiện If - Else trong JavaScript</a></h3>
<p>Câu lệnh <code>if...else</code> thực hiện code khác nhau dựa trên điều kiện đúng hay sai.</p>
<ul>
<li><code>if (condition) { ... }</code>: Nếu <code>condition</code> đúng (<code>true</code>), code trong block <code>if</code> được thực hiện.</li>
<li><code>else { ... }</code>: Nếu <code>condition</code> sai (<code>false</code>), code trong block <code>else</code> được thực hiện (tùy chọn).</li>
<li><code>else if (condition2) { ... }</code>: Kiểm tra thêm điều kiện nếu điều kiện <code>if</code> sai (có thể có nhiều <code>else if</code>).</li>
</ul>
<p><strong>Ví dụ:</strong></p>
<pre><code class="language-javascript">let age = 18;
if (age &gt;= 18) {
    console.log(&quot;Bạn đã đủ tuổi trưởng thành.&quot;);
} else {
    console.log(&quot;Bạn chưa đủ tuổi trưởng thành.&quot;);
}
</code></pre>
<h3 id="toán-tử-logical-trong-javascript"><a class="header" href="#toán-tử-logical-trong-javascript">Toán tử logical trong JavaScript</a></h3>
<p>Toán tử logic kết hợp các biểu thức boolean.</p>
<ul>
<li><code>&amp;&amp;</code> (AND - và): <code>true</code> nếu <strong>cả hai</strong> toán hạng đều <code>true</code>.</li>
<li><code>||</code> (OR - hoặc): <code>true</code> nếu <strong>ít nhất một</strong> toán hạng là <code>true</code>.</li>
<li><code>!</code> (NOT - phủ định): Đảo ngược giá trị boolean (<code>!true</code> là <code>false</code>, <code>!false</code> là <code>true</code>).</li>
</ul>
<p><strong>Ví dụ:</strong></p>
<pre><code class="language-javascript">let hasLicense = true;
let hasCar = false;
if (hasLicense &amp;&amp; hasCar) { // Cả hai phải true
    console.log(&quot;Đủ điều kiện lái xe.&quot;);
} else if (hasLicense || hasCar) { // Ít nhất một true
    console.log(&quot;Có một trong hai điều kiện.&quot;);
} else {
    console.log(&quot;Không đủ điều kiện.&quot;);
}
console.log(!hasLicense); // false (phủ định true)
</code></pre>
<h3 id="kiểu-dữ-liệu-trong-javascript"><a class="header" href="#kiểu-dữ-liệu-trong-javascript">Kiểu dữ liệu trong JavaScript</a></h3>
<p>JavaScript là ngôn ngữ kiểu dữ liệu động (dynamic typing), kiểu dữ liệu của biến được xác định khi chạy chương trình, không cần khai báo rõ ràng. Các kiểu dữ liệu cơ bản:</p>
<ul>
<li><code>Number</code> (số): Số nguyên, số thực.</li>
<li><code>String</code> (chuỗi): Văn bản.</li>
<li><code>Boolean</code> (boolean): <code>true</code> hoặc <code>false</code>.</li>
<li><code>Null</code>: Giá trị rỗng có chủ ý.</li>
<li><code>Undefined</code>: Biến đã khai báo nhưng chưa gán giá trị.</li>
<li><code>Symbol</code> (ES6): Giá trị duy nhất, thường dùng làm key object.</li>
<li><code>Object</code> (đối tượng): Tập hợp các cặp key-value.</li>
</ul>
<h3 id="toán-tử-so-sánh-trong-javascript-phần-2"><a class="header" href="#toán-tử-so-sánh-trong-javascript-phần-2">Toán tử so sánh trong JavaScript (phần 2)</a></h3>
<p>Tiếp tục về toán tử so sánh, tập trung vào sự khác biệt giữa <code>==</code> và <code>===</code>. Nên dùng <code>===</code> và <code>!==</code> để so sánh chính xác, tránh các hành vi ép kiểu không mong muốn của <code>==</code> và <code>!=</code>.</p>
<h3 id="toán-tử-logical-và-câu-lệnh-điều-kiện-if-trong-javascript"><a class="header" href="#toán-tử-logical-và-câu-lệnh-điều-kiện-if-trong-javascript">Toán tử logical và câu lệnh điều kiện If trong JavaScript</a></h3>
<p>Kết hợp toán tử logic và câu lệnh <code>if</code> để tạo điều kiện phức tạp hơn.</p>
<p><strong>Ví dụ:</strong></p>
<pre><code class="language-javascript">let age = 20;
let hasTicket = true;
if (age &gt;= 18 &amp;&amp; hasTicket) { // Vừa đủ tuổi, vừa có vé
    console.log(&quot;Được vào xem phim.&quot;);
} else {
    console.log(&quot;Không được vào xem phim.&quot;);
}
</code></pre>
<h3 id="chuỗi-trong-javascript"><a class="header" href="#chuỗi-trong-javascript">Chuỗi trong JavaScript</a></h3>
<p>Chuỗi (string) là kiểu dữ liệu văn bản trong JavaScript, được bao quanh bởi dấu nháy đơn (<code>'...'</code>), nháy kép (<code>&quot;...&quot;</code>) hoặc backtick (`...`). Backtick dùng cho template literals (chuỗi template).</p>
<p><strong>Ví dụ:</strong></p>
<pre><code class="language-javascript">let singleQuoteString = 'Chuỗi nháy đơn';
let doubleQuoteString = &quot;Chuỗi nháy kép&quot;;
let templateString = `Chuỗi template literals`; // Backtick
console.log(singleQuoteString);
console.log(doubleQuoteString);
console.log(templateString);
</code></pre>
<h3 id="làm-việc-với-chuỗi-trong-javascript"><a class="header" href="#làm-việc-với-chuỗi-trong-javascript">Làm việc với chuỗi trong JavaScript</a></h3>
<p>String methods (phương thức chuỗi) là các hàm có sẵn để thao tác với chuỗi. Ví dụ:</p>
<ul>
<li><code>length</code>: Thuộc tính lấy độ dài chuỗi.</li>
<li><code>charAt(index)</code>: Lấy ký tự tại vị trí index.</li>
<li><code>indexOf(substring)</code>: Tìm vị trí đầu tiên của substring.</li>
<li><code>lastIndexOf(substring)</code>: Tìm vị trí cuối cùng của substring.</li>
<li><code>slice(start, end)</code>: Cắt chuỗi từ vị trí start đến end (không bao gồm end).</li>
<li><code>substring(start, end)</code>: Tương tự <code>slice</code>.</li>
<li><code>toUpperCase()</code>, <code>toLowerCase()</code>: Chuyển chuỗi thành chữ hoa, chữ thường.</li>
<li><code>trim()</code>: Xóa khoảng trắng đầu và cuối chuỗi.</li>
<li><code>split(delimiter)</code>: Chia chuỗi thành mảng các chuỗi con dựa trên delimiter.</li>
<li><code>replace(oldValue, newValue)</code>: Thay thế chuỗi con oldValue bằng newValue.</li>
</ul>
<p><strong>Ví dụ:</strong></p>
<pre><code class="language-javascript">let message = &quot;  Hello World!  &quot;;
console.log(message.length); // 15 (độ dài chuỗi)
console.log(message.charAt(0)); // &quot; &quot; (ký tự đầu tiên)
console.log(message.indexOf(&quot;World&quot;)); // 7 (vị trí của &quot;World&quot;)
console.log(message.slice(2, 7)); // &quot;Hello&quot; (cắt từ vị trí 2 đến 6)
console.log(message.toUpperCase()); // &quot;  HELLO WORLD!  &quot;
console.log(message.trim()); // &quot;Hello World!&quot; (xóa khoảng trắng)
console.log(message.split(&quot; &quot;)); // [&quot;&quot;, &quot;&quot;, &quot;Hello&quot;, &quot;World!&quot;, &quot;&quot;, &quot;&quot;] (chia thành mảng)
console.log(message.replace(&quot;World&quot;, &quot;JavaScript&quot;)); // &quot;  Hello JavaScript!  &quot;
</code></pre>
<h3 id="số-và-làm-việc-với-kiểu-số-trong-javascript"><a class="header" href="#số-và-làm-việc-với-kiểu-số-trong-javascript">Số và làm việc với kiểu số trong JavaScript</a></h3>
<p>Number methods (phương thức số) là các hàm có sẵn để thao tác với số. Ví dụ:</p>
<ul>
<li><code>toFixed(digits)</code>: Định dạng số thập phân với <code>digits</code> chữ số sau dấu phẩy.</li>
<li><code>parseInt()</code>, <code>parseFloat()</code>: Chuyển đổi chuỗi sang số nguyên, số thực.</li>
<li><code>isNaN()</code>: Kiểm tra xem có phải NaN (Not-a-Number) không.</li>
<li><code>Number.isInteger()</code>: Kiểm tra xem có phải số nguyên không.</li>
<li><code>Math.random()</code>: Sinh số ngẫu nhiên từ 0 đến &lt; 1.</li>
<li><code>Math.floor()</code>, <code>Math.ceil()</code>, <code>Math.round()</code>: Làm tròn số xuống, lên, gần nhất.</li>
<li><code>Math.max()</code>, <code>Math.min()</code>: Tìm số lớn nhất, nhỏ nhất.</li>
</ul>
<p><strong>Ví dụ:</strong></p>
<pre><code class="language-javascript">let pi = 3.14159;
console.log(pi.toFixed(2)); // &quot;3.14&quot; (làm tròn đến 2 chữ số thập phân)
let numString = &quot;42&quot;;
let numInt = parseInt(numString); // 42 (chuyển sang số nguyên)
console.log(isNaN(&quot;hello&quot;)); // true (không phải số)
console.log(Number.isInteger(10)); // true (số nguyên)
console.log(Math.random()); // Số ngẫu nhiên (ví dụ: 0.567...)
console.log(Math.floor(3.9)); // 3 (làm tròn xuống)
console.log(Math.max(1, 5, 2)); // 5 (số lớn nhất)
</code></pre>
<h3 id="mảng-trong-javascript"><a class="header" href="#mảng-trong-javascript">Mảng trong JavaScript</a></h3>
<p>Mảng (array) là kiểu dữ liệu danh sách, chứa nhiều giá trị theo thứ tự. Các phần tử mảng có thể có kiểu dữ liệu khác nhau. Mảng được khai báo bằng dấu ngoặc vuông <code>[...]</code>.</p>
<p><strong>Ví dụ:</strong></p>
<pre><code class="language-javascript">let colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;]; // Mảng chuỗi
let numbers = [1, 2, 3, 4, 5]; // Mảng số
let mixedArray = [1, &quot;hello&quot;, true, null]; // Mảng hỗn hợp
console.log(colors[0]); // &quot;red&quot; (phần tử đầu tiên, index 0)
console.log(numbers.length); // 5 (độ dài mảng)
</code></pre>
<h3 id="làm-việc-với-mảng-trong-javascript"><a class="header" href="#làm-việc-với-mảng-trong-javascript">Làm việc với mảng trong JavaScript</a></h3>
<p>Các thao tác cơ bản với mảng:</p>
<ul>
<li>Truy cập phần tử: <code>array[index]</code>.</li>
<li>Sửa đổi phần tử: <code>array[index] = newValue;</code>.</li>
<li>Thêm phần tử:
<ul>
<li><code>push(element)</code>: Thêm vào cuối mảng.</li>
<li><code>unshift(element)</code>: Thêm vào đầu mảng.</li>
</ul>
</li>
<li>Xóa phần tử:
<ul>
<li><code>pop()</code>: Xóa phần tử cuối mảng và trả về phần tử đó.</li>
<li><code>shift()</code>: Xóa phần tử đầu mảng và trả về phần tử đó.</li>
<li><code>splice(startIndex, deleteCount, item1, item2, ...)</code>: Xóa và/hoặc thêm phần tử tại vị trí bất kỳ.</li>
</ul>
</li>
</ul>
<p><strong>Ví dụ:</strong></p>
<pre><code class="language-javascript">let fruits = [&quot;apple&quot;, &quot;banana&quot;, &quot;orange&quot;];
console.log(fruits[1]); // &quot;banana&quot;
fruits[1] = &quot;grape&quot;; // Sửa đổi phần tử
console.log(fruits); // [&quot;apple&quot;, &quot;grape&quot;, &quot;orange&quot;]
fruits.push(&quot;mango&quot;); // Thêm vào cuối
console.log(fruits); // [&quot;apple&quot;, &quot;grape&quot;, &quot;orange&quot;, &quot;mango&quot;]
fruits.unshift(&quot;kiwi&quot;); // Thêm vào đầu
console.log(fruits); // [&quot;kiwi&quot;, &quot;apple&quot;, &quot;grape&quot;, &quot;orange&quot;, &quot;mango&quot;]
let lastFruit = fruits.pop(); // Xóa cuối
console.log(lastFruit); // &quot;mango&quot;
console.log(fruits); // [&quot;kiwi&quot;, &quot;apple&quot;, &quot;grape&quot;, &quot;orange&quot;]
fruits.splice(1, 2, &quot;pear&quot;, &quot;melon&quot;); // Xóa 2 phần tử từ index 1, thêm &quot;pear&quot;, &quot;melon&quot;
console.log(fruits); // [&quot;kiwi&quot;, &quot;pear&quot;, &quot;melon&quot;, &quot;orange&quot;]
</code></pre>
<h3 id="hàm-trong-javascript"><a class="header" href="#hàm-trong-javascript">Hàm trong JavaScript</a></h3>
<p>Hàm (function) là khối code thực hiện một tác vụ cụ thể, có thể tái sử dụng nhiều lần. Giúp code có cấu trúc, dễ đọc, dễ bảo trì.</p>
<ul>
<li><strong>Khai báo hàm:</strong></li>
</ul>
<pre><code class="language-javascript">function functionName(parameter1, parameter2, ...) {
    // Code thực hiện trong hàm
    // ...
    return value; // (tùy chọn, trả về giá trị)
}
</code></pre>
<ul>
<li><strong>Gọi hàm:</strong> <code>functionName(argument1, argument2, ...);</code></li>
</ul>
<p><strong>Ví dụ:</strong></p>
<pre><code class="language-javascript">function add(a, b) { // Hàm cộng hai số
    return a + b;
}

let sum = add(5, 3); // Gọi hàm add với đối số 5 và 3
console.log(sum); // 8
</code></pre>
<h3 id="tham-số-trong-hàm"><a class="header" href="#tham-số-trong-hàm">Tham số trong hàm</a></h3>
<p>Tham số (parameter) là biến được khai báo trong định nghĩa hàm, dùng để nhận giá trị đầu vào khi gọi hàm. Đối số (argument) là giá trị thực tế được truyền vào khi gọi hàm.</p>
<p><strong>Ví dụ:</strong> (ví dụ trên đã có tham số)</p>
<pre><code class="language-javascript">function greet(name) { // 'name' là tham số
    console.log(&quot;Xin chào, &quot; + name + &quot;!&quot;);
}

greet(&quot;Gemini&quot;); // &quot;Gemini&quot; là đối số
greet(&quot;User&quot;); // &quot;User&quot; là đối số
</code></pre>
<h3 id="return-trong-hàm-js"><a class="header" href="#return-trong-hàm-js">Return trong hàm JS</a></h3>
<p>Câu lệnh <code>return</code> trong hàm dùng để trả về một giá trị từ hàm. Hàm có thể trả về bất kỳ kiểu dữ liệu nào (số, chuỗi, mảng, object...). Nếu không có <code>return</code>, hàm trả về <code>undefined</code>.</p>
<p><strong>Ví dụ:</strong> (ví dụ hàm <code>add</code> và <code>greet</code> trên đã có return và không return)</p>
<pre><code class="language-javascript">function square(number) {
    return number * number; // Trả về bình phương của số
}

let result = square(4);
console.log(result); // 16

function sayHello() { // Không có return
    console.log(&quot;Hello!&quot;);
}

let greeting = sayHello();
console.log(greeting); // undefined (hàm không trả về gì)
</code></pre>
<h3 id="hiểu-hơn-về-function-trong-javascript"><a class="header" href="#hiểu-hơn-về-function-trong-javascript">Hiểu hơn về function trong JavaScript</a></h3>
<p>Hàm là first-class citizens trong JavaScript: có thể gán cho biến, truyền như đối số cho hàm khác, trả về từ hàm khác. Hàm có thể có tên (named function) hoặc không tên (anonymous function).</p>
<h3 id="các-loại-function-trong-javascript"><a class="header" href="#các-loại-function-trong-javascript">Các loại function trong JavaScript</a></h3>
<p>Các loại function trong JavaScript:</p>
<ul>
<li>
<p><strong>Named function:</strong> Hàm có tên, khai báo bằng từ khóa <code>function</code>. (ví dụ trên)</p>
</li>
<li>
<p><strong>Anonymous function:</strong> Hàm không tên, thường dùng gán cho biến hoặc làm callback.</p>
</li>
<li>
<p><strong>Arrow function (ES6):</strong> Cú pháp ngắn gọn hơn cho anonymous function.</p>
</li>
<li>
<p><strong>Ví dụ (Anonymous function và Arrow function):</strong></p>
</li>
</ul>
<pre><code class="language-javascript">// Anonymous function gán cho biến
let multiply = function(a, b) {
    return a * b;
};
console.log(multiply(3, 7)); // 21

// Arrow function (tương đương hàm multiply ở trên)
let multiplyArrow = (a, b) =&gt; a * b;
console.log(multiplyArrow(4, 6)); // 24

// Callback function (anonymous function truyền vào hàm khác)
setTimeout(function() {
    console.log(&quot;Hello after 1 second&quot;);
}, 1000);

// Callback function (arrow function)
setTimeout(() =&gt; {
    console.log(&quot;Hello again after 2 seconds&quot;);
}, 2000);
</code></pre>
<h3 id="object-trong-javascript"><a class="header" href="#object-trong-javascript">Object trong JavaScript</a></h3>
<p>Object (đối tượng) là kiểu dữ liệu phức tạp trong JavaScript, biểu diễn một thực thể có thuộc tính (properties) và phương thức (methods). Object là tập hợp các cặp key-value, key là chuỗi (hoặc Symbol), value có thể là bất kỳ kiểu dữ liệu nào. Object được khai báo bằng dấu ngoặc nhọn <code>{...}</code>.</p>
<p><strong>Ví dụ:</strong></p>
<pre><code class="language-javascript">let person = {
    name: &quot;Gemini&quot;, // Thuộc tính name
    age: 2,        // Thuộc tính age
    isRobot: true,  // Thuộc tính isRobot
    greet: function() { // Phương thức greet
        console.log(&quot;Xin chào, tôi là &quot; + this.name);
    }
};

console.log(person.name); // &quot;Gemini&quot; (truy cập thuộc tính bằng dấu chấm)
console.log(person[&quot;age&quot;]); // 2 (truy cập thuộc tính bằng dấu ngoặc vuông)
person.greet(); // Gọi phương thức greet
</code></pre>
<h3 id="object-constructor-trong-javascript"><a class="header" href="#object-constructor-trong-javascript">Object constructor trong JavaScript</a></h3>
<p>Object constructor (hàm tạo đối tượng) là hàm đặc biệt dùng để tạo ra các object cùng loại (cùng cấu trúc thuộc tính và phương thức). Dùng từ khóa <code>new</code> để gọi constructor.</p>
<p><strong>Ví dụ:</strong></p>
<pre><code class="language-javascript">function Dog(name, breed) { // Constructor Dog
    this.name = name;
    this.breed = breed;
    this.bark = function() {
        console.log(&quot;Woof!&quot;);
    };
}

let myDog = new Dog(&quot;Lucky&quot;, &quot;Golden Retriever&quot;); // Tạo object Dog bằng constructor
console.log(myDog.name); // &quot;Lucky&quot;
myDog.bark(); // Gọi phương thức bark
</code></pre>
<h3 id="object-prototypecơ-bản-trong-javascript"><a class="header" href="#object-prototypecơ-bản-trong-javascript">Object prototype(cơ bản) trong JavaScript</a></h3>
<p>Prototype là cơ chế kế thừa trong JavaScript. Mỗi object được tạo ra từ constructor có một prototype. Prototype là một object khác, chứa các thuộc tính và phương thức mà các object con kế thừa. Giúp tái sử dụng code, tiết kiệm bộ nhớ.</p>
<h3 id="date-object-trong-javascript"><a class="header" href="#date-object-trong-javascript">Date object trong JavaScript</a></h3>
<p>Date object (đối tượng Date) dùng để làm việc với ngày và giờ trong JavaScript. Tạo Date object bằng <code>new Date()</code>.</p>
<p><strong>Ví dụ:</strong></p>
<pre><code class="language-javascript">let now = new Date(); // Date object hiện tại
console.log(now); // In ra ngày giờ hiện tại

let specificDate = new Date(2025, 2, 26); // Date object cho ngày 26/03/2025 (tháng bắt đầu từ 0)
console.log(specificDate);

console.log(now.getFullYear()); // Lấy năm
console.log(now.getMonth()); // Lấy tháng (0-11)
console.log(now.getDate()); // Lấy ngày
console.log(now.getHours()); // Lấy giờ
console.log(now.getMinutes()); // Lấy phút
</code></pre>
<h2 id="phần-3-câu-lệnh-điều-khiển-và-vòng-lặp"><a class="header" href="#phần-3-câu-lệnh-điều-khiển-và-vòng-lặp">Phần 3: Câu lệnh điều khiển và Vòng lặp</a></h2>
<h3 id="câu-lệnh-rẽ-nhánh-if-else"><a class="header" href="#câu-lệnh-rẽ-nhánh-if-else">Câu lệnh rẽ nhánh If, else</a></h3>
<p>(Đã đề cập ở mục 15) Ôn lại và mở rộng về câu lệnh <code>if...else</code>, <code>else if</code>.</p>
<h3 id="câu-lệnh-rẽ-nhánh-switch-trong-javascript"><a class="header" href="#câu-lệnh-rẽ-nhánh-switch-trong-javascript">Câu lệnh rẽ nhánh Switch trong JavaScript</a></h3>
<p>Câu lệnh <code>switch...case</code> là một cách khác để rẽ nhánh chương trình dựa trên giá trị của một biểu thức. Thường dùng khi có nhiều trường hợp (case) có thể xảy ra.</p>
<p><strong>Ví dụ:</strong></p>
<pre><code class="language-javascript">let dayOfWeek = 3; // 1: Thứ Hai, 2: Thứ Ba, ..., 7: Chủ Nhật
let dayName;

switch (dayOfWeek) {
    case 1:
        dayName = &quot;Thứ Hai&quot;;
        break;
    case 2:
        dayName = &quot;Thứ Ba&quot;;
        break;
    case 3:
        dayName = &quot;Thứ Tư&quot;;
        break;
    case 4:
        dayName = &quot;Thứ Năm&quot;;
        break;
    case 5:
        dayName = &quot;Thứ Sáu&quot;;
        break;
    case 6:
        dayName = &quot;Thứ Bảy&quot;;
        break;
    case 7:
        dayName = &quot;Chủ Nhật&quot;;
        break;
    default:
        dayName = &quot;Không hợp lệ&quot;;
}

console.log(&quot;Hôm nay là &quot; + dayName); // Hôm nay là Thứ Tư
</code></pre>
<h3 id="toán-tử-3-ngôiternary-operator-trong-javascript"><a class="header" href="#toán-tử-3-ngôiternary-operator-trong-javascript">Toán tử 3 ngôi(ternary operator) trong JavaScript</a></h3>
<p>Toán tử 3 ngôi (ternary operator) <code>condition ? valueIfTrue : valueIfFalse</code> là cú pháp rút gọn của câu lệnh <code>if...else</code> khi chỉ có một điều kiện và trả về một trong hai giá trị.</p>
<p><strong>Ví dụ:</strong></p>
<pre><code class="language-javascript">let age = 15;
let message = age &gt;= 18 ? &quot;Đủ tuổi&quot; : &quot;Chưa đủ tuổi&quot;; // Toán tử 3 ngôi
console.log(message); // &quot;Chưa đủ tuổi&quot;

// Tương đương với if...else:
let message2;
if (age &gt;= 18) {
    message2 = &quot;Đủ tuổi&quot;;
} else {
    message2 = &quot;Chưa đủ tuổi&quot;;
}
console.log(message2); // &quot;Chưa đủ tuổi&quot;
</code></pre>
<h3 id="vòng-lặp-trong-javascript"><a class="header" href="#vòng-lặp-trong-javascript">Vòng lặp trong JavaScript</a></h3>
<p>Vòng lặp (loop) dùng để lặp đi lặp lại một khối code nhiều lần. Các loại vòng lặp trong JavaScript:</p>
<ul>
<li><code>for</code> loop.</li>
<li><code>for...in</code> loop (lặp qua thuộc tính của object).</li>
<li><code>for...of</code> loop (lặp qua giá trị của iterable object - mảng, chuỗi...).</li>
<li><code>while</code> loop.</li>
<li><code>do...while</code> loop.</li>
</ul>
<h3 id="vòng-lặp-for-trong-javascript"><a class="header" href="#vòng-lặp-for-trong-javascript">Vòng lặp For trong JavaScript</a></h3>
<p><code>for</code> loop có cú pháp: <code>for (initialization; condition; increment/decrement) { ... }</code></p>
<ul>
<li><code>initialization</code>: Khởi tạo biến đếm (chạy một lần đầu tiên).</li>
<li><code>condition</code>: Điều kiện lặp (kiểm tra trước mỗi lần lặp, nếu <code>true</code> thì lặp tiếp, <code>false</code> thì dừng).</li>
<li><code>increment/decrement</code>: Tăng/giảm biến đếm sau mỗi lần lặp.</li>
</ul>
<p><strong>Ví dụ:</strong></p>
<pre><code class="language-javascript">for (let i = 1; i &lt;= 5; i++) { // Lặp 5 lần, i từ 1 đến 5
    console.log(&quot;Lần lặp thứ &quot; + i);
}
</code></pre>
<p><code>for...in</code> loop lặp qua <strong>thuộc tính (key)</strong> của một object.</p>
<p><strong>Ví dụ:</strong></p>
<pre><code class="language-javascript">let person = {
    name: &quot;Gemini&quot;,
    age: 2,
    city: &quot;Internet&quot;
};

for (let key in person) { // Lặp qua key của object person
    console.log(key + &quot;: &quot; + person[key]);
}
// In ra:
// name: Gemini
// age: 2
// city: Internet
</code></pre>
<h3 id="vòng-lặp-forof-trong-javascript"><a class="header" href="#vòng-lặp-forof-trong-javascript">Vòng lặp For/of trong JavaScript</a></h3>
<p><code>for...of</code> loop lặp qua <strong>giá trị</strong> của một <strong>iterable object</strong> (mảng, chuỗi, Map, Set...).</p>
<p><strong>Ví dụ:</strong></p>
<pre><code class="language-javascript">let colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;];

for (let color of colors) { // Lặp qua giá trị của mảng colors
    console.log(color);
}
// In ra:
// red
// green
// blue

let message = &quot;Hello&quot;;
for (let char of message) { // Lặp qua ký tự của chuỗi message
    console.log(char);
}
// In ra:
// H
// e
// l
// l
// o
</code></pre>
<h3 id="vòng-lặp-while-trong-javascript"><a class="header" href="#vòng-lặp-while-trong-javascript">Vòng lặp While trong JavaScript</a></h3>
<p><code>while</code> loop lặp khi điều kiện còn đúng (<code>true</code>). Cú pháp: <code>while (condition) { ... }</code></p>
<p><strong>Ví dụ:</strong></p>
<pre><code class="language-javascript">let count = 1;
while (count &lt;= 5) { // Lặp khi count &lt;= 5
    console.log(&quot;Count: &quot; + count);
    count++; // Tăng count sau mỗi lần lặp
}
</code></pre>
<h3 id="vòng-lặp-dowhile-trong-javascript"><a class="header" href="#vòng-lặp-dowhile-trong-javascript">Vòng lặp Do/while trong JavaScript</a></h3>
<p><code>do...while</code> loop tương tự <code>while</code> loop, nhưng code trong block <code>do</code> được thực hiện <strong>ít nhất một lần</strong> trước khi kiểm tra điều kiện. Cú pháp: <code>do { ... } while (condition);</code></p>
<p><strong>Ví dụ:</strong></p>
<pre><code class="language-javascript">let num = 0;
do {
    console.log(&quot;Num: &quot; + num);
    num++;
} while (num &lt; 3); // Lặp khi num &lt; 3
// In ra:
// Num: 0
// Num: 1
// Num: 2
</code></pre>
<h3 id="break-và-continue-trong-vòng-lặp"><a class="header" href="#break-và-continue-trong-vòng-lặp">Break và Continue trong vòng lặp</a></h3>
<ul>
<li>
<p><strong>Tóm tắt:</strong></p>
</li>
<li>
<p><code>break</code>: Thoát khỏi vòng lặp ngay lập tức.</p>
</li>
<li>
<p><code>continue</code>: Bỏ qua lần lặp hiện tại và chuyển sang lần lặp tiếp theo.</p>
</li>
</ul>
<p><strong>Ví dụ:</strong></p>
<pre><code class="language-javascript">for (let i = 1; i &lt;= 10; i++) {
    if (i === 5) {
        break; // Thoát khỏi vòng lặp khi i = 5
    }
    console.log(&quot;i (break): &quot; + i); // In ra 1, 2, 3, 4
}

for (let j = 1; j &lt;= 5; j++) {
    if (j === 3) {
        continue; // Bỏ qua lần lặp khi j = 3
    }
    console.log(&quot;j (continue): &quot; + j); // In ra 1, 2, 4, 5 (bỏ qua 3)
}
</code></pre>
<h3 id="vòng-lặp-lồng-nhau-nested-loop"><a class="header" href="#vòng-lặp-lồng-nhau-nested-loop">Vòng lặp lồng nhau (Nested loop)</a></h3>
<p>Nested loop (vòng lặp lồng nhau) là vòng lặp bên trong vòng lặp khác. Thường dùng để xử lý dữ liệu đa chiều (ví dụ: ma trận, bảng).</p>
<p><strong>Ví dụ:</strong></p>
<pre><code class="language-javascript">for (let i = 1; i &lt;= 3; i++) { // Vòng lặp ngoài
    console.log(&quot;Vòng lặp ngoài lần &quot; + i);
    for (let j = 1; j &lt;= 2; j++) { // Vòng lặp trong (lặp 2 lần cho mỗi lần lặp ngoài)
        console.log(&quot;  Vòng lặp trong lần &quot; + j);
    }
}
// In ra:
// Vòng lặp ngoài lần 1
//   Vòng lặp trong lần 1
//   Vòng lặp trong lần 2
// Vòng lặp ngoài lần 2
//   Vòng lặp trong lần 1
//   Vòng lặp trong lần 2
// Vòng lặp ngoài lần 3
//   Vòng lặp trong lần 1
//   Vòng lặp trong lần 2
</code></pre>
<h3 id="ví-dụ-mở-rộng-về-vòng-lặp"><a class="header" href="#ví-dụ-mở-rộng-về-vòng-lặp">Ví dụ mở rộng về vòng lặp</a></h3>
<p>Tổng hợp các ví dụ phức tạp hơn về vòng lặp, có thể kết hợp với điều kiện, mảng, object... để giải quyết các bài toán thực tế.</p>
<h2 id="phần-4-làm-việc-với-mảng-nâng-cao"><a class="header" href="#phần-4-làm-việc-với-mảng-nâng-cao">Phần 4: Làm việc với Mảng nâng cao</a></h2>
<h3 id="làm-việc-với-mảng-trong-javascript-1"><a class="header" href="#làm-việc-với-mảng-trong-javascript-1">Làm việc với mảng trong JavaScript</a></h3>
<p>Tiếp tục về Array methods, giới thiệu các phương thức quan trọng để thao tác và xử lý mảng:</p>
<ul>
<li><code>concat(array2, array3, ...)</code>: Nối mảng với các mảng khác.</li>
<li><code>join(separator)</code>: Nối các phần tử mảng thành chuỗi, phân tách bằng separator.</li>
<li><code>slice(startIndex, endIndex)</code>: Trả về mảng con từ startIndex đến endIndex (không bao gồm endIndex).</li>
<li><code>splice(startIndex, deleteCount, item1, item2, ...)</code>: (Đã đề cập ở mục 24) Xóa và/hoặc thêm phần tử tại vị trí bất kỳ.</li>
<li><code>sort()</code>: Sắp xếp mảng (mặc định theo thứ tự bảng chữ cái hoặc số tăng dần). Cần custom function để sắp xếp số đúng cách.</li>
<li><code>reverse()</code>: Đảo ngược mảng.</li>
</ul>
<p><strong>Ví dụ:</strong></p>
<pre><code class="language-javascript">let arr1 = [1, 2, 3];
let arr2 = [4, 5, 6];
let combinedArray = arr1.concat(arr2); // Nối mảng
console.log(combinedArray); // [1, 2, 3, 4, 5, 6]

let fruits = [&quot;apple&quot;, &quot;banana&quot;, &quot;orange&quot;];
let fruitString = fruits.join(&quot;, &quot;); // Nối thành chuỗi
console.log(fruitString); // &quot;apple, banana, orange&quot;

let numbers = [1, 5, 2, 8, 3];
numbers.sort(); // Sắp xếp (mặc định theo chuỗi) -&gt; [1, 2, 3, 5, 8]
numbers.sort((a, b) =&gt; a - b); // Sắp xếp số tăng dần
console.log(numbers); // [1, 2, 3, 5, 8]
numbers.reverse(); // Đảo ngược mảng
console.log(numbers); // [8, 5, 3, 2, 1]
</code></pre>
<h3 id="array-map-method-trong-javascript"><a class="header" href="#array-map-method-trong-javascript">Array map method trong JavaScript</a></h3>
<p><code>map()</code> method tạo ra một <strong>mảng mới</strong> bằng cách gọi một function (callback) cho <strong>mỗi phần tử</strong> của mảng ban đầu. Callback function nhận vào phần tử hiện tại và trả về giá trị mới cho phần tử tương ứng trong mảng mới.</p>
<p><strong>Ví dụ:</strong></p>
<pre><code class="language-javascript">let numbers = [1, 2, 3, 4, 5];
let squaredNumbers = numbers.map(function(number) { // map() với anonymous function
    return number * number; // Bình phương mỗi số
});
console.log(squaredNumbers); // [1, 4, 9, 16, 25]

// Sử dụng arrow function cho ngắn gọn hơn:
let doubledNumbers = numbers.map(number =&gt; number * 2); // Nhân đôi mỗi số
console.log(doubledNumbers); // [2, 4, 6, 8, 10]
</code></pre>
<h3 id="phương-thức-reduce-khi-làm-việc-với-array"><a class="header" href="#phương-thức-reduce-khi-làm-việc-với-array">Phương thức reduce khi làm việc với array</a></h3>
<p><code>reduce()</code> method thực hiện một callback function &quot;reducer&quot; trên mỗi phần tử của mảng, và trả về một <strong>giá trị duy nhất</strong> (không phải mảng mới như <code>map()</code>). Thường dùng để tính tổng, tích, hoặc gom nhóm dữ liệu trong mảng.</p>
<ul>
<li>
<p><strong>Callback function của <code>reduce()</code> nhận 2 tham số chính:</strong></p>
</li>
<li>
<p><code>accumulator</code> (giá trị tích lũy): Giá trị được trả về từ lần gọi callback trước đó (hoặc <code>initialValue</code> nếu được cung cấp).</p>
</li>
<li>
<p><code>currentValue</code> (giá trị hiện tại): Phần tử mảng đang được xử lý.</p>
</li>
<li>
<p><strong>Cú pháp:</strong> <code>array.reduce(reducerFunction, initialValue);</code> (<code>initialValue</code> là giá trị khởi tạo cho <code>accumulator</code>, tùy chọn).</p>
</li>
<li>
<p><strong>Ví dụ (tính tổng mảng):</strong></p>
</li>
</ul>
<pre><code class="language-javascript">let numbers = [1, 2, 3, 4, 5];
let sum = numbers.reduce(function(accumulator, currentValue) { // reduce() với anonymous function
    return accumulator + currentValue; // Cộng dồn vào accumulator
}, 0); // initialValue = 0 (tổng ban đầu = 0)
console.log(sum); // 15 (tổng các số trong mảng)

// Sử dụng arrow function:
let product = numbers.reduce((accumulator, currentValue) =&gt; accumulator * currentValue, 1); // Tính tích
console.log(product); // 120 (tích các số trong mảng)
</code></pre>
<h3 id="phương-thức-reduce-khi-làm-việc-với-array---phần-2"><a class="header" href="#phương-thức-reduce-khi-làm-việc-với-array---phần-2">Phương thức reduce khi làm việc với array - phần 2</a></h3>
<p>Tiếp tục về <code>reduce()</code>, có thể đi sâu vào các ứng dụng phức tạp hơn như gom nhóm đối tượng trong mảng, flatten mảng đa chiều...</p>
<h3 id="phương-thức-includes"><a class="header" href="#phương-thức-includes">Phương thức includes</a></h3>
<p><code>includes()</code> method kiểm tra xem một chuỗi có chứa một substring (với chuỗi) hoặc một mảng có chứa một phần tử (với mảng) hay không. Trả về <code>true</code> nếu có, <code>false</code> nếu không.</p>
<p><strong>Ví dụ:</strong></p>
<pre><code class="language-javascript">let message = &quot;Hello World&quot;;
console.log(message.includes(&quot;World&quot;)); // true (chuỗi message chứa &quot;World&quot;)
console.log(message.includes(&quot;JavaScript&quot;)); // false

let fruits = [&quot;apple&quot;, &quot;banana&quot;, &quot;orange&quot;];
console.log(fruits.includes(&quot;banana&quot;)); // true (mảng fruits chứa &quot;banana&quot;)
console.log(fruits.includes(&quot;grape&quot;)); // false
</code></pre>
<h3 id="Đối-tượng-math"><a class="header" href="#Đối-tượng-math">Đối tượng math</a></h3>
<p>Math object là built-in object cung cấp các hằng số toán học và hàm toán học. Không cần tạo instance (không dùng <code>new Math()</code>). Truy cập trực tiếp qua <code>Math.property</code> hoặc <code>Math.method()</code>.</p>
<ul>
<li><strong>Hằng số:</strong> <code>Math.PI</code> (số Pi), <code>Math.E</code> (số e), ...</li>
<li><strong>Hàm:</strong> <code>Math.random()</code>, <code>Math.floor()</code>, <code>Math.ceil()</code>, <code>Math.round()</code>, <code>Math.max()</code>, <code>Math.min()</code>, <code>Math.pow()</code>, <code>Math.sqrt()</code>, ... (đã đề cập một số ở mục 22).</li>
</ul>
<p><strong>Ví dụ:</strong></p>
<pre><code class="language-javascript">console.log(Math.PI); // 3.141592653589793 (số Pi)
console.log(Math.sqrt(25)); // 5 (căn bậc hai)
console.log(Math.pow(2, 3)); // 8 (2 mũ 3)
console.log(Math.round(4.6)); // 5 (làm tròn gần nhất)
</code></pre>
<h3 id="hiểu-về-javascript-callback-functions"><a class="header" href="#hiểu-về-javascript-callback-functions">Hiểu về Javascript Callback Functions</a></h3>
<p>Callback function (hàm callback) là hàm được truyền vào làm đối số của một hàm khác, và sẽ được gọi lại (callback) sau khi hàm cha thực hiện xong một tác vụ nào đó (thường là tác vụ bất đồng bộ - asynchronous). Dùng nhiều trong xử lý sự kiện, AJAX, Promises...</p>
<ul>
<li><strong>Ví dụ (setTimeout với callback):</strong></li>
</ul>
<pre><code class="language-javascript">function doSomething(callback) { // Hàm doSomething nhận callback làm đối số
    console.log(&quot;Bắt đầu tác vụ...&quot;);
    setTimeout(function() { // Giả lập tác vụ bất đồng bộ (ví dụ: gọi API)
        console.log(&quot;Tác vụ hoàn thành!&quot;);
        callback(); // Gọi callback function sau khi tác vụ xong
    }, 2000);
}

doSomething(function() { // Truyền anonymous function làm callback
    console.log(&quot;Callback được gọi!&quot;);
});
</code></pre>
<h3 id="callback-trong-javascript"><a class="header" href="#callback-trong-javascript">Callback trong JavaScript</a></h3>
<p>Tiếp tục về callback, có thể đi sâu vào callback hell (callback lồng nhau quá sâu, code khó đọc, khó bảo trì) và cách khắc phục (Promises, async/await).</p>
<h3 id="xây-dựng-phương-thức-làm-việc-với-array"><a class="header" href="#xây-dựng-phương-thức-làm-việc-với-array">Xây dựng phương thức làm việc với array</a></h3>
<p>Có thể nói về việc tạo custom array methods (phương thức mảng tự định nghĩa) bằng cách thêm phương thức vào <code>Array.prototype</code>. Tuy nhiên, cách này ít dùng hiện nay vì có thể xung đột với các phương thức chuẩn hoặc thư viện khác. Nên ưu tiên dùng các phương thức mảng có sẵn.</p>
<h3 id="xây-dựng-phương-thức-foreach"><a class="header" href="#xây-dựng-phương-thức-foreach">Xây dựng phương thức forEach</a></h3>
<p><code>forEach()</code> method lặp qua từng phần tử của mảng và thực hiện callback function cho mỗi phần tử. Tương tự <code>for...of</code> loop, nhưng ngắn gọn hơn. Không tạo mảng mới, không trả về giá trị, chỉ thực hiện side effects (ví dụ: in ra console, sửa đổi mảng gốc...).</p>
<p><strong>Ví dụ:</strong></p>
<pre><code class="language-javascript">let colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;];
colors.forEach(function(color) { // forEach() với anonymous function
    console.log(&quot;Màu: &quot; + color);
});

// Sử dụng arrow function:
colors.forEach(color =&gt; console.log(&quot;Màu (arrow): &quot; + color));
</code></pre>
<h3 id="xây-dựng-phương-thức-filter"><a class="header" href="#xây-dựng-phương-thức-filter">Xây dựng phương thức filter</a></h3>
<p><code>filter()</code> method tạo ra một <strong>mảng mới</strong> chứa các phần tử thỏa mãn một điều kiện nào đó (được kiểm tra bởi callback function). Callback function trả về <code>true</code> nếu phần tử thỏa mãn điều kiện, <code>false</code> nếu không.</p>
<p><strong>Ví dụ:</strong></p>
<pre><code class="language-javascript">let numbers = [1, 2, 3, 4, 5, 6];
let evenNumbers = numbers.filter(function(number) { // filter() với anonymous function
    return number % 2 === 0; // Điều kiện: số chẵn
});
console.log(evenNumbers); // [2, 4, 6] (mảng mới chỉ chứa số chẵn)

// Sử dụng arrow function:
let oddNumbers = numbers.filter(number =&gt; number % 2 !== 0); // Lọc số lẻ
console.log(oddNumbers); // [1, 3, 5]
</code></pre>
<h3 id="xây-dựng-phương-thức-some"><a class="header" href="#xây-dựng-phương-thức-some">Xây dựng phương thức some</a></h3>
<p><code>some()</code> method kiểm tra xem <strong>ít nhất một</strong> phần tử trong mảng có thỏa mãn điều kiện (callback function) hay không. Trả về <code>true</code> nếu có ít nhất một phần tử thỏa mãn, <code>false</code> nếu không có phần tử nào thỏa mãn.</p>
<p><strong>Ví dụ:</strong></p>
<pre><code class="language-javascript">let numbers = [1, 2, 3, 4, 5];
let hasEvenNumber = numbers.some(function(number) { // some() với anonymous function
    return number % 2 === 0; // Điều kiện: số chẵn
});
console.log(hasEvenNumber); // true (mảng numbers có số chẵn)

let allOddNumbers = numbers.some(number =&gt; number % 2 !== 0); // Kiểm tra có số lẻ không
console.log(allOddNumbers); // true
</code></pre>
<h3 id="xây-dựng-phương-thức-every"><a class="header" href="#xây-dựng-phương-thức-every">Xây dựng phương thức every</a></h3>
<p><code>every()</code> method kiểm tra xem <strong>tất cả</strong> phần tử trong mảng có thỏa mãn điều kiện (callback function) hay không. Trả về <code>true</code> nếu <strong>tất cả</strong> phần tử thỏa mãn, <code>false</code> nếu có ít nhất một phần tử không thỏa mãn.</p>
<p><strong>Ví dụ:</strong></p>
<pre><code class="language-javascript">let numbers = [2, 4, 6, 8];
let allEvenNumbers = numbers.every(function(number) { // every() với anonymous function
    return number % 2 === 0; // Điều kiện: số chẵn
});
console.log(allEvenNumbers); // true (tất cả số trong mảng đều chẵn)

let allPositiveNumbers = numbers.every(number =&gt; number &gt; 0); // Kiểm tra tất cả số dương
console.log(allPositiveNumbers); // true
</code></pre>
<h3 id="Đệ-quy-là-gì-học-về-đệ-quy-trong-javascript"><a class="header" href="#Đệ-quy-là-gì-học-về-đệ-quy-trong-javascript">Đệ quy là gì? Học về đệ quy trong JavaScript</a></h3>
<p>Đệ quy (recursion) là kỹ thuật lập trình mà một hàm tự gọi lại chính nó. Dùng để giải quyết các bài toán có cấu trúc lặp lại, hoặc bài toán có thể chia nhỏ thành các bài toán con tương tự. Cần có điều kiện dừng (base case) để tránh lặp vô hạn.</p>
<ul>
<li><strong>Ví dụ (tính giai thừa):</strong></li>
</ul>
<pre><code class="language-javascript">function factorial(n) {
    if (n === 0) { // Base case: giai thừa của 0 là 1
        return 1;
    } else {
        return n * factorial(n - 1); // Gọi lại hàm factorial với n-1 (đệ quy)
    }
}

console.log(factorial(5)); // 120 (5! = 5 * 4 * 3 * 2 * 1)
</code></pre>
<h2 id="phần-5-dom-và-events"><a class="header" href="#phần-5-dom-và-events">Phần 5: DOM và Events</a></h2>
<h3 id="html-dom-là-gì"><a class="header" href="#html-dom-là-gì">HTML DOM là gì?</a></h3>
<p>HTML DOM (Document Object Model) là mô hình biểu diễn cấu trúc HTML dưới dạng cây các đối tượng (nodes). JavaScript có thể truy cập và thao tác với DOM để thay đổi nội dung, cấu trúc, style của trang web.</p>
<h3 id="html-dom-và-dom-api-là-gì"><a class="header" href="#html-dom-và-dom-api-là-gì">HTML DOM và DOM API là gì?</a></h3>
<p>DOM API (Application Programming Interface) là tập hợp các đối tượng, thuộc tính, phương thức do trình duyệt cung cấp để JavaScript tương tác với DOM. Ví dụ: <code>document.getElementById()</code>, <code>element.innerHTML</code>, <code>element.style.color</code>, <code>element.addEventListener()</code>.</p>
<h3 id="dom-document-object-trong-javascript"><a class="header" href="#dom-document-object-trong-javascript">DOM Document Object trong JavaScript</a></h3>
<p><code>document</code> object là entry point (điểm bắt đầu) để truy cập DOM từ JavaScript. Đại diện cho toàn bộ trang HTML. Các phương thức và thuộc tính của <code>document</code> cho phép truy cập và thao tác với các phần tử HTML trên trang.</p>
<h3 id="lấy-element-trong-dom"><a class="header" href="#lấy-element-trong-dom">Lấy element trong DOM</a></h3>
<p>Các phương thức chính để lấy element (phần tử HTML) từ DOM:</p>
<ul>
<li><code>document.getElementById(id)</code>: Lấy element có <code>id</code> attribute tương ứng (trả về 1 element hoặc <code>null</code>).</li>
<li><code>document.getElementsByClassName(className)</code>: Lấy danh sách (HTMLCollection) các element có <code>class</code> attribute tương ứng (trả về HTMLCollection rỗng nếu không tìm thấy).</li>
<li><code>document.getElementsByTagName(tagName)</code>: Lấy danh sách (HTMLCollection) các element có tag name tương ứng (ví dụ: &quot;p&quot;, &quot;div&quot;, &quot;a&quot;...) (trả về HTMLCollection rỗng nếu không tìm thấy).</li>
<li><code>document.querySelector(selector)</code>: Lấy <strong>element đầu tiên</strong> phù hợp với CSS selector (trả về 1 element hoặc <code>null</code>).</li>
<li><code>document.querySelectorAll(selector)</code>: Lấy danh sách (NodeList) <strong>tất cả</strong> element phù hợp với CSS selector (trả về NodeList rỗng nếu không tìm thấy). Nên dùng <code>querySelector</code> và <code>querySelectorAll</code> vì linh hoạt hơn (dùng CSS selector).</li>
</ul>
<p><strong>Ví dụ:</strong></p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Ví dụ DOM Get Element&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h1 id=&quot;title&quot;&gt;Tiêu đề chính&lt;/h1&gt;
    &lt;p class=&quot;paragraph&quot;&gt;Đoạn văn 1.&lt;/p&gt;
    &lt;p class=&quot;paragraph&quot;&gt;Đoạn văn 2.&lt;/p&gt;
    &lt;ul&gt;
        &lt;li&gt;Item 1&lt;/li&gt;
        &lt;li&gt;Item 2&lt;/li&gt;
    &lt;/ul&gt;
    &lt;div id=&quot;container&quot;&gt;
        &lt;button&gt;Click me&lt;/button&gt;
    &lt;/div&gt;

    &lt;script&gt;
        let titleElement = document.getElementById(&quot;title&quot;); // Lấy theo ID
        console.log(titleElement); // &lt;h1 id=&quot;title&quot;&gt;...&lt;/h1&gt;

        let paragraphElements = document.getElementsByClassName(&quot;paragraph&quot;); // Lấy theo class
        console.log(paragraphElements); // HTMLCollection [p.paragraph, p.paragraph]

        let liElements = document.getElementsByTagName(&quot;li&quot;); // Lấy theo tag name
        console.log(liElements); // HTMLCollection [li, li]

        let firstParagraph = document.querySelector(&quot;.paragraph&quot;); // Lấy element đầu tiên theo CSS selector
        console.log(firstParagraph); // &lt;p class=&quot;paragraph&quot;&gt;...&lt;/p&gt;

        let allParagraphs = document.querySelectorAll(&quot;.paragraph&quot;); // Lấy tất cả element theo CSS selector
        console.log(allParagraphs); // NodeList [p.paragraph, p.paragraph]
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="lấy-element-trong-dom-1"><a class="header" href="#lấy-element-trong-dom-1">Lấy element trong DOM</a></h3>
<p>Tiếp tục về các phương thức lấy element, có thể tập trung vào <code>querySelector</code> và <code>querySelectorAll</code> và các loại CSS selector có thể dùng (class, id, tag name, attribute selectors, pseudo-classes...).</p>
<h3 id="lấy-element-trong-dom-2"><a class="header" href="#lấy-element-trong-dom-2">Lấy element trong DOM</a></h3>
<p>Có thể đi sâu vào performance khi chọn element, cách tối ưu selector, và sự khác biệt giữa HTMLCollection và NodeList (HTMLCollection là live collection - tự động cập nhật khi DOM thay đổi, NodeList có thể là static hoặc live tùy phương thức lấy).</p>
<h3 id="attribute-node-và-text-node-trong-html-dom"><a class="header" href="#attribute-node-và-text-node-trong-html-dom">Attribute node và Text node trong HTML DOM</a></h3>
<p>Trong DOM tree, mỗi element HTML là một element node. Bên trong element node có thể có attribute nodes (thuộc tính HTML) và text nodes (nội dung text).</p>
<h3 id="dom-attribute"><a class="header" href="#dom-attribute">DOM attribute</a></h3>
<p>DOM API cung cấp các phương thức để thao tác với attribute nodes:</p>
<ul>
<li><code>element.getAttribute(attributeName)</code>: Lấy giá trị attribute.</li>
<li><code>element.setAttribute(attributeName, value)</code>: Sửa đổi hoặc thêm attribute.</li>
<li><code>element.removeAttribute(attributeName)</code>: Xóa attribute.</li>
<li><code>element.hasAttribute(attributeName)</code>: Kiểm tra xem element có attribute không.</li>
</ul>
<p><strong>Ví dụ:</strong></p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Ví dụ DOM Attribute&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;a id=&quot;link&quot; href=&quot;https://f8.edu.vn&quot; target=&quot;_blank&quot;&gt;F8&lt;/a&gt;

    &lt;script&gt;
        let linkElement = document.getElementById(&quot;link&quot;);
        console.log(linkElement.getAttribute(&quot;href&quot;)); // &quot;https://f8.edu.vn&quot;
        linkElement.setAttribute(&quot;title&quot;, &quot;Học lập trình tại F8&quot;); // Thêm attribute title
        console.log(linkElement.getAttribute(&quot;title&quot;)); // &quot;Học lập trình tại F8&quot;
        linkElement.removeAttribute(&quot;target&quot;); // Xóa attribute target
        console.log(linkElement.hasAttribute(&quot;target&quot;)); // false
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="innertext--textcontent-property"><a class="header" href="#innertext--textcontent-property">InnerText &amp; textContent Property</a></h3>
<p><code>innerText</code> và <code>textContent</code> properties dùng để lấy hoặc set nội dung text của một element.</p>
<ul>
<li><code>innerText</code>: Chỉ lấy text &quot;hiển thị&quot; (sau khi render), không lấy text của các element ẩn (ví dụ: <code>display: none</code>).</li>
<li><code>textContent</code>: Lấy <strong>tất cả</strong> text content, kể cả text của element ẩn. Nên dùng <code>textContent</code> vì chuẩn hơn, nhất quán hơn.</li>
</ul>
<p><strong>Ví dụ:</strong></p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Ví dụ innerText &amp; textContent&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;content&quot;&gt;
        &lt;p&gt;Đoạn văn bản 1.&lt;/p&gt;
        &lt;p style=&quot;display: none;&quot;&gt;Đoạn văn bản 2 (ẩn).&lt;/p&gt;
    &lt;/div&gt;

    &lt;script&gt;
        let contentElement = document.getElementById(&quot;content&quot;);
        console.log(contentElement.innerText);
        // Đoạn văn bản 1.
        console.log(contentElement.textContent);
        // Đoạn văn bản 1.
        // Đoạn văn bản 2 (ẩn).
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="thêm-element-vào-element-trong-dom"><a class="header" href="#thêm-element-vào-element-trong-dom">Thêm element vào element trong DOM</a></h3>
<ul>
<li>
<p><strong>Tóm tắt:</strong></p>
</li>
<li>
<p><code>element.innerHTML</code>: Lấy hoặc set <strong>HTML content bên trong</strong> element (dạng chuỗi HTML). Có thể dùng để thêm HTML vào element.</p>
</li>
<li>
<p><code>element.outerHTML</code>: Lấy hoặc set <strong>HTML content của chính element và bên trong nó</strong> (dạng chuỗi HTML).</p>
</li>
</ul>
<p><strong>Ví dụ:</strong></p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Ví dụ innerHTML &amp; outerHTML&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;container&quot;&gt;
        &lt;p&gt;Đoạn văn bản ban đầu.&lt;/p&gt;
    &lt;/div&gt;

    &lt;script&gt;
        let containerElement = document.getElementById(&quot;container&quot;);
        console.log(containerElement.innerHTML); // &quot;&lt;p&gt;Đoạn văn bản ban đầu.&lt;/p&gt;&quot;

        containerElement.innerHTML = &quot;&lt;h2&gt;Tiêu đề mới&lt;/h2&gt;&lt;p&gt;Đoạn văn bản mới.&lt;/p&gt;&quot;; // Set HTML content mới
        console.log(containerElement.innerHTML);
        // &quot;&lt;h2&gt;Tiêu đề mới&lt;/h2&gt;&lt;p&gt;Đoạn văn bản mới.&lt;/p&gt;&quot;

        console.log(containerElement.outerHTML);
        // &quot;&lt;div id=&quot;container&quot;&gt;&lt;h2&gt;Tiêu đề mới&lt;/h2&gt;&lt;p&gt;Đoạn văn bản mới.&lt;/p&gt;&lt;/div&gt;&quot;
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="node-properties"><a class="header" href="#node-properties">Node properties</a></h3>
<p>Node properties (thuộc tính node) cung cấp thông tin về node trong DOM tree. Ví dụ:</p>
<ul>
<li><code>node.nodeName</code>: Tên node (tag name cho element node, &quot;#text&quot; cho text node...).</li>
<li><code>node.nodeType</code>: Loại node (1: element node, 3: text node...).</li>
<li><code>node.parentNode</code>: Node cha.</li>
<li><code>node.childNodes</code>: Danh sách node con (HTMLCollection/NodeList).</li>
<li><code>node.firstChild</code>, <code>node.lastChild</code>, <code>node.nextSibling</code>, <code>node.previousSibling</code>: Node con đầu, con cuối, node anh em kế tiếp, node anh em trước đó.</li>
</ul>
<h3 id="Đối-tượng-dom-style-trong-element-node"><a class="header" href="#Đối-tượng-dom-style-trong-element-node">Đối tượng DOM style trong Element node</a></h3>
<p><code>element.style</code> object cho phép truy cập và sửa đổi inline styles (style viết trực tiếp trong attribute <code>style</code>) của element từ JavaScript.</p>
<p><strong>Ví dụ:</strong></p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Ví dụ DOM Style&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;box&quot; style=&quot;background-color: lightblue; width: 200px; height: 100px;&quot;&gt;
        Khối hộp
    &lt;/div&gt;

    &lt;script&gt;
        let boxElement = document.getElementById(&quot;box&quot;);
        console.log(boxElement.style.backgroundColor); // &quot;lightblue&quot; (lấy style background-color)
        boxElement.style.color = &quot;red&quot;; // Set style color
        boxElement.style.border = &quot;2px solid black&quot;; // Set style border
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="classlist-property"><a class="header" href="#classlist-property">ClassList Property</a></h3>
<p><code>element.classList</code> property trả về một đối tượng <code>DOMTokenList</code> đại diện cho danh sách class của element. Cung cấp các phương thức để thao tác với class:</p>
<ul>
<li><code>classList.add(className)</code>: Thêm class.</li>
<li><code>classList.remove(className)</code>: Xóa class.</li>
<li><code>classList.toggle(className)</code>: Thêm class nếu chưa có, xóa class nếu đã có.</li>
<li><code>classList.contains(className)</code>: Kiểm tra xem element có class không.</li>
</ul>
<p><strong>Ví dụ:</strong></p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Ví dụ classList&lt;/title&gt;
    &lt;style&gt;
        .highlight {
            background-color: yellow;
            font-weight: bold;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;p id=&quot;text&quot;&gt;Đoạn văn bản.&lt;/p&gt;
    &lt;button id=&quot;toggleBtn&quot;&gt;Toggle Highlight&lt;/button&gt;

    &lt;script&gt;
        let textElement = document.getElementById(&quot;text&quot;);
        let toggleButton = document.getElementById(&quot;toggleBtn&quot;);

        toggleButton.addEventListener(&quot;click&quot;, function() {
            textElement.classList.toggle(&quot;highlight&quot;); // Toggle class &quot;highlight&quot;
        });
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="dom-events"><a class="header" href="#dom-events">DOM events</a></h3>
<p>DOM events (sự kiện DOM) là các hành động xảy ra trên trang web (click chuột, gõ phím, load trang...). JavaScript có thể lắng nghe (listen) và xử lý (handle) các sự kiện này để tạo tương tác.</p>
<h3 id="dom-events-example"><a class="header" href="#dom-events-example">DOM events example</a></h3>
<p>Ví dụ về các sự kiện DOM phổ biến:</p>
<ul>
<li>
<p><code>click</code>: Click chuột.</p>
</li>
<li>
<p><code>mouseover</code>, <code>mouseout</code>: Chuột di vào, di ra khỏi element.</p>
</li>
<li>
<p><code>keydown</code>, <code>keyup</code>: Phím được nhấn, phím được nhả.</p>
</li>
<li>
<p><code>submit</code>: Form được submit.</p>
</li>
<li>
<p><code>load</code>: Trang hoặc resource (ảnh, script...) đã load xong.</p>
</li>
<li>
<p><code>DOMContentLoaded</code>: DOM tree đã được parse xong.</p>
</li>
<li>
<p><strong>Ví dụ (sự kiện click):</strong></p>
</li>
</ul>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Ví dụ DOM Event&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;button id=&quot;myButton&quot;&gt;Click me&lt;/button&gt;
    &lt;p id=&quot;message&quot;&gt;&lt;/p&gt;

    &lt;script&gt;
        let buttonElement = document.getElementById(&quot;myButton&quot;);
        let messageElement = document.getElementById(&quot;message&quot;);

        buttonElement.addEventListener(&quot;click&quot;, function() { // Lắng nghe sự kiện click
            messageElement.textContent = &quot;Button đã được click!&quot;; // Xử lý sự kiện click
        });
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="preventdefault--stoppropagation"><a class="header" href="#preventdefault--stoppropagation">PreventDefault &amp; StopPropagation</a></h3>
<ul>
<li>
<p><strong>Tóm tắt:</strong></p>
</li>
<li>
<p><code>event.preventDefault()</code>: Ngăn chặn hành vi mặc định của sự kiện (ví dụ: ngăn link chuyển trang, ngăn form submit trang).</p>
</li>
<li>
<p><code>event.stopPropagation()</code>: Ngăn chặn sự kiện lan truyền lên các element cha (event bubbling).</p>
</li>
<li>
<p><strong>Ví dụ (<code>preventDefault</code> trên link):</strong></p>
</li>
</ul>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Ví dụ preventDefault&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;a href=&quot;https://f8.edu.vn&quot; id=&quot;link&quot;&gt;Link F8&lt;/a&gt;
    &lt;script&gt;
        let linkElement = document.getElementById(&quot;link&quot;);
        linkElement.addEventListener(&quot;click&quot;, function(event) {
            event.preventDefault(); // Ngăn link chuyển trang
            alert(&quot;Link click bị chặn!&quot;);
        });
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="event-listener"><a class="header" href="#event-listener">Event listener</a></h3>
<p>Event listener (bộ lắng nghe sự kiện) dùng để đăng ký (attach) một function (event handler) để xử lý một sự kiện trên một element.</p>
<ul>
<li><code>element.addEventListener(eventType, eventHandler, useCapture)</code>: Đăng ký event listener.</li>
<li><code>element.removeEventListener(eventType, eventHandler, useCapture)</code>: Gỡ bỏ event listener.</li>
</ul>
<pre><code class="language-js">const button = document.querySelector(&quot;.btn&quot;)
button.addEventListener(&quot;click&quot;, function(event) {
  console.log(&quot;Hello!&quot;);
})

// OR using Javascript one-liners
button.addEventListener(&quot;click&quot;, event =&gt; console.log(&quot;Hello!&quot;))
</code></pre>
<h2 id="phần-6-json-promise-es6"><a class="header" href="#phần-6-json-promise-es6">Phần 6: JSON, Promise, ES6+</a></h2>
<h3 id="json-là-gì-Được-sử-dụng-ra-sao-trong-js"><a class="header" href="#json-là-gì-Được-sử-dụng-ra-sao-trong-js">JSON là gì? Được sử dụng ra sao trong JS?</a></h3>
<p>JSON (JavaScript Object Notation) là định dạng dữ liệu text nhẹ, dễ đọc, dễ parse, dựa trên cú pháp object của JavaScript. Dùng phổ biến để trao đổi dữ liệu giữa server và client trong web development (ví dụ: API).</p>
<ul>
<li>
<p>Cấu trúc: key-value pairs, key là chuỗi, value có thể là string, number, boolean, null, array, object.</p>
</li>
<li>
<p>Ví dụ JSON:</p>
</li>
</ul>
<pre><code class="language-json">    {
        &quot;name&quot;: &quot;Gemini&quot;,
        &quot;age&quot;: 2,
        &quot;isRobot&quot;: true,
        &quot;skills&quot;: [&quot;learning&quot;, &quot;coding&quot;, &quot;talking&quot;]
    }
</code></pre>
<ul>
<li>
<p><strong>JavaScript built-in object <code>JSON</code> cung cấp:</strong></p>
</li>
<li>
<p><code>JSON.stringify(object)</code>: Chuyển đổi object JavaScript sang chuỗi JSON.</p>
</li>
<li>
<p><code>JSON.parse(jsonString)</code>: Chuyển đổi chuỗi JSON sang object JavaScript.</p>
</li>
</ul>
<p><strong>Ví dụ:</strong></p>
<pre><code class="language-javascript">let personObject = { name: &quot;Gemini&quot;, age: 2 };
let jsonString = JSON.stringify(personObject); // Chuyển object sang JSON string
console.log(jsonString); // '{&quot;name&quot;:&quot;Gemini&quot;,&quot;age&quot;:2}'

let parsedObject = JSON.parse(jsonString); // Chuyển JSON string sang object
console.log(parsedObject.name); // &quot;Gemini&quot;
</code></pre>
<h3 id="promise-sync-async-trong-javascript"><a class="header" href="#promise-sync-async-trong-javascript">Promise (sync async) trong JavaScript</a></h3>
<p>Promise là object đại diện cho kết quả (thành công hoặc thất bại) của một tác vụ <strong>bất đồng bộ</strong> (asynchronous) và có thể chưa hoàn thành ngay lập tức (ví dụ: gọi API, đọc file...). Giúp xử lý bất đồng bộ một cách dễ đọc, dễ quản lý hơn so với callback.</p>
<ul>
<li><strong>Trạng thái Promise:</strong>
<ul>
<li><code>pending</code> (chờ xử lý): Tác vụ chưa hoàn thành.</li>
<li><code>fulfilled</code> (thành công): Tác vụ hoàn thành thành công.</li>
<li><code>rejected</code> (thất bại): Tác vụ hoàn thành thất bại.</li>
</ul>
</li>
</ul>
<h3 id="promise-nỗi-đau"><a class="header" href="#promise-nỗi-đau">Promise (nỗi đau)</a></h3>
<p>Có thể nói về &quot;callback hell&quot; và tại sao Promise ra đời để giải quyết vấn đề callback hell. Promise giúp code bất đồng bộ dễ đọc, dễ maintain hơn bằng cách &quot;chaining&quot; các tác vụ bất đồng bộ tuần tự hoặc song song.</p>
<h3 id="promise-trong-javascript"><a class="header" href="#promise-trong-javascript">Promise trong Javascript</a></h3>
<p>Cách tạo Promise: <code>new Promise((resolve, reject) =&gt; { ... });</code></p>
<ul>
<li>
<p><code>resolve(value)</code>: Gọi khi tác vụ thành công, truyền giá trị kết quả.</p>
</li>
<li>
<p><code>reject(error)</code>: Gọi khi tác vụ thất bại, truyền lỗi.</p>
</li>
<li>
<p><strong>Cách xử lý kết quả Promise:</strong></p>
</li>
<li>
<p><code>.then(onFulfilled)</code>: Xử lý khi Promise fulfilled (thành công).</p>
</li>
<li>
<p><code>.catch(onRejected)</code>: Xử lý khi Promise rejected (thất bại).</p>
</li>
<li>
<p><code>.finally(onFinally)</code>: Thực hiện code sau khi Promise fulfilled hoặc rejected (không quan tâm kết quả), thường dùng để cleanup (ví dụ: tắt loading indicator).</p>
</li>
<li>
<p><strong>Ví dụ (Promise đơn giản):</strong></p>
</li>
</ul>
<pre><code class="language-javascript">let myPromise = new Promise((resolve, reject) =&gt; {
    setTimeout(function() {
        let success = true; // Giả lập tác vụ thành công/thất bại
        if (success) {
            resolve(&quot;Dữ liệu thành công!&quot;); // Gọi resolve khi thành công
        } else {
            reject(&quot;Lỗi xảy ra!&quot;); // Gọi reject khi thất bại
        }
    }, 2000);
});

myPromise.then(function(result) { // Xử lý khi thành công
    console.log(&quot;Thành công:&quot;, result); // &quot;Thành công: Dữ liệu thành công!&quot;
}).catch(function(error) { // Xử lý khi thất bại
    console.log(&quot;Lỗi:&quot;, error); // &quot;Lỗi: Lỗi xảy ra!&quot; (nếu success = false)
}).finally(function() { // Thực hiện sau khi Promise xong (dù thành công hay thất bại)
    console.log(&quot;Promise đã hoàn thành.&quot;);
});
</code></pre>
<h3 id="promise-chain"><a class="header" href="#promise-chain">Promise chain</a></h3>
<p>Promise chaining (chuỗi Promise) cho phép liên kết các tác vụ bất đồng bộ tuần tự. <code>.then()</code> có thể trả về một Promise mới, tạo thành chuỗi. Giúp xử lý các tác vụ phụ thuộc lẫn nhau một cách tuần tự.</p>
<ul>
<li><strong>Ví dụ (Promise chain):</strong></li>
</ul>
<pre><code class="language-javascript">function fetchData(url) {
    return new Promise((resolve, reject) =&gt; {
        // Giả lập fetch API
        setTimeout(function() {
            let data = &quot;Dữ liệu từ &quot; + url;
            resolve(data);
        }, 1000);
    });
}

fetchData(&quot;url1&quot;).then(function(data1) { // Gọi API 1
    console.log(&quot;Dữ liệu 1:&quot;, data1); // Xử lý dữ liệu 1
    return fetchData(&quot;url2&quot;); // Trả về Promise mới để gọi API 2
}).then(function(data2) { // Chạy khi Promise trả về từ .then() trước đó fulfilled
    console.log(&quot;Dữ liệu 2:&quot;, data2); // Xử lý dữ liệu 2
    return fetchData(&quot;url3&quot;); // Tiếp tục chain
}).then(function(data3) {
    console.log(&quot;Dữ liệu 3:&quot;, data3);
}).catch(function(error) { // Bắt lỗi nếu có lỗi ở bất kỳ Promise nào trong chuỗi
    console.log(&quot;Lỗi:&quot;, error);
});
</code></pre>
<h3 id="promise-methods-resolve-reject-all"><a class="header" href="#promise-methods-resolve-reject-all">Promise methods (resolve, reject, all)</a></h3>
<p>Các static methods của <code>Promise</code> object:</p>
<ul>
<li>
<p><code>Promise.resolve(value)</code>: Trả về một Promise đã fulfilled với giá trị <code>value</code>.</p>
</li>
<li>
<p><code>Promise.reject(error)</code>: Trả về một Promise đã rejected với lỗi <code>error</code>.</p>
</li>
<li>
<p><code>Promise.all(promises)</code>: Nhận vào một mảng các Promises, trả về một Promise mới fulfilled khi <strong>tất cả</strong> Promises trong mảng fulfilled, hoặc rejected ngay lập tức nếu có <strong>ít nhất một</strong> Promise rejected. Dùng để chạy các tác vụ bất đồng bộ song song và đợi tất cả hoàn thành.</p>
</li>
<li>
<p><strong>Ví dụ (<code>Promise.all</code>):</strong></p>
</li>
</ul>
<pre><code class="language-javascript">let promise1 = Promise.resolve(&quot;Promise 1 thành công&quot;);
let promise2 = new Promise(resolve =&gt; setTimeout(() =&gt; resolve(&quot;Promise 2 thành công&quot;), 1000));
let promise3 = Promise.resolve(&quot;Promise 3 thành công&quot;);

Promise.all([promise1, promise2, promise3]).then(function(results) { // Chạy song song, đợi tất cả xong
    console.log(&quot;Tất cả Promises thành công:&quot;, results); // [&quot;Promise 1 thành công&quot;, &quot;Promise 2 thành công&quot;, &quot;Promise 3 thành công&quot;]
}).catch(function(error) {
    console.log(&quot;Có lỗi:&quot;, error);
});
</code></pre>
<h3 id="học-về-javascript-ecmascript-6"><a class="header" href="#học-về-javascript-ecmascript-6">Học về JavaScript ECMAScript 6</a></h3>
<p>ECMAScript 6 (ES6) hoặc ES2015 là phiên bản JavaScript ra mắt năm 2015, giới thiệu nhiều tính năng mới, hiện đại, giúp code JavaScript mạnh mẽ và dễ viết hơn. Các tính năng ES6 quan trọng: <code>let</code>, <code>const</code>, arrow function, template literals, classes, modules, destructuring, spread operator...</p>
<p>Sẽ được cập nhật dần bên dưới </p>
<h3 id="let--const-keyword"><a class="header" href="#let--const-keyword">Let &amp; Const keyword</a></h3>
<p>(Đã đề cập ở mục 5) Ôn lại và so sánh <code>let</code> và <code>const</code> với <code>var</code>. Nên ưu tiên dùng <code>let</code> và <code>const</code> thay cho <code>var</code> vì có phạm vi block-scoped rõ ràng hơn, tránh lỗi hoisting.</p>
<h3 id="arrow-function-trong-javascript-es6"><a class="header" href="#arrow-function-trong-javascript-es6">Arrow function trong JavaScript ES6</a></h3>
<p>(Đã đề cập ở mục 29) Ôn lại arrow function, cú pháp ngắn gọn hơn cho anonymous function, đặc biệt hữu ích trong callback functions.</p>
<pre><code class="language-js">const multiplyByTwo = (num) =&gt; {
    return num * 2;
}
</code></pre>
<h3 id="template-literals-template-string-trong-javascript-es6"><a class="header" href="#template-literals-template-string-trong-javascript-es6">Template literals (Template string) trong javascript ES6</a></h3>
<p>Template literals (template string) dùng backtick `` để khai báo chuỗi, cho phép nhúng biến trực tiếp vào chuỗi bằng cú pháp <code>${variable}</code> (string interpolation), và hỗ trợ chuỗi nhiều dòng dễ dàng.</p>
<p><strong>Ví dụ:</strong></p>
<pre><code class="language-javascript">let name = &quot;Gemini&quot;;
let age = 2;
let message = `Xin chào, tôi là ${name}, ${age} tuổi.
Tôi là một robot.`; // Template literals, chuỗi nhiều dòng
console.log(message);
// Xin chào, tôi là Gemini, 2 tuổi.
// Tôi là một robot.
</code></pre>
<h3 id="classes-trong-javascript-es6"><a class="header" href="#classes-trong-javascript-es6">Classes trong JavaScript ES6</a></h3>
<p>Classes trong ES6 cung cấp cú pháp mới để định nghĩa object và kế thừa, gần gũi hơn với các ngôn ngữ hướng đối tượng khác (nhưng vẫn dựa trên prototype-based inheritance của JavaScript).</p>
<ul>
<li><strong>Ví dụ (Class cơ bản):</strong></li>
</ul>
<pre><code class="language-javascript">class Animal { // Định nghĩa class Animal
    constructor(name) { // Constructor
        this.name = name;
    }

    speak() { // Method speak
        console.log(this.name + &quot; makes a sound.&quot;);
    }
}

class Dog extends Animal { // Class Dog kế thừa từ Animal
    constructor(name, breed) {
        super(name); // Gọi constructor của class cha
        this.breed = breed;
    }

    bark() { // Method bark riêng của Dog
        console.log(&quot;Woof!&quot;);
    }
}

let animal = new Animal(&quot;Generic Animal&quot;);
animal.speak(); // &quot;Generic Animal makes a sound.&quot;

let dog = new Dog(&quot;Lucky&quot;, &quot;Golden Retriever&quot;);
dog.speak(); // &quot;Lucky makes a sound.&quot; (kế thừa từ Animal)
dog.bark(); // &quot;Woof!&quot; (method của Dog)
</code></pre>
<h3 id="enhanced-object-literals-trong-javascript-es6"><a class="header" href="#enhanced-object-literals-trong-javascript-es6">Enhanced object literals trong javascript ES6</a></h3>
<p>Enhanced object literals (object literals cải tiến) trong ES6 cung cấp cú pháp ngắn gọn hơn để tạo object:</p>
<ul>
<li>Shorthand property names: Nếu key và value có cùng tên biến, có thể viết tắt <code>key</code> thay vì <code>key: key</code>.</li>
<li>Method shorthand: Bỏ từ khóa <code>function</code> khi định nghĩa method trong object.</li>
<li>Computed property names: Key có thể là biểu thức được tính toán trong ngoặc vuông <code>[...]</code>.</li>
</ul>
<p><strong>Ví dụ:</strong></p>
<pre><code class="language-javascript">let name = &quot;Gemini&quot;;
let age = 2;

let person = {
    name, // Shorthand property name (tương đương name: name)
    age,  // Shorthand property name (tương đương age: age)
    greet() { // Method shorthand (bỏ function keyword)
        console.log(&quot;Xin chào, tôi là &quot; + this.name);
    },
    [&quot;skill&quot; + &quot;1&quot;]: &quot;learning&quot; // Computed property name (key được tính toán)
};

console.log(person.name); // &quot;Gemini&quot;
person.greet(); // &quot;Xin chào, tôi là Gemini&quot;
console.log(person.skill1); // &quot;learning&quot;
</code></pre>
<h3 id="default-parameter-values-trong-javascript-es6"><a class="header" href="#default-parameter-values-trong-javascript-es6">Default parameter values trong JavaScript ES6</a></h3>
<p>Default parameter values (giá trị tham số mặc định) trong ES6 cho phép gán giá trị mặc định cho tham số của hàm. Nếu khi gọi hàm không truyền đối số cho tham số đó, tham số sẽ nhận giá trị mặc định.</p>
<p><strong>Ví dụ:</strong></p>
<pre><code class="language-javascript">function greet(name = &quot;Guest&quot;) { // Tham số name có giá trị mặc định &quot;Guest&quot;
    console.log(&quot;Xin chào, &quot; + name + &quot;!&quot;);
}

greet(&quot;Gemini&quot;); // &quot;Xin chào, Gemini!&quot; (truyền đối số)
greet(); // &quot;Xin chào, Guest!&quot; (không truyền đối số, dùng giá trị mặc định)
</code></pre>
<h3 id="destructuring-trong-javascript-es6"><a class="header" href="#destructuring-trong-javascript-es6">Destructuring trong JavaScript ES6</a></h3>
<p>Destructuring (phân rã cấu trúc) trong ES6 cho phép &quot;giải nén&quot; giá trị từ mảng hoặc object vào các biến riêng biệt một cách ngắn gọn.</p>
<ul>
<li><strong>Ví dụ (destructuring mảng):</strong></li>
</ul>
<pre><code class="language-javascript">let colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;];
let [firstColor, secondColor, thirdColor] = colors; // Destructuring mảng

console.log(firstColor); // &quot;red&quot;
console.log(secondColor); // &quot;green&quot;
console.log(thirdColor); // &quot;blue&quot;
</code></pre>
<ul>
<li><strong>Ví dụ (destructuring object):</strong></li>
</ul>
<pre><code class="language-javascript">let person = { name: &quot;Gemini&quot;, age: 2, city: &quot;Internet&quot; };
let { name, age } = person; // Destructuring object (lấy thuộc tính name và age)

console.log(name); // &quot;Gemini&quot;
console.log(age); // 2
</code></pre>
<h3 id="spread-trong-javascript-es6"><a class="header" href="#spread-trong-javascript-es6">Spread trong JavaScript ES6</a></h3>
<p>Spread operator (<code>...</code>) trong ES6 có nhiều ứng dụng:</p>
<ul>
<li>
<p><strong>Copy mảng/object:</strong> Tạo bản sao nông (shallow copy) của mảng hoặc object.</p>
</li>
<li>
<p><strong>Nối mảng:</strong> Nối nhiều mảng thành một mảng mới.</p>
</li>
<li>
<p><strong>Truyền đối số hàm:</strong> Truyền các phần tử của mảng làm đối số riêng lẻ cho hàm.</p>
</li>
<li>
<p><strong>Rest parameters (tham số rest):</strong> Thu thập các đối số còn lại của hàm vào một mảng.</p>
</li>
<li>
<p><strong>Ví dụ (copy mảng, nối mảng):</strong></p>
</li>
</ul>
<pre><code class="language-javascript">let arr1 = [1, 2, 3];
let arr2 = [...arr1]; // Copy mảng arr1
console.log(arr2); // [1, 2, 3]
arr2.push(4); // Thay đổi arr2 không ảnh hưởng arr1 (shallow copy)
console.log(arr1); // [1, 2, 3]

let arr3 = [4, 5, 6];
let combinedArray = [...arr1, ...arr3]; // Nối mảng arr1 và arr3
console.log(combinedArray); // [1, 2, 3, 4, 5, 6]
</code></pre>
<h3 id="khái-niệm-tagged-template-literals-ít-người-biết"><a class="header" href="#khái-niệm-tagged-template-literals-ít-người-biết">Khái niệm tagged template literals (ít người biết)</a></h3>
<p>Tagged template literals là một tính năng nâng cao của template literals. Cho phép bạn định nghĩa một &quot;tag function&quot; để xử lý template literal theo cách tùy chỉnh. Ít dùng trong thực tế hàng ngày, nhưng hữu ích trong một số trường hợp đặc biệt (ví dụ: sanitizing input, i18n...).</p>
<h3 id="module-trong-javascript-es6"><a class="header" href="#module-trong-javascript-es6">Module trong JavaScript ES6</a></h3>
<p>Modules trong ES6 cho phép chia code JavaScript thành các file (module) riêng biệt, giúp code có cấu trúc tốt hơn, dễ tái sử dụng, dễ bảo trì.</p>
<ul>
<li><code>export</code>: Để export (xuất) các biến, hàm, class từ module.</li>
<li><code>import</code>: Để import (nhập) các module khác vào module hiện tại.</li>
</ul>
<p><strong>Ví dụ:</strong></p>
<ul>
<li><strong><code>module1.js</code> (module 1):</strong></li>
</ul>
<pre><code class="language-javascript">    export const message = &quot;Xin chào từ module 1!&quot;; // Export biến
    export function greet(name) { // Export hàm
        console.log(message + &quot; &quot; + name);
    }
</code></pre>
<ul>
<li><strong><code>main.js</code> (module chính):</strong></li>
</ul>
<pre><code class="language-javascript">    import { message, greet } from './module1.js'; // Import từ module1.js

    console.log(message); // &quot;Xin chào từ module 1!&quot;
    greet(&quot;User&quot;); // &quot;Xin chào từ module 1! User&quot;
</code></pre>
<ul>
<li><strong>Trong HTML, cần thêm <code>type=&quot;module&quot;</code> vào thẻ <code>&lt;script&gt;</code>:</strong></li>
</ul>
<pre><code class="language-html">    &lt;script type=&quot;module&quot; src=&quot;main.js&quot;&gt;&lt;/script&gt;
</code></pre>
<h3 id="khái-niệm-optional-chaining"><a class="header" href="#khái-niệm-optional-chaining">Khái niệm Optional chaining</a></h3>
<p>Optional chaining operator <code>?.</code> (ES2020+) giúp truy cập thuộc tính của object một cách an toàn, tránh lỗi khi object hoặc thuộc tính trung gian có thể <code>null</code> hoặc <code>undefined</code>. Nếu giá trị trước <code>?.</code> là <code>null</code> hoặc <code>undefined</code>, biểu thức trả về <code>undefined</code> ngay lập tức, không gây lỗi.</p>
<p><strong>Ví dụ:</strong></p>
<pre><code class="language-javascript">let user = {
    name: &quot;Gemini&quot;,
    address: {
        city: &quot;Internet&quot;
    }
};

console.log(user.address?.city); // &quot;Internet&quot; (truy cập an toàn, nếu address có tồn tại)
console.log(user.profile?.email); // undefined (user.profile không tồn tại, không lỗi)

// Không dùng optional chaining, có thể gây lỗi:
// console.log(user.profile.email); // Lỗi: Cannot read property 'email' of undefined
</code></pre>
<h3 id="fetch"><a class="header" href="#fetch">Fetch</a></h3>
<p>Fetch API là built-in API hiện đại trong JavaScript để thực hiện các request HTTP (gọi API) một cách bất đồng bộ (dựa trên Promise). Thay thế cho <code>XMLHttpRequest</code> cũ.</p>
<ul>
<li><strong>Ví dụ (GET request với Fetch API):</strong></li>
</ul>
<pre><code class="language-javascript">fetch('https://jsonplaceholder.typicode.com/todos/1') // Gọi API GET
    .then(response =&gt; response.json()) // Parse response body thành JSON (trả về Promise)
    .then(data =&gt; { // Chạy khi Promise từ response.json() fulfilled
        console.log(data); // In ra dữ liệu JSON
    })
    .catch(error =&gt; { // Bắt lỗi nếu có lỗi trong quá trình fetch hoặc parse JSON
        console.error(&quot;Lỗi fetch:&quot;, error);
    });
</code></pre>
<h3 id="json-server"><a class="header" href="#json-server">JSON server</a></h3>
<p>JSON Server là thư viện Node.js giúp tạo nhanh REST API giả lập từ file JSON. Dùng để test frontend, làm backend demo, học API... Cài đặt bằng npm: <code>npm install -g json-server</code>. Chạy server: <code>json-server --watch db.json</code>.</p>
<h3 id="phương-thức-reduce-có-logic-như-thế-nào"><a class="header" href="#phương-thức-reduce-có-logic-như-thế-nào">Phương thức reduce có logic như thế nào?</a></h3>
<p>(Đã đề cập ở mục 51, 52) Ôn lại và đi sâu hơn về logic hoạt động của <code>reduce()</code> method, cách accumulator và currentValue thay đổi qua mỗi lần lặp, và các ứng dụng khác nhau của <code>reduce()</code>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../html-css/index.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../js/co-ban.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../html-css/index.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../js/co-ban.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
