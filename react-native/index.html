<!DOCTYPE HTML>
<html lang="vi" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>React Native - Kho code của duykhanh471</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../index.html"><strong aria-hidden="true">1.</strong> Trang chủ dự án</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.</strong> HTML/CSS/JS</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../html-css/index.html"><strong aria-hidden="true">2.1.</strong> HTML/CSS</a></li><li class="chapter-item expanded "><a href="../js/index.html"><strong aria-hidden="true">2.2.</strong> JS</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../js/co-ban.html"><strong aria-hidden="true">2.2.1.</strong> Cơ bản</a></li><li class="chapter-item expanded "><a href="../js/array.html"><strong aria-hidden="true">2.2.2.</strong> Array</a></li><li class="chapter-item expanded "><a href="../js/ngay-gio.html"><strong aria-hidden="true">2.2.3.</strong> Ngày giờ</a></li><li class="chapter-item expanded "><a href="../js/string.html"><strong aria-hidden="true">2.2.4.</strong> String</a></li><li class="chapter-item expanded "><a href="../js/object.html"><strong aria-hidden="true">2.2.5.</strong> Object</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../java/index.html"><strong aria-hidden="true">3.</strong> Java</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../java/snippets/index.html"><strong aria-hidden="true">3.1.</strong> Kho snippets</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../java/snippets/algorithms.html"><strong aria-hidden="true">3.1.1.</strong> Algorithms</a></li><li class="chapter-item expanded "><a href="../java/snippets/array.html"><strong aria-hidden="true">3.1.2.</strong> Array</a></li><li class="chapter-item expanded "><a href="../java/snippets/cls.html"><strong aria-hidden="true">3.1.3.</strong> CLS</a></li><li class="chapter-item expanded "><a href="../java/snippets/date.html"><strong aria-hidden="true">3.1.4.</strong> Date</a></li><li class="chapter-item expanded "><a href="../java/snippets/encoding.html"><strong aria-hidden="true">3.1.5.</strong> Encoding & Decoding</a></li><li class="chapter-item expanded "><a href="../java/snippets/file.html"><strong aria-hidden="true">3.1.6.</strong> File</a></li><li class="chapter-item expanded "><a href="../java/snippets/io.html"><strong aria-hidden="true">3.1.7.</strong> IO</a></li><li class="chapter-item expanded "><a href="../java/snippets/math.html"><strong aria-hidden="true">3.1.8.</strong> Math</a></li><li class="chapter-item expanded "><a href="../java/snippets/media.html"><strong aria-hidden="true">3.1.9.</strong> Media</a></li><li class="chapter-item expanded "><a href="../java/snippets/network.html"><strong aria-hidden="true">3.1.10.</strong> Network</a></li><li class="chapter-item expanded "><a href="../java/snippets/string.html"><strong aria-hidden="true">3.1.11.</strong> String</a></li><li class="chapter-item expanded "><a href="../java/snippets/thread.html"><strong aria-hidden="true">3.1.12.</strong> Thread</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../spring-boot/index.html"><strong aria-hidden="true">4.</strong> Spring Boot</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../spring-boot/core.html"><strong aria-hidden="true">4.1.</strong> Core</a></li><li class="chapter-item expanded "><a href="../spring-boot/spring-boot.html"><strong aria-hidden="true">4.2.</strong> Spring Boot</a></li><li class="chapter-item expanded "><a href="../spring-boot/jpa.html"><strong aria-hidden="true">4.3.</strong> Jpa</a></li><li class="chapter-item expanded "><a href="../spring-boot/ss.html"><strong aria-hidden="true">4.4.</strong> Spring Security</a></li><li class="chapter-item expanded "><a href="../spring-boot/redis.html"><strong aria-hidden="true">4.5.</strong> Redis</a></li></ol></li><li class="chapter-item expanded "><a href="../rust/index.html"><strong aria-hidden="true">5.</strong> Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../rust/thuat-toan.html"><strong aria-hidden="true">5.1.</strong> Thuật toán</a></li><li class="chapter-item expanded "><a href="../rust/command-line.html"><strong aria-hidden="true">5.2.</strong> CLI</a></li><li class="chapter-item expanded "><a href="../rust/he-thong.html"><strong aria-hidden="true">5.3.</strong> System</a></li><li class="chapter-item expanded "><a href="../rust/internet.html"><strong aria-hidden="true">5.4.</strong> Internet</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.5.</strong> Tệp</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../rust/tep/epub.html"><strong aria-hidden="true">5.5.1.</strong> EPUB</a></li><li class="chapter-item expanded "><a href="../rust/tep/git.html"><strong aria-hidden="true">5.5.2.</strong> Git</a></li><li class="chapter-item expanded "><a href="../rust/tep/html.html"><strong aria-hidden="true">5.5.3.</strong> HTML</a></li><li class="chapter-item expanded "><a href="../rust/tep/rss.html"><strong aria-hidden="true">5.5.4.</strong> RSS</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../react/index.html"><strong aria-hidden="true">6.</strong> React</a></li><li class="chapter-item expanded "><a href="../react-native/index.html" class="active"><strong aria-hidden="true">7.</strong> React Native</a></li><li class="chapter-item expanded "><a href="../bash/tong-hop.html"><strong aria-hidden="true">8.</strong> Bash</a></li><li class="chapter-item expanded "><a href="../regex/tong-hop.html"><strong aria-hidden="true">9.</strong> Regex</a></li><li class="chapter-item expanded "><a href="../khac/yt-dlp.html"><strong aria-hidden="true">10.</strong> yt-dlp</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Kho code của duykhanh471</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="khởi-động-react-native"><a class="header" href="#khởi-động-react-native">Khởi động React Native</a></h1>
<h2 id="bài-1"><a class="header" href="#bài-1">Bài 1</a></h2>
<p>Bài này sẽ học về React nên qua <a href="https://react.dev/">react.dev</a> để học nha.</p>
<h2 id="bài-2"><a class="header" href="#bài-2">Bài 2</a></h2>
<p>Bình thường thì sẽ là thế này:</p>
<pre><code class="language-bash">npx create-expo-app@latest &lt;app-name&gt;
# Khởi tạo thì nó sẽ ra dự án default với cả đống code mà bạn không cần, nên để dọn đi thì chỉ cần chạy
npm run reset-project
# Là xong
</code></pre>
<p>Nhưng với dự án học tập và để hiểu về React Native với React thì có thể sử dụng phần dưới đây:</p>
<pre><code class="language-bash">npx create-expo-app@latest &lt;app-name&gt; --template blank
# Do cái này không hỗ trợ Preview trên trình duyệt nên cần tải thêm
npx expo install react-dom react-native-web @expo/metro-runtime
# Là xong
</code></pre>
<p>Để chạy ứng dụng thì chỉ cần gõ:</p>
<pre><code class="language-bash">npx expo start
</code></pre>
<p>What’s inside a React Native project?</p>
<pre><code>.gitignore:
  .expo
  .vscode
node_modules:
  # Holds 3rd party packages

assets:
  # Holds images used inside app

package.json, package-lock.json:
  # Holds dependencies, script commands, etc.

app.json:
  # Configuration settings

App.js:
  # The real code
</code></pre>
<p>There’s a function component called <code>App</code>. This component acts as the root component by default. In React Native, you can’t use HTML tags in JSX code. Unlike React where your application runs on the browser, React Native application runs on mobile devices.</p>
<p><a href="https://reactnative.dev/docs/components-and-apis">React Native components documentation</a></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">React Native UI Component</th><th style="text-align: left">Android View</th><th style="text-align: left">iOS View</th><th style="text-align: left">Web Analog</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>&lt;View&gt;</code></td><td style="text-align: left"><code>&lt;ViewGroup&gt;</code></td><td style="text-align: left"><code>&lt;UIView&gt;</code></td><td style="text-align: left">A non-scrolling <code>&lt;div&gt;</code></td><td style="text-align: left">A container that supports layout with flexbox, style, some touch handling, and accessibility controls</td></tr>
<tr><td style="text-align: left"><code>&lt;Text&gt;</code></td><td style="text-align: left"><code>&lt;TextView&gt;</code></td><td style="text-align: left"><code>&lt;UITextView&gt;</code></td><td style="text-align: left"><code>&lt;p&gt;</code></td><td style="text-align: left">Displays, styles, and nests strings of text and even handles touch events</td></tr>
<tr><td style="text-align: left"><code>&lt;Image&gt;</code></td><td style="text-align: left"><code>&lt;ImageView&gt;</code></td><td style="text-align: left"><code>&lt;UIImageView&gt;</code></td><td style="text-align: left"><code>&lt;img&gt;</code></td><td style="text-align: left">Displays different types of images</td></tr>
<tr><td style="text-align: left"><code>&lt;ScrollView&gt;</code></td><td style="text-align: left"><code>&lt;ScrollView&gt;</code></td><td style="text-align: left"><code>&lt;UIScrollView&gt;</code></td><td style="text-align: left"><code>&lt;div&gt;</code></td><td style="text-align: left">A generic scrolling container that can contain multiple components and views</td></tr>
<tr><td style="text-align: left"><code>&lt;TextInput&gt;</code></td><td style="text-align: left"><code>&lt;EditText&gt;</code></td><td style="text-align: left"><code>&lt;UITextField&gt;</code></td><td style="text-align: left"><code>&lt;input type=&quot;text&quot;&gt;</code></td><td style="text-align: left">Allows the user to enter text</td></tr>
</tbody></table>
</div>
<p>Trong React Native thì chúng ta sẽ sử dụng <code>StyleSheet Objects</code> (Kiểu CSS, nhưng viết bằng JavaScript).</p>
<p>Về cơ bản thì nó sẽ trông như thế này:</p>
<pre><code class="language-jsx">const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center'
  }
});
</code></pre>
<h2 id="bài-3"><a class="header" href="#bài-3">Bài 3</a></h2>
<h3 id="what-is-fast-refresh"><a class="header" href="#what-is-fast-refresh">What is Fast Refresh?</a></h3>
<ul>
<li>Fast Refresh is a feature in React that updates the application instantly after editing the source code without reloading the entire page.</li>
<li>Key benefits:
<ul>
<li>Preserves state in function components and Hooks.</li>
<li>Speeds up development and reduces interruptions.</li>
</ul>
</li>
</ul>
<p>Limitations: State is not preserved in:</p>
<ul>
<li>Class components.</li>
<li>Modules with multiple exports besides React components.</li>
<li>Higher-order components returning class components.</li>
</ul>
<p>(Phần về Fast Refresh chắc là học qua phần lý thuyết thôi)</p>
<pre><code class="language-jsx">import React, { Component } from &quot;react&quot;;
import { Button, Text, View } from &quot;react-native&quot;;

// State is not preserved in class components
class App extends Component {
  state = { count: 0 };

  increment = () =&gt; this.setState({ count: this.state.count + 1 });

  render() {
    return (
      &lt;View&gt;
        &lt;Text&gt;{this.state.count}&lt;/Text&gt;
        &lt;Button title=&quot;Increment&quot; onPress={this.increment} /&gt;
      &lt;/View&gt;
    );
  }
}
</code></pre>
<h3 id="fast-refresh-and-hooks"><a class="header" href="#fast-refresh-and-hooks">Fast Refresh and Hooks</a></h3>
<ul>
<li><code>useState</code>, <code>useRef</code>: Preserve their values if the arguments are unchanged.</li>
<li><code>useEffect</code>, <code>useMemo</code>, <code>useCallback</code>: Always update during Fast Refresh, even if dependencies don’t change (Luôn được cập nhật trong Fast Refresh).</li>
</ul>
<pre><code class="language-jsx">import React, { useEffect, useMemo, useState } from &quot;react&quot;;
import { Button, Text, View } from &quot;react-native&quot;;

const App = ({ multiplier }) =&gt; {
  const [count, setCount] = useState(0);

  // useMemo will re-run when edited
  const double = useMemo(() =&gt; count * multiplier, [count]);

  useEffect(() =&gt; {
    console.log(&quot;Component re-rendered&quot;);
  }, []);

  return (
    &lt;View&gt;
      &lt;Text&gt;Double: {double}&lt;/Text&gt;
      &lt;Button title=&quot;Increment&quot; onPress={() =&gt; setCount(count + 1)} /&gt;
    &lt;/View&gt;
  );
};
</code></pre>
<blockquote>
<p>Mẹo hay: Type “?” on Terminal to see full list of command while <code>npm start</code> process is running. Press <code>m</code> to toggle a menu on device/emulator.</p>
</blockquote>
<h3 id="building-adaptive-user-interfaces"><a class="header" href="#building-adaptive-user-interfaces">Building Adaptive User Interfaces</a></h3>
<p>Responsive Units:</p>
<ul>
<li>Use relative units like <code>%, vh, or vw</code> for widths and heights.</li>
<li>Use scalable units like <code>em or rem</code> for font sizes.</li>
<li>Use third-party libraries such as <code>react-native-size-matters</code> to simplify responsive development.</li>
</ul>
<p>Using <code>maxWidth</code> or <code>minWidth</code> besides the regular width to create more responsive sizes.</p>
<h3 id="dimensions-api"><a class="header" href="#dimensions-api">Dimensions API</a></h3>
<pre><code class="language-jsx">import { Dimensions } from 'react-native';

const windowWidth = Dimensions.get('window').width;
const windowHeight = Dimensions.get('window').height;

// `useWindowDimensions()` is the preferred API for React components.
const { width, height } = useWindowDimensions();
</code></pre>
<h3 id="managing-layout-when-keyboard-is-visible"><a class="header" href="#managing-layout-when-keyboard-is-visible">Managing layout when keyboard is visible</a></h3>
<p><code>KeyboardAvoidingView</code></p>
<pre><code class="language-jsx">import { KeyboardAvoidingView } from 'react-native';

&lt;KeyboardAvoidingView style={styles.screen} behavior=&quot;position&quot;&gt;
  &lt;TextInput .../&gt;
&lt;/KeyboardAvoidingView&gt;
</code></pre>
<h3 id="handling-user-input"><a class="header" href="#handling-user-input">Handling user input</a></h3>
<ul>
<li>Input Components:
<ul>
<li><code>TextInput</code>: The core component for receiving user input (Hộp để ghi chữ vào).</li>
<li><code>Button</code>: Used to handle submission or trigger an action.</li>
</ul>
</li>
<li>Events:
<ul>
<li><code>onChangeText</code>: captures changes in TextInput (so that we can update the state) (Cái này để cập nhật lại thông tin vào state trong <code>&lt;TextInput&gt;</code>)</li>
<li><code>onPress</code>: Bằng <code>onClick</code> bình thường.</li>
</ul>
</li>
</ul>
<h3 id="core-component-scrollview"><a class="header" href="#core-component-scrollview">Core component: ScrollView</a></h3>
<p>Đây là phần Data để thử nghiệm</p>
<pre><code class="language-js">const users = [
  {
    userName: &quot;John Doe&quot;,
    userAge: 28,
    userAddress: &quot;123 Main St, Anytown, USA&quot;
  },
  {
    userName: &quot;Jane Smith&quot;,
    userAge: 34,
    userAddress: &quot;456 Oak Ave, Othercity, USA&quot;
  },
  {
    userName: &quot;Alice Johnson&quot;,
    userAge: 22,
    userAddress: &quot;789 Elm St, Yetanothertown, USA&quot;
  },
  {
    userName: &quot;Bob Brown&quot;,
    userAge: 45,
    userAddress: &quot;321 Pine Rd, Somewhere, USA&quot;
  },
  {
    userName: &quot;Eve Davis&quot;,
    userAge: 30,
    userAddress: &quot;654 Cedar Ln, Placesburg, USA&quot;
  }
];
</code></pre>
<pre><code class="language-jsx">&lt;View&gt;
  &lt;ScrollView&gt;
    {users.map((user, index) =&gt; (
      // Add a key prop when mapping over arrays
      &lt;View key={index}&gt;
        &lt;Text&gt;username: {user.userName}&lt;/Text&gt;
        &lt;Text&gt;userage: {user.userAge}&lt;/Text&gt;
        &lt;Text&gt;user addr: {user.userAddress}&lt;/Text&gt;
      &lt;/View&gt;
    ))}
  &lt;/ScrollView&gt;
&lt;/View&gt;;
</code></pre>
<h4 id="flatlist"><a class="header" href="#flatlist">FlatList</a></h4>
<pre><code class="language-jsx">&lt;View style={styles.bottomSection}&gt;
  &lt;FlatList
    data={DATA}
    renderItem={({ item }) =&gt; &lt;Item title={item.title} /&gt;}
    keyExtractor={item =&gt; item.id}
  /&gt;
&lt;/View&gt;;
</code></pre>
<h3 id="core-component-pressable"><a class="header" href="#core-component-pressable">Core component: Pressable</a></h3>
<p>Tương tự <code>Button</code> hoặc <code>TouchableOpacity</code></p>
<pre><code class="language-jsx">&lt;Pressable
  // Only works on Android: A feedback effect when a Pressable is touched
  android_ripple={{ color: '#cccccc' }}
  onPress={() =&gt; { console.log('Pressed') }}
&gt;
  &lt;Text style={styles.goalItem}&gt;{obj.item}&lt;/Text&gt;
&lt;/Pressable&gt;
</code></pre>
<p>Key Features of Pressable:</p>
<ul>
<li><code>onPress</code>: Handles the basic press event.</li>
<li><code>onPressIn</code>: Triggered when the press gesture starts.</li>
<li><code>onPressOut</code>: Triggered when the press gesture ends.</li>
<li><code>onLongPress</code>: Triggered when the user presses and holds the component.</li>
<li><code>style</code>: Allows you to define styles that change based on the component's state (e.g., pressed, hovered).</li>
</ul>
<h3 id="core-component-image"><a class="header" href="#core-component-image">Core component: Image</a></h3>
<pre><code class="language-jsx">// Static image:
&lt;Image source={require('./assets/favicon.png')} /&gt;

// Network image:
&lt;Image
  style={{ width: 64, height: 64 }}
  source={{
    uri: '[https://reactnative.dev/img/tiny_logo.png](https://reactnative.dev/img/tiny_logo.png)'
  }}
/&gt;
</code></pre>
<h3 id="core-component-modal"><a class="header" href="#core-component-modal">Core component: Modal</a></h3>
<p>The Modal component is a basic way to present content above an enclosing view. It will appear above the main view.</p>
<pre><code class="language-jsx">function TestModal() {
  const [modalVisible, setModalVisible] = useState(true);

  return (
    &lt;Modal
      visible={modalVisible}
      onRequestClose={() =&gt; {
        Alert.alert('Modal has been closed.');
        setModalVisible(!modalVisible);
      }}
    &gt;
      &lt;View&gt;
        &lt;Text&gt;Phần View này sẽ trôi nổi trên màn hình&lt;/Text&gt;
        &lt;Button title=&quot;Title&quot; onPress={() =&gt; setModalVisible(!modalVisible)} /&gt;
      &lt;/View&gt;
    &lt;/Modal&gt;
  )
}
</code></pre>
<h2 id="lecture-4"><a class="header" href="#lecture-4">Lecture 4</a></h2>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Events</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>onPress</code></td><td style="text-align: left">Triggered when a user taps a button or Touchable component.</td></tr>
<tr><td style="text-align: left"><code>onChangeText</code></td><td style="text-align: left">Fires when text changes in an TextInput field.</td></tr>
<tr><td style="text-align: left"><code>onSubmitEditing</code></td><td style="text-align: left">Executes when the user presses &quot;Enter&quot; or submits input.</td></tr>
<tr><td style="text-align: left"><code>onLongPress</code></td><td style="text-align: left">Activated when a user presses and holds a button.</td></tr>
<tr><td style="text-align: left"><code>onFocus</code> / <code>onBlur</code></td><td style="text-align: left">Used for handling focus state in input fields.</td></tr>
</tbody></table>
</div>
<pre><code class="language-jsx">import React, { useState } from &quot;react&quot;;
import { View, Text, Button, StyleSheet } from &quot;react-native&quot;;

const CounterApp = () =&gt; {
  const [count, setCount] = useState(0);
  return (
    &lt;View style={styles.container}&gt;
      &lt;Text&gt;Count: {count}&lt;/Text&gt;
      &lt;Button title=&quot;Increase&quot; onPress={() =&gt; setCount(count + 1)} /&gt;
    &lt;/View&gt;
  );
};

export default CounterApp;

// Assume styles object is defined elsewhere
const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
});
</code></pre>
<ul>
<li>The <code>count</code> state stores a number.</li>
<li><code>setCount</code> updates the value when the button is clicked.</li>
</ul>
<p>Syntax of <code>useEffect</code>, không hiểu lắm (Hình như là để giữ state cho external systems hoặc gì đó thôi)</p>
<pre><code class="language-jsx">useEffect(() =&gt; {
  // Code to run on mount
  return () =&gt; {
    // Cleanup function (like componentWillUnmount)
  };
}, [dependencies]); // Dependencies control re-runs
</code></pre>
<h3 id="core-component-imagebackground"><a class="header" href="#core-component-imagebackground">Core Component: <code>ImageBackground</code></a></h3>
<pre><code class="language-jsx">&lt;ImageBackground
  source={require(&quot;./assets/background.jpg&quot;)}
  style={styles.background}
&gt;
  &lt;Text style={styles.text}&gt;Weather App&lt;/Text&gt;
&lt;/ImageBackground&gt;
</code></pre>
<h3 id="statusbar"><a class="header" href="#statusbar">StatusBar</a></h3>
<pre><code class="language-jsx">&lt;StatusBar barStyle=&quot;light-content&quot; backgroundColor=&quot;#000&quot; /&gt;
</code></pre>
<h3 id="core-component-activityindicator"><a class="header" href="#core-component-activityindicator">Core component: <code>ActivityIndicator</code></a></h3>
<pre><code class="language-jsx">&lt;ActivityIndicator size=&quot;large&quot; color=&quot;#0000ff&quot; animating={true} /&gt;
</code></pre>
<h3 id="core-component-textinput"><a class="header" href="#core-component-textinput">Core component: TextInput</a></h3>
<pre><code class="language-jsx">&lt;TextInput
  style={{...}} // Apply your styles here
  placeholder=&quot;Enter city name&quot;
  onChangeText={(text) =&gt; console.log(text)}
/&gt;
</code></pre>
<h3 id="gọi-api-trong-react"><a class="header" href="#gọi-api-trong-react">Gọi API trong React</a></h3>
<p>Tương tự như bên JS thôi, dùng <code>Workspace()</code> để gọi API.</p>
<pre><code class="language-jsx">const getData = async () =&gt; {
  try {
    const response = await fetch(&quot;API_URL&quot;);
    const data = await response.json();
    console.log(data);
  } catch (error) {
    console.error(&quot;Error fetching weather:&quot;, error);
  }
};
</code></pre>
<h2 id="lecture-5"><a class="header" href="#lecture-5">Lecture 5</a></h2>
<p>Nếu tải sử dụng template <code>default</code> của Expo thì không dùng được cái này đâu nha ;-; Tui chưa biết sửa sao nên tải template <code>blank</code> thì dùng được.</p>
<pre><code class="language-bash"># Linux
npm install @react-navigation/native-stack @react-navigation/elements
# Bên Windows thì phải dùng lệnh này
npm install @react-navigation/native-stack; npm install @react-navigation/elements
</code></pre>
<h3 id="react-navigation-static-vs-dynamic-apis"><a class="header" href="#react-navigation-static-vs-dynamic-apis">React Navigation: Static vs Dynamic APIs</a></h3>
<h4 id="creating-a-native-stack-navigator-static"><a class="header" href="#creating-a-native-stack-navigator-static">Creating a native stack navigator (Static)</a></h4>
<pre><code class="language-jsx">import { createStaticNavigation } from &quot;@react-navigation/native&quot;;
import { createNativeStackNavigator } from &quot;@react-navigation/native-stack&quot;;
import { View, Text } from &quot;react-native&quot;; // Import necessary components

function HomeScreen() {
  return (
    &lt;View style={{ flex: 1, alignItems: &quot;center&quot;, justifyContent: &quot;center&quot; }}&gt;
      &lt;Text style={{ fontSize: 30 }}&gt;Home Page&lt;/Text&gt;
    &lt;/View&gt;
  );
}

function AboutScreen() {
  return (
    &lt;View style={{ flex: 1, alignItems: &quot;center&quot;, justifyContent: &quot;center&quot; }}&gt;
      &lt;Text style={{ fontSize: 30 }}&gt;About Page&lt;/Text&gt;
    &lt;/View&gt;
  );
}

const RootStack = createNativeStackNavigator({
  screens: {
    Home: HomeScreen,
    About: AboutScreen,
  },
});

const Navigation = createStaticNavigation(RootStack);

export default function App() {
  return &lt;Navigation /&gt;;
}
</code></pre>
<p>Thử tạo xong mà có thấy cái gì đâu :&lt;. Phần tiếp theo là thêm chút Options vào nè:</p>
<pre><code class="language-jsx">import { createStaticNavigation } from &quot;@react-navigation/native&quot;;
import { createNativeStackNavigator } from &quot;@react-navigation/native-stack&quot;;
import { View, Text } from &quot;react-native&quot;; // Import necessary components

function HomeScreen() {
  return (
    &lt;View style={{ flex: 1, alignItems: &quot;center&quot;, justifyContent: &quot;center&quot; }}&gt;
      &lt;Text style={{ fontSize: 30 }}&gt;Home Page&lt;/Text&gt;
    &lt;/View&gt;
  );
}

function AboutScreen() {
  return (
    &lt;View style={{ flex: 1, alignItems: &quot;center&quot;, justifyContent: &quot;center&quot; }}&gt;
      &lt;Text style={{ fontSize: 30 }}&gt;About Page&lt;/Text&gt;
    &lt;/View&gt;
  );
}

const RootStack = createNativeStackNavigator({
  initialRouteName: &quot;Home&quot;,
  // Cũng có thể thêm Options cho tất cả các màn hình thế lày
  screenOptions: {
    headerStyle: { backgroundColor: &quot;tomato&quot; },
  },
  screens: {
    Home: {
      screen: HomeScreen,
      options: {
        title: &quot;Welcome&quot;,
      },
    },
    About: AboutScreen,
  },
});

const Navigation = createStaticNavigation(RootStack);

export default function App() {
  return &lt;Navigation /&gt;;
}
</code></pre>
<p>Có thể mọi người sẽ hướng đến dùng Dynamic API hơn, cái trên học cho biết lý thuyết thôi :&lt; mà chạy Preview có thấy j đâu.</p>
<h4 id="creating-a-native-stack-navigator-dynamic-api"><a class="header" href="#creating-a-native-stack-navigator-dynamic-api">Creating a native stack navigator (Dynamic API)</a></h4>
<p>Khá lằng nhằng nên đây sẽ là Code luôn. Đầu tiên cần khai báo trước đã.</p>
<pre><code class="language-jsx">import { NavigationContainer, useNavigation } from '@react-navigation/native'; // Import useNavigation
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { View, Text, Button } from 'react-native'; // Import Button and other necessary components

const Stack = createNativeStackNavigator();

// Define your screen components
function Product() {
  const navigation = useNavigation();
  return (
    &lt;View style={{ flex: 1, alignItems: 'center', justifyContent: 'center' }}&gt;
      &lt;Text style={{ fontSize: 30 }}&gt;Product Page&lt;/Text&gt;
      &lt;Button
        // Navigating to a new screen
        title='Click on to navigate detail page'
        onPress={() =&gt; navigation.navigate('Detail')}
      &gt;&lt;/Button&gt;
    &lt;/View&gt;
  );
}

function ProductDetail() {
  return (
    &lt;View style={{ flex: 1, alignItems: 'center', justifyContent: 'center' }}&gt;
      &lt;Text style={{ fontSize: 30 }}&gt;Product Detail Page&lt;/Text&gt;
    &lt;/View&gt;
  );
}

export default function App() {
  return (
    &lt;NavigationContainer&gt;
      &lt;Stack.Navigator&gt;
        &lt;Stack.Screen name=&quot;Product&quot; component={Product} /&gt;
        &lt;Stack.Screen name=&quot;Detail&quot; component={ProductDetail} /&gt;
      &lt;/Stack.Navigator&gt;
    &lt;/NavigationContainer&gt;
  );
}
</code></pre>
<p>Cần phải tạo <code>Stack</code> sử dụng <code>createNativeStackNavigator()</code>. Rồi sau đó lần lượt thêm
<code>&lt;NavigationContainer&gt;</code> rồi <code>&lt;Stack.Navigator&gt;</code>, trong đó sẽ thêm một cái kiểu như
<code>&lt;Stack.Screen name=&quot;Product&quot; component={Product} /&gt;</code> để thể hiện một màn hình.</p>
<p>yep, mình chẳng hiểu mình đã viết cái gì nữa. nma cứ kệ đi nha, miễn dùng được là được. Tiếp đến là tạo một Component:</p>
<pre><code class="language-jsx">import { useNavigation } from '@react-navigation/native';
import { View, Text, Button } from 'react-native'; // Import necessary components

function Product() {
  const navigation = useNavigation();
  return (
    &lt;View style={{ flex: 1, alignItems: 'center', justifyContent: 'center' }}&gt;
      &lt;Text style={{ fontSize: 30 }}&gt;Product Page&lt;/Text&gt;
      &lt;Button
        // Navigating to a new screen
        title='Click on to navigate detail page'
        onPress={() =&gt; navigation.navigate('Detail')}
      &gt;&lt;/Button&gt;
    &lt;/View&gt;
  );
}
</code></pre>
<p>Tạo một navigation object sử dụng <code>const navigation = useNavigation()</code>, sau đó viết giùm cái nút
và thêm cái này vào <code>onPress</code>: <code>onPress={() =&gt; navigation.navigate('Detail')}</code>, chính là cái <code>navigation</code> vừa khai báo! Xong.</p>
<blockquote>
<p>warning: When using the Dynamic API, the component prop accepts a component, not a render function. Don't pass an inline function (e.g. <code>component={() =&gt; &lt;HomeScreen /&gt;}</code>), or your component will unmount and remount, losing all state, when the parent component re-renders.</p>
</blockquote>
<p>Bạn cũng có thể thêm Options vào nữa:</p>
<pre><code class="language-jsx">import { NavigationContainer } from '@react-navigation/native';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { View, Text } from 'react-native'; // Import necessary components

// Define your screen components
function HomeScreen() {
  return (
    &lt;View style={{ flex: 1, alignItems: &quot;center&quot;, justifyContent: &quot;center&quot; }}&gt;
      &lt;Text style={{ fontSize: 30 }}&gt;Home Page&lt;/Text&gt;
    &lt;/View&gt;
  );
}

function AboutScreen() {
  return (
    &lt;View style={{ flex: 1, alignItems: &quot;center&quot;, justifyContent: &quot;center&quot; }}&gt;
      &lt;Text style={{ fontSize: 30 }}&gt;About Page&lt;/Text&gt;
    &lt;/View&gt;
  );
}

const Stack = createNativeStackNavigator();

&lt;NavigationContainer&gt;
  {/* Hoặc thêm điểm khởi đầu: &lt;Stack.Navigator initialRouteName='About'&gt; */}
  &lt;Stack.Navigator initialRouteName=&quot;About&quot;&gt;
    &lt;Stack.Screen
      name=&quot;Home&quot;
      component={HomeScreen}
      options={{ title: &quot;Welcome&quot; }}
    /&gt;
    &lt;Stack.Screen name=&quot;About&quot; component={AboutScreen} /&gt;
  &lt;/Stack.Navigator&gt;
&lt;/NavigationContainer&gt;;
</code></pre>
<h3 id="passing-additional-props"><a class="header" href="#passing-additional-props">Passing additional props</a></h3>
<p>Theo lý thuyết trên Slides thì: Use React context and wrap the navigator with a context provider to pass data to the screens (recommended).</p>
<p>The <code>useContext</code> hook: A React Hook that lets you create context data (values) in a parent component and retrieve them from its descendant components (TODO: Không hiểu gì cả).</p>
<pre><code class="language-jsx">// First, use the createContext function to create a Context.
import { createContext, useContext } from &quot;react&quot;;
import { NavigationContainer } from &quot;@react-navigation/native&quot;; // Import necessary component
import { createNativeStackNavigator } from &quot;@react-navigation/native-stack&quot;; // Import necessary component
import { View, Text } from &quot;react-native&quot;; // Import necessary components

// Define your screen components (HomeScreen, AboutScreen) as needed

const ScreenNameContext = createContext(null);

// Then, wrap the context’s provider around the components that will use the context value.
const Stack = createNativeStackNavigator();

// Assume scrNames is defined somewhere
const scrNames = { home: 'Trang Chủ', about: 'Giới Thiệu' }; // Example scrNames

&lt;ScreenNameContext.Provider value={scrNames}&gt;
  &lt;NavigationContainer&gt;
    &lt;Stack.Navigator&gt;
      &lt;Stack.Screen name=&quot;Home&quot; component={HomeScreen} /&gt;
      &lt;Stack.Screen name=&quot;About&quot; component={AboutScreen} /&gt;
    &lt;/Stack.Navigator&gt;
  &lt;/NavigationContainer&gt;
&lt;/ScreenNameContext.Provider&gt;;
</code></pre>
<p>Retrieving Context Data from a component</p>
<pre><code class="language-jsx">import { useContext } from &quot;react&quot;;
import { View, Text } from &quot;react-native&quot;; // Import necessary components

// Assume ScreenNameContext is imported or defined
// Assume ScreenNameContext is created with createContext(null);

// Technically, any can retrieve the context data.
// However, it’s recommended that the component is one of the context provider’s descendant.
function AboutScreen() {
  const screenNames = useContext(ScreenNameContext);
  return (
    &lt;View style={{ flex: 1, alignItems: &quot;center&quot;, justifyContent: &quot;center&quot; }}&gt;
      &lt;Text&gt;{screenNames?.about}&lt;/Text&gt; {/* Use optional chaining */}
    &lt;/View&gt;
  );
}
</code></pre>
<h3 id="difference-between-maps-and-push-add-multiple-instances"><a class="header" href="#difference-between-maps-and-push-add-multiple-instances">Difference between <code>Maps</code> and <code>push</code> (add multiple instances)</a></h3>
<pre><code class="language-jsx">import { useNavigation } from &quot;@react-navigation/native&quot;;
import { Button } from &quot;react-native&quot;; // Import Button

// If you want to open a new instance of the About screen, use navigation.push('About').
// Each time push is called, a new About screen instance is added to the navigation stack.
function MyComponent() { // Example component
  const navigation = useNavigation();
  return (
    &lt;Button title=&quot;About Us... again&quot; onPress={() =&gt; navigation.push(&quot;About&quot;)} /&gt;
  );
}
</code></pre>
<ul>
<li><code>Maps('About')</code> → Does nothing if already on the About screen.</li>
<li><code>Maps.push('About')</code> → Creates a new instance of the About screen. This approach is useful when passing unique data to each instance of a screen.</li>
</ul>
<h3 id="manually-triggering-back-navigation"><a class="header" href="#manually-triggering-back-navigation">Manually Triggering Back Navigation</a></h3>
<p>Use <code>navigation.goBack()</code> to programmatically navigate to the previous screen.</p>
<pre><code class="language-jsx">import { useNavigation } from &quot;@react-navigation/native&quot;;
import { Button } from &quot;react-native&quot;; // Import Button

function MyComponent() { // Example component
  const navigation = useNavigation();
  return (
    &lt;&gt;
      &lt;Button title=&quot;Go Back&quot; onPress={() =&gt; navigation.goBack()} /&gt;
      {/* Assuming 'Home' is a screen name in your stack */}
      &lt;Button title=&quot;Go Home&quot; onPress={() =&gt; navigation.popToTop()} /&gt; {/* Changed to popToTop for typical Home behavior */}
    &lt;/&gt;
  );
}
</code></pre>
<p><em>Note: <code>popTo(&quot;Home&quot;)</code> is not a standard method in <code>@react-navigation/native-stack</code>. <code>popToTop()</code> is used to go back to the first screen in the stack.</em></p>
<h3 id="ném-params-khi-maps"><a class="header" href="#ném-params-khi-maps">Ném Params khi <code>Maps()</code></a></h3>
<p>Đầu tiên, thêm cái <code>{}</code> vào sau phần tên màn hình như này:</p>
<pre><code class="language-jsx">onPress={() =&gt; navigation.navigate(&quot;About&quot;, { name: &quot;Quan&quot; })}
</code></pre>
<p>Chuyển qua màn hình khác, nhận params kiểu gì:</p>
<pre><code class="language-jsx">import { useNavigation, useRoute } from &quot;@react-navigation/native&quot;; // Import useRoute
import { View, Text } from &quot;react-native&quot;; // Import necessary components

function AboutScreen() {
  const navigation = useNavigation();
  const route = useRoute(); // Use the useRoute hook
  const { name } = route.params || {}; // Use optional chaining and default empty object
  // ... rest of your component
  return (
    &lt;View style={{ flex: 1, alignItems: &quot;center&quot;, justifyContent: &quot;center&quot; }}&gt;
      &lt;Text&gt;Welcome, {name}!&lt;/Text&gt;
    &lt;/View&gt;
  );
}
</code></pre>
<p>Hoặc khởi tạo dùng <code>initialParams</code></p>
<pre><code class="language-jsx">import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { View, Text } from 'react-native'; // Import necessary components

// Define AboutScreen component as shown above
function AboutScreen({ route }) {
  const { name } = route.params || {};
  return (
    &lt;View style={{ flex: 1, alignItems: &quot;center&quot;, justifyContent: &quot;center&quot; }}&gt;
      &lt;Text&gt;Welcome, {name}!&lt;/Text&gt;
    &lt;/View&gt;
  );
}

const Stack = createNativeStackNavigator();

&lt;Stack.Screen
  name=&quot;About&quot;
  component={AboutScreen}
  initialParams={{ name: &quot;Us&quot; }}
/&gt;;
</code></pre>
<p>Hoặc cập nhật params dùng <code>setParams</code>:</p>
<pre><code class="language-jsx">import { useNavigation } from &quot;@react-navigation/native&quot;;
import { Button } from &quot;react-native&quot;; // Import Button

function MyComponent() { // Example component
  const navigation = useNavigation();
  return (
    &lt;Button
      title=&quot;Set Name to Vinh&quot;
      onPress={() =&gt; navigation.setParams({ name: &quot;Vinh&quot; })}
    /&gt;
  );
}
</code></pre>
<blockquote>
<p>Mẹo: Avoid using <code>setParams</code> to update screen options such as <code>title</code>. If you need to update options, use <code>setOptions</code> instead.</p>
</blockquote>
<pre><code class="language-jsx">// Don't do this
navigation.navigate(&quot;Profile&quot;, {
  user: {
    id: 21,
    firstName: &quot;Jane&quot;,
    lastName: &quot;Done&quot;,
    age: 25,
  },
});

// Do this
navigation.navigate(&quot;Profile&quot;, { userId: 21 });
</code></pre>
<p>Ở đây, bạn không nên ném dữ liệu kiểu này, mà thay vào đó, ném ID để có thể sử dụng làm địa chỉ truy cập phần dữ liệu được lưu ở chỗ khác (global store or cache).</p>
<blockquote>
<p>What should be in params?: Params should not be used for state management. If data is needed across multiple screens, it should be stored in a global store or cache.</p>
</blockquote>
<h2 id="lecture-6"><a class="header" href="#lecture-6">Lecture 6</a></h2>
<h3 id="ngăn-chặn-các-header-trùng-lặp"><a class="header" href="#ngăn-chặn-các-header-trùng-lặp">Ngăn chặn các Header trùng lặp</a></h3>
<p>Tránh các header bị trùng lặp -&gt; ẩn header của thành phần cha (Đặt <code>headerShown: false</code> trong <code>options</code> của <code>Stack.Screen</code> là xong):</p>
<pre><code class="language-javascript">import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { View, Text } from 'react-native'; // Import necessary components

// Assume HomeTabs component is defined elsewhere
function HomeTabs() {
  return (
    &lt;View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}&gt;
      &lt;Text&gt;Home Tabs&lt;/Text&gt;
    &lt;/View&gt;
  );
}

const Stack = createNativeStackNavigator();

// Inside your Navigator
// &lt;Stack.Navigator&gt;
  &lt;Stack.Screen
    name=&quot;Home&quot;
    component={HomeTabs}
    options={{ headerShown: false }}
  /&gt;
  // ... other screens
// &lt;/Stack.Navigator&gt;
</code></pre>
<p>Bạn cũng có thể ẩn tất cả các header bằng cách đặt <code>headerShown: false</code> trong <code>screenOptions</code> của <code>Stack.Navigator</code>:</p>
<pre><code class="language-javascript">import { createNativeStackNavigator } from '@react-navigation/native-stack';

const Stack = createNativeStackNavigator();

&lt;Stack.Navigator screenOptions={{ headerShown: false }}&gt;
  {/* ... your screens */}
&lt;/Stack.Navigator&gt;
</code></pre>
<h3 id="cấu-hình-header-bar"><a class="header" href="#cấu-hình-header-bar">Cấu hình Header Bar</a></h3>
<h4 id="Đặt-tiêu-đề-cố-định"><a class="header" href="#Đặt-tiêu-đề-cố-định">Đặt tiêu đề cố định</a></h4>
<p>Sử dụng thuộc tính <code>title</code> trong <code>options</code> để đặt tiêu đề cố định cho mỗi màn hình:</p>
<pre><code class="language-javascript">import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { View, Text } from 'react-native'; // Import necessary components

// Assume HomeScreen component is defined elsewhere
function HomeScreen() {
  return (
    &lt;View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}&gt;
      &lt;Text&gt;Home Screen&lt;/Text&gt;
    &lt;/View&gt;
  );
}

const Stack = createNativeStackNavigator();

// Inside your Navigator
// &lt;Stack.Navigator&gt;
  &lt;Stack.Screen
    name=&quot;Home&quot;
    component={HomeScreen}
    options={{ title: 'My home' }}
  /&gt;
  // ... other screens
// &lt;/Stack.Navigator&gt;
</code></pre>
<h4 id="sử-dụng-params-trong-tiêu-đề"><a class="header" href="#sử-dụng-params-trong-tiêu-đề">Sử dụng Params trong tiêu đề</a></h4>
<p><code>options</code> nên là một hàm nhận vào <code>route</code> và trả về tiêu đề.</p>
<p>Đối số được truyền vào hàm <code>options</code> là một đối tượng với các thuộc tính <code>navigation</code> và <code>route</code> (Cái này thì chịu nha).</p>
<pre><code class="language-javascript">import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { View, Text } from 'react-native'; // Import necessary components

// Assume ProfileScreen component is defined elsewhere
function ProfileScreen() {
  return (
    &lt;View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}&gt;
      &lt;Text&gt;Profile Screen&lt;/Text&gt;
    &lt;/View&gt;
  );
}

const Stack = createNativeStackNavigator();

// Inside your Navigator
// &lt;Stack.Navigator&gt;
  &lt;Stack.Screen
    name=&quot;Profile&quot;
    component={ProfileScreen}
    options={({ route }) =&gt; ({ title: route.params.name })}
  /&gt;
  // ... other screens
// &lt;/Stack.Navigator&gt;
</code></pre>
<h4 id="cập-nhật-tiêu-đề-với-setoptions"><a class="header" href="#cập-nhật-tiêu-đề-với-setoptions">Cập nhật tiêu đề với <code>setOptions</code></a></h4>
<p>Để cập nhật cấu hình <code>options</code> cho màn hình đang hoạt động từ chính component màn hình đã mount (mount là cái gì?), có thể dùng <code>navigation.setOptions</code>.</p>
<pre><code class="language-javascript">import { useNavigation } from '@react-navigation/native';
import { Button } from 'react-native'; // Import Button

function MyComponent() { // Example component
  const navigation = useNavigation();
  return (
    &lt;Button
      onPress={() =&gt; navigation.setOptions({ title: 'Updated!' })}
      title=&quot;Update the title&quot;
    /&gt;
  );
}
</code></pre>
<h3 id="tùy-chỉnh-header-styles"><a class="header" href="#tùy-chỉnh-header-styles">Tùy chỉnh Header Styles</a></h3>
<p>Có ba thuộc tính chính để tạo kiểu cho header:</p>
<ul>
<li><code>headerStyle</code>: Tạo kiểu cho nền header.</li>
<li><code>headerTintColor</code>: Đặt màu cho nút back và tiêu đề.</li>
<li><code>headerTitleStyle</code>: Tùy chỉnh các thuộc tính font cho tiêu đề.</li>
</ul>
<p>Ví dụ:</p>
<pre><code class="language-javascript">import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { View, Text } from 'react-native'; // Import necessary components

// Assume HomeScreen component is defined elsewhere
function HomeScreen() {
  return (
    &lt;View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}&gt;
      &lt;Text&gt;Home Screen&lt;/Text&gt;
    &lt;/View&gt;
  );
}

const Stack = createNativeStackNavigator();

// Inside your Navigator
// &lt;Stack.Navigator&gt;
  &lt;Stack.Screen
    name=&quot;Home&quot;
    component={HomeScreen}
    options={{
      title: 'My home',
      headerStyle: { backgroundColor: '#f4511e' },
      headerTintColor: '#fff',
      headerTitleStyle: { fontWeight: 'bold' },
    }}
  /&gt;
  // ... other screens
// &lt;/Stack.Navigator&gt;
</code></pre>
<h4 id="chia-sẻ-common-options-giữa-các-màn-hình"><a class="header" href="#chia-sẻ-common-options-giữa-các-màn-hình">Chia sẻ Common Options giữa các màn hình</a></h4>
<p>Thay vì lặp lại các kiểu cho mỗi màn hình, bạn có thể đặt <code>screenOptions</code> trong <code>Stack.Navigator</code>.</p>
<pre><code class="language-javascript">import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { View, Text } from 'react-native'; // Import necessary components

// Assume HomeScreen and DetailsScreen components are defined elsewhere
function HomeScreen() { /* ... */ }
function DetailsScreen() { /* ... */ }

const Stack = createNativeStackNavigator();

&lt;Stack.Navigator
  screenOptions={{
    headerStyle: { backgroundColor: '#f4511e' },
    headerTintColor: '#fff',
    headerTitleStyle: { fontWeight: 'bold' },
  }}
&gt;
  &lt;Stack.Screen name=&quot;Home&quot; component={HomeScreen} options={{ title: 'My home' }} /&gt;
  &lt;Stack.Screen name=&quot;Details&quot; component={DetailsScreen} /&gt;
&lt;/Stack.Navigator&gt;
</code></pre>
<h4 id="thay-thế-tiêu-đề-bằng-custom-component"><a class="header" href="#thay-thế-tiêu-đề-bằng-custom-component">Thay thế tiêu đề bằng Custom Component</a></h4>
<p>Sử dụng <code>headerTitle</code> để thay thế tiêu đề văn bản bằng một custom component, chẳng hạn như hình ảnh hoặc nút.</p>
<pre><code class="language-javascript">import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { Image, View, Text } from 'react-native'; // Import necessary components

function LogoTitle() {
  return (
    &lt;Image
      style={{ width: 50, height: 50 }}
      source={require('@expo/snack-static/react-native-logo.png')}
    /&gt;
  );
}

// Assume HomeScreen component is defined elsewhere
function HomeScreen() { /* ... */ }

const Stack = createNativeStackNavigator();

// ...
// Inside your Navigator
// &lt;Stack.Navigator&gt;
  &lt;Stack.Screen
    name=&quot;Home&quot;
    component={HomeScreen}
    options={{ headerTitle: (props) =&gt; &lt;LogoTitle {...props} /&gt; }}
  /&gt;
  // ... other screens
// &lt;/Stack.Navigator&gt;
</code></pre>
<h4 id="sự-khác-biệt-giữa-title-và-headertitle"><a class="header" href="#sự-khác-biệt-giữa-title-và-headertitle">Sự khác biệt giữa <code>title</code> và <code>headerTitle</code></a></h4>
<ul>
<li><code>title</code> được sử dụng cho nhiều loại điều hướng như tab bars và drawers.</li>
<li><code>headerTitle</code> dành riêng cho stack navigators và thay thế component <code>Text</code> mặc định.</li>
</ul>
<h3 id="header-buttons"><a class="header" href="#header-buttons">Header Buttons</a></h3>
<p>Bạn có thể đặt các nút trong header bằng cách sử dụng <code>headerLeft</code> (bên trái) hoặc <code>headerRight</code> (bên phải).</p>
<pre><code class="language-javascript">import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { Button, View, Text } from 'react-native'; // Import necessary components

// Assume HomeScreen component is defined elsewhere
function HomeScreen() { /* ... */ }

const Stack = createNativeStackNavigator();

// Inside your Navigator
// &lt;Stack.Navigator&gt;
  &lt;Stack.Screen
    name=&quot;Home&quot;
    component={HomeScreen}
    options={{
      headerRight: () =&gt; (
        &lt;Button
          onPress={() =&gt; alert('This is a button!')}
          title=&quot;Info&quot;
        /&gt;
      ),
    }}
  /&gt;
  // ... other screens
// &lt;/Stack.Navigator&gt;
</code></pre>
<h4 id="tương-tác-của-header-với-screen-component"><a class="header" href="#tương-tác-của-header-với-screen-component">Tương tác của Header với Screen Component</a></h4>
<p>Khi bạn định nghĩa nút theo cách này, biến <code>this</code> trong <code>options</code> không phải là instance của <code>HomeScreen</code>, vì vậy bạn không thể gọi <code>setState</code> hoặc bất kỳ phương thức instance nào trên đó.</p>
<p>Việc các nút trong header tương tác với màn hình mà header thuộc về là phổ biến. Để nút tương tác với trạng thái của màn hình, hãy sử dụng <code>navigation.setOptions</code>. Bằng cách sử dụng <code>navigation.setOptions</code> bên trong component màn hình, chúng ta có quyền truy cập vào các props, state, context, v.v. của màn hình.</p>
<pre><code class="language-javascript">import { useNavigation } from '@react-navigation/native';
import React, { useState, useEffect } from 'react'; // Import React, useState, useEffect
import { Button, Text, View } from 'react-native'; // Import necessary components

function HomeScreen() {
  const navigation = useNavigation();
  const [count, setCount] = useState(0); // Correct usage of useState

  useEffect(() =&gt; { // Correct usage of useEffect
    navigation.setOptions({
      headerRight: () =&gt; (
        &lt;Button
          onPress={() =&gt; setCount((c) =&gt; c + 1)}
          title=&quot;Update count&quot;
        /&gt;
      ),
    });
  }, [navigation, setCount]); // Added setCount to dependency array

  return (
    &lt;View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}&gt;
      &lt;Text&gt;Count: {count}&lt;/Text&gt;
    &lt;/View&gt;
  );
}
</code></pre>
<h3 id="tùy-chỉnh-nút-back"><a class="header" href="#tùy-chỉnh-nút-back">Tùy chỉnh nút Back</a></h3>
<p>React Navigation cung cấp các giá trị mặc định dành riêng cho từng nền tảng cho các nút back. Trên iOS, nút back hiển thị tiêu đề của màn hình trước đó khi có đủ không gian.</p>
<h4 id="các-tùy-chọn-tùy-chỉnh"><a class="header" href="#các-tùy-chọn-tùy-chỉnh">Các tùy chọn tùy chỉnh:</a></h4>
<ul>
<li><code>headerBackTitle</code>: Thay đổi văn bản nút back.</li>
<li><code>headerBackTitleStyle</code>: Tạo kiểu cho văn bản nút back.</li>
<li><code>headerBackImageSource</code>: Đặt hình ảnh tùy chỉnh cho nút back.</li>
</ul>
<p>Ví dụ:</p>
<pre><code class="language-javascript">import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { View, Text } from 'react-native'; // Import necessary components

// Assume HomeScreen and DetailsScreen components are defined elsewhere
function HomeScreen() { /* ... */ }
function DetailsScreen() { /* ... */ }

const Stack = createNativeStackNavigator();

&lt;Stack.Navigator&gt;
  &lt;Stack.Screen name=&quot;Home&quot; component={HomeScreen} /&gt;
  &lt;Stack.Screen
    name=&quot;Details&quot;
    component={DetailsScreen}
    options={{
      headerBackTitle: 'Custom Back',
      headerBackTitleStyle: { fontSize: 30 },
    }}
  /&gt;
&lt;/Stack.Navigator&gt;
</code></pre>
<h4 id="ghi-đè-nút-back"><a class="header" href="#ghi-đè-nút-back">Ghi đè nút Back</a></h4>
<p>Nếu bạn cần một nút back hoàn toàn tùy chỉnh, hãy sử dụng <code>headerLeft</code>.</p>
<pre><code class="language-javascript">import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { Button, View, Text } from 'react-native'; // Import necessary components

// Assume DetailsScreen component is defined elsewhere
function DetailsScreen() { /* ... */ }

const Stack = createNativeStackNavigator();

// Inside your Navigator
// &lt;Stack.Navigator&gt;
  &lt;Stack.Screen
    name=&quot;Details&quot;
    component={DetailsScreen}
    options={{
      headerLeft: () =&gt; (
        &lt;Button
          onPress={() =&gt; alert('Custom Back Pressed')}
          title=&quot;Back&quot;
        /&gt;
      ),
    }}
  /&gt;
  // ... other screens
// &lt;/Stack.Navigator&gt;
</code></pre>
<h3 id="nesting-navigators"><a class="header" href="#nesting-navigators">Nesting Navigators</a></h3>
<p>Nesting Navigators có nghĩa là đặt một navigator bên trong một màn hình của một navigator khác. Ví dụ: một Tab Navigator bên trong một Stack Navigator.</p>
<h4 id="các-hành-vi-chính-của-nested-navigators"><a class="header" href="#các-hành-vi-chính-của-nested-navigators">Các hành vi chính của Nested Navigators</a></h4>
<ul>
<li>Lịch sử điều hướng độc lập: Mỗi navigator duy trì lịch sử điều hướng back riêng.</li>
<li>Tùy chọn màn hình riêng biệt: Các tùy chọn của một navigator lồng nhau (ví dụ: tiêu đề) không ảnh hưởng đến navigator cha.</li>
<li>Params độc lập: Params của một màn hình lồng nhau không thể truy cập được từ các màn hình cha/con.</li>
<li>Navigation Actions Bubble Up: Nếu một navigator con không thể xử lý một hành động, navigator cha sẽ xử lý.</li>
<li>Các phương thức dành riêng cho Navigator: Các phương thức như <code>openDrawer</code> chỉ có sẵn bên trong navigator đó.</li>
<li>Không kế thừa Parent Events: Các màn hình bên trong một navigator lồng nhau không nhận được các sự kiện từ navigator cha.</li>
<li>Parent UI Renders on Top: Một drawer được đặt bên trong một stack sẽ xuất hiện bên dưới header của stack.</li>
</ul>
<h4 id="ví-dụ-nesting-navigators"><a class="header" href="#ví-dụ-nesting-navigators">Ví dụ: Nesting Navigators</a></h4>
<pre><code class="language-javascript">import { createBottomTabNavigator } from '@react-navigation/bottom-tabs'; // Import Tab navigator creator
import { createNativeStackNavigator } from '@react-navigation/native-stack'; // Import Stack navigator creator
import { NavigationContainer } from '@react-navigation/native'; // Import NavigationContainer
import { View, Text } from 'react-native'; // Import necessary components

const HomeScreen = () =&gt; (
  &lt;View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}&gt;
    &lt;Text&gt;Home Screen&lt;/Text&gt;
  &lt;/View&gt;
);
const SettingsScreen = () =&gt; (
  &lt;View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}&gt;
    &lt;Text&gt;Settings Screen&lt;/Text&gt;
  &lt;/View&gt;
);
const DetailsScreen = () =&gt; (
  &lt;View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}&gt;
    &lt;Text&gt;Details Screen&lt;/Text&gt;
  &lt;/View&gt;
);

const Tab = createBottomTabNavigator();

function MyTabs() {
  return (
    &lt;Tab.Navigator&gt;
      &lt;Tab.Screen name=&quot;Home&quot; component={HomeScreen} /&gt;
      &lt;Tab.Screen name=&quot;Settings&quot; component={SettingsScreen} /&gt;
    &lt;/Tab.Navigator&gt;
  );
}

const { Navigator, Screen } = createNativeStackNavigator();

export default function App() {
  return (
    &lt;NavigationContainer&gt;
      &lt;Navigator&gt;
        &lt;Screen name=&quot;Tabs&quot; component={MyTabs} /&gt;
        &lt;Screen name=&quot;Details&quot; component={DetailsScreen} /&gt;
      &lt;/Navigator&gt;
    &lt;/NavigationContainer&gt;
  );
}
</code></pre>
<h4 id="Điều-hướng-trong-nested-navigators"><a class="header" href="#Điều-hướng-trong-nested-navigators">Điều hướng trong Nested Navigators</a></h4>
<p>Để điều hướng đến một màn hình bên trong một nested navigator:</p>
<pre><code class="language-javascript">import { useNavigation } from '@react-navigation/native';

function MyComponent() { // Example component
  const navigation = useNavigation();
  // ...
  navigation.navigate('Tabs', {
    screen: 'Settings'
    // Truyền params khi điều hướng:
    // params: { user: 'jane' }
  });
  // ...
}
</code></pre>
<p>Để truyền params khi điều hướng đến màn hình trong tab:</p>
<pre><code class="language-javascript">import { useNavigation } from '@react-navigation/native';

function MyComponent() { // Example component
  const navigation = useNavigation();
  // ...
  navigation.navigate('Tabs', {
    screen: 'Settings',
    params: { user: 'jane' }
  });
  // ...
}
</code></pre>
<h2 id="lecture-7"><a class="header" href="#lecture-7">Lecture 7</a></h2>
<h3 id="style-in-react-native"><a class="header" href="#style-in-react-native">Style in React Native</a></h3>
<p>Cái nào được đặt sau thì sẽ sử dụng cái đấy, ví dụ như trong hình thì <code>&lt;Text style={[styles.bigBlue, styles.red]}&gt;bigBlue, then red&lt;/Text&gt;</code> sẽ hiện màu đỏ, chứ không phải xanh.</p>
<pre><code class="language-jsx">import { StyleSheet, Text, View } from 'react-native'; // Import necessary components

// Assume styles object is defined below
const styles = StyleSheet.create({
  container: { marginTop: 50 },
  bigBlue: { color: 'blue', fontWeight: 'bold', fontSize: 30 },
  red: { color: 'red' }
});

&lt;View style={styles.container}&gt;
  &lt;Text style={styles.red}&gt;just red&lt;/Text&gt;
  &lt;Text style={styles.bigBlue}&gt;just bigBlue&lt;/Text&gt;
  &lt;Text style={[styles.bigBlue, styles.red]}&gt;bigBlue, then red&lt;/Text&gt;
  &lt;Text style={[styles.red, styles.bigBlue]}&gt;red, then bigBlue&lt;/Text&gt;
&lt;/View&gt;
</code></pre>
<p>Dựa trên nội dung bạn cung cấp từ Lecture 7, dưới đây là các đoạn code và giải thích về Styling và Layout với Flexbox trong React Native:</p>
<h3 id="styling-trong-react-native"><a class="header" href="#styling-trong-react-native">Styling trong React Native</a></h3>
<ul>
<li><strong>Styling với JavaScript</strong>: Các component trong React Native chấp nhận một <code>style</code> prop. Tên thuộc tính style được viết theo kiểu <code>camelCase</code> (ví dụ: <code>backgroundColor</code> thay vì <code>background-color</code>).</li>
<li><strong>Định nghĩa styles</strong>:
<ul>
<li>Styles có thể là một đối tượng JavaScript đơn giản.</li>
<li>Có thể sử dụng một mảng các styles (style cuối cùng trong mảng sẽ được ưu tiên).</li>
<li>Đối với các component phức tạp, sử dụng <code>StyleSheet.create</code> giúp tổ chức styles gọn gàng hơn.</li>
</ul>
</li>
</ul>
<h4 id="sử-dụng-stylesheetcreate"><a class="header" href="#sử-dụng-stylesheetcreate">Sử dụng <code>StyleSheet.create</code></a></h4>
<p><code>StyleSheet.create</code> giúp định nghĩa nhiều style ở một nơi.</p>
<ul>
<li><strong>Lợi ích</strong>: Hiệu suất (styles bất biến), Validation, Tính nhất quán, Tích hợp tốt hơn với React Native, Minification (giảm kích thước bundle).</li>
</ul>
<pre><code class="language-javascript">import React from 'react';
import { StyleSheet, Text, View } from 'react-native';

export default function LotsOfStyles() {
  return (
    &lt;View style={styles.container}&gt;
      &lt;Text style={styles.red}&gt;just red&lt;/Text&gt;
      &lt;Text style={styles.bigBlue}&gt;just bigBlue&lt;/Text&gt;
      &lt;Text style={[styles.bigBlue, styles.red]}&gt;
        bigBlue, then red&lt;/Text&gt;
      &lt;Text style={[styles.red, styles.bigBlue]}&gt;
        red, then bigBlue&lt;/Text&gt;
    &lt;/View&gt;
  );
}

const styles = StyleSheet.create({
  container: { marginTop: 50 },
  bigBlue: { color: 'blue', fontWeight: 'bold', fontSize: 30 },
  red: { color: 'red' }
});
</code></pre>
<ul>
<li><strong>Kế thừa styles</strong>: Một component có thể nhận <code>style</code> prop và truyền nó cho các subcomponent, cho phép styles &quot;cascade&quot; giống như trong CSS.</li>
<li><strong>Vấn đề tương thích</strong>: Có một số khác biệt so với web CSS, ví dụ: vùng chạm không mở rộng ra ngoài view cha và lề âm không được hỗ trợ trên Android.</li>
</ul>
<h3 id="height-and-width"><a class="header" href="#height-and-width">Height and Width</a></h3>
<h4 id="fixed-dimensions-kích-thước-cố-định"><a class="header" href="#fixed-dimensions-kích-thước-cố-định">Fixed Dimensions (Kích thước cố định)</a></h4>
<p>Cách thông thường để đặt kích thước của một component là thêm <code>width</code> và <code>height</code> cố định vào <code>style</code>. Tất cả các kích thước trong React Native là <em>không có đơn vị</em>, và đại diện cho <em>density-independent pixels (dp)</em>.</p>
<pre><code class="language-javascript">import { View } from 'react-native'; // Import necessary component

&lt;View style={{ flex: 1 }}&gt;
  &lt;View style={{
    width: 50 ,
    height: 50 ,
    backgroundColor: 'powderblue'
  }} /&gt;
  &lt;View style={{
    width: 100 ,
    height: 100 ,
    backgroundColor: 'skyblue'
  }} /&gt;
  &lt;View style={{
    width: 150 ,
    height: 150 ,
    backgroundColor: 'steelblue'
  }} /&gt;
&lt;/View&gt;
</code></pre>
<h4 id="flex-dimensions-kích-thước-linh-hoạt"><a class="header" href="#flex-dimensions-kích-thước-linh-hoạt">Flex Dimensions (Kích thước linh hoạt)</a></h4>
<p>Sử dụng <code>flex</code> trong style của component để làm cho nó mở rộng hoặc co lại dựa trên không gian có sẵn.</p>
<ul>
<li><code>flex: 1</code> làm cho component lấp đầy tất cả không gian có sẵn, chia sẻ đều với các component ngang cấp.</li>
<li>Giá trị <code>flex</code> lớn hơn sẽ cho component một phần không gian lớn hơn.</li>
<li>Một component chỉ có thể mở rộng nếu component cha của nó có kích thước được định nghĩa (kích thước cố định hoặc flex).</li>
</ul>
<pre><code class="language-javascript">import React from 'react';
import { View } from 'react-native'; // Import necessary component

export default function FlexDimensionsBasics() {
  return (
    // Try removing the `flex: 1` on the parent View.
    // The parent will not have dimensions, so the
    // children can't expand.
    // What if you add `height: 300` instead of `flex: 1`?
    &lt;View style={{ flex: 1 }}&gt;
      &lt;View style={{
        flex: 1 , backgroundColor: 'powderblue'
      }} /&gt;
      &lt;View style={{
        flex: 2 , backgroundColor: 'skyblue'
      }} /&gt;
      &lt;View style={{
        flex: 3 , backgroundColor: 'steelblue'
      }} /&gt;
    &lt;/View&gt;
  );
};
</code></pre>
<h4 id="percentage-dimensions-kích-thước-theo-phần-trăm"><a class="header" href="#percentage-dimensions-kích-thước-theo-phần-trăm">Percentage Dimensions (Kích thước theo phần trăm)</a></h4>
<p>Thay vì <code>flex</code>, bạn có thể sử dụng giá trị phần trăm để kiểm soát kích thước của component, nhưng component cha phải có kích thước được định nghĩa.</p>
<pre><code class="language-javascript">import { View } from 'react-native'; // Import necessary component

&lt;View style={{ height: '100%' }}&gt;
  &lt;View style={{
    height: '15%',
    backgroundColor: 'powderblue'
  }} /&gt;
  &lt;View style={{
    width: '66%',
    height: '35%',
    backgroundColor: 'skyblue'
  }} /&gt;
  &lt;View style={{
    width: '33%',
    height: '50%',
    backgroundColor: 'steelblue'
  }} /&gt;
&lt;/View&gt;
</code></pre>
<h3 id="layout-với-flexbox"><a class="header" href="#layout-với-flexbox">Layout với Flexbox</a></h3>
<p>Một component có thể chỉ định layout của các component con bằng thuật toán Flexbox. Flexbox được thiết kế để cung cấp layout nhất quán trên các kích thước màn hình khác nhau. Bạn thường sử dụng kết hợp <code>flexDirection</code>, <code>alignItems</code>, và <code>justifyContent</code> để đạt được layout mong muốn.</p>
<ul>
<li><strong>LƯU Ý</strong>: Flexbox hoạt động tương tự trong React Native như trong CSS trên web, với một vài ngoại lệ: các giá trị mặc định khác nhau (<code>flexDirection</code> mặc định là <code>column</code> thay vì <code>row</code>, <code>alignContent</code> mặc định là <code>flex-start</code> thay vì <code>stretch</code>, <code>flexShrink</code> mặc định là 0 thay vì 1, tham số <code>flex</code> chỉ hỗ trợ một số duy nhất).</li>
</ul>
<h4 id="flex"><a class="header" href="#flex">Flex</a></h4>
<p><code>flex</code> sẽ xác định cách các item của bạn &quot;lấp đầy&quot; không gian có sẵn dọc theo trục chính. Không gian sẽ được chia theo thuộc tính <code>flex</code> của mỗi phần tử.</p>
<pre><code class="language-javascript">import React from 'react';
import { StyleSheet, View } from 'react-native'; // Import necessary components

export default function Flex() {
  return (
    &lt;View style={[
      styles.container,
      { // Try setting 'flexDirection' to 'row'
        flexDirection: 'column'
      }]}&gt;
      &lt;View style={{flex: 1 , backgroundColor: 'red'}} /&gt;
      &lt;View style={{flex: 2 , backgroundColor: 'darkorange'}} /&gt;
      &lt;View style={{flex: 3 , backgroundColor: 'green'}} /&gt;
    &lt;/View&gt;
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1 ,
    padding: 20
  }
});
</code></pre>
<h4 id="flex-direction"><a class="header" href="#flex-direction">Flex Direction</a></h4>
<p><code>flexDirection</code> kiểm soát hướng mà các component con được bố trí. Đây còn được gọi là trục chính. Trục chéo là trục vuông góc với trục chính.</p>
<ul>
<li><code>column</code> (giá trị mặc định): Sắp xếp các component con từ trên xuống dưới.</li>
<li><code>row</code>: Sắp xếp các component con từ trái sang phải.</li>
<li><code>column-reverse</code>: Sắp xếp các component con từ dưới lên trên.</li>
<li><code>row-reverse</code>: Sắp xếp các component con từ phải sang trái.</li>
</ul>
<p>Ví dụ về <code>flexDirection</code>:</p>
<p>Thiết lập ban đầu:</p>
<pre><code class="language-javascript">import React, { useState } from 'react';
import { StyleSheet, Text, View } from 'react-native';

const FlexDirectionExample = () =&gt; {
  const [flexDirection, setFlexDirection] = useState('column');
  return (
    &lt;View style={styles.container}&gt;
      &lt;Text style={styles.label}&gt;flexDirection: {flexDirection}&lt;/Text&gt;
      {/* Remaining parts will be introduced in later slides */}
    &lt;/View&gt;
  );
};

// Assume styles object is defined elsewhere
// const styles = StyleSheet.create({ ... });
</code></pre>
<p>Thay đổi <code>flexDirection</code> với Buttons:</p>
<pre><code class="language-javascript">import { TouchableOpacity, Text, View, StyleSheet } from 'react-native'; // Import necessary components
import React, { useState } from 'react'; // Import useState

// Assume styles object is defined elsewhere
const styles = StyleSheet.create({
  container: { flex: 1, padding: 10 },
  label: { textAlign: &quot;center&quot;, fontSize: 18, marginBottom: 10 },
  buttons: { flexDirection: &quot;row&quot;, justifyContent: &quot;center&quot; },
  button: {
    padding: 8,
    margin: 5,
    backgroundColor: &quot;oldlace&quot;,
    borderRadius: 5,
  },
  selected: { backgroundColor: &quot;coral&quot; },
  boxContainer: { flex: 1, justifyContent: &quot;center&quot;, alignItems: &quot;center&quot; },
  box: { width: 50, height: 50, margin: 5 }
});

const FlexDirectionExample = () =&gt; {
  const [flexDirection, setFlexDirection] = useState('column');
  return (
    &lt;View style={styles.container}&gt;
      &lt;Text style={styles.label}&gt;flexDirection: {flexDirection}&lt;/Text&gt;
      &lt;View style={styles.buttons}&gt;
        {['column', 'row', 'row-reverse', 'column-reverse'].map(value =&gt; (
          &lt;TouchableOpacity
            key={value}
            onPress={() =&gt; setFlexDirection(value)}
            style={[styles.button, flexDirection === value &amp;&amp; styles.selected]}
          &gt;
            &lt;Text style={styles.buttonText}&gt;{value}&lt;/Text&gt;
          &lt;/TouchableOpacity&gt;
        ))}
      &lt;/View&gt;
      {/* The boxContainer part will be rendered below */}
    &lt;/View&gt;
  );
};
</code></pre>
<p>Thay đổi layout với <code>flexDirection</code>:</p>
<pre><code class="language-javascript">import { View, StyleSheet } from 'react-native'; // Import necessary components
import React, { useState } from 'react'; // Import useState

// Assume styles object is defined elsewhere
const styles = StyleSheet.create({
  container: { flex: 1, padding: 10 },
  label: { textAlign: &quot;center&quot;, fontSize: 18, marginBottom: 10 },
  buttons: { flexDirection: &quot;row&quot;, justifyContent: &quot;center&quot; },
  button: {
    padding: 8,
    margin: 5,
    backgroundColor: &quot;oldlace&quot;,
    borderRadius: 5,
  },
  selected: { backgroundColor: &quot;coral&quot; },
  boxContainer: { flex: 1, justifyContent: &quot;center&quot;, alignItems: &quot;center&quot; },
  box: { width: 50, height: 50, margin: 5 }
});

const FlexDirectionExample = () =&gt; {
  const [flexDirection, setFlexDirection] = useState('column');
  return (
    &lt;View style={styles.container}&gt;
      &lt;Text style={styles.label}&gt;flexDirection: {flexDirection}&lt;/Text&gt;
      {/* Buttons part rendered above */}
      &lt;View style={[styles.boxContainer, { flexDirection }]}&gt;
        &lt;View style={[styles.box, { backgroundColor: 'powderblue' }]} /&gt;
        &lt;View style={[styles.box, { backgroundColor: 'skyblue' }]} /&gt;
        &lt;View style={[styles.box, { backgroundColor: 'steelblue' }]} /&gt;
      &lt;/View&gt;
    &lt;/View&gt;
  );
};

export default FlexDirectionExample; // Export the component
</code></pre>
<p>Styles cho ví dụ <code>flexDirection</code>:</p>
<pre><code class="language-javascript">import { StyleSheet } from 'react-native';

const styles = StyleSheet.create({
  container: { flex: 1 , padding: 10 },
  label: { textAlign: &quot;center&quot;, fontSize: 18 , marginBottom: 10 },
  buttons: { flexDirection: &quot;row&quot;, justifyContent: &quot;center&quot; },
  button: {
    padding: 8 ,
    margin: 5 ,
    backgroundColor: &quot;oldlace&quot;,
    borderRadius: 5 ,
  },
  selected: { backgroundColor: &quot;coral&quot; },
  boxContainer: { flex: 1 , justifyContent: &quot;center&quot;, alignItems: &quot;center&quot; },
  box: { width: 50 , height: 50 , margin: 5 }
});
</code></pre>
<h4 id="layout-direction"><a class="header" href="#layout-direction">Layout Direction</a></h4>
<p><code>layoutDirection</code> chỉ định hướng của các component con và văn bản. Nó ảnh hưởng đến ý nghĩa của <code>start</code> và <code>end</code>.</p>
<ul>
<li><code>LTR</code> (giá trị mặc định): Văn bản và component con được bố trí từ trái sang phải.</li>
<li><code>RTL</code>: Văn bản và component con được bố trí từ phải sang trái.</li>
</ul>
<h4 id="justify-content"><a class="header" href="#justify-content">Justify Content</a></h4>
<p><code>justifyContent</code> mô tả cách căn chỉnh các component con dọc theo trục chính của container.</p>
<ul>
<li><code>flex-start</code> (giá trị mặc định): Căn chỉnh về đầu trục chính.</li>
<li><code>flex-end</code>: Căn chỉnh về cuối trục chính.</li>
<li><code>center</code>: Căn chỉnh vào giữa trục chính.</li>
<li><code>space-between</code>: Phân bổ đều không gian giữa các component con dọc theo trục chính.</li>
<li><code>space-around</code>: Phân bổ đều không gian xung quanh các component con dọc theo trục chính.</li>
<li><code>space-evenly</code>: Phân bổ đều không gian giữa các component con, không gian ở hai đầu container và khoảng cách giữa các item đều bằng nhau.</li>
</ul>
<h4 id="align-items"><a class="header" href="#align-items">Align Items</a></h4>
<p><code>alignItems</code> mô tả cách căn chỉnh các component con dọc theo trục chéo của container. Nó tương tự như <code>justifyContent</code> nhưng dùng cho trục chéo.</p>
<ul>
<li><code>stretch</code> (giá trị mặc định): Kéo dài các component con để khớp với chiều cao của trục chéo.</li>
<li><code>flex-start</code>: Căn chỉnh về đầu trục chéo.</li>
<li><code>flex-end</code>: Căn chỉnh về cuối trục chéo.</li>
<li><code>center</code>: Căn chỉnh vào giữa trục chéo.</li>
<li><code>baseline</code>: Căn chỉnh các component con dọc theo một đường cơ sở chung.</li>
</ul>
<h4 id="align-self"><a class="header" href="#align-self">Align Self</a></h4>
<p><code>alignSelf</code> có các tùy chọn và hiệu ứng giống như <code>alignItems</code> nhưng áp dụng cho một component con duy nhất để thay đổi căn chỉnh của nó bên trong component cha. <code>alignSelf</code> ghi đè bất kỳ tùy chọn nào được đặt bởi component cha với <code>alignItems</code>.</p>
<h4 id="align-content"><a class="header" href="#align-content">Align Content</a></h4>
<p><code>alignContent</code> định nghĩa cách phân bổ các dòng dọc theo trục chéo. Điều này chỉ có hiệu lực khi các item được xuống dòng bằng <code>flexWrap</code>.</p>
<ul>
<li><code>flex-start</code> (giá trị mặc định): Căn chỉnh các dòng đã xuống dòng về đầu trục chéo.</li>
<li><code>flex-end</code>: Căn chỉnh các dòng đã xuống dòng về cuối trục chéo.</li>
<li><code>stretch</code>: Kéo dài các dòng đã xuống dòng để khớp với chiều cao của trục chéo.</li>
<li><code>center</code>: Căn chỉnh các dòng đã xuống dòng vào giữa trục chéo.</li>
<li><code>space-between</code>: Phân bổ đều không gian giữa các dòng đã xuống dòng dọc theo trục chéo.</li>
<li><code>space-around</code>: Phân bổ đều không gian xung quanh các dòng đã xuống dòng dọc theo trục chéo.</li>
<li><code>space-evenly</code>: Phân bổ đều không gian giữa các dòng đã xuống dòng dọc theo trục chéo.</li>
</ul>
<h4 id="flex-wrap"><a class="header" href="#flex-wrap">Flex Wrap</a></h4>
<p>Thuộc tính <code>flexWrap</code> được đặt trên container và kiểm soát điều gì xảy ra khi các component con tràn ra ngoài kích thước của container dọc theo trục chính. Mặc định, các component con bị ép vào một dòng duy nhất. Nếu cho phép xuống dòng, các item sẽ được xuống dòng thành nhiều dòng dọc theo trục chính nếu cần.</p>
<h4 id="flex-basis-và-grow"><a class="header" href="#flex-basis-và-grow">Flex Basis và Grow</a></h4>
<ul>
<li><strong>flexBasis</strong>: Định nghĩa kích thước mặc định của một item dọc theo trục chính. Hoạt động giống như <code>width</code> nếu <code>flexDirection: row</code>, hoặc <code>height</code> nếu <code>flexDirection: column</code>. Kích thước của item trước khi điều chỉnh bởi <code>flexGrow</code> và <code>flexShrink</code>.</li>
<li><strong>flexGrow</strong>: Xác định lượng không gian còn lại mà một component con nên chiếm trong container. Chấp nhận giá trị ≥ 0 (mặc định là 0). Không gian được phân bổ theo tỷ lệ dựa trên giá trị <code>flexGrow</code>.</li>
</ul>
<h4 id="flexshrink"><a class="header" href="#flexshrink">flexShrink</a></h4>
<p>Định nghĩa cách một component con co lại khi nội dung tràn ra ngoài container. Chấp nhận giá trị ≥ 0 (mặc định là 0, nhưng là 1 trong web). Hoạt động với <code>flexGrow</code> để cho phép các phần tử mở rộng và co lại một cách linh hoạt.</p>
<h4 id="row-gap-column-gap-và-gap"><a class="header" href="#row-gap-column-gap-và-gap">Row Gap, Column Gap và Gap</a></h4>
<ul>
<li><code>rowGap</code>: Đặt kích thước của khoảng cách (gutter) giữa các hàng của một phần tử.</li>
<li><code>columnGap</code>: Đặt kích thước của khoảng cách (gutter) giữa các cột của một phần tử.</li>
<li><code>gap</code>: Đặt kích thước của khoảng cách (gutter) giữa các hàng và cột. Nó là shorthand cho <code>rowGap</code> và <code>columnGap</code>.</li>
</ul>
<p>Bạn có thể sử dụng <code>flexWrap</code> và <code>alignContent</code> cùng với <code>gap</code> để thêm khoảng cách nhất quán giữa các item.</p>
<h2 id="bài-8-tailwind-css-for-react-native-ie-nativewind"><a class="header" href="#bài-8-tailwind-css-for-react-native-ie-nativewind">Bài 8: Tailwind CSS for React Native i.e. NativeWind</a></h2>
<pre><code class="language-bash">npm install nativewind@2.0.11 tailwindcss@3.2.2
# Optional
npm install react-native-reanimated
# (optional)
npm install react-native-safe-area-context
</code></pre>
<ol start="2">
<li><strong>Thiết lập NativeWind:</strong> Chạy <code>npx tailwindcss init</code> để tạo file <code>tailwind.config.js</code>. Thêm đường dẫn đến tất cả các file component của bạn vào file <code>tailwind.config.js</code>.</li>
</ol>
<pre><code class="language-javascript">    /** @type {import('tailwindcss').Config} */
    module.exports = {
      content: [
        &quot;./TailwindApp.js&quot;,
        &quot;./components/*.js&quot;,
        &quot;./screens/*.js&quot;
      ],
      theme: {
        extend: {},
      },
      plugins: [],
    }
</code></pre>
<ol start="3">
<li><strong>Thêm Babel preset:</strong> Bước này đảm bảo NativeWind hoạt động chính xác trong React Native bằng cách biến đổi cú pháp JSX để hỗ trợ <code>className</code> theo kiểu Tailwind CSS. Tạo file <code>babel.config.js</code>.</li>
</ol>
<pre><code class="language-javascript">    module.exports = {
      presets: [&quot;babel-preset-expo&quot;],
      plugins: [&quot;nativewind/babel&quot;],
    };
</code></pre>
<h3 id="styling-với-utility-classes"><a class="header" href="#styling-với-utility-classes">Styling với Utility Classes</a></h3>
<p>Bạn tạo kiểu bằng Tailwind bằng cách kết hợp nhiều class trình bày (utility classes) có mục đích đơn lẻ trực tiếp trong markup của bạn.</p>
<pre><code class="language-javascript">&lt;View className=&quot;flex-1 justify-center items-center bg-blue-100&quot;&gt;
  &lt;View className=&quot;flex-row items-center shadow-2xl shadow-gray-900 gap-x-4 rounded-xl bg-white p-6&quot;&gt;
    &lt;View&gt;
      &lt;Image className=&quot;w-20 h-20&quot; resizeMode=&quot;contain&quot; source={require('./assets/chitchat.png')} /&gt;
    &lt;/View&gt;
    &lt;View&gt;
      &lt;Text className=&quot;text-xl font-medium text-black&quot;&gt;ChitChat&lt;/Text&gt;
      &lt;Text className=&quot;text-gray-500&quot;&gt;You have a new message!&lt;/Text&gt;
    &lt;/View&gt;
  &lt;/View&gt;
&lt;/View&gt;
</code></pre>
<p>Trong ví dụ trên, các utility classes như <code>flex</code>, <code>flex-row</code>, <code>p-6</code>, <code>justify-center</code>, <code>items-center</code>, <code>bg-white</code>, <code>rounded-xl</code>, <code>shadow-2xl</code>, <code>shadow-gray-900</code>, <code>w-20</code>, <code>h-20</code>, <code>gap-x-4</code>, <code>text-xl</code>, <code>text-black</code>, <code>font-medium</code>, <code>text-gray-500</code> được sử dụng để kiểm soát layout, căn chỉnh, kiểu dáng hộp, kích thước hình ảnh, khoảng cách và kiểu văn bản.</p>
<h4 id="lợi-ích-chính-của-utility-first-styling"><a class="header" href="#lợi-ích-chính-của-utility-first-styling">Lợi ích chính của Utility-First Styling:</a></h4>
<ul>
<li>Phát triển nhanh hơn.</li>
<li>Thay đổi an toàn hơn.</li>
<li>Bảo trì dễ dàng hơn.</li>
<li>Code portable hơn.</li>
<li>Sử dụng bộ nhớ nhỏ.</li>
</ul>
<p>Sử dụng utility classes có nhiều lợi thế quan trọng so với inline styles, bao gồm thiết kế với các ràng buộc, hỗ trợ các trạng thái như <code>focus</code>, <code>press</code> và media queries.</p>
<h3 id="các-tính-năng-cốt-lõi-của-tailwindnativewind"><a class="header" href="#các-tính-năng-cốt-lõi-của-tailwindnativewind">Các tính năng cốt lõi của Tailwind/NativeWind</a></h3>
<ul>
<li>Variants cho các trạng thái (ví dụ: <code>focus:bg-orange-200</code>).</li>
<li>Thiết kế responsive sử dụng tiền tố như <code>sm:grid-cols-3</code>).</li>
<li>Styling chế độ tối với <code>dark:bg-gray-800</code>).</li>
<li>Arbitrary values (ví dụ: <code>bg-[#316ff6]</code>) cho các styles tùy chỉnh.</li>
</ul>
<h4 id="state-variants"><a class="header" href="#state-variants">State Variants</a></h4>
<p>Ví dụ về TextInput với các kiểu khác nhau khi focus và không focus:</p>
<pre><code class="language-javascript">&lt;TextInput
  className=&quot;border p-2 rounded focus:border-blue-500 focus:outline-none&quot;
  placeholder=&quot;Enter text...&quot;
/&gt;
</code></pre>
<h4 id="media-queries-và-breakpoints"><a class="header" href="#media-queries-và-breakpoints">Media Queries và Breakpoints</a></h4>
<p>Bạn có thể tạo kiểu cho các phần tử ở các breakpoint khác nhau bằng cách thêm tiền tố breakpoint vào utility class.</p>
<pre><code class="language-javascript">&lt;View className=&quot;flex flex-row sm:flex-col&quot;&gt;
  &lt;Text&gt;A&lt;/Text&gt;
  &lt;Text&gt;B&lt;/Text&gt;
  &lt;Text&gt;C&lt;/Text&gt;
&lt;/View&gt;
</code></pre>
<h4 id="sử-dụng-arbitrary-values"><a class="header" href="#sử-dụng-arbitrary-values">Sử dụng Arbitrary Values</a></h4>
<p>Khi bạn cần sử dụng một giá trị một lần nằm ngoài theme của mình, hãy sử dụng cú pháp ngoặc vuông đặc biệt để chỉ định arbitrary values.</p>
<pre><code class="language-javascript">&lt;Pressable className=&quot;bg-[#316ff6] ...&quot;&gt;
  &lt;Text className=&quot;text-[#ffe]&quot;&gt;Sign in with Facebook&lt;/Text&gt;
&lt;/Pressable&gt;
</code></pre>
<h2 id="lecture-10"><a class="header" href="#lecture-10">Lecture 10</a></h2>
<p>Dưới đây là các đoạn code và giải thích từ tài liệu Lecture 10 về Quản lý State với Redux trong React Native:</p>
<h3 id="tại-sao-sử-dụng-redux"><a class="header" href="#tại-sao-sử-dụng-redux">Tại sao sử dụng Redux?</a></h3>
<ul>
<li>Quản lý state theo cách truyền thống trong React/React Native với <code>useState</code> có thể dẫn đến vấn đề &quot;prop drilling&quot; (truyền prop qua nhiều cấp), không có &quot;single source of truth&quot; (nguồn dữ liệu duy nhất) và liên kết chặt chẽ giữa presentation và data model.</li>
<li>Redux cung cấp một giải pháp quản lý state tập trung, giúp giải quyết các vấn đề trên.</li>
<li>Lợi ích của việc chọn Redux bao gồm: hệ sinh thái middleware phong phú, công cụ phát triển tuyệt vời, tài liệu tốt, là lựa chọn hàng đầu cho quản lý state trong React, hỗ trợ tốt bởi các thư viện/framework khác, và hỗ trợ React server side rendering.</li>
</ul>
<h3 id="các-thành-phần-cốt-lõi-của-redux-data-flow"><a class="header" href="#các-thành-phần-cốt-lõi-của-redux-data-flow">Các thành phần cốt lõi của Redux Data Flow</a></h3>
<p>Để sử dụng Redux hiệu quả, bạn cần hiểu bốn thành phần chính của nó:</p>
<ol>
<li><strong>Store:</strong> Nơi lưu trữ tập trung giữ toàn bộ state của ứng dụng. State trong store là read-only.</li>
<li><strong>Views (UI Components):</strong> Các component React kết nối với store để hiển thị dữ liệu và kích hoạt actions.</li>
<li><strong>Actions:</strong> Các đối tượng JavaScript thuần mô tả những gì đã xảy ra (ví dụ: tương tác của người dùng hoặc phản hồi từ API). Actions có thuộc tính <code>type</code> và thường có thuộc tính <code>payload</code>.</li>
</ol>
<pre><code class="language-javascript">    store.dispatch({ type: 'BEGIN_LOADING' });
    store.dispatch({ type: 'DONE_LOADING' });
    store.dispatch({ type: 'UPDATE_SEARCH_TERM', payload: 'mpr' });
</code></pre>
<ol start="4">
<li><strong>Reducers:</strong> Các pure function (hàm thuần khiết) nhận state hiện tại và một action, sau đó trả về một state mới. Reducer không sửa đổi state gốc trực tiếp mà trả về một đối tượng state mới. Mỗi reducer ánh xạ đến chính xác 1 phần của cây state.</li>
</ol>
<pre><code class="language-javascript">    function todoReducer(state = [], action) {
      switch (action.type) {
        case 'ADD_TODO':
          // creates new array, adds todo at the end
          return [...state, action.payload];
        case 'REMOVE_TODO':
          // creates new array filtering out matching todo by id
          return state.filter(todo =&gt; todo.id !== action.payload);
        default:
          return state;
      }
    }
</code></pre>
<h4 id="action-creators"><a class="header" href="#action-creators">Action Creators</a></h4>
<p>Là các factory function trả về một action. Mặc dù không bắt buộc, nhưng nó thường được sử dụng.</p>
<pre><code class="language-javascript">// searchTermActions.js
function updateSearchTerm(searchTerm) {
  return {
    type: 'UPDATE_SEARCH_TERM',
    payload: searchTerm,
  };
}

// SearchComponent.js
store.dispatch(updateSearchTerm('homework'));
</code></pre>
<h4 id="root-reducer"><a class="header" href="#root-reducer">Root Reducer</a></h4>
<p>Một ứng dụng Redux thực sự chỉ có một hàm reducer: &quot;root reducer&quot; mà bạn sẽ truyền vào <code>createStore</code>. Root reducer này xử lý tất cả các actions được dispatch và tính toán toàn bộ state mới.</p>
<pre><code class="language-javascript">export default function appReducer(state = initialState, action) {
  switch (action.type) {
    case 'todos/todoAdded': {
      return {
        ...state,
        todos: [...state.todos, newTodo]
      };
    }
    case 'todos/todoToggled': {
      return {
        ...state,
        todos: [...state.todos, toggledTodo]
      };
    }
    default:
      return state;
  }
}
</code></pre>
<h4 id="splitting-reducers"><a class="header" href="#splitting-reducers">Splitting Reducers</a></h4>
<p>Reducers thường được chia nhỏ dựa trên phần state mà chúng cập nhật. Reducer cho một phần cụ thể của state được gọi là &quot;slice reducer&quot;. Các actions liên quan đến một slice reducer nên có cùng tiền tố (ví dụ: <code>todos/todoAdd</code>).</p>
<pre><code class="language-javascript">// todosSlice.js
const initialState = [
  { id: 0, text: 'Learn React', completed: true },
  { id: 1, text: 'Learn Redux', completed: false },
];

export default function todosReducer(state = initialState, action) {
  switch (action.type) {
    case 'todos/todoAdded': {
      // code to handle this action
      return state; // placeholder
    }
    case 'todos/todoToggled': {
      // code to handle this action
      return state; // placeholder
    }
    default:
      return state;
  }
}
</code></pre>
<h4 id="combining-reducers"><a class="header" href="#combining-reducers">Combining Reducers</a></h4>
<p>Store chỉ cần một root reducer, vì vậy bạn cần kết hợp tất cả các slice reducer lại với nhau. Có thể làm thủ công hoặc sử dụng utility function <code>combineReducers</code>.</p>
<p>Sử dụng <code>combineReducers</code>:</p>
<pre><code class="language-javascript">import { combineReducers } from 'redux';
import todosReducer from './features/todos/todosSlice';
import filtersReducer from './features/filters/filtersSlice';

const rootReducer = combineReducers({
  todos: todosReducer,
  filters: filtersReducer,
});

export default rootReducer;
</code></pre>
<p>Kết hợp thủ công:</p>
<pre><code class="language-javascript">import todosReducer from './features/todos/todosSlice';
import filtersReducer from './features/filters/filtersSlice';

export default function rootReducer(state = {}, action) {
  return {
    // the value of `state.todos` is whatever
    // the todos reducer returns
    todos: todosReducer(state.todos, action),
    // For both reducers, we only pass in
    // their slice of the state
    filters: filtersReducer(state.filters, action),
  };
}
</code></pre>
<h3 id="redux-store"><a class="header" href="#redux-store">Redux Store</a></h3>
<ul>
<li>Store là nơi chứa toàn bộ cây state của ứng dụng. State tree là read-only. Cách duy nhất để thay đổi state bên trong store là dispatch một action lên nó.</li>
<li>Store không phải là một class, nó chỉ là một đối tượng với một vài phương thức.</li>
</ul>
<h4 id="tạo-một-redux-store"><a class="header" href="#tạo-một-redux-store">Tạo một Redux store</a></h4>
<pre><code class="language-javascript">import { createStore, combineReducers, applyMiddleware } from 'redux';

// Assume loadingReducer, todosReducer, searchTermReducer, bookMarksReducer, userProfileReducer are defined
// Assume INITIAL_STATE is defined
// Assume logger, thunk are defined (middleware)

const store = createStore(
  combineReducers({
    isLoading: loadingReducer,
    todos: todosReducer,
    searchTerm: searchTermReducer,
    bookmarks: bookMarksReducer,
    userProfile: userProfileReducer,
  }), // required – the root reducer
  INITIAL_STATE, // optional
  applyMiddleware(logger, thunk), // optional
);
</code></pre>
<h4 id="lắng-nghe-cập-nhật-của-store"><a class="header" href="#lắng-nghe-cập-nhật-của-store">Lắng nghe cập nhật của store</a></h4>
<p>Phương thức <code>subscribe</code> thêm một hàm lắng nghe sự thay đổi. Nó sẽ được gọi bất cứ khi nào một action được dispatch và một phần nào đó của cây state có thể đã thay đổi.</p>
<pre><code class="language-javascript">let currentValue;

function handleChange() {
  let previousValue = currentValue;
  currentValue = store.getState().some.property; // Replace 'some.property' with the actual state slice you want to track

  if (previousValue !== currentValue) {
    console.log(
      'Some property changed from',
      previousValue,
      'to',
      currentValue
    );
  }
}

const unsubscribe = store.subscribe(handleChange);

// Call unsubscribe() later to remove the listener
</code></pre>
<h3 id="redux-và-middleware"><a class="header" href="#redux-và-middleware">Redux và Middleware</a></h3>
<ul>
<li>Middleware là một lớp nằm giữa action creators và reducers. Nó có thể chặn hoặc dispatch các actions bổ sung, có toàn quyền truy cập vào action và state của ứng dụng, và có thể xử lý các async actions.</li>
<li>Middleware được áp dụng cho store bằng cách sử dụng hàm <code>applyMiddleware</code>.</li>
<li>Ví dụ về Middleware: Redux Logger (ghi log state trước action, action được dispatch, state sau action) và Redux DevTools (hiển thị timeline của actions, cho phép time travel debugging).</li>
</ul>
<h3 id="làm-việc-với-redux-store-bằng-react-redux"><a class="header" href="#làm-việc-với-redux-store-bằng-react-redux">Làm việc với Redux store bằng <code>react-redux</code></a></h3>
<p>Thư viện <code>react-redux</code> cung cấp các hook để tương tác với Redux store trong các component React.</p>
<h4 id="hook-useselector"><a class="header" href="#hook-useselector">Hook <code>useSelector()</code></a></h4>
<p>Cho phép component React đọc dữ liệu từ Redux store. Nó nhận một hàm selector làm đối số, hàm này nhận toàn bộ state của store, đọc một giá trị từ state và trả về kết quả đó. <code>useSelector</code> tự động subscribe vào store.</p>
<pre><code class="language-javascript">import { useSelector } from 'react-redux';
import { FlatList, View, Text } from 'react-native'; // Import necessary components

// Assume Todo component is defined elsewhere
function Todo({ todo }) {
  return (
    &lt;View&gt;
      &lt;Text&gt;{todo}&lt;/Text&gt;
    &lt;/View&gt;
  );
}

const selectTodos = state =&gt; state.todos;

export const TodoList = ({ DATA }) =&gt; { // Assuming DATA is passed as a prop or comes from context/state
  const todos = useSelector(selectTodos);

  return (
    &lt;FlatList
      data={todos} // Or use DATA prop if needed
      renderItem={({ item }) =&gt; &lt;Todo key={item.id} todo={item.text} /&gt;} // Assuming item has id and text properties
      style={{}} // Apply your styles here, e.g., styles.todoList
    /&gt;
  );
};
</code></pre>
<h4 id="hook-usedispatch"><a class="header" href="#hook-usedispatch">Hook <code>useDispatch()</code></a></h4>
<p>Hook <code>useDispatch</code> trả về phương thức <code>dispatch</code> của store. Bạn có thể khai báo <code>const dispatch = useDispatch()</code> trong bất kỳ component nào và sử dụng <code>dispatch(someAction)</code> khi cần.</p>
<pre><code class="language-javascript">import { useDispatch } from 'react-redux';
import { useState } from 'react'; // Import useState
import { TextInput, Button, View } from 'react-native'; // Import necessary components

export default Header = () =&gt; {
  const [text, setText] = useState('');
  const dispatch = useDispatch();

  const handleSubmit = () =&gt; { // Changed to a regular function
    // Dispatch the &quot;todo added&quot; action with this text
    dispatch({ type: 'todos/todoAdded', payload: text });
    // Clear out the text input
    setText('');
  };

  return (
    &lt;View&gt;
      &lt;TextInput
        placeholder=&quot;What needs to be done?&quot;
        value={text}
        onChangeText={val =&gt; setText(val)}
        onSubmitEditing={handleSubmit}
      /&gt;
    &lt;/View&gt;
  );
};
</code></pre>
<h4 id="redux-store-provider"><a class="header" href="#redux-store-provider">Redux store Provider</a></h4>
<p>Để <code>useSelector</code> và <code>useDispatch</code> tìm thấy store, bạn cần bọc toàn bộ ứng dụng bằng component <code>&lt;Provider&gt;</code> từ <code>react-redux</code> và truyền store vào prop <code>store</code>.</p>
<pre><code class="language-javascript">// index.js (or App.js depending on your project structure)
import { Provider } from 'react-redux';
import { registerRootComponent } from 'expo'; // If using Expo
import App from './App';
import store from './store'; // Assume your store is exported from './store.js'

// If using Expo
registerRootComponent(
  &lt;Provider store={store}&gt;
    &lt;App /&gt;
  &lt;/Provider&gt;
);

// If not using Expo, typically wrap your root component in your entry file
/*
import React from 'react';
import { AppRegistry } from 'react-native';
import App from './App';
import store from './store'; // Assume your store is exported from './store.js'

const AppWithStore = () =&gt; (
  &lt;Provider store={store}&gt;
    &lt;App /&gt;
  &lt;/Provider&gt;
);

AppRegistry.registerComponent('YourAppName', () =&gt; AppWithStore);
*/
</code></pre>
<h3 id="async-actions-với-redux-thunk-middleware"><a class="header" href="#async-actions-với-redux-thunk-middleware">Async Actions với <code>redux-thunk</code> middleware</a></h3>
<p>Redux chỉ hoạt động đồng bộ theo mặc định. Để xử lý các async actions, bạn cần sử dụng middleware như <code>redux-thunk</code>.</p>
<h4 id="thunk-là-gì"><a class="header" href="#thunk-là-gì">Thunk là gì?</a></h4>
<p>Thunk là một hàm bọc một biểu thức để trì hoãn việc tính toán của nó.</p>
<pre><code class="language-javascript">// calculation of 1 + 2 is immediate
// x === 3
let x = 1 + 2;

// calculation of 1 + 2 is delayed
// foo can be called later to perform the calculation
// foo is a thunk!
let foo = () =&gt; 1 + 2;
</code></pre>
<h4 id="sử-dụng-redux-thunk"><a class="header" href="#sử-dụng-redux-thunk">Sử dụng <code>redux-thunk</code></a></h4>
<p>Đầu tiên, tạo một phiên bản store đã được sửa đổi để chấp nhận các thunk function bằng cách áp dụng middleware <code>redux-thunk</code>.</p>
<pre><code class="language-javascript">import { createStore, applyMiddleware } from 'redux';
import thunk from 'redux-thunk';
import rootReducer from './reducer'; // Assume your root reducer is exported from './reducer.js'

// The store now has the ability to accept thunk functions in `dispatch`
const store = createStore(rootReducer, applyMiddleware(thunk));

export default store;
</code></pre>
<h4 id="ví-dụ-dispatching-một-function-sử-dụng-redux-thunk"><a class="header" href="#ví-dụ-dispatching-một-function-sử-dụng-redux-thunk">Ví dụ: Dispatching một Function (sử dụng <code>redux-thunk</code>)</a></h4>
<pre><code class="language-javascript">// thunk function
// Assume fetchData is defined elsewhere (e.g., your API utility)
export async function fetchTodos(dispatch) {
  try {
    const response = await fetchData('/fakeApi/todos');
    dispatch({ type: 'todos/todosLoaded', payload: response.todos });
  } catch (error) {
    // Handle errors, maybe dispatch an error action
    console.error(&quot;Error fetching todos:&quot;, error);
  }
}

// using the thunk function later on
// Assume store is imported
// store.dispatch(fetchTodos); // Call the thunk function
</code></pre>
<h2 id="lecture-11-multimedia"><a class="header" href="#lecture-11-multimedia">Lecture 11: Multimedia</a></h2>
<h3 id="expo-imagepicker"><a class="header" href="#expo-imagepicker">Expo ImagePicker</a></h3>
<p><code>expo-image-picker</code> cung cấp quyền truy cập vào UI hệ thống để chọn hình ảnh và video từ thư viện của điện thoại hoặc chụp ảnh bằng camera.</p>
<ul>
<li><strong>Cài đặt:</strong></li>
</ul>
<pre><code class="language-bash">npx expo install expo-image-picker
</code></pre>
<ul>
<li><strong>Cấu hình trong <code>app.json</code> (với plugin config):</strong>
Cấu hình này được sử dụng khi sử dụng Expo Image Picker thông qua hệ thống plugin của Expo. <code>photosPermission</code> chỉ định thông báo sẽ hiển thị cho người dùng khi ứng dụng yêu cầu quyền truy cập vào ảnh của họ (chỉ cho iOS).</li>
</ul>
<pre><code class="language-json">&quot;expo&quot;: {
  &quot;plugins&quot;: [
    [
      &quot;expo-image-picker&quot;,
      {
        &quot;photosPermission&quot;: &quot;The app accesses your photos to let you share them with your friends.&quot;
      }
    ]
  ]
}
</code></pre>
<ul>
<li>
<p><strong>Các thuộc tính cấu hình khác (chỉ cho iOS):</strong></p>
<ul>
<li><code>photosPermission</code>: Đặt thông báo quyền truy cập thư viện ảnh.</li>
<li><code>cameraPermission</code>: Đặt thông báo quyền truy cập camera.</li>
<li><code>microphonePermission</code>: Đặt thông báo quyền truy cập microphone.</li>
</ul>
</li>
<li>
<p><strong>Sử dụng Image Picker:</strong>
Nhập thư viện và sử dụng hook <code>useState</code> để quản lý trạng thái ảnh đã chọn.</p>
</li>
</ul>
<pre><code class="language-javascript">import * as ImagePicker from 'expo-image-picker';
import { useState } from 'react'; // Assuming useState is imported
import { Button, Image, View, StyleSheet } from 'react-native'; // Import necessary components

// Assume styles object is defined elsewhere
const styles = StyleSheet.create({
  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },
  image: { width: 200, height: 200, marginTop: 20, resizeMode: 'contain' },
});

function MyImagePickerComponent() { // Example component
  const [image, setImage] = useState(null);

  const pickImage = async () =&gt; {
    // No permissions request is necessary for launching the image library
    let result = await ImagePicker.launchImageLibraryAsync({
      mediaTypes: ['images', 'videos'],
      allowsEditing: true,
      aspect: [4, 3],
      quality: 1,
    });

    if (!result.canceled) {
      setImage(result.assets[0].uri);
      console.log(result.assets[0].uri); // Log the URI
    }
    console.log(result); // Log the entire result object
  };

  // Hiển thị ảnh đã chọn:
  return (
    &lt;View style={styles.container}&gt;
      &lt;Button title=&quot;Pick an image from camera roll&quot; onPress={pickImage} /&gt;
      {image &amp;&amp; &lt;Image source={{ uri: image }} style={styles.image} /&gt;}
    &lt;/View&gt;
  );
}

export default MyImagePickerComponent; // Export the component
</code></pre>
<ul>
<li><code>ImagePicker.launchImageLibraryAsync</code> mở thư viện ảnh.</li>
<li><code>mediaTypes</code> xác định loại media có thể chọn.</li>
<li><code>allowsEditing</code> cho phép chỉnh sửa ảnh đã chọn.</li>
<li><code>aspect</code> đặt tỷ lệ khung hình khi chỉnh sửa.</li>
<li><code>quality</code> đặt chất lượng nén.</li>
</ul>
<p><strong>Kiểm tra quyền cho iOS (cách cũ, tài liệu mới có thể khác):</strong></p>
<pre><code class="language-javascript">import { askAsync, MEDIA_LIBRARY } from 'expo-permissions'; // Note: expo-permissions might be deprecated in newer Expo versions
import * as ImagePicker from 'expo-image-picker'; // Import ImagePicker

const pickImage = async () =&gt; {
  // Request permission to access the photo library
  const { status } = await askAsync(MEDIA_LIBRARY);
  if (status !== 'granted') {
    alert('Sorry, we need camera roll permissions to make this work!');
    return;
  }

  // Launch the image library
  let result = await ImagePicker.launchImageLibraryAsync({
    mediaTypes: ['images', 'videos'],
    allowsEditing: true,
    aspect: [4, 3],
    quality: 1,
  });

  if (!result.canceled) {
    console.log(result.assets[0].uri);
  }
};
</code></pre>
<h3 id="expo-imagemanipulator"><a class="header" href="#expo-imagemanipulator">Expo ImageManipulator</a></h3>
<p><code>expo-image-manipulator</code> cho phép bạn thao tác trực tiếp với hình ảnh trong ứng dụng React Native, bao gồm xoay, lật, cắt và thay đổi kích thước.</p>
<ul>
<li><strong>Cài đặt:</strong></li>
</ul>
<pre><code class="language-bash">npx expo install expo-image-manipulator
</code></pre>
<ul>
<li>
<p><strong>Các tính năng chính:</strong></p>
<ul>
<li><strong>Image Transformation:</strong> Xoay, lật (ngang/dọc), cắt, thay đổi kích thước.</li>
<li><strong>Image Format:</strong> Lưu dưới dạng JPEG hoặc PNG, điều chỉnh chất lượng nén.</li>
<li><strong>Integration:</strong> Hoạt động tốt với ảnh từ camera hoặc thư viện, và có thể dùng với <code>expo-image-picker</code>.</li>
</ul>
</li>
<li>
<p><strong>Sử dụng ImageManipulator:</strong>
Ví dụ về xoay và lật ảnh:</p>
</li>
</ul>
<pre><code class="language-javascript">import { useState } from 'react';
import { Button, Image, StyleSheet, View } from 'react-native';
import { Asset } from 'expo-asset';
import { FlipType, SaveFormat, useImageManipulator } from 'expo-image-manipulator';

// Loading the Image
const IMAGE = Asset.fromModule(require('./assets/avatar.jpg'));

export default function App() { // Example App component
  const [image, setImage] = useState(IMAGE);

  // useImageManipulator creates a manipulation context for the image.
  const context = useImageManipulator(IMAGE.uri);

  // This function is triggered when the &quot;Rotate and Flip&quot; button is pressed.
  const rotate90andFlip = async () =&gt; {
    context.rotate(90).flip(FlipType.Vertical);
    const manipulatedImage = await context.renderAsync(); // Rename to avoid conflict
    const result = await manipulatedImage.saveAsync({
      format: SaveFormat.PNG,
    });
    setImage(result);
  };

  return (
    &lt;View style={styles.container}&gt;
      &lt;View style={styles.imageContainer}&gt;
        &lt;Image source={{ uri: image.localUri || image.uri }} style={styles.image} /&gt;
      &lt;/View&gt;
      &lt;Button title=&quot;Rotate and Flip&quot; onPress={rotate90andFlip} /&gt;
    &lt;/View&gt;
  );
}

// Assume styles object is defined elsewhere
const styles = StyleSheet.create({
  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },
  imageContainer: { marginBottom: 20 },
  image: { width: 200, height: 200, resizeMode: 'contain' },
});
</code></pre>
<ul>
<li><code>Asset.fromModule</code> tải ảnh từ assets.</li>
<li><code>useImageManipulator</code> tạo context để thao tác.</li>
<li><code>context.rotate()</code> và <code>context.flip()</code> thực hiện các phép biến đổi.</li>
<li><code>context.renderAsync()</code> áp dụng các phép biến đổi.</li>
<li><code>manipulatedImage.saveAsync()</code> lưu ảnh đã thao tác.</li>
</ul>
<h3 id="expo-video"><a class="header" href="#expo-video">Expo Video</a></h3>
<p>Component <code>Expo Video</code> là một phần của thư viện <code>expo-av</code>, được sử dụng để phát âm thanh và video trong ứng dụng React Native.</p>
<ul>
<li><strong>Cài đặt:</strong></li>
</ul>
<pre><code class="language-bash">npx expo install expo-video
</code></pre>
<ul>
<li><strong>Cấu hình trong <code>app.json</code> (với config plugin):</strong></li>
</ul>
<pre><code class="language-json">{
  &quot;expo&quot;: {
    &quot;plugins&quot;: [
      [
        &quot;expo-video&quot;,
        {
          &quot;supportsBackgroundPlayback&quot;: true, // Chỉ cho iOS
          &quot;supportsPictureInPicture&quot;: true    // Cho Android và iOS
        }
      ]
    ]
  }
}
</code></pre>
<pre><code>* `supportsBackgroundPlayback` (chỉ iOS): Bật phát lại nền.
* `supportsPictureInPicture`: Bật chế độ Picture-in-Picture.
</code></pre>
<ul>
<li><strong>Phát media cục bộ từ thư mục assets:</strong>
Hỗ trợ phát media được tải bằng hàm <code>require</code>.</li>
</ul>
<pre><code class="language-javascript">import { VideoSource, useVideoPlayer } from 'expo-video'; // Import necessary components

const assetId = require('./assets/bigbuckbunny.mp4');

const videoSource: VideoSource = {
  assetId,
  metadata: {
    title: 'Big Buck Bunny',
    artist: 'The Open Movie Project'
  }
};

const player1 = useVideoPlayer(assetId); // You can use the `asset` directly as a video source
const player2 = useVideoPlayer(videoSource);
</code></pre>
<ul>
<li><strong>Preloading videos:</strong>
Có thể tải video trước khi hiển thị để chuyển đổi nhanh hơn.</li>
</ul>
<pre><code class="language-javascript">import { useVideoPlayer, VideoView, VideoSource } from 'expo-video';
import { useState, useCallback } from 'react'; // Import necessary hooks
import { View, Text, TouchableOpacity, StyleSheet } from 'react-native'; // Import necessary components

// Assume video sources are defined elsewhere
const bigBuckBunnySource: VideoSource = 'YOUR_BIG_BUCK_BUNNY_VIDEO_SOURCE';
const elephantsDreamSource: VideoSource = 'YOUR_ELEPHANTS_DREAM_VIDEO_SOURCE';

export default function PreloadingVideoPlayerScreen() {
  const player1 = useVideoPlayer(bigBuckBunnySource, player =&gt; {
    // Optional: You can perform actions when the player is ready
    // player.play();
  });
  const player2 = useVideoPlayer(elephantsDreamSource, player =&gt; {
    // Optional: You can perform actions when the player is ready
    // player.currentTime = 20;
  });

  const [currentPlayer, setCurrentPlayer] = useState(player1);

  const replacePlayer = useCallback(() =&gt; { // Removed async as it's not needed for pause/play
    if (currentPlayer) {
      currentPlayer.pause();
    }
    if (currentPlayer === player1) {
      setCurrentPlayer(player2);
      player2?.play(); // Use optional chaining in case player2 is null/undefined
    } else {
      setCurrentPlayer(player1);
      player1?.play(); // Use optional chaining
    }
  }, [player1, player2, currentPlayer]); // Added player2 to dependencies

  return (
    &lt;View style={styles.contentContainer}&gt;
      &lt;VideoView player={currentPlayer} style={styles.video} nativeControls={false} /&gt;
      &lt;TouchableOpacity style={styles.button} onPress={replacePlayer}&gt;
        &lt;Text style={styles.buttonText}&gt;Replace Player&lt;/Text&gt;
      &lt;/TouchableOpacity&gt;
    &lt;/View&gt;
  );
}

// Assume styles object is defined elsewhere
const styles = StyleSheet.create({
  contentContainer: { flex: 1, justifyContent: 'center', alignItems: 'center' },
  video: { width: 300, height: 200 },
  button: { marginTop: 20, padding: 10, backgroundColor: 'lightblue' },
  buttonText: { color: 'white' },
});
</code></pre>
<ul>
<li>
<p><code>useVideoPlayer</code> hook quản lý playback.</p>
</li>
<li>
<p><code>VideoView</code> component hiển thị video.</p>
</li>
<li>
<p><code>VideoSource</code> đại diện cho nguồn video.</p>
</li>
<li>
<p><strong>Sử dụng VideoPlayer trực tiếp (<code>createVideoPlayer</code>):</strong>
Trong các trường hợp nâng cao, có thể tạo <code>VideoPlayer</code> mà không tự động hủy khi component unmount. Cần gọi <code>release()</code> thủ công để tránh rò rò bộ nhớ.</p>
</li>
</ul>
<pre><code class="language-javascript">import { createVideoPlayer, VideoSource } from 'expo-video';

// Assume videoSource is defined
const videoSource: VideoSource = 'YOUR_VIDEO_SOURCE';

const player = createVideoPlayer(videoSource);
// Remember to call player.release() when the player is no longer needed
</code></pre>
<ul>
<li>
<p><strong>Nhận các sự kiện (Receiving events):</strong>
Các thay đổi trong <code>VideoPlayer</code> không cập nhật state React. Cần lắng nghe các sự kiện mà nó phát ra.</p>
<ul>
<li><code>useEvent</code> hook: Tạo listener trả về giá trị stateful. Tự động dọn dẹp khi component unmount.</li>
</ul>
<pre><code class="language-javascript">import { useEvent } from 'expo';
// ... Other imports, definition of the component, creating the player etc.
// Assuming 'player' is a VideoPlayer instance
const { status, error } = useEvent(player, 'statusChange', {
  status: player.status
});
// Rest of the component...
</code></pre>
<ul>
<li><code>useEventListener</code> hook: Tạo event listener với tự động dọn dẹp.</li>
</ul>
<pre><code class="language-javascript">import { useEventListener } from 'expo';
import { useState } from 'react'; // Import useState
import { View, Text } from 'react-native'; // Import necessary components

// ...Other imports, definition of the component, creating the player etc.
// Assuming 'player' is a VideoPlayer instance passed as prop
export default function MyVideoComponent({ player }) {
  const [playerStatus, setPlayerStatus] = useState(null);
  const [playerError, setPlayerError] = useState(null);

  useEventListener(player, 'statusChange', ({ status, error }) =&gt; {
    setPlayerStatus(status);
    setPlayerError(error);
    console.log('Player status changed: ', status);
  });

  // Rest of the component...
  return (
    &lt;View&gt;
      &lt;Text&gt;Player Status: {playerStatus}&lt;/Text&gt;
      {playerError &amp;&amp; playerError.message &amp;&amp; &lt;Text&gt;Player Error: {playerError.message}&lt;/Text&gt;} {/* Added check for playerError.message */}
      {/* Render VideoView or other UI */}
    &lt;/View&gt;
  );
}
</code></pre>
<ul>
<li><code>Player.addListener</code> method: Cách linh hoạt nhất nhưng yêu cầu dọn dẹp thủ công.</li>
</ul>
<pre><code class="language-javascript">import { useEffect, useState } from 'react'; // Import useEffect and useState
import { View, Text } from 'react-native'; // Import necessary components

// ...Imports, definition of the component, creating the player etc.
// Assuming 'player' is a VideoPlayer instance passed as prop
export default function AnotherVideoComponent({ player }) {
  const [playerStatus, setPlayerStatus] = useState(null);
  const [playerError, setPlayerError] = useState(null);

  useEffect(() =&gt; {
    const subscription = player.addListener('statusChange', ({ status, error }) =&gt; {
      setPlayerStatus(status);
      setPlayerError(error);
      console.log('Player status changed: ', status);
    });

    return () =&gt; {
      subscription.remove();
    };
  }, [player]); // Add player to dependencies

  // Rest of the component...
  return (
    &lt;View&gt;
      &lt;Text&gt;Player Status: {playerStatus}&lt;/Text&gt;
      {playerError &amp;&amp; playerError.message &amp;&amp; &lt;Text&gt;Player Error: {playerError.message}&lt;/Text&gt;} {/* Added check for playerError.message */}
      {/* Render VideoView or other UI */}
    &lt;/View&gt;
  );
}
</code></pre>
</li>
</ul>
<h3 id="expo-camera"><a class="header" href="#expo-camera">Expo Camera</a></h3>
<p><code>expo-camera</code> cung cấp một component React hiển thị bản xem trước của camera trước hoặc sau của thiết bị.</p>
<ul>
<li><strong>Cài đặt:</strong></li>
</ul>
<pre><code class="language-bash">npx expo install expo-camera
</code></pre>
<ul>
<li><strong>Cấu hình trong <code>app.json</code> (với plugin):</strong></li>
</ul>
<pre><code class="language-json">&quot;expo&quot;: {
  &quot;plugins&quot;: [
    [
      &quot;expo-camera&quot;,
      {
        &quot;cameraPermission&quot;: &quot;Allow $(PRODUCT_NAME) to access your camera&quot;,
        &quot;microphonePermission&quot;: &quot;Allow $(PRODUCT_NAME) to access your microphone&quot;,
        &quot;recordAudioAndroid&quot;: true
      }
    ]
  ]
}
</code></pre>
<ul>
<li>
<p><strong>Permissions:</strong></p>
<ul>
<li><strong>Android:</strong> Cần thêm quyền <code>CAMERA</code> và <code>RECORD_AUDIO</code> (nếu quay video có âm thanh) vào <code>app.json</code>.</li>
</ul>
</li>
</ul>
<pre><code class="language-json">    &quot;android&quot;: {
      &quot;permissions&quot;: [
        &quot;CAMERA&quot;,
        &quot;RECORD_AUDIO&quot;
      ]
    },
</code></pre>
<ul>
<li>
<p><strong>iOS:</strong> Cần khai báo <code>NSCameraUsageDescription</code> và <code>NSMicrophoneUsageDescription</code> trong <code>app.json</code> để hiển thị thông báo quyền cho người dùng.</p>
</li>
<li>
<p><strong>Sử dụng Expo Camera:</strong>
Ứng dụng sử dụng Expo Camera cho phép mở/đóng camera, chuyển đổi giữa camera trước/sau, và yêu cầu quyền camera.</p>
<ul>
<li><strong>Import:</strong></li>
</ul>
</li>
</ul>
<pre><code class="language-javascript">import { CameraView, CameraType, useCameraPermissions } from 'expo-camera';
import { useState } from 'react'; // Import useState
import { View, Text, Button, TouchableOpacity, StyleSheet } from 'react-native'; // Import necessary components
</code></pre>
<ul>
<li><strong>Khởi tạo State:</strong></li>
</ul>
<pre><code class="language-javascript">const [facing, setFacing] = useState('back'); // 'back' or 'front'
const [cameraActive, setCameraActive] = useState(false);
const [permission, requestPermission] = useCameraPermissions();
</code></pre>
<ul>
<li><strong>Xử lý quyền:</strong></li>
</ul>
<pre><code class="language-javascript">import { useCameraPermissions } from 'expo-camera';
import { View, Text, Button, StyleSheet } from 'react-native'; // Import necessary components

// Assume styles object is defined elsewhere
const styles = StyleSheet.create({
  container: { flex: 1, justifyContent: 'center', alignItems: 'center' },
  message: { textAlign: 'center', paddingBottom: 10 },
});


function CameraPermissionHandler() { // Example component
  const [permission, requestPermission] = useCameraPermissions();

  if (!permission) {
    // Camera permissions are still loading.
    return &lt;View /&gt;;
  }
  if (!permission.granted) {
    // Camera permissions are not granted yet.
    return (
      &lt;View style={styles.container}&gt;
        &lt;Text style={styles.message}&gt;We need your permission to show the camera&lt;/Text&gt;
        &lt;Button onPress={requestPermission} title=&quot;Grant Permission&quot; /&gt;
      &lt;/View&gt;
    );
  }

  // If permission is granted, you can render the camera controls or CameraView here
  return &lt;View&gt;{/* Render camera controls or CameraView */}&lt;/View&gt;;
}

export default CameraPermissionHandler; // Export the component
</code></pre>
<ul>
<li><strong>Hàm lật Camera:</strong></li>
</ul>
<pre><code class="language-javascript">import { useState } from 'react'; // Import useState
import { CameraType } from 'expo-camera'; // Import CameraType

function useCameraToggle() { // Custom hook for camera state
  const [facing, setFacing] = useState&lt;CameraType&gt;('back'); // Use CameraType for type safety

  const toggleCameraFacing = () =&gt; {
    setFacing((current) =&gt; (current === 'back' ? 'front' : 'back'));
  };

  return { facing, toggleCameraFacing };
}

// Usage in a component:
// const { facing, toggleCameraFacing } = useCameraToggle();
</code></pre>
<ul>
<li><strong>Hàm bật/tắt Camera:</strong></li>
</ul>
<pre><code class="language-javascript">import { useState } from 'react'; // Import useState

function useCameraActive() { // Custom hook for camera active state
  const [cameraActive, setCameraActive] = useState(false);

  const toggleCamera = () =&gt; {
    setCameraActive((current) =&gt; !current);
  };

  return { cameraActive, toggleCamera };
}

// Usage in a component:
// const { cameraActive, toggleCamera } = useCameraActive();
</code></pre>
<ul>
<li><strong>Render CameraView có điều kiện:</strong></li>
</ul>
<pre><code class="language-javascript">import { CameraView, CameraType } from 'expo-camera';
import { View, StyleSheet } from 'react-native'; // Import necessary components

// Assume cameraActive and facing states are managed elsewhere
// Assume styles object is defined elsewhere

const styles = StyleSheet.create({
  camera: { flex: 1 }, // Example style
});

function CameraRenderer({ cameraActive, facing }) { // Example component to render camera
  return (
    &lt;&gt; {/* Use a Fragment */}
      {cameraActive &amp;&amp; (
        &lt;CameraView style={styles.camera} facing={facing}&gt;
          {/* ... các controls hoặc overlay khác bên trong camera view */}
        &lt;/CameraView&gt;
      )}
    &lt;/&gt;
  );
}
</code></pre>
<ul>
<li><code>cameraActive</code> điều khiển việc hiển thị CameraView.</li>
<li><code>style={styles.camera}</code> áp dụng kiểu dáng.</li>
<li><code>facing={facing}</code> đặt camera trước hoặc sau.</li>
</ul>
<p><strong>Nút lật Camera (hoặc đóng Camera tùy thuộc vào logic đầy đủ):</strong></p>
<pre><code class="language-javascript">import { TouchableOpacity, Text, StyleSheet } from 'react-native'; // Import necessary components
// Assume toggleCameraFacing or toggleCamera function is available in the component's scope
// Assume styles object is defined elsewhere

const styles = StyleSheet.create({
  button: { /* button styles */ },
  text: { /* text styles */ },
});


function CameraControlButton({ onPress, title }) { // Reusable button component
  return (
    &lt;TouchableOpacity style={styles.button} onPress={onPress}&gt;
      &lt;Text style={styles.text}&gt;{title}&lt;/Text&gt;
    &lt;/TouchableOpacity&gt;
  );
}

// Usage in a component:
// &lt;CameraControlButton onPress={toggleCameraFacing} title=&quot;Flip Camera&quot; /&gt;
// &lt;CameraControlButton onPress={toggleCamera} title=&quot;Close Camera&quot; /&gt;
</code></pre>
<ul>
<li><code>TouchableOpacity</code> tạo nút có phản hồi chạm.</li>
<li><code>onPress</code> gọi hàm xử lý sự kiện.</li>
</ul>
<p><strong>Nút mở Camera (hiển thị khi Camera không hoạt động):</strong></p>
<pre><code class="language-javascript">import { Button } from 'react-native'; // Import Button
// Assume cameraActive and toggleCamera function is available in the component's scope

function OpenCameraButton({ cameraActive, toggleCamera }) { // Example component
  return (
    &lt;&gt; {/* Use a Fragment */}
      {!cameraActive &amp;&amp; (
        &lt;Button title=&quot;Open Camera&quot; onPress={toggleCamera} /&gt;
      )}
    &lt;/&gt;
  );
}
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../react/index.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../bash/tong-hop.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../react/index.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../bash/tong-hop.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
