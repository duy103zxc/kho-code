<!DOCTYPE HTML>
<html lang="vi" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Kho code của duykhanh471</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> Trang chủ dự án</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.</strong> HTML/CSS/JS</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="html-css/index.html"><strong aria-hidden="true">2.1.</strong> HTML/CSS</a></li><li class="chapter-item expanded "><a href="js/index.html"><strong aria-hidden="true">2.2.</strong> JS</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="js/co-ban.html"><strong aria-hidden="true">2.2.1.</strong> Cơ bản</a></li><li class="chapter-item expanded "><a href="js/array.html"><strong aria-hidden="true">2.2.2.</strong> Array</a></li><li class="chapter-item expanded "><a href="js/ngay-gio.html"><strong aria-hidden="true">2.2.3.</strong> Ngày giờ</a></li><li class="chapter-item expanded "><a href="js/string.html"><strong aria-hidden="true">2.2.4.</strong> String</a></li><li class="chapter-item expanded "><a href="js/object.html"><strong aria-hidden="true">2.2.5.</strong> Object</a></li></ol></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.</strong> Java</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="java/1.html"><strong aria-hidden="true">3.1.</strong> Giới thiệu Java, JVM</a></li><li class="chapter-item expanded "><a href="java/2.html"><strong aria-hidden="true">3.2.</strong> Biến, phạm vi, kiểu dữ liệu, toán tử trong Java</a></li><li class="chapter-item expanded "><a href="java/3.html"><strong aria-hidden="true">3.3.</strong> Hàm và câu lệnh điều kiện</a></li><li class="chapter-item expanded "><a href="java/4.html"><strong aria-hidden="true">3.4.</strong> Nhập xuất dữ liệu trong Java</a></li><li class="chapter-item expanded "><a href="java/5.html"><strong aria-hidden="true">3.5.</strong> Vì sao nên sử dụng StringBuffer</a></li><li class="chapter-item expanded "><a href="java/6.html"><strong aria-hidden="true">3.6.</strong> Hướng dẫn Java Reflection</a></li><li class="chapter-item expanded "><a href="java/7.html"><strong aria-hidden="true">3.7.</strong> Hướng dẫn tự tạo một Annotations</a></li><li class="chapter-item expanded "><a href="java/8.html"><strong aria-hidden="true">3.8.</strong> Functional Interfaces & Lambda Expressions cực dễ hiểu</a></li><li class="chapter-item expanded "><a href="java/9.html"><strong aria-hidden="true">3.9.</strong> Hướng dẫn Stream API</a></li><li class="chapter-item expanded "><a href="java/10.html"><strong aria-hidden="true">3.10.</strong> Khái niệm ThreadPool và Executor trong Java</a></li><li class="chapter-item expanded "><a href="java/11.html"><strong aria-hidden="true">3.11.</strong> ThreadPoolExecutor và nguyên tắc quản lý pool size</a></li><li class="chapter-item expanded "><a href="java/12.html"><strong aria-hidden="true">3.12.</strong> Giới thiệu Reactive Programming với Reactor</a></li><li class="chapter-item expanded "><a href="java/13.html"><strong aria-hidden="true">3.13.</strong> Giới thiệu Reactor Core</a></li><li class="chapter-item expanded "><a href="java/14.html"><strong aria-hidden="true">3.14.</strong> Abstract Interface</a></li><li class="chapter-item expanded "><a href="java/15.html"><strong aria-hidden="true">3.15.</strong> Thread</a></li><li class="chapter-item expanded "><a href="java/16.html"><strong aria-hidden="true">3.16.</strong> Optional</a></li><li class="chapter-item expanded "><a href="java/snippets/index.html"><strong aria-hidden="true">3.17.</strong> Kho snippets</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="java/snippets/algorithms.html"><strong aria-hidden="true">3.17.1.</strong> Algorithms</a></li><li class="chapter-item expanded "><a href="java/snippets/array.html"><strong aria-hidden="true">3.17.2.</strong> Array</a></li><li class="chapter-item expanded "><a href="java/snippets/cls.html"><strong aria-hidden="true">3.17.3.</strong> CLS</a></li><li class="chapter-item expanded "><a href="java/snippets/date.html"><strong aria-hidden="true">3.17.4.</strong> Date</a></li><li class="chapter-item expanded "><a href="java/snippets/encoding.html"><strong aria-hidden="true">3.17.5.</strong> Encoding & Decoding</a></li><li class="chapter-item expanded "><a href="java/snippets/file.html"><strong aria-hidden="true">3.17.6.</strong> File</a></li><li class="chapter-item expanded "><a href="java/snippets/io.html"><strong aria-hidden="true">3.17.7.</strong> IO</a></li><li class="chapter-item expanded "><a href="java/snippets/math.html"><strong aria-hidden="true">3.17.8.</strong> Math</a></li><li class="chapter-item expanded "><a href="java/snippets/media.html"><strong aria-hidden="true">3.17.9.</strong> Media</a></li><li class="chapter-item expanded "><a href="java/snippets/network.html"><strong aria-hidden="true">3.17.10.</strong> Network</a></li><li class="chapter-item expanded "><a href="java/snippets/string.html"><strong aria-hidden="true">3.17.11.</strong> String</a></li><li class="chapter-item expanded "><a href="java/snippets/thread.html"><strong aria-hidden="true">3.17.12.</strong> Thread</a></li></ol></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.</strong> Spring Boot</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="spring-boot/index.html"><strong aria-hidden="true">4.1.</strong> Trang chủ khóa học</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.2.</strong> Core</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="spring-boot/core1.html"><strong aria-hidden="true">4.2.1.</strong> Khái niệm tight-coupling (liên kết ràng buộc) và cách loosely coupled</a></li><li class="chapter-item expanded "><a href="spring-boot/core2.html"><strong aria-hidden="true">4.2.2.</strong> Giải thích Dependency Injection (DI) và IoC</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.3.</strong> Spring Boot</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="spring-boot/sb1.html"><strong aria-hidden="true">4.3.1.</strong> Hướng dẫn @Component và @Autowired</a></li><li class="chapter-item expanded "><a href="spring-boot/sb2.html"><strong aria-hidden="true">4.3.2.</strong> @Autowired - @Primary - @Qualifier</a></li><li class="chapter-item expanded "><a href="spring-boot/sb3.html"><strong aria-hidden="true">4.3.3.</strong> Spring Bean Life Cycle + @PostConstruct và @PreDestroy</a></li><li class="chapter-item expanded "><a href="spring-boot/sb4.html"><strong aria-hidden="true">4.3.4.</strong> @Component vs @Service vs @Repository</a></li><li class="chapter-item expanded "><a href="spring-boot/sb5.html"><strong aria-hidden="true">4.3.5.</strong> Component Scan là gì?</a></li><li class="chapter-item expanded "><a href="spring-boot/sb6.html"><strong aria-hidden="true">4.3.6.</strong> @Configuration và @Bean</a></li><li class="chapter-item expanded "><a href="spring-boot/sb7.html"><strong aria-hidden="true">4.3.7.</strong> Spring Boot Application Config và @Value</a></li><li class="chapter-item expanded "><a href="spring-boot/sb8.html"><strong aria-hidden="true">4.3.8.</strong> Tạo Web Helloworld với @Controller + Thymeleaf</a></li><li class="chapter-item expanded "><a href="spring-boot/sb9.html"><strong aria-hidden="true">4.3.9.</strong> Giải thích cách Thymeleaf vận hành + Expression + Demo Full</a></li><li class="chapter-item expanded "><a href="spring-boot/sb10.html"><strong aria-hidden="true">4.3.10.</strong> @RequestMapping + @PostMapping + @ModelAttribute + @RequestParam + Web To-Do với Thymeleaf</a></li><li class="chapter-item expanded "><a href="spring-boot/sb11.html"><strong aria-hidden="true">4.3.11.</strong> Hướng dẫn Spring Boot JPA + MySQL</a></li><li class="chapter-item expanded "><a href="spring-boot/sb12.html"><strong aria-hidden="true">4.3.12.</strong> Spring JPA Method + @Query</a></li><li class="chapter-item expanded "><a href="spring-boot/sb13.html"><strong aria-hidden="true">4.3.13.</strong> Chi tiết Spring Boot + Thymeleaf + MySQL + i18n + Web Demo</a></li><li class="chapter-item expanded "><a href="spring-boot/sb14.html"><strong aria-hidden="true">4.3.14.</strong> Restful API + @RestController + @PathVariable + @RequestBody</a></li><li class="chapter-item expanded "><a href="spring-boot/sb15.html"><strong aria-hidden="true">4.3.15.</strong> Exception Handling @ExceptionHandler + @RestControllerAdvice / @ControllerAdvice + @ResponseStatus</a></li><li class="chapter-item expanded "><a href="spring-boot/sb16.html"><strong aria-hidden="true">4.3.16.</strong> Hướng dẫn sử dụng @ConfigurationPropertie</a></li><li class="chapter-item expanded "><a href="spring-boot/sb17.html"><strong aria-hidden="true">4.3.17.</strong> Chạy nhiều môi trường với Spring Profile</a></li><li class="chapter-item expanded "><a href="spring-boot/sb18.html"><strong aria-hidden="true">4.3.18.</strong> Hướng dẫn chi tiết Test Spring Boot</a></li><li class="chapter-item expanded "><a href="spring-boot/sb19.html"><strong aria-hidden="true">4.3.19.</strong> Hướng dẫn chi tiết Test Spring Boot (Phần 2)</a></li><li class="chapter-item expanded "><a href="spring-boot/sb20.html"><strong aria-hidden="true">4.3.20.</strong> Hướng dẫn toàn tập Mockito</a></li><li class="chapter-item expanded "><a href="spring-boot/sb21.html"><strong aria-hidden="true">4.3.21.</strong> Hướng dẫn tạo Bean có điều kiện với @Conditional</a></li><li class="chapter-item expanded "><a href="spring-boot/sb22.html"><strong aria-hidden="true">4.3.22.</strong> Hướng dẫn tự tạo custom @Conditional</a></li><li class="chapter-item expanded "><a href="spring-boot/sb23.html"><strong aria-hidden="true">4.3.23.</strong> Xử lý sự kiện với @EventListener + @Async</a></li><li class="chapter-item expanded "><a href="spring-boot/sb24.html"><strong aria-hidden="true">4.3.24.</strong> RESTful API Document Tạo với Spring Boot + Swagger</a></li><li class="chapter-item expanded "><a href="spring-boot/sb25.html"><strong aria-hidden="true">4.3.25.</strong> RESTful API Document với Spring Boot + OpenApi 3.0</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.4.</strong> Jpa</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="spring-boot/jpa1.html"><strong aria-hidden="true">4.4.1.</strong> 「Jpa」Hibernate là gì?</a></li><li class="chapter-item expanded "><a href="spring-boot/jpa2.html"><strong aria-hidden="true">4.4.2.</strong> 「Jpa」Hướng dẫn sử dụng Specification (Phần 1)</a></li><li class="chapter-item expanded "><a href="spring-boot/jpa3.html"><strong aria-hidden="true">4.4.3.</strong> 「Jpa」Hướng dẫn sử dụng @OneToOne</a></li><li class="chapter-item expanded "><a href="spring-boot/jpa4.html"><strong aria-hidden="true">4.4.4.</strong> 「Jpa」@OneToMany và @ManyToOne</a></li><li class="chapter-item expanded "><a href="spring-boot/jpa5.html"><strong aria-hidden="true">4.4.5.</strong> 「Jpa」Hướng dẫn @ManyToMany</a></li><li class="chapter-item expanded "><a href="spring-boot/jpa6.html"><strong aria-hidden="true">4.4.6.</strong> 「Jpa」Hướng dẫn Query phân trang bằng Pageable (Phần 1)</a></li><li class="chapter-item expanded "><a href="spring-boot/jpa7.html"><strong aria-hidden="true">4.4.7.</strong> 「Jpa」Hướng dẫn sử dụng Criteria API trong Hibernate</a></li><li class="chapter-item expanded "><a href="spring-boot/jpa8.html"><strong aria-hidden="true">4.4.8.</strong> 「Jpa」Hướng dẫn sử dụng Criteria API trong Hibernate (Phần 2)</a></li><li class="chapter-item expanded "><a href="spring-boot/jpa9.html"><strong aria-hidden="true">4.4.9.</strong> 「Jpa」Hướng dẫn tự tạo Validator để kiểm tra Model & Entity</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.5.</strong> Spring Security</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="spring-boot/ss1.html"><strong aria-hidden="true">4.5.1.</strong> 「SS」Hướng dẫn Spring Security cơ bản, dễ hiểu</a></li><li class="chapter-item expanded "><a href="spring-boot/ss2.html"><strong aria-hidden="true">4.5.2.</strong> 「SS」Hướng dẫn Spring Security + Jpa Hibernate</a></li><li class="chapter-item expanded "><a href="spring-boot/ss3.html"><strong aria-hidden="true">4.5.3.</strong> 「SS」Hướng dẫn Spring Security + JWT (Json Web Token) + Hibernate</a></li></ol></li><li class="chapter-item expanded "><a href="spring-boot/redis.html"><strong aria-hidden="true">4.6.</strong> Redis</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.</strong> Rust</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="rust/thuat-toan.html"><strong aria-hidden="true">5.1.</strong> Thuật toán</a></li><li class="chapter-item expanded "><a href="rust/command-line.html"><strong aria-hidden="true">5.2.</strong> CLI</a></li><li class="chapter-item expanded "><a href="rust/he-thong.html"><strong aria-hidden="true">5.3.</strong> System</a></li><li class="chapter-item expanded "><a href="rust/internet.html"><strong aria-hidden="true">5.4.</strong> Internet</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.5.</strong> Tệp</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="rust/tep/epub.html"><strong aria-hidden="true">5.5.1.</strong> EPUB</a></li><li class="chapter-item expanded "><a href="rust/tep/git.html"><strong aria-hidden="true">5.5.2.</strong> Git</a></li><li class="chapter-item expanded "><a href="rust/tep/html.html"><strong aria-hidden="true">5.5.3.</strong> HTML</a></li><li class="chapter-item expanded "><a href="rust/tep/rss.html"><strong aria-hidden="true">5.5.4.</strong> RSS</a></li></ol></li><li class="chapter-item expanded "><a href="rust/essentials/intro.html"><strong aria-hidden="true">5.6.</strong> Essentials</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="rust/essentials/core-concepts/intro.html"><strong aria-hidden="true">5.6.1.</strong> Core Concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="rust/essentials/core-concepts/function.html"><strong aria-hidden="true">5.6.1.1.</strong> Functions</a></li><li class="chapter-item expanded "><a href="rust/essentials/core-concepts/flow-control.html"><strong aria-hidden="true">5.6.1.2.</strong> Flow Control</a></li><li class="chapter-item expanded "><a href="rust/essentials/core-concepts/pattern-matching.html"><strong aria-hidden="true">5.6.1.3.</strong> Pattern Matching</a></li><li class="chapter-item expanded "><a href="rust/essentials/core-concepts/closure.html"><strong aria-hidden="true">5.6.1.4.</strong> Closures</a></li><li class="chapter-item expanded "><a href="rust/essentials/core-concepts/ownership.html"><strong aria-hidden="true">5.6.1.5.</strong> Ownership</a></li><li class="chapter-item expanded "><a href="rust/essentials/core-concepts/borrow.html"><strong aria-hidden="true">5.6.1.6.</strong> Borrow</a></li><li class="chapter-item expanded "><a href="rust/essentials/core-concepts/macro.html"><strong aria-hidden="true">5.6.1.7.</strong> Macros</a></li><li class="chapter-item expanded "><a href="rust/essentials/core-concepts/concurency.html"><strong aria-hidden="true">5.6.1.8.</strong> Concurency</a></li><li class="chapter-item expanded "><a href="rust/essentials/core-concepts/error-handling.html"><strong aria-hidden="true">5.6.1.9.</strong> Error Handling</a></li><li class="chapter-item expanded "><a href="rust/essentials/core-concepts/lifetime.html"><strong aria-hidden="true">5.6.1.10.</strong> Lifetime</a></li><li class="chapter-item expanded "><a href="rust/essentials/core-concepts/module.html"><strong aria-hidden="true">5.6.1.11.</strong> Modules</a></li><li class="chapter-item expanded "><a href="rust/essentials/core-concepts/crate.html"><strong aria-hidden="true">5.6.1.12.</strong> Crates</a></li></ol></li><li class="chapter-item expanded "><a href="rust/essentials/types/intro.html"><strong aria-hidden="true">5.6.2.</strong> Types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="rust/essentials/types/scalar.html"><strong aria-hidden="true">5.6.2.1.</strong> Scalar Types</a></li><li class="chapter-item expanded "><a href="rust/essentials/types/compound.html"><strong aria-hidden="true">5.6.2.2.</strong> Compound Types</a></li><li class="chapter-item expanded "><a href="rust/essentials/types/trait.html"><strong aria-hidden="true">5.6.2.3.</strong> Traits</a></li><li class="chapter-item expanded "><a href="rust/essentials/types/struct.html"><strong aria-hidden="true">5.6.2.4.</strong> Structs</a></li><li class="chapter-item expanded "><a href="rust/essentials/types/enum.html"><strong aria-hidden="true">5.6.2.5.</strong> Enums</a></li><li class="chapter-item expanded "><a href="rust/essentials/types/struct-vs-enum.html"><strong aria-hidden="true">5.6.2.6.</strong> Structs vs Enums</a></li><li class="chapter-item expanded "><a href="rust/essentials/types/generic.html"><strong aria-hidden="true">5.6.2.7.</strong> Generics</a></li><li class="chapter-item expanded "><a href="rust/essentials/types/type-alias.html"><strong aria-hidden="true">5.6.2.8.</strong> Type Alias</a></li><li class="chapter-item expanded "><a href="rust/essentials/types/pointer.html"><strong aria-hidden="true">5.6.2.9.</strong> Pointers</a></li><li class="chapter-item expanded "><a href="rust/essentials/types/vector.html"><strong aria-hidden="true">5.6.2.10.</strong> Vectors</a></li></ol></li><li class="chapter-item expanded "><a href="rust/essentials/operators/intro.html"><strong aria-hidden="true">5.6.3.</strong> Operators</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="rust/essentials/operators/arithmetic-operations.html"><strong aria-hidden="true">5.6.3.1.</strong> Arithmetic Operations</a></li><li class="chapter-item expanded "><a href="rust/essentials/operators/comparison-operations.html"><strong aria-hidden="true">5.6.3.2.</strong> Comparison Operators</a></li><li class="chapter-item expanded "><a href="rust/essentials/operators/logical-operations.html"><strong aria-hidden="true">5.6.3.3.</strong> Logical Operators</a></li><li class="chapter-item expanded "><a href="rust/essentials/operators/bitwise-operations.html"><strong aria-hidden="true">5.6.3.4.</strong> Bitwise Operators</a></li><li class="chapter-item expanded "><a href="rust/essentials/operators/assignement-operations.html"><strong aria-hidden="true">5.6.3.5.</strong> Assignment Operators</a></li></ol></li><li class="chapter-item expanded "><a href="rust/essentials/packaging/intro.html"><strong aria-hidden="true">5.6.4.</strong> Packaging</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="rust/essentials/packaging/no-std.html"><strong aria-hidden="true">5.6.4.1.</strong> ![no_std] Attribute</a></li><li class="chapter-item expanded "><a href="rust/essentials/packaging/modules.html"><strong aria-hidden="true">5.6.4.2.</strong> Requiring Modules</a></li><li class="chapter-item expanded "><a href="rust/essentials/packaging/package-names.html"><strong aria-hidden="true">5.6.4.3.</strong> Package Names</a></li><li class="chapter-item expanded "><a href="rust/essentials/packaging/crates-tag.html"><strong aria-hidden="true">5.6.4.4.</strong> Tag your Crate</a></li><li class="chapter-item expanded "><a href="rust/essentials/packaging/feature-attribute.html"><strong aria-hidden="true">5.6.4.5.</strong> Feature Attribute</a></li><li class="chapter-item expanded "><a href="rust/essentials/packaging/features-compilation.html"><strong aria-hidden="true">5.6.4.6.</strong> Features Compilation</a></li></ol></li><li class="chapter-item expanded "><a href="rust/essentials/std-lib/intro.html"><strong aria-hidden="true">5.6.5.</strong> Standard Library</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="rust/essentials/std-lib/refcell.html"><strong aria-hidden="true">5.6.5.1.</strong> RefCell Struct</a></li><li class="chapter-item expanded "><a href="rust/essentials/std-lib/rc.html"><strong aria-hidden="true">5.6.5.2.</strong> Rc Type</a></li><li class="chapter-item expanded "><a href="rust/essentials/std-lib/self-as-type.html"><strong aria-hidden="true">5.6.5.3.</strong> Self Type</a></li><li class="chapter-item expanded "><a href="rust/essentials/std-lib/self-vs-self.html"><strong aria-hidden="true">5.6.5.4.</strong> Self vs self</a></li><li class="chapter-item expanded "><a href="rust/essentials/std-lib/self.html"><strong aria-hidden="true">5.6.5.5.</strong> self Keyword</a></li><li class="chapter-item expanded "><a href="rust/essentials/std-lib/imp.html"><strong aria-hidden="true">5.6.5.6.</strong> imp Keyword</a></li><li class="chapter-item expanded "><a href="rust/essentials/std-lib/new.html"><strong aria-hidden="true">5.6.5.7.</strong> new Keyword</a></li><li class="chapter-item expanded "><a href="rust/essentials/std-lib/some.html"><strong aria-hidden="true">5.6.5.8.</strong> Some Keyword</a></li><li class="chapter-item expanded "><a href="rust/essentials/std-lib/option.html"><strong aria-hidden="true">5.6.5.9.</strong> Option Enum</a></li><li class="chapter-item expanded "><a href="rust/essentials/std-lib/drive(debug).html"><strong aria-hidden="true">5.6.5.10.</strong> #[derive(Debug)]</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="rust/patterns/intro.html"><strong aria-hidden="true">5.7.</strong> Patterns</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="rust/patterns/creational/intro.html"><strong aria-hidden="true">5.7.1.</strong> Creational</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="rust/patterns/creational/singleton.html"><strong aria-hidden="true">5.7.1.1.</strong> Singleton</a></li><li class="chapter-item expanded "><a href="rust/patterns/creational/factory-method.html"><strong aria-hidden="true">5.7.1.2.</strong> Factory Method</a></li><li class="chapter-item expanded "><a href="rust/patterns/creational/abstract-method.html"><strong aria-hidden="true">5.7.1.3.</strong> Abstract Factory</a></li><li class="chapter-item expanded "><a href="rust/patterns/creational/builder.html"><strong aria-hidden="true">5.7.1.4.</strong> Builder</a></li><li class="chapter-item expanded "><a href="rust/patterns/creational/prototype.html"><strong aria-hidden="true">5.7.1.5.</strong> Prototype</a></li></ol></li><li class="chapter-item expanded "><a href="rust/patterns/behavioral/intro.html"><strong aria-hidden="true">5.7.2.</strong> Behavioral</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="rust/patterns/behavioral/observer.html"><strong aria-hidden="true">5.7.2.1.</strong> Observer</a></li><li class="chapter-item expanded "><a href="rust/patterns/behavioral/strategy.html"><strong aria-hidden="true">5.7.2.2.</strong> Strategy</a></li><li class="chapter-item expanded "><a href="rust/patterns/behavioral/command.html"><strong aria-hidden="true">5.7.2.3.</strong> Command</a></li><li class="chapter-item expanded "><a href="rust/patterns/behavioral/chain-of-responsibility.html"><strong aria-hidden="true">5.7.2.4.</strong> Chain of Responsibility</a></li><li class="chapter-item expanded "><a href="rust/patterns/behavioral/iterator.html"><strong aria-hidden="true">5.7.2.5.</strong> Iterator</a></li><li class="chapter-item expanded "><a href="rust/patterns/behavioral/mediator.html"><strong aria-hidden="true">5.7.2.6.</strong> Mediator</a></li><li class="chapter-item expanded "><a href="rust/patterns/behavioral/visitor.html"><strong aria-hidden="true">5.7.2.7.</strong> Visitor</a></li></ol></li><li class="chapter-item expanded "><a href="rust/patterns/structural/intro.html"><strong aria-hidden="true">5.7.3.</strong> Structural</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="rust/patterns/structural/adapter.html"><strong aria-hidden="true">5.7.3.1.</strong> Adapter</a></li><li class="chapter-item expanded "><a href="rust/patterns/structural/bridge.html"><strong aria-hidden="true">5.7.3.2.</strong> Bridge</a></li><li class="chapter-item expanded "><a href="rust/patterns/structural/composite.html"><strong aria-hidden="true">5.7.3.3.</strong> Composite</a></li><li class="chapter-item expanded "><a href="rust/patterns/structural/decorator.html"><strong aria-hidden="true">5.7.3.4.</strong> Decorator</a></li><li class="chapter-item expanded "><a href="rust/patterns/structural/facade.html"><strong aria-hidden="true">5.7.3.5.</strong> Facade</a></li><li class="chapter-item expanded "><a href="rust/patterns/structural/flyweight.html"><strong aria-hidden="true">5.7.3.6.</strong> Flyweight</a></li><li class="chapter-item expanded "><a href="rust/patterns/structural/proxy.html"><strong aria-hidden="true">5.7.3.7.</strong> Proxy</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="rust/algorithms/intro.html"><strong aria-hidden="true">5.8.</strong> Algorithms</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="rust/algorithms/sorting/intro.html"><strong aria-hidden="true">5.8.1.</strong> Sorting</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="rust/algorithms/sorting/buble.html"><strong aria-hidden="true">5.8.1.1.</strong> Buble Sort</a></li><li class="chapter-item expanded "><a href="rust/algorithms/sorting/quick.html"><strong aria-hidden="true">5.8.1.2.</strong> Quick Sort</a></li><li class="chapter-item expanded "><a href="rust/algorithms/sorting/merge.html"><strong aria-hidden="true">5.8.1.3.</strong> Merge Sort</a></li><li class="chapter-item expanded "><a href="rust/algorithms/sorting/heap.html"><strong aria-hidden="true">5.8.1.4.</strong> Heap Sort</a></li><li class="chapter-item expanded "><a href="rust/algorithms/sorting/counting.html"><strong aria-hidden="true">5.8.1.5.</strong> Counting Sort</a></li></ol></li><li class="chapter-item expanded "><a href="rust/algorithms/searching/intro.html"><strong aria-hidden="true">5.8.2.</strong> Searching</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="rust/algorithms/searching/linear.html"><strong aria-hidden="true">5.8.2.1.</strong> Linear Search</a></li><li class="chapter-item expanded "><a href="rust/algorithms/searching/binary.html"><strong aria-hidden="true">5.8.2.2.</strong> Binary Search</a></li><li class="chapter-item expanded "><a href="rust/algorithms/searching/depth-first.html"><strong aria-hidden="true">5.8.2.3.</strong> DFS</a></li><li class="chapter-item expanded "><a href="rust/algorithms/searching/breadth-first.html"><strong aria-hidden="true">5.8.2.4.</strong> BFS</a></li></ol></li><li class="chapter-item expanded "><a href="rust/algorithms/graph/intro.html"><strong aria-hidden="true">5.8.3.</strong> Graph</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="rust/algorithms/graph/shortest-path.html"><strong aria-hidden="true">5.8.3.1.</strong> Dijkstra’s Algorithm</a></li><li class="chapter-item expanded "><a href="rust/algorithms/graph/minimum-spanning-tree.html"><strong aria-hidden="true">5.8.3.2.</strong> Kruskal’s Algorithm </a></li><li class="chapter-item expanded "><a href="rust/algorithms/graph/a-star.html"><strong aria-hidden="true">5.8.3.3.</strong> A* Algorithm </a></li><li class="chapter-item expanded "><a href="rust/algorithms/graph/all-pairs-shortest-path.html"><strong aria-hidden="true">5.8.3.4.</strong> Floyd-Warshall Algorithm</a></li></ol></li><li class="chapter-item expanded "><a href="rust/algorithms/dynamic-programming/intro.html"><strong aria-hidden="true">5.8.4.</strong> Dynamic Programming</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="rust/algorithms/dynamic-programming/knapsack-problem.html"><strong aria-hidden="true">5.8.4.1.</strong> Knapsack Problem</a></li><li class="chapter-item expanded "><a href="rust/algorithms/dynamic-programming/longest-common-subsequence.html"><strong aria-hidden="true">5.8.4.2.</strong> Longest Common Subsequence</a></li><li class="chapter-item expanded "><a href="rust/algorithms/dynamic-programming/matrix-chain-multiplication.html"><strong aria-hidden="true">5.8.4.3.</strong> Matrix Chain Multiplication</a></li><li class="chapter-item expanded "><a href="rust/algorithms/dynamic-programming/fibonacci.html"><strong aria-hidden="true">5.8.4.4.</strong> Fibonacci Sequence</a></li></ol></li><li class="chapter-item expanded "><a href="rust/algorithms/cryptographic/intro.html"><strong aria-hidden="true">5.8.5.</strong> Cryptography</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="rust/algorithms/cryptographic/rsa.html"><strong aria-hidden="true">5.8.5.1.</strong> RSA</a></li><li class="chapter-item expanded "><a href="rust/algorithms/cryptographic/aes.html"><strong aria-hidden="true">5.8.5.2.</strong> AES</a></li><li class="chapter-item expanded "><a href="rust/algorithms/cryptographic/sha-256.html"><strong aria-hidden="true">5.8.5.3.</strong> SHA-256</a></li><li class="chapter-item expanded "><a href="rust/algorithms/cryptographic/diffie-hellman.html"><strong aria-hidden="true">5.8.5.4.</strong> Diffie-Hellman</a></li><li class="chapter-item expanded "><a href="rust/algorithms/cryptographic/bcrypt.html"><strong aria-hidden="true">5.8.5.5.</strong> Bcrypt</a></li></ol></li></ol></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.</strong> React</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="react/bai-1.html"><strong aria-hidden="true">6.1.</strong> Bài 1</a></li><li class="chapter-item expanded "><a href="react/bai-2.html"><strong aria-hidden="true">6.2.</strong> Bài 2</a></li><li class="chapter-item expanded "><a href="react/bai-3.html"><strong aria-hidden="true">6.3.</strong> Bài 3</a></li></ol></li><li class="chapter-item expanded "><a href="react-native/index.html"><strong aria-hidden="true">7.</strong> React Native</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.</strong> TypeScript</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="ts/bai-1.html"><strong aria-hidden="true">8.1.</strong> Bài 1</a></li></ol></li><li class="chapter-item expanded "><a href="bash/tong-hop.html"><strong aria-hidden="true">9.</strong> Bash</a></li><li class="chapter-item expanded "><a href="regex/tong-hop.html"><strong aria-hidden="true">10.</strong> Regex</a></li><li class="chapter-item expanded "><a href="khac/yt-dlp.html"><strong aria-hidden="true">11.</strong> yt-dlp</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Kho code của duykhanh471</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="kho-lưu-code"><a class="header" href="#kho-lưu-code">Kho lưu code</a></h1>
<p>Đây là một kho lưu toàn bộ code snippets của nhiều ngôn ngữ mà mình có dịp sử dụng.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hướng-dẫn-học-htmlcss-khá-là-nhanh"><a class="header" href="#hướng-dẫn-học-htmlcss-khá-là-nhanh">Hướng dẫn học HTML/CSS khá là nhanh</a></h1>
<h2 id="phần-1-html"><a class="header" href="#phần-1-html">Phần 1: HTML</a></h2>
<h3 id="html-css-là-gì"><a class="header" href="#html-css-là-gì">HTML CSS là gì?</a></h3>
<p>HTML (HyperText Markup Language) là ngôn ngữ đánh dấu cấu trúc nội dung trang web, CSS (Cascading Style Sheets) là ngôn ngữ tạo kiểu dáng cho trang web. HTML tạo bộ khung, CSS trang trí bộ khung đó.</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Ví dụ HTML &amp; CSS&lt;/title&gt;
    &lt;style&gt;
        body {
            font-family: Arial, sans-serif;
            color: #333;
        }
        h1 {
            color: blue;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h1&gt;Đây là tiêu đề&lt;/h1&gt;
    &lt;p&gt;Đây là đoạn văn bản.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="cần-học-cách-sử-dụng-dev-tools"><a class="header" href="#cần-học-cách-sử-dụng-dev-tools">Cần học cách sử dụng Dev Tools</a></h3>
<p>Đọc/xem một trong những hướng dẫn dưới đây</p>
<ul>
<li><a href="https://www.youtube.com/watch?v=gTVpBbFWry8">Chrome DevTools - Crash Course</a></li>
<li><a href="https://www.headspin.io/blog/chrome-devtools-a-complete-guide">A Detailed Guide to Chrome DevTools</a></li>
<li><a href="https://websitehcm.com/chrome-developer-tools-va-cach-su-dung/">Chrome Developer Tools và Cách Sử Dụng: Hướng Dẫn Chi Tiết</a></li>
</ul>
<h3 id="cài-đặt-môi-trường-công-cụ-cần-thiết-để-bắt-đầu-học-html-css"><a class="header" href="#cài-đặt-môi-trường-công-cụ-cần-thiết-để-bắt-đầu-học-html-css">Cài đặt môi trường, công cụ cần thiết để bắt đầu học HTML CSS</a></h3>
<p>Theo tiêu chuẩn là cài đặt <a href="https://code.visualstudio.com/">VSCode</a> (Hoặc <a href="https://vscodium.com/">VSCodium</a>). Rồi bạn tìm mục <strong>Extensions</strong>, tìm những Addons có từ khóa HTML/CSS, JS và chọn bừa :smile: cộng với tải <strong>Live Server</strong> là xong.</p>
<h3 id="cấu-trúc-tệp-html"><a class="header" href="#cấu-trúc-tệp-html">Cấu trúc tệp HTML</a></h3>
<p>File HTML cơ bản có cấu trúc:</p>
<ul>
<li><code>&lt;!DOCTYPE html&gt;</code>: Khai báo loại tài liệu HTML5.</li>
<li><code>&lt;html&gt;</code>: Thẻ gốc của trang HTML.</li>
<li><code>&lt;head&gt;</code>: Chứa meta thông tin (tiêu đề, CSS, JavaScript...).</li>
<li><code>&lt;body&gt;</code>: Chứa nội dung hiển thị trên trang web.</li>
</ul>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;vi&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Tiêu đề trang&lt;/title&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;style.css&quot;&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;script src=&quot;script.js&quot;&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="comments-trong-html"><a class="header" href="#comments-trong-html">Comments trong HTML</a></h3>
<p>Comment (chú thích) trong HTML giúp ghi chú, giải thích code, hoặc tạm ẩn code mà không ảnh hưởng đến hiển thị.</p>
<p><strong>Cú pháp:</strong> ``</p>
<pre><code class="language-html">&lt;p&gt;Đoạn văn bản này hiển thị.&lt;/p&gt;
</code></pre>
<h3 id="những-thẻ-html-thông-dụng"><a class="header" href="#những-thẻ-html-thông-dụng">Những thẻ HTML thông dụng</a></h3>
<p>HTML có nhiều thẻ khác nhau, mỗi thẻ có chức năng riêng để tạo cấu trúc và nội dung:</p>
<ul>
<li>Thẻ tiêu đề: <code>&lt;h1&gt;</code> - <code>&lt;h6&gt;</code> (quan trọng nhất là <code>&lt;h1&gt;</code>).</li>
<li>Thẻ đoạn văn: <code>&lt;p&gt;</code>.</li>
<li>Thẻ liên kết: <code>&lt;a&gt;</code> (<code>href</code> attribute để chỉ đích đến link).</li>
<li>Thẻ hình ảnh: <code>&lt;img&gt;</code> (<code>src</code> attribute để chỉ đường dẫn ảnh, <code>alt</code> attribute cho text thay thế).</li>
<li>Thẻ danh sách: <code>&lt;ul&gt;</code> (danh sách không thứ tự), <code>&lt;ol&gt;</code> (danh sách thứ tự), <code>&lt;li&gt;</code> (item trong danh sách).</li>
<li>Thẻ div và span: <code>&lt;div&gt;</code> (khối), <code>&lt;span&gt;</code> (nội tuyến), dùng để nhóm các phần tử và style.</li>
<li>Thẻ form: <code>&lt;form&gt;</code>, <code>&lt;input&gt;</code>, <code>&lt;button&gt;</code>, <code>&lt;textarea&gt;</code>, <code>&lt;select&gt;</code>, <code>&lt;label&gt;</code>.</li>
<li>Thẻ table: <code>&lt;table&gt;</code>, <code>&lt;tr&gt;</code> (row), <code>&lt;th&gt;</code> (header cell), <code>&lt;td&gt;</code> (data cell).</li>
</ul>
<pre><code class="language-html">&lt;h1&gt;Tiêu đề chính&lt;/h1&gt;
&lt;p&gt;Đây là một đoạn văn bản.&lt;/p&gt;
&lt;a href=&quot;https://f8.edu.vn&quot;&gt;F8 - Học lập trình&lt;/a&gt;
&lt;img src=&quot;image.jpg&quot; alt=&quot;Ảnh minh họa&quot;&gt;
&lt;ul&gt;
    &lt;li&gt;Item 1&lt;/li&gt;
    &lt;li&gt;Item 2&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;
    &lt;p&gt;Đây là một div chứa đoạn văn.&lt;/p&gt;
&lt;/div&gt;
</code></pre>
<h3 id="attributes-trong-html"><a class="header" href="#attributes-trong-html">Attributes trong HTML</a></h3>
<p>Attributes (thuộc tính) cung cấp thông tin bổ sung cho thẻ HTML, giúp điều chỉnh hành vi hoặc hiển thị của thẻ. Cú pháp: <code>attribute=&quot;value&quot;</code> (nằm trong thẻ mở).</p>
<pre><code class="language-html">&lt;a href=&quot;https://f8.edu.vn&quot; target=&quot;_blank&quot;&gt;Liên kết F8 (mở tab mới)&lt;/a&gt;
&lt;img src=&quot;image.jpg&quot; alt=&quot;Ảnh&quot; width=&quot;200&quot;&gt;
&lt;div class=&quot;container&quot; id=&quot;main-content&quot;&gt;Nội dung&lt;/div&gt;
</code></pre>
<h2 id="phần-2-css"><a class="header" href="#phần-2-css">Phần 2: CSS</a></h2>
<h3 id="cách-sử-dụng-css-trong-html"><a class="header" href="#cách-sử-dụng-css-trong-html">Cách sử dụng CSS trong HTML</a></h3>
<p>Có 3 cách chính để sử dụng CSS trong HTML:</p>
<ol>
<li><strong>Inline CSS:</strong> Viết trực tiếp trong thuộc tính <code>style</code> của thẻ HTML (ưu tiên cao nhất, ít dùng vì khó quản lý).</li>
<li><strong>Internal CSS:</strong> Viết trong thẻ <code>&lt;style&gt;</code> trong <code>&lt;head&gt;</code> của file HTML (dùng cho style riêng của trang).</li>
<li><strong>External CSS:</strong> Viết trong file CSS riêng (<code>.css</code>), liên kết đến HTML bằng thẻ <code>&lt;link&gt;</code> trong <code>&lt;head&gt;</code> (tốt nhất cho dự án lớn, dễ quản lý, tái sử dụng).</li>
</ol>
<p><strong><code>index.html</code>:</strong></p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Ví dụ External CSS&lt;/title&gt;
    &lt;!--Dùng CSS từ tệp ngoài như này--&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;style.css&quot;&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h1&gt;Tiêu đề&lt;/h1&gt;
    &lt;p&gt;Đoạn văn bản.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><strong><code>style.css</code>:</strong></p>
<pre><code class="language-css">body {
    font-family: Arial, sans-serif;
}
h1 {
    color: red;
}
</code></pre>
<h3 id="id-và-class-trong-css-selectors"><a class="header" href="#id-và-class-trong-css-selectors">ID và Class trong CSS selectors</a></h3>
<p>CSS selectors (bộ chọn) để chọn các phần tử HTML để style. ID và Class là 2 loại selector quan trọng:</p>
<ul>
<li>
<p><strong>ID selector:</strong> Chọn phần tử HTML có <code>id</code> attribute tương ứng. Bắt đầu bằng <code>#</code>. ID là duy nhất trên trang.</p>
</li>
<li>
<p><strong>Class selector:</strong> Chọn các phần tử HTML có <code>class</code> attribute tương ứng. Bắt đầu bằng <code>.</code>. Class có thể dùng cho nhiều phần tử.</p>
</li>
<li>
<p><strong><code>index.html</code>:</strong></p>
</li>
</ul>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Ví dụ ID và Class&lt;/title&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;style.css&quot;&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h1 id=&quot;main-title&quot;&gt;Tiêu đề chính&lt;/h1&gt;
    &lt;p class=&quot;paragraph&quot;&gt;Đoạn văn bản 1.&lt;/p&gt;
    &lt;p class=&quot;paragraph special-text&quot;&gt;Đoạn văn bản 2 (class đặc biệt).&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<ul>
<li><strong><code>style.css</code>:</strong></li>
</ul>
<pre><code class="language-css">#main-title { /* ID selector */
    color: green;
    text-align: center;
}
.paragraph { /* Class selector */
    font-size: 16px;
    line-height: 1.5;
}
.special-text { /* Class selector cho class &quot;special-text&quot; */
    font-weight: bold;
}
</code></pre>
<h3 id="mức-độ-ưu-tiên-trong-css"><a class="header" href="#mức-độ-ưu-tiên-trong-css">Mức độ ưu tiên trong CSS</a></h3>
<p>Khi có nhiều CSS rules cùng style một phần tử, trình duyệt áp dụng mức độ ưu tiên để quyết định rule nào được dùng:</p>
<ol>
<li><strong>Inline CSS</strong> (cao nhất).</li>
<li><strong>ID selectors</strong>.</li>
<li><strong>Class selectors, attribute selectors, pseudo-classes</strong>.</li>
<li><strong>Element selectors, pseudo-elements</strong> (thấp nhất).</li>
<li><strong>!important</strong> (cực cao, nên hạn chế dùng).</li>
</ol>
<ul>
<li><strong><code>index.html</code>:</strong></li>
</ul>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Mức độ ưu tiên CSS&lt;/title&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;style.css&quot;&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;p id=&quot;para-id&quot; class=&quot;para-class&quot; style=&quot;color: purple;&quot;&gt;
        Đoạn văn bản này có nhiều style.
    &lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<ul>
<li><strong><code>style.css</code>:</strong></li>
</ul>
<pre><code class="language-css">p { /* Element selector (thấp nhất) */
    color: blue;
}
.para-class { /* Class selector */
    color: orange;
}
#para-id { /* ID selector */
    color: red;
}
</code></pre>
<ul>
<li>Đoạn văn bản sẽ có màu <strong>tím</strong> (inline CSS ưu tiên nhất). Nếu bỏ inline style, sẽ có màu <strong>đỏ</strong> (ID selector ưu tiên hơn class và element).</li>
</ul>
<h3 id="biến-trong-css-css-variable"><a class="header" href="#biến-trong-css-css-variable">Biến trong CSS (CSS Variable)</a></h3>
<p>CSS Variables (biến CSS) cho phép bạn định nghĩa các giá trị có thể tái sử dụng trong CSS, giúp code dễ bảo trì và tùy biến. <strong>Cú pháp:</strong></p>
<ul>
<li>Khai báo biến: <code>--variable-name: value;</code> (trong <code>:root</code> selector để global, hoặc trong selector khác để local).</li>
<li>Sử dụng biến: <code>var(--variable-name)</code></li>
</ul>
<pre><code class="language-css">:root { /* Global variables */
    --primary-color: blue;
    --font-size-large: 20px;
}

body {
    font-family: Arial, sans-serif;
    color: var(--primary-color); /* Sử dụng biến */
}

h1 {
    color: var(--primary-color);
    font-size: var(--font-size-large);
}
</code></pre>
<h3 id="css-units-là-gì"><a class="header" href="#css-units-là-gì">CSS Units là gì?</a></h3>
<p>CSS Units (đơn vị CSS) xác định kích thước, khoảng cách, độ dài... trong CSS. Có 2 loại chính:</p>
<ul>
<li><strong>Absolute units:</strong> Cố định, không thay đổi theo môi trường (px, cm, mm, in, pt, pc). <code>px</code> (pixel) phổ biến nhất cho web.</li>
<li><strong>Relative units:</strong> Tương đối, thay đổi theo môi trường (%, em, rem, vw, vh).
<ul>
<li><code>%</code>: Phần trăm so với phần tử cha.</li>
<li><code>em</code>: Tương đối với <code>font-size</code> của phần tử cha.</li>
<li><code>rem</code>: Tương đối với <code>font-size</code> của thẻ gốc <code>&lt;html&gt;</code>.</li>
<li><code>vw</code>, <code>vh</code>: Phần trăm chiều rộng, chiều cao viewport (cửa sổ trình duyệt).</li>
</ul>
</li>
</ul>
<pre><code class="language-css">body {
    font-size: 16px; /* Pixel (absolute) */
}

h1 {
    font-size: 2em; /* em (relative to body font-size) -&gt; 32px */
}

div {
    width: 50%; /* % (relative to parent width) */
    padding: 10px; /* Pixel (absolute) */
}
</code></pre>
<h3 id="thuộc-tính-padding-trong-css"><a class="header" href="#thuộc-tính-padding-trong-css">Thuộc tính Padding trong CSS</a></h3>
<p><code>padding</code> tạo khoảng trắng bên trong <strong>viền</strong> của phần tử, đẩy nội dung ra xa viền. Có thể set <code>padding-top</code>, <code>padding-right</code>, <code>padding-bottom</code>, <code>padding-left</code> hoặc <code>padding</code> shorthand (top right bottom left).</p>
<pre><code class="language-css">div {
    width: 200px;
    height: 100px;
    background-color: lightblue;
    border: 1px solid black;
    padding: 20px; /* Padding đều 4 phía 20px */
}
</code></pre>
<h3 id="thuộc-tính-border-trong-css"><a class="header" href="#thuộc-tính-border-trong-css">Thuộc tính Border trong CSS</a></h3>
<p><code>border</code> tạo viền xung quanh phần tử. Các thuộc tính:</p>
<ul>
<li><code>border-width</code>: Độ dày viền (px, em...).</li>
<li><code>border-style</code>: Kiểu viền (solid, dashed, dotted, double...).</li>
<li><code>border-color</code>: Màu viền.</li>
<li><code>border</code> shorthand: <code>border: width style color;</code></li>
<li><code>border-radius</code>: Bo tròn góc viền.</li>
</ul>
<pre><code class="language-css">div {
    width: 200px;
    height: 100px;
    background-color: lightblue;
    border: 5px solid red; /* Viền đỏ, dày 5px, kiểu solid */
    border-radius: 10px; /* Bo tròn góc 10px */
}
</code></pre>
<h3 id="thuộc-tính-margin-trong-css"><a class="header" href="#thuộc-tính-margin-trong-css">Thuộc tính Margin trong CSS</a></h3>
<p><code>margin</code> tạo khoảng trắng bên ngoài <strong>viền</strong> của phần tử, đẩy phần tử ra xa các phần tử xung quanh. Tương tự padding, có <code>margin-top</code>, <code>margin-right</code>, <code>margin-bottom</code>, <code>margin-left</code> hoặc <code>margin</code> shorthand.</p>
<pre><code class="language-css">div {
    width: 200px;
    height: 100px;
    background-color: lightblue;
    border: 1px solid black;
    margin-bottom: 30px; /* Margin dưới 30px, đẩy phần tử tiếp theo xuống */
}
</code></pre>
<h3 id="css-box-sizing"><a class="header" href="#css-box-sizing">CSS Box-sizing</a></h3>
<p><code>box-sizing</code> quyết định cách tính tổng kích thước của phần tử (width, height) khi có <code>padding</code> và <code>border</code>.</p>
<ul>
<li><code>content-box</code> (mặc định): <code>width</code> và <code>height</code> chỉ tính phần nội dung, <code>padding</code> và <code>border</code> cộng thêm vào tổng kích thước.</li>
<li><code>border-box</code>: <code>width</code> và <code>height</code> bao gồm cả <code>padding</code> và <code>border</code>. Thuận tiện hơn, dễ kiểm soát kích thước phần tử.</li>
</ul>
<pre><code class="language-css">.content-box {
    box-sizing: content-box; /* Mặc định */
    width: 200px;
    padding: 20px;
    border: 10px solid black;
    /* Tổng chiều rộng: 200px (width) + 20px*2 (padding) + 10px*2 (border) = 260px */
}

.border-box {
    box-sizing: border-box;
    width: 200px;
    padding: 20px;
    border: 10px solid black;
    /* Tổng chiều rộng: vẫn là 200px (width đã bao gồm padding và border) */
}
</code></pre>
<h3 id="css-background-clip"><a class="header" href="#css-background-clip">CSS Background-clip</a></h3>
<p><code>background-clip</code> xác định vùng mà background (màu, ảnh) sẽ được hiển thị bên trong phần tử.</p>
<ul>
<li><code>border-box</code> (mặc định): Background clip đến mép ngoài của viền.</li>
<li><code>padding-box</code>: Background clip đến mép ngoài của padding.</li>
<li><code>content-box</code>: Background clip đến mép ngoài của content box.</li>
<li><code>text</code>: Background clip theo hình dạng chữ (chỉ áp dụng cho text).</li>
</ul>
<pre><code class="language-css">div {
    width: 200px;
    height: 100px;
    background-color: lightblue;
    border: 20px dashed red;
    padding: 20px;
    background-clip: padding-box; /* Background chỉ hiển thị trong vùng padding và content */
}
</code></pre>
<h3 id="css-background-image"><a class="header" href="#css-background-image">CSS Background-image</a></h3>
<p><code>background-image</code> đặt ảnh nền cho phần tử. Giá trị là <code>url(&quot;path/to/image.jpg&quot;)</code> hoặc <code>linear-gradient()</code>, <code>radial-gradient()</code>...</p>
<pre><code class="language-css">div {
    width: 300px;
    height: 200px;
    background-image: url(&quot;background.jpg&quot;); /* Đặt ảnh nền */
    background-size: cover; /* Ảnh nền phủ kín div */
    color: white; /* Chữ màu trắng để dễ nhìn trên nền ảnh */
    text-align: center;
    padding-top: 50px;
}
</code></pre>
<h3 id="thuộc-tính-background-size"><a class="header" href="#thuộc-tính-background-size">Thuộc tính Background-size</a></h3>
<p><code>background-size</code> điều chỉnh kích thước ảnh nền. Các giá trị phổ biến:</p>
<ul>
<li><code>auto</code> (mặc định): Kích thước ảnh gốc.</li>
<li><code>cover</code>: Ảnh nền phủ kín phần tử, có thể bị crop.</li>
<li><code>contain</code>: Ảnh nền vừa khít trong phần tử, có thể có khoảng trắng xung quanh.</li>
<li><code>px</code>, <code>%</code>: Kích thước cụ thể (px) hoặc phần trăm (%).</li>
</ul>
<pre><code class="language-css">div {
    width: 300px;
    height: 200px;
    background-image: url(&quot;background.jpg&quot;);
    background-size: cover; /* Ảnh nền phủ kín div */
}
</code></pre>
<h3 id="thuộc-tính-background-origin"><a class="header" href="#thuộc-tính-background-origin">Thuộc tính Background-origin</a></h3>
<p><code>background-origin</code> xác định vị trí bắt đầu của background-image.</p>
<ul>
<li><code>border-box</code> (mặc định): Bắt đầu từ mép trên-trái của border box.</li>
<li><code>padding-box</code>: Bắt đầu từ mép trên-trái của padding box.</li>
<li><code>content-box</code>: Bắt đầu từ mép trên-trái của content box.</li>
</ul>
<pre><code class="language-css">div {
    width: 200px;
    height: 100px;
    background-image: url(&quot;pattern.png&quot;); /* Ảnh pattern nhỏ */
    border: 20px dashed red;
    padding: 20px;
    background-repeat: repeat; /* Lặp lại ảnh nền */
    background-origin: content-box; /* Ảnh nền bắt đầu từ content box */
}
</code></pre>
<h3 id="thuộc-tính-background-position"><a class="header" href="#thuộc-tính-background-position">Thuộc tính Background-position</a></h3>
<p><code>background-position</code> định vị trí của ảnh nền trong phần tử. Giá trị:</p>
<ul>
<li><code>top</code>, <code>bottom</code>, <code>left</code>, <code>right</code>, <code>center</code>.</li>
<li><code>px</code>, <code>%</code>: Vị trí cụ thể (px) hoặc phần trăm (%).</li>
<li>Cặp giá trị: <code>background-position: horizontal vertical;</code> (ví dụ: <code>top center</code>, <code>50% 20px</code>).</li>
</ul>
<pre><code class="language-css">div {
    width: 300px;
    height: 200px;
    background-image: url(&quot;background.jpg&quot;);
    background-size: contain; /* Ảnh nền vừa khít */
    background-repeat: no-repeat; /* Không lặp lại ảnh nền */
    background-position: center; /* Ảnh nền ở giữa div */
}
</code></pre>
<h3 id="cú-pháp-shorthand"><a class="header" href="#cú-pháp-shorthand">Cú pháp shorthand</a></h3>
<p>CSS Shorthand (cú pháp rút gọn) giúp viết nhiều thuộc tính CSS liên quan trong một dòng. <code>background</code> shorthand gộp nhiều thuộc tính background: <code>background: color image repeat position/size origin clip;</code> (thứ tự không quan trọng, có thể bỏ qua một số giá trị).</p>
<pre><code class="language-css">div {
    width: 300px;
    height: 200px;
    background: lightblue url(&quot;background.jpg&quot;) no-repeat center/cover padding-box;
    /* Rút gọn của:
        background-color: lightblue;
        background-image: url(&quot;background.jpg&quot;);
        background-repeat: no-repeat;
        background-position: center;
        background-size: cover;
        background-origin: padding-box;
    */
}
</code></pre>
<h3 id="css-functions"><a class="header" href="#css-functions">CSS Functions</a></h3>
<p>CSS Functions (hàm CSS) là các hàm dựng sẵn trong CSS để tạo ra các giá trị động hoặc phức tạp. Ví dụ:</p>
<ul>
<li><code>rgb()</code>, <code>rgba()</code>, <code>hsl()</code>, <code>hsla()</code>: Hàm màu.</li>
<li><code>linear-gradient()</code>, <code>radial-gradient()</code>: Hàm tạo gradient màu.</li>
<li><code>calc()</code>: Hàm tính toán.</li>
<li><code>var()</code>: Hàm dùng biến CSS.</li>
</ul>
<pre><code class="language-css">div {
    width: 200px;
    height: 100px;
    background-color: rgba(0, 0, 255, 0.5); /* Màu xanh lam trong suốt */
    background-image: linear-gradient(to right, red, yellow); /* Gradient từ đỏ sang vàng */
    font-size: calc(100% - 20px); /* Tính toán font-size */
}
</code></pre>
<h3 id="css-pseudo-classes"><a class="header" href="#css-pseudo-classes">CSS Pseudo classes</a></h3>
<p>CSS Pseudo-classes (lớp giả) chọn các phần tử dựa trên trạng thái hoặc vị trí đặc biệt, không dựa trên class hay ID. Bắt đầu bằng <code>:</code>. Ví dụ:</p>
<ul>
<li><code>:hover</code>: Khi chuột di vào.</li>
<li><code>:active</code>: Khi phần tử đang được click.</li>
<li><code>:focus</code>: Khi phần tử được focus (ví dụ input).</li>
<li><code>:first-child</code>, <code>:last-child</code>, <code>:nth-child()</code>: Chọn phần tử con đầu, cuối, thứ n.</li>
</ul>
<pre><code class="language-css">a:hover { /* Style link khi hover */
    color: red;
    text-decoration: none; /* Bỏ gạch chân khi hover */
}

li:first-child { /* Style item đầu tiên trong danh sách */
    font-weight: bold;
}
</code></pre>
<h3 id="phần-tử-giả-trong-css"><a class="header" href="#phần-tử-giả-trong-css">Phần tử giả trong CSS</a></h3>
<p>CSS Pseudo-elements (phần tử giả) tạo ra các phần tử &quot;ảo&quot; để style các phần cụ thể của phần tử thật. Bắt đầu bằng <code>::</code>. Ví dụ:</p>
<ul>
<li><code>::before</code>, <code>::after</code>: Tạo phần tử ảo trước/sau nội dung phần tử thật.</li>
<li><code>::first-line</code>, <code>::first-letter</code>: Style dòng đầu, chữ cái đầu của text.</li>
</ul>
<pre><code class="language-css">p::first-line { /* Style dòng đầu tiên của đoạn văn */
    font-variant: small-caps; /* Chữ in hoa nhỏ */
}

a::before { /* Thêm icon trước link */
    content: &quot;🔗 &quot;;
}
</code></pre>
<h3 id="thuộc-tính-position"><a class="header" href="#thuộc-tính-position">Thuộc tính Position</a></h3>
<p><code>position</code> xác định cách phần tử được định vị trong layout. <code>position: relative</code> (tương đối):</p>
<ul>
<li>Phần tử vẫn ở vị trí bình thường trong luồng văn bản.</li>
<li><code>top</code>, <code>right</code>, <code>bottom</code>, <code>left</code> dịch chuyển phần tử <strong>tương đối</strong> so với vị trí ban đầu của nó.</li>
<li>Không ảnh hưởng đến vị trí các phần tử khác.</li>
</ul>
<pre><code class="language-css">div {
    width: 100px;
    height: 100px;
    background-color: lightblue;
    position: relative; /* Định vị tương đối */
    left: 30px; /* Dịch sang phải 30px */
    top: 20px; /* Dịch xuống dưới 20px */
}
</code></pre>
<h3 id="thuộc-tính-vị-trí-tuyệt-đối"><a class="header" href="#thuộc-tính-vị-trí-tuyệt-đối">Thuộc tính vị trí tuyệt đối</a></h3>
<p><code>position: absolute</code> (tuyệt đối):</p>
<ul>
<li>Phần tử bị loại khỏi luồng văn bản bình thường.</li>
<li>Định vị <strong>tuyệt đối</strong> so với phần tử cha <strong>gần nhất</strong> có <code>position: relative</code>, <code>absolute</code>, <code>fixed</code> (nếu không có cha nào thì so với thẻ <code>&lt;html&gt;</code>).</li>
<li>Các phần tử khác có thể &quot;chèn&quot; vào vị trí của phần tử absolute.</li>
</ul>
<pre><code class="language-html">&lt;div style=&quot;position: relative; width: 300px; height: 200px; border: 1px solid black;&quot;&gt;
    &lt;div style=&quot;position: absolute; top: 50px; left: 50px; width: 100px; height: 100px; background-color: lightblue;&quot;&gt;
        Absolute div
    &lt;/div&gt;
    Relative container
&lt;/div&gt;
</code></pre>
<h3 id="thuộc-tính-position-fixed"><a class="header" href="#thuộc-tính-position-fixed">Thuộc tính Position: Fixed</a></h3>
<p><code>position: fixed</code> (cố định):</p>
<ul>
<li>Tương tự <code>absolute</code>: bị loại khỏi luồng văn bản.</li>
<li>Định vị <strong>cố định</strong> so với <strong>viewport</strong> (cửa sổ trình duyệt).</li>
<li>Không scroll theo trang, luôn ở vị trí cố định trên màn hình.</li>
</ul>
<pre><code class="language-css">div {
    position: fixed; /* Định vị cố định */
    top: 0;
    left: 0;
    width: 100%;
    background-color: lightblue;
    padding: 10px;
    text-align: center;
}
</code></pre>
<h3 id="thuộc-tính-position-sticky"><a class="header" href="#thuộc-tính-position-sticky">Thuộc tính Position: Sticky</a></h3>
<p><code>position: sticky</code> (dính):</p>
<ul>
<li>Kết hợp <code>relative</code> và <code>fixed</code>.</li>
<li>Ban đầu hoạt động như <code>relative</code> (trong luồng văn bản).</li>
<li>Khi scroll đến một vị trí nhất định (set bằng <code>top</code>, <code>bottom</code>, <code>left</code>, <code>right</code>), nó sẽ &quot;dính&quot; lại như <code>fixed</code> trong phạm vi phần tử cha.</li>
</ul>
<pre><code class="language-css">div {
    position: sticky; /* Định vị sticky */
    top: 0; /* Dính vào mép trên khi scroll đến */
    background-color: lightblue;
    padding: 10px;
    margin-bottom: 500px; /* Tạo scroll để thấy hiệu ứng */
}
</code></pre>
<h3 id="giới-thiệu-flexbox"><a class="header" href="#giới-thiệu-flexbox">Giới thiệu Flexbox</a></h3>
<p>Flexbox là layout module mạnh mẽ trong CSS, giúp tạo layout linh hoạt, một chiều (chính hoặc phụ). Dùng cho layout thành phần, UI nhỏ.</p>
<ul>
<li><strong>Kích hoạt Flexbox:</strong> <code>display: flex;</code> cho phần tử cha (container). Các phần tử con trực tiếp trở thành flex items.</li>
<li><strong>Trục chính (main axis) và trục phụ (cross axis):</strong> Flexbox layout dựa trên 2 trục này. Mặc định trục chính là ngang (row), trục phụ là dọc (column).</li>
</ul>
<h3 id="những-thuộc-tính-css-sử-dụng-trong-flexbox"><a class="header" href="#những-thuộc-tính-css-sử-dụng-trong-flexbox">Những thuộc tính CSS sử dụng trong Flexbox</a></h3>
<p><strong>Thuộc tính cho container (phần tử cha):</strong></p>
<ul>
<li><code>flex-direction</code>: Hướng trục chính (row, column, row-reverse, column-reverse).</li>
<li><code>justify-content</code>: Căn chỉnh các flex items trên trục chính (flex-start, flex-end, center, space-between, space-around, space-evenly).</li>
<li><code>align-items</code>: Căn chỉnh các flex items trên trục phụ (flex-start, flex-end, center, stretch, baseline).</li>
<li><code>flex-wrap</code>: Cho phép flex items xuống dòng khi không đủ chỗ (nowrap, wrap, wrap-reverse).</li>
<li><code>align-content</code>: Căn chỉnh các dòng flex items (khi <code>flex-wrap: wrap</code> hoặc <code>wrap-reverse</code>) trên trục phụ (flex-start, flex-end, center, space-between, space-around, stretch).</li>
</ul>
<p><strong>Thuộc tính cho items (phần tử con):</strong></p>
<ul>
<li><code>order</code>: Sắp xếp thứ tự item.</li>
<li><code>flex-grow</code>:  Item có thể lớn ra để lấp đầy không gian thừa.</li>
<li><code>flex-shrink</code>: Item có thể nhỏ lại khi không đủ chỗ.</li>
<li><code>flex-basis</code>: Kích thước cơ sở của item trước khi <code>flex-grow</code> và <code>flex-shrink</code> áp dụng.</li>
<li><code>align-self</code>: Ghi đè <code>align-items</code> cho item cụ thể.</li>
</ul>
<h3 id="học-flexbox-css-qua-ví-dụ"><a class="header" href="#học-flexbox-css-qua-ví-dụ">Học Flexbox CSS qua ví dụ</a></h3>
<p><strong>Ví dụ (layout menu ngang):</strong></p>
<pre><code class="language-html">&lt;nav class=&quot;menu&quot;&gt;
    &lt;a href=&quot;#&quot;&gt;Home&lt;/a&gt;
    &lt;a href=&quot;#&quot;&gt;About&lt;/a&gt;
    &lt;a href=&quot;#&quot;&gt;Services&lt;/a&gt;
    &lt;a href=&quot;#&quot;&gt;Contact&lt;/a&gt;
&lt;/nav&gt;
</code></pre>
<pre><code class="language-css">.menu {
    display: flex; /* Kích hoạt flexbox */
    justify-content: space-around; /* Các link cách đều nhau trên trục ngang */
    background-color: lightgray;
    padding: 10px;
}

.menu a {
    text-decoration: none;
    color: black;
    padding: 10px 15px;
}
</code></pre>
<h3 id="flexbox-nâng-cao-liên-hệ-flex-model-với-các-thuộc-tính-flexbox-trong-css"><a class="header" href="#flexbox-nâng-cao-liên-hệ-flex-model-với-các-thuộc-tính-flexbox-trong-css">[Flexbox nâng cao] Liên hệ Flex model với các thuộc tính Flexbox trong CSS</a></h3>
<p>Hiểu rõ flex container, flex items, trục chính, trục phụ, main size, cross size... giúp dùng Flexbox hiệu quả hơn. Các thuộc tính Flexbox điều khiển cách flex items phân bổ không gian trên trục chính và trục phụ.</p>
<h3 id="css-bem-là-gì-Đặt-tên-css-class-theo-tiêu-chuẩn-bem"><a class="header" href="#css-bem-là-gì-Đặt-tên-css-class-theo-tiêu-chuẩn-bem">CSS BEM Là Gì? Đặt Tên CSS Class Theo Tiêu Chuẩn BEM</a></h3>
<p>BEM (Block, Element, Modifier) là quy tắc đặt tên class CSS giúp code dễ đọc, dễ bảo trì, tránh xung đột.</p>
<ul>
<li><strong>Block:</strong> Phần tử độc lập, tái sử dụng (ví dụ: <code>menu</code>, <code>button</code>). Class: <code>block</code>.</li>
<li><strong>Element:</strong> Phần con của Block, phụ thuộc vào Block (ví dụ: <code>menu__item</code>, <code>button__text</code>). Class: <code>block__element</code>.</li>
<li><strong>Modifier:</strong> Biến thể của Block hoặc Element, thay đổi style (ví dụ: <code>button--primary</code>, <code>menu__item--active</code>). Class: <code>block--modifier</code> hoặc <code>block__element--modifier</code>.</li>
</ul>
<pre><code class="language-html">&lt;div class=&quot;button button--primary&quot;&gt;
    &lt;span class=&quot;button__text&quot;&gt;Click me&lt;/span&gt;
&lt;/div&gt;
</code></pre>
<pre><code class="language-css">.button { /* Block */
    padding: 10px 20px;
    border: none;
    border-radius: 5px;
}

.button--primary { /* Modifier cho Block */
    background-color: blue;
    color: white;
}

.button__text { /* Element của Block */
    font-size: 16px;
}
</code></pre>
<h3 id="tối-ưu-performace-khi-sử-dụng-ảnh-với-srcset"><a class="header" href="#tối-ưu-performace-khi-sử-dụng-ảnh-với-srcset">Tối ưu performace khi sử dụng ảnh với srcset</a></h3>
<p><code>srcset</code> attribute của thẻ <code>&lt;img&gt;</code> giúp cung cấp nhiều phiên bản ảnh với kích thước khác nhau, trình duyệt tự chọn ảnh phù hợp với kích thước màn hình, tối ưu hiệu suất tải trang, đặc biệt trên mobile.</p>
<pre><code class="language-html">&lt;img src=&quot;image-large.jpg&quot;
        srcset=&quot;image-small.jpg 320w,
                image-medium.jpg 768w,
                image-large.jpg 1200w&quot;
        alt=&quot;Ảnh responsive&quot;&gt;
</code></pre>
<h3 id="css-selectors-cơ-bản"><a class="header" href="#css-selectors-cơ-bản">CSS selectors cơ bản</a></h3>
<p>Ôn lại các CSS selectors cơ bản:</p>
<ul>
<li><strong>Element selectors:</strong> <code>p</code>, <code>h1</code>, <code>div</code>...</li>
<li><strong>Class selectors:</strong> <code>.class-name</code></li>
<li><strong>ID selectors:</strong> <code>#id-name</code></li>
<li><strong>Attribute selectors:</strong> <code>[attribute]</code>, <code>[attribute=&quot;value&quot;]</code>...</li>
<li><strong>Universal selector:</strong> <code>*</code> (chọn tất cả phần tử).</li>
<li><strong>Combinators:</strong>
<ul>
<li>Descendant selector (space): <code>div p</code> (chọn <code>&lt;p&gt;</code> bên trong <code>&lt;div&gt;</code>).</li>
<li>Child selector (<code>&gt;</code>): <code>div &gt; p</code> (chọn <code>&lt;p&gt;</code> là con trực tiếp của <code>&lt;div&gt;</code>).</li>
<li>Adjacent sibling selector (<code>+</code>): <code>h1 + p</code> (chọn <code>&lt;p&gt;</code> ngay sau <code>&lt;h1&gt;</code>).</li>
<li>General sibling selector (<code>~</code>): <code>h1 ~ p</code> (chọn tất cả <code>&lt;p&gt;</code> là anh em của <code>&lt;h1&gt;</code>).</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hướng-dẫn-học-js-cực-nhanh"><a class="header" href="#hướng-dẫn-học-js-cực-nhanh">Hướng dẫn học JS cực nhanh</a></h1>
<p>Chắc thế, cái này do Gemini viết dựa trên nội dung khóa học của F8 nha.</p>
<h2 id="phần-1-giới-thiệu-và-cài-đặt"><a class="header" href="#phần-1-giới-thiệu-và-cài-đặt">Phần 1: Giới thiệu và Cài đặt</a></h2>
<h3 id="cài-đặt-môi-trường-công-cụ-phù-hợp-để-học-javascript"><a class="header" href="#cài-đặt-môi-trường-công-cụ-phù-hợp-để-học-javascript">Cài đặt môi trường, công cụ phù hợp để học JavaScript</a></h3>
<p>Để học JavaScript, bạn cần:</p>
<ul>
<li><strong>Trình duyệt web:</strong> Bất kỳ trình duyệt hiện đại nào (Chrome, Firefox, Edge...) đều có thể chạy JavaScript.</li>
<li><strong>Trình soạn thảo code:</strong> VS Code (Visual Studio Code) là lựa chọn tốt, miễn phí, nhiều extension hỗ trợ JavaScript.</li>
<li><strong>Node.js (tùy chọn):</strong>  Để chạy JavaScript ngoài trình duyệt (backend, công cụ...). Cài đặt từ <a href="https://www.google.com/url?sa=E&amp;source=gmail&amp;q=https://nodejs.org/">https://nodejs.org/</a>.</li>
</ul>
<h3 id="cách-sử-dụng-js-trong-file-html"><a class="header" href="#cách-sử-dụng-js-trong-file-html">Cách sử dụng JS trong file HTML</a></h3>
<p>Có 2 cách chính để nhúng JavaScript vào file HTML:</p>
<ul>
<li>
<p><strong>Internal (nội tuyến):</strong> Viết code JS trực tiếp trong thẻ <code>&lt;script&gt;</code> bên trong <code>&lt;head&gt;</code> hoặc <code>&lt;body&gt;</code> của file HTML.</p>
</li>
<li>
<p><strong>External (ngoại tuyến):</strong> Viết code JS trong file riêng (<code>.js</code>), sau đó liên kết đến file HTML bằng thẻ <code>&lt;script src=&quot;path/to/script.js&quot;&gt;&lt;/script&gt;</code>. Cách này tốt hơn cho dự án lớn, dễ quản lý code.</p>
</li>
<li>
<p><strong>Ví dụ (External JS - phổ biến nhất):</strong></p>
</li>
<li>
<p><strong><code>index.html</code>:</strong></p>
</li>
</ul>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Ví dụ External JS&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h1&gt;Xin chào JavaScript!&lt;/h1&gt;
    &lt;script src=&quot;script.js&quot;&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<ul>
<li><strong><code>script.js</code>:</strong></li>
</ul>
<pre><code class="language-javascript">    alert('Chào mừng đến với JavaScript!');
</code></pre>
<h2 id="phần-2-cú-pháp-và-cơ-bản"><a class="header" href="#phần-2-cú-pháp-và-cơ-bản">Phần 2: Cú pháp và Cơ bản</a></h2>
<h3 id="khai-báo-biến"><a class="header" href="#khai-báo-biến">Khai báo biến</a></h3>
<p>Biến dùng để lưu trữ dữ liệu trong chương trình. Trong JavaScript, có 3 từ khóa khai báo biến:</p>
<ul>
<li><code>var</code> (ít dùng hiện nay, phạm vi function-scoped).</li>
<li><code>let</code> (phạm vi block-scoped, có thể gán lại giá trị).</li>
<li><code>const</code> (phạm vi block-scoped, không thể gán lại giá trị sau khi khởi tạo). Nên dùng <code>const</code> khi giá trị không đổi, <code>let</code> khi cần thay đổi.</li>
</ul>
<p><strong>Ví dụ:</strong></p>
<pre><code class="language-javascript">let age = 30; // Khai báo biến age với let, giá trị 30
const name = &quot;Gemini&quot;; // Khai báo biến name với const, giá trị &quot;Gemini&quot;
age = 31; // Có thể gán lại giá trị cho age
// name = &quot;Bard&quot;; // Lỗi! Không thể gán lại giá trị cho const name
console.log(name + &quot; is &quot; + age + &quot; years old.&quot;);
</code></pre>
<h3 id="sử-dụng-comments-trong-javascript"><a class="header" href="#sử-dụng-comments-trong-javascript">Sử dụng Comments trong JavaScript</a></h3>
<p>Comment (chú thích) trong JavaScript giúp ghi chú, giải thích code, hoặc tạm ẩn code mà không ảnh hưởng đến chương trình.</p>
<ul>
<li>
<p><strong>Single-line comment:</strong> <code>// Đây là comment một dòng</code></p>
</li>
<li>
<p><strong>Multi-line comment:</strong></p>
</li>
</ul>
<pre><code class="language-javascript">/*
Đây là
comment
nhiều dòng
*/
</code></pre>
<p><strong>Ví dụ:</strong></p>
<pre><code class="language-javascript">// Đây là comment giải thích biến name
const name = &quot;Gemini&quot;;
/*
Đoạn code này
sẽ in ra lời chào
*/
console.log(&quot;Xin chào, &quot; + name + &quot;!&quot;);
</code></pre>
<h3 id="một-số-hàm-built-in-trong-javascript"><a class="header" href="#một-số-hàm-built-in-trong-javascript">Một số hàm built-in trong JavaScript</a></h3>
<p>Built-in functions (hàm dựng sẵn) là các hàm có sẵn trong JavaScript để thực hiện các tác vụ phổ biến. Ví dụ:</p>
<ul>
<li><code>alert()</code>: Hiển thị hộp thoại thông báo.</li>
<li><code>console.log()</code>: In thông tin ra console (DevTools).</li>
<li><code>prompt()</code>: Hiển thị hộp thoại nhập liệu.</li>
<li><code>parseInt()</code>, <code>parseFloat()</code>: Chuyển đổi chuỗi sang số nguyên, số thực.</li>
<li><code>typeof()</code>: Kiểm tra kiểu dữ liệu của biến.</li>
</ul>
<p><strong>Ví dụ:</strong></p>
<pre><code class="language-javascript">alert(&quot;Đây là thông báo!&quot;); // Hiển thị thông báo
console.log(&quot;Thông tin này in ra console&quot;); // In ra console
let input = prompt(&quot;Nhập tên của bạn:&quot;); // Hiển thị hộp thoại nhập liệu
console.log(&quot;Bạn đã nhập: &quot; + input);
let numberString = &quot;123&quot;;
let number = parseInt(numberString); // Chuyển chuỗi &quot;123&quot; sang số 123
console.log(typeof(number)); // In ra &quot;number&quot;
</code></pre>
<h3 id="làm-quen-với-toán-tử-trong-javascript"><a class="header" href="#làm-quen-với-toán-tử-trong-javascript">Làm quen với toán tử trong JavaScript</a></h3>
<p>Toán tử (operator) là ký hiệu thực hiện phép toán trên các giá trị (toán hạng). JavaScript có nhiều loại toán tử:</p>
<ul>
<li>Toán tử số học (+, -, *, /, %, **, ++, --).</li>
<li>Toán tử gán (=, +=, -=, *=, /=, %=).</li>
<li>Toán tử so sánh (==, ===, !=, !==, &gt;, &lt;, &gt;=, &lt;=).</li>
<li>Toán tử logic (&amp;&amp; - AND, || - OR, ! - NOT).</li>
<li>Toán tử chuỗi (+ - cộng chuỗi).</li>
</ul>
<h3 id="toán-tử-số-học-trong-javascript"><a class="header" href="#toán-tử-số-học-trong-javascript">Toán tử số học trong JavaScript</a></h3>
<p>Toán tử số học thực hiện các phép toán cơ bản:</p>
<ul>
<li><code>+</code> (cộng), <code>-</code> (trừ), <code>*</code> (nhân), <code>/</code> (chia).</li>
<li><code>%</code> (chia lấy dư - modulo).</li>
<li><code>**</code> (lũy thừa - exponentiation).</li>
</ul>
<p><strong>Ví dụ:</strong></p>
<pre><code class="language-javascript">let x = 10;
let y = 5;
console.log(x + y); // 15 (cộng)
console.log(x - y); // 5 (trừ)
console.log(x * y); // 50 (nhân)
console.log(x / y); // 2 (chia)
console.log(x % y); // 0 (chia lấy dư)
console.log(x ** y); // 100000 (10 mũ 5)
</code></pre>
<h3 id="toán-tử------với-tiền-tố--hậu-tố-prefix--postfix-trong-javascript"><a class="header" href="#toán-tử------với-tiền-tố--hậu-tố-prefix--postfix-trong-javascript">Toán tử ++  -- với tiền tố &amp; hậu tố (Prefix &amp; Postfix) trong JavaScript</a></h3>
<p>Toán tử tăng/giảm (<code>++</code>, <code>--</code>) tăng hoặc giảm giá trị biến đi 1.</p>
<ul>
<li><strong>Prefix (++x, --x):</strong> Tăng/giảm giá trị <strong>trước</strong> khi sử dụng giá trị đó trong biểu thức.</li>
<li><strong>Postfix (x++, x--):</strong> Tăng/giảm giá trị <strong>sau</strong> khi sử dụng giá trị đó trong biểu thức.</li>
</ul>
<p><strong>Ví dụ:</strong></p>
<pre><code class="language-javascript">let a = 5;
let b = ++a; // Prefix: a tăng lên 6 trước, sau đó b = 6
console.log(&quot;a:&quot;, a, &quot;b:&quot;, b); // a: 6 b: 6

let c = 5;
let d = c++; // Postfix: d = 5 trước, sau đó c tăng lên 6
console.log(&quot;c:&quot;, c, &quot;d:&quot;, d); // c: 6 d: 5
</code></pre>
<h3 id="toán-tử-gán-trong-javascript"><a class="header" href="#toán-tử-gán-trong-javascript">Toán tử gán trong JavaScript</a></h3>
<p>Toán tử gán gán giá trị cho biến.</p>
<ul>
<li><code>=</code> (gán trực tiếp).</li>
<li><code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code>, <code>%=</code> (gán kết hợp phép toán).</li>
</ul>
<p><strong>Ví dụ:</strong></p>
<pre><code class="language-javascript">let num = 10;
num = 20; // Gán trực tiếp num = 20
num += 5; // num = num + 5 (num = 25)
num -= 3; // num = num - 3 (num = 22)
num *= 2; // num = num * 2 (num = 44)
num /= 4; // num = num / 4 (num = 11)
num %= 3; // num = num % 3 (num = 2 - dư của 11 chia 3)
console.log(num); // 2
</code></pre>
<h3 id="toán-tử-chuỗi-string-operator-trong-javascript"><a class="header" href="#toán-tử-chuỗi-string-operator-trong-javascript">Toán tử chuỗi (String Operator) trong JavaScript</a></h3>
<p>Toán tử chuỗi chính là toán tử <code>+</code> (cộng) dùng để <strong>nối chuỗi</strong> (concatenation).</p>
<p><strong>Ví dụ:</strong></p>
<pre><code class="language-javascript">let firstName = &quot;Gemini&quot;;
let lastName = &quot;AI&quot;;
let fullName = firstName + &quot; &quot; + lastName; // Nối chuỗi
console.log(fullName); // Gemini AI
</code></pre>
<h3 id="toán-tử-so-sánh-trong-javascript-phần-1"><a class="header" href="#toán-tử-so-sánh-trong-javascript-phần-1">Toán tử so sánh trong Javascript (phần 1)</a></h3>
<p>Toán tử so sánh so sánh hai giá trị và trả về giá trị boolean (<code>true</code> hoặc <code>false</code>).</p>
<ul>
<li><code>==</code> (bằng giá trị - loose equality): So sánh giá trị, có thể ép kiểu dữ liệu.</li>
<li><code>===</code> (bằng giá trị và kiểu dữ liệu - strict equality): So sánh cả giá trị và kiểu dữ liệu, không ép kiểu. Nên dùng <code>===</code> để so sánh chính xác.</li>
<li><code>!=</code> (không bằng giá trị - loose inequality).</li>
<li><code>!==</code> (không bằng giá trị hoặc kiểu dữ liệu - strict inequality).</li>
<li><code>&gt;</code> (lớn hơn), <code>&lt;</code> (nhỏ hơn), <code>&gt;=</code> (lớn hơn hoặc bằng), <code>&lt;=</code> (nhỏ hơn hoặc bằng).</li>
</ul>
<h3 id="kiểu-dữ-liệu-boolean-boolean-data-type-trong-javascript"><a class="header" href="#kiểu-dữ-liệu-boolean-boolean-data-type-trong-javascript">Kiểu dữ liệu Boolean (Boolean data type) trong JavaScript</a></h3>
<p>Boolean là kiểu dữ liệu logic chỉ có 2 giá trị: <code>true</code> (đúng) và <code>false</code> (sai). Thường dùng trong câu lệnh điều kiện và toán tử logic.</p>
<p><strong>Ví dụ:</strong></p>
<pre><code class="language-javascript">let isAdult = true;
let isRaining = false;
console.log(typeof(isAdult)); // &quot;boolean&quot;
console.log(isRaining); // false
</code></pre>
<h3 id="câu-lệnh-điều-kiện-if---else-trong-javascript"><a class="header" href="#câu-lệnh-điều-kiện-if---else-trong-javascript">Câu lệnh điều kiện If - Else trong JavaScript</a></h3>
<p>Câu lệnh <code>if...else</code> thực hiện code khác nhau dựa trên điều kiện đúng hay sai.</p>
<ul>
<li><code>if (condition) { ... }</code>: Nếu <code>condition</code> đúng (<code>true</code>), code trong block <code>if</code> được thực hiện.</li>
<li><code>else { ... }</code>: Nếu <code>condition</code> sai (<code>false</code>), code trong block <code>else</code> được thực hiện (tùy chọn).</li>
<li><code>else if (condition2) { ... }</code>: Kiểm tra thêm điều kiện nếu điều kiện <code>if</code> sai (có thể có nhiều <code>else if</code>).</li>
</ul>
<p><strong>Ví dụ:</strong></p>
<pre><code class="language-javascript">let age = 18;
if (age &gt;= 18) {
    console.log(&quot;Bạn đã đủ tuổi trưởng thành.&quot;);
} else {
    console.log(&quot;Bạn chưa đủ tuổi trưởng thành.&quot;);
}
</code></pre>
<h3 id="toán-tử-logical-trong-javascript"><a class="header" href="#toán-tử-logical-trong-javascript">Toán tử logical trong JavaScript</a></h3>
<p>Toán tử logic kết hợp các biểu thức boolean.</p>
<ul>
<li><code>&amp;&amp;</code> (AND - và): <code>true</code> nếu <strong>cả hai</strong> toán hạng đều <code>true</code>.</li>
<li><code>||</code> (OR - hoặc): <code>true</code> nếu <strong>ít nhất một</strong> toán hạng là <code>true</code>.</li>
<li><code>!</code> (NOT - phủ định): Đảo ngược giá trị boolean (<code>!true</code> là <code>false</code>, <code>!false</code> là <code>true</code>).</li>
</ul>
<p><strong>Ví dụ:</strong></p>
<pre><code class="language-javascript">let hasLicense = true;
let hasCar = false;
if (hasLicense &amp;&amp; hasCar) { // Cả hai phải true
    console.log(&quot;Đủ điều kiện lái xe.&quot;);
} else if (hasLicense || hasCar) { // Ít nhất một true
    console.log(&quot;Có một trong hai điều kiện.&quot;);
} else {
    console.log(&quot;Không đủ điều kiện.&quot;);
}
console.log(!hasLicense); // false (phủ định true)
</code></pre>
<h3 id="kiểu-dữ-liệu-trong-javascript"><a class="header" href="#kiểu-dữ-liệu-trong-javascript">Kiểu dữ liệu trong JavaScript</a></h3>
<p>JavaScript là ngôn ngữ kiểu dữ liệu động (dynamic typing), kiểu dữ liệu của biến được xác định khi chạy chương trình, không cần khai báo rõ ràng. Các kiểu dữ liệu cơ bản:</p>
<ul>
<li><code>Number</code> (số): Số nguyên, số thực.</li>
<li><code>String</code> (chuỗi): Văn bản.</li>
<li><code>Boolean</code> (boolean): <code>true</code> hoặc <code>false</code>.</li>
<li><code>Null</code>: Giá trị rỗng có chủ ý.</li>
<li><code>Undefined</code>: Biến đã khai báo nhưng chưa gán giá trị.</li>
<li><code>Symbol</code> (ES6): Giá trị duy nhất, thường dùng làm key object.</li>
<li><code>Object</code> (đối tượng): Tập hợp các cặp key-value.</li>
</ul>
<h3 id="toán-tử-so-sánh-trong-javascript-phần-2"><a class="header" href="#toán-tử-so-sánh-trong-javascript-phần-2">Toán tử so sánh trong JavaScript (phần 2)</a></h3>
<p>Tiếp tục về toán tử so sánh, tập trung vào sự khác biệt giữa <code>==</code> và <code>===</code>. Nên dùng <code>===</code> và <code>!==</code> để so sánh chính xác, tránh các hành vi ép kiểu không mong muốn của <code>==</code> và <code>!=</code>.</p>
<h3 id="toán-tử-logical-và-câu-lệnh-điều-kiện-if-trong-javascript"><a class="header" href="#toán-tử-logical-và-câu-lệnh-điều-kiện-if-trong-javascript">Toán tử logical và câu lệnh điều kiện If trong JavaScript</a></h3>
<p>Kết hợp toán tử logic và câu lệnh <code>if</code> để tạo điều kiện phức tạp hơn.</p>
<p><strong>Ví dụ:</strong></p>
<pre><code class="language-javascript">let age = 20;
let hasTicket = true;
if (age &gt;= 18 &amp;&amp; hasTicket) { // Vừa đủ tuổi, vừa có vé
    console.log(&quot;Được vào xem phim.&quot;);
} else {
    console.log(&quot;Không được vào xem phim.&quot;);
}
</code></pre>
<h3 id="chuỗi-trong-javascript"><a class="header" href="#chuỗi-trong-javascript">Chuỗi trong JavaScript</a></h3>
<p>Chuỗi (string) là kiểu dữ liệu văn bản trong JavaScript, được bao quanh bởi dấu nháy đơn (<code>'...'</code>), nháy kép (<code>&quot;...&quot;</code>) hoặc backtick (`...`). Backtick dùng cho template literals (chuỗi template).</p>
<p><strong>Ví dụ:</strong></p>
<pre><code class="language-javascript">let singleQuoteString = 'Chuỗi nháy đơn';
let doubleQuoteString = &quot;Chuỗi nháy kép&quot;;
let templateString = `Chuỗi template literals`; // Backtick
console.log(singleQuoteString);
console.log(doubleQuoteString);
console.log(templateString);
</code></pre>
<h3 id="làm-việc-với-chuỗi-trong-javascript"><a class="header" href="#làm-việc-với-chuỗi-trong-javascript">Làm việc với chuỗi trong JavaScript</a></h3>
<p>String methods (phương thức chuỗi) là các hàm có sẵn để thao tác với chuỗi. Ví dụ:</p>
<ul>
<li><code>length</code>: Thuộc tính lấy độ dài chuỗi.</li>
<li><code>charAt(index)</code>: Lấy ký tự tại vị trí index.</li>
<li><code>indexOf(substring)</code>: Tìm vị trí đầu tiên của substring.</li>
<li><code>lastIndexOf(substring)</code>: Tìm vị trí cuối cùng của substring.</li>
<li><code>slice(start, end)</code>: Cắt chuỗi từ vị trí start đến end (không bao gồm end).</li>
<li><code>substring(start, end)</code>: Tương tự <code>slice</code>.</li>
<li><code>toUpperCase()</code>, <code>toLowerCase()</code>: Chuyển chuỗi thành chữ hoa, chữ thường.</li>
<li><code>trim()</code>: Xóa khoảng trắng đầu và cuối chuỗi.</li>
<li><code>split(delimiter)</code>: Chia chuỗi thành mảng các chuỗi con dựa trên delimiter.</li>
<li><code>replace(oldValue, newValue)</code>: Thay thế chuỗi con oldValue bằng newValue.</li>
</ul>
<p><strong>Ví dụ:</strong></p>
<pre><code class="language-javascript">let message = &quot;  Hello World!  &quot;;
console.log(message.length); // 15 (độ dài chuỗi)
console.log(message.charAt(0)); // &quot; &quot; (ký tự đầu tiên)
console.log(message.indexOf(&quot;World&quot;)); // 7 (vị trí của &quot;World&quot;)
console.log(message.slice(2, 7)); // &quot;Hello&quot; (cắt từ vị trí 2 đến 6)
console.log(message.toUpperCase()); // &quot;  HELLO WORLD!  &quot;
console.log(message.trim()); // &quot;Hello World!&quot; (xóa khoảng trắng)
console.log(message.split(&quot; &quot;)); // [&quot;&quot;, &quot;&quot;, &quot;Hello&quot;, &quot;World!&quot;, &quot;&quot;, &quot;&quot;] (chia thành mảng)
console.log(message.replace(&quot;World&quot;, &quot;JavaScript&quot;)); // &quot;  Hello JavaScript!  &quot;
</code></pre>
<h3 id="số-và-làm-việc-với-kiểu-số-trong-javascript"><a class="header" href="#số-và-làm-việc-với-kiểu-số-trong-javascript">Số và làm việc với kiểu số trong JavaScript</a></h3>
<p>Number methods (phương thức số) là các hàm có sẵn để thao tác với số. Ví dụ:</p>
<ul>
<li><code>toFixed(digits)</code>: Định dạng số thập phân với <code>digits</code> chữ số sau dấu phẩy.</li>
<li><code>parseInt()</code>, <code>parseFloat()</code>: Chuyển đổi chuỗi sang số nguyên, số thực.</li>
<li><code>isNaN()</code>: Kiểm tra xem có phải NaN (Not-a-Number) không.</li>
<li><code>Number.isInteger()</code>: Kiểm tra xem có phải số nguyên không.</li>
<li><code>Math.random()</code>: Sinh số ngẫu nhiên từ 0 đến &lt; 1.</li>
<li><code>Math.floor()</code>, <code>Math.ceil()</code>, <code>Math.round()</code>: Làm tròn số xuống, lên, gần nhất.</li>
<li><code>Math.max()</code>, <code>Math.min()</code>: Tìm số lớn nhất, nhỏ nhất.</li>
</ul>
<p><strong>Ví dụ:</strong></p>
<pre><code class="language-javascript">let pi = 3.14159;
console.log(pi.toFixed(2)); // &quot;3.14&quot; (làm tròn đến 2 chữ số thập phân)
let numString = &quot;42&quot;;
let numInt = parseInt(numString); // 42 (chuyển sang số nguyên)
console.log(isNaN(&quot;hello&quot;)); // true (không phải số)
console.log(Number.isInteger(10)); // true (số nguyên)
console.log(Math.random()); // Số ngẫu nhiên (ví dụ: 0.567...)
console.log(Math.floor(3.9)); // 3 (làm tròn xuống)
console.log(Math.max(1, 5, 2)); // 5 (số lớn nhất)
</code></pre>
<h3 id="mảng-trong-javascript"><a class="header" href="#mảng-trong-javascript">Mảng trong JavaScript</a></h3>
<p>Mảng (array) là kiểu dữ liệu danh sách, chứa nhiều giá trị theo thứ tự. Các phần tử mảng có thể có kiểu dữ liệu khác nhau. Mảng được khai báo bằng dấu ngoặc vuông <code>[...]</code>.</p>
<p><strong>Ví dụ:</strong></p>
<pre><code class="language-javascript">let colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;]; // Mảng chuỗi
let numbers = [1, 2, 3, 4, 5]; // Mảng số
let mixedArray = [1, &quot;hello&quot;, true, null]; // Mảng hỗn hợp
console.log(colors[0]); // &quot;red&quot; (phần tử đầu tiên, index 0)
console.log(numbers.length); // 5 (độ dài mảng)
</code></pre>
<h3 id="làm-việc-với-mảng-trong-javascript"><a class="header" href="#làm-việc-với-mảng-trong-javascript">Làm việc với mảng trong JavaScript</a></h3>
<p>Các thao tác cơ bản với mảng:</p>
<ul>
<li>Truy cập phần tử: <code>array[index]</code>.</li>
<li>Sửa đổi phần tử: <code>array[index] = newValue;</code>.</li>
<li>Thêm phần tử:
<ul>
<li><code>push(element)</code>: Thêm vào cuối mảng.</li>
<li><code>unshift(element)</code>: Thêm vào đầu mảng.</li>
</ul>
</li>
<li>Xóa phần tử:
<ul>
<li><code>pop()</code>: Xóa phần tử cuối mảng và trả về phần tử đó.</li>
<li><code>shift()</code>: Xóa phần tử đầu mảng và trả về phần tử đó.</li>
<li><code>splice(startIndex, deleteCount, item1, item2, ...)</code>: Xóa và/hoặc thêm phần tử tại vị trí bất kỳ.</li>
</ul>
</li>
</ul>
<p><strong>Ví dụ:</strong></p>
<pre><code class="language-javascript">let fruits = [&quot;apple&quot;, &quot;banana&quot;, &quot;orange&quot;];
console.log(fruits[1]); // &quot;banana&quot;
fruits[1] = &quot;grape&quot;; // Sửa đổi phần tử
console.log(fruits); // [&quot;apple&quot;, &quot;grape&quot;, &quot;orange&quot;]
fruits.push(&quot;mango&quot;); // Thêm vào cuối
console.log(fruits); // [&quot;apple&quot;, &quot;grape&quot;, &quot;orange&quot;, &quot;mango&quot;]
fruits.unshift(&quot;kiwi&quot;); // Thêm vào đầu
console.log(fruits); // [&quot;kiwi&quot;, &quot;apple&quot;, &quot;grape&quot;, &quot;orange&quot;, &quot;mango&quot;]
let lastFruit = fruits.pop(); // Xóa cuối
console.log(lastFruit); // &quot;mango&quot;
console.log(fruits); // [&quot;kiwi&quot;, &quot;apple&quot;, &quot;grape&quot;, &quot;orange&quot;]
fruits.splice(1, 2, &quot;pear&quot;, &quot;melon&quot;); // Xóa 2 phần tử từ index 1, thêm &quot;pear&quot;, &quot;melon&quot;
console.log(fruits); // [&quot;kiwi&quot;, &quot;pear&quot;, &quot;melon&quot;, &quot;orange&quot;]
</code></pre>
<h3 id="hàm-trong-javascript"><a class="header" href="#hàm-trong-javascript">Hàm trong JavaScript</a></h3>
<p>Hàm (function) là khối code thực hiện một tác vụ cụ thể, có thể tái sử dụng nhiều lần. Giúp code có cấu trúc, dễ đọc, dễ bảo trì.</p>
<ul>
<li><strong>Khai báo hàm:</strong></li>
</ul>
<pre><code class="language-javascript">function functionName(parameter1, parameter2, ...) {
    // Code thực hiện trong hàm
    // ...
    return value; // (tùy chọn, trả về giá trị)
}
</code></pre>
<ul>
<li><strong>Gọi hàm:</strong> <code>functionName(argument1, argument2, ...);</code></li>
</ul>
<p><strong>Ví dụ:</strong></p>
<pre><code class="language-javascript">function add(a, b) { // Hàm cộng hai số
    return a + b;
}

let sum = add(5, 3); // Gọi hàm add với đối số 5 và 3
console.log(sum); // 8
</code></pre>
<h3 id="tham-số-trong-hàm"><a class="header" href="#tham-số-trong-hàm">Tham số trong hàm</a></h3>
<p>Tham số (parameter) là biến được khai báo trong định nghĩa hàm, dùng để nhận giá trị đầu vào khi gọi hàm. Đối số (argument) là giá trị thực tế được truyền vào khi gọi hàm.</p>
<p><strong>Ví dụ:</strong> (ví dụ trên đã có tham số)</p>
<pre><code class="language-javascript">function greet(name) { // 'name' là tham số
    console.log(&quot;Xin chào, &quot; + name + &quot;!&quot;);
}

greet(&quot;Gemini&quot;); // &quot;Gemini&quot; là đối số
greet(&quot;User&quot;); // &quot;User&quot; là đối số
</code></pre>
<h3 id="return-trong-hàm-js"><a class="header" href="#return-trong-hàm-js">Return trong hàm JS</a></h3>
<p>Câu lệnh <code>return</code> trong hàm dùng để trả về một giá trị từ hàm. Hàm có thể trả về bất kỳ kiểu dữ liệu nào (số, chuỗi, mảng, object...). Nếu không có <code>return</code>, hàm trả về <code>undefined</code>.</p>
<p><strong>Ví dụ:</strong> (ví dụ hàm <code>add</code> và <code>greet</code> trên đã có return và không return)</p>
<pre><code class="language-javascript">function square(number) {
    return number * number; // Trả về bình phương của số
}

let result = square(4);
console.log(result); // 16

function sayHello() { // Không có return
    console.log(&quot;Hello!&quot;);
}

let greeting = sayHello();
console.log(greeting); // undefined (hàm không trả về gì)
</code></pre>
<h3 id="hiểu-hơn-về-function-trong-javascript"><a class="header" href="#hiểu-hơn-về-function-trong-javascript">Hiểu hơn về function trong JavaScript</a></h3>
<p>Hàm là first-class citizens trong JavaScript: có thể gán cho biến, truyền như đối số cho hàm khác, trả về từ hàm khác. Hàm có thể có tên (named function) hoặc không tên (anonymous function).</p>
<h3 id="các-loại-function-trong-javascript"><a class="header" href="#các-loại-function-trong-javascript">Các loại function trong JavaScript</a></h3>
<p>Các loại function trong JavaScript:</p>
<ul>
<li>
<p><strong>Named function:</strong> Hàm có tên, khai báo bằng từ khóa <code>function</code>. (ví dụ trên)</p>
</li>
<li>
<p><strong>Anonymous function:</strong> Hàm không tên, thường dùng gán cho biến hoặc làm callback.</p>
</li>
<li>
<p><strong>Arrow function (ES6):</strong> Cú pháp ngắn gọn hơn cho anonymous function.</p>
</li>
<li>
<p><strong>Ví dụ (Anonymous function và Arrow function):</strong></p>
</li>
</ul>
<pre><code class="language-javascript">// Anonymous function gán cho biến
let multiply = function(a, b) {
    return a * b;
};
console.log(multiply(3, 7)); // 21

// Arrow function (tương đương hàm multiply ở trên)
let multiplyArrow = (a, b) =&gt; a * b;
console.log(multiplyArrow(4, 6)); // 24

// Callback function (anonymous function truyền vào hàm khác)
setTimeout(function() {
    console.log(&quot;Hello after 1 second&quot;);
}, 1000);

// Callback function (arrow function)
setTimeout(() =&gt; {
    console.log(&quot;Hello again after 2 seconds&quot;);
}, 2000);
</code></pre>
<h3 id="object-trong-javascript"><a class="header" href="#object-trong-javascript">Object trong JavaScript</a></h3>
<p>Object (đối tượng) là kiểu dữ liệu phức tạp trong JavaScript, biểu diễn một thực thể có thuộc tính (properties) và phương thức (methods). Object là tập hợp các cặp key-value, key là chuỗi (hoặc Symbol), value có thể là bất kỳ kiểu dữ liệu nào. Object được khai báo bằng dấu ngoặc nhọn <code>{...}</code>.</p>
<p><strong>Ví dụ:</strong></p>
<pre><code class="language-javascript">let person = {
    name: &quot;Gemini&quot;, // Thuộc tính name
    age: 2,        // Thuộc tính age
    isRobot: true,  // Thuộc tính isRobot
    greet: function() { // Phương thức greet
        console.log(&quot;Xin chào, tôi là &quot; + this.name);
    }
};

console.log(person.name); // &quot;Gemini&quot; (truy cập thuộc tính bằng dấu chấm)
console.log(person[&quot;age&quot;]); // 2 (truy cập thuộc tính bằng dấu ngoặc vuông)
person.greet(); // Gọi phương thức greet
</code></pre>
<h3 id="object-constructor-trong-javascript"><a class="header" href="#object-constructor-trong-javascript">Object constructor trong JavaScript</a></h3>
<p>Object constructor (hàm tạo đối tượng) là hàm đặc biệt dùng để tạo ra các object cùng loại (cùng cấu trúc thuộc tính và phương thức). Dùng từ khóa <code>new</code> để gọi constructor.</p>
<p><strong>Ví dụ:</strong></p>
<pre><code class="language-javascript">function Dog(name, breed) { // Constructor Dog
    this.name = name;
    this.breed = breed;
    this.bark = function() {
        console.log(&quot;Woof!&quot;);
    };
}

let myDog = new Dog(&quot;Lucky&quot;, &quot;Golden Retriever&quot;); // Tạo object Dog bằng constructor
console.log(myDog.name); // &quot;Lucky&quot;
myDog.bark(); // Gọi phương thức bark
</code></pre>
<h3 id="object-prototypecơ-bản-trong-javascript"><a class="header" href="#object-prototypecơ-bản-trong-javascript">Object prototype(cơ bản) trong JavaScript</a></h3>
<p>Prototype là cơ chế kế thừa trong JavaScript. Mỗi object được tạo ra từ constructor có một prototype. Prototype là một object khác, chứa các thuộc tính và phương thức mà các object con kế thừa. Giúp tái sử dụng code, tiết kiệm bộ nhớ.</p>
<h3 id="date-object-trong-javascript"><a class="header" href="#date-object-trong-javascript">Date object trong JavaScript</a></h3>
<p>Date object (đối tượng Date) dùng để làm việc với ngày và giờ trong JavaScript. Tạo Date object bằng <code>new Date()</code>.</p>
<p><strong>Ví dụ:</strong></p>
<pre><code class="language-javascript">let now = new Date(); // Date object hiện tại
console.log(now); // In ra ngày giờ hiện tại

let specificDate = new Date(2025, 2, 26); // Date object cho ngày 26/03/2025 (tháng bắt đầu từ 0)
console.log(specificDate);

console.log(now.getFullYear()); // Lấy năm
console.log(now.getMonth()); // Lấy tháng (0-11)
console.log(now.getDate()); // Lấy ngày
console.log(now.getHours()); // Lấy giờ
console.log(now.getMinutes()); // Lấy phút
</code></pre>
<h2 id="phần-3-câu-lệnh-điều-khiển-và-vòng-lặp"><a class="header" href="#phần-3-câu-lệnh-điều-khiển-và-vòng-lặp">Phần 3: Câu lệnh điều khiển và Vòng lặp</a></h2>
<h3 id="câu-lệnh-rẽ-nhánh-if-else"><a class="header" href="#câu-lệnh-rẽ-nhánh-if-else">Câu lệnh rẽ nhánh If, else</a></h3>
<p>(Đã đề cập ở mục 15) Ôn lại và mở rộng về câu lệnh <code>if...else</code>, <code>else if</code>.</p>
<h3 id="câu-lệnh-rẽ-nhánh-switch-trong-javascript"><a class="header" href="#câu-lệnh-rẽ-nhánh-switch-trong-javascript">Câu lệnh rẽ nhánh Switch trong JavaScript</a></h3>
<p>Câu lệnh <code>switch...case</code> là một cách khác để rẽ nhánh chương trình dựa trên giá trị của một biểu thức. Thường dùng khi có nhiều trường hợp (case) có thể xảy ra.</p>
<p><strong>Ví dụ:</strong></p>
<pre><code class="language-javascript">let dayOfWeek = 3; // 1: Thứ Hai, 2: Thứ Ba, ..., 7: Chủ Nhật
let dayName;

switch (dayOfWeek) {
    case 1:
        dayName = &quot;Thứ Hai&quot;;
        break;
    case 2:
        dayName = &quot;Thứ Ba&quot;;
        break;
    case 3:
        dayName = &quot;Thứ Tư&quot;;
        break;
    case 4:
        dayName = &quot;Thứ Năm&quot;;
        break;
    case 5:
        dayName = &quot;Thứ Sáu&quot;;
        break;
    case 6:
        dayName = &quot;Thứ Bảy&quot;;
        break;
    case 7:
        dayName = &quot;Chủ Nhật&quot;;
        break;
    default:
        dayName = &quot;Không hợp lệ&quot;;
}

console.log(&quot;Hôm nay là &quot; + dayName); // Hôm nay là Thứ Tư
</code></pre>
<h3 id="toán-tử-3-ngôiternary-operator-trong-javascript"><a class="header" href="#toán-tử-3-ngôiternary-operator-trong-javascript">Toán tử 3 ngôi(ternary operator) trong JavaScript</a></h3>
<p>Toán tử 3 ngôi (ternary operator) <code>condition ? valueIfTrue : valueIfFalse</code> là cú pháp rút gọn của câu lệnh <code>if...else</code> khi chỉ có một điều kiện và trả về một trong hai giá trị.</p>
<p><strong>Ví dụ:</strong></p>
<pre><code class="language-javascript">let age = 15;
let message = age &gt;= 18 ? &quot;Đủ tuổi&quot; : &quot;Chưa đủ tuổi&quot;; // Toán tử 3 ngôi
console.log(message); // &quot;Chưa đủ tuổi&quot;

// Tương đương với if...else:
let message2;
if (age &gt;= 18) {
    message2 = &quot;Đủ tuổi&quot;;
} else {
    message2 = &quot;Chưa đủ tuổi&quot;;
}
console.log(message2); // &quot;Chưa đủ tuổi&quot;
</code></pre>
<h3 id="vòng-lặp-trong-javascript"><a class="header" href="#vòng-lặp-trong-javascript">Vòng lặp trong JavaScript</a></h3>
<p>Vòng lặp (loop) dùng để lặp đi lặp lại một khối code nhiều lần. Các loại vòng lặp trong JavaScript:</p>
<ul>
<li><code>for</code> loop.</li>
<li><code>for...in</code> loop (lặp qua thuộc tính của object).</li>
<li><code>for...of</code> loop (lặp qua giá trị của iterable object - mảng, chuỗi...).</li>
<li><code>while</code> loop.</li>
<li><code>do...while</code> loop.</li>
</ul>
<h3 id="vòng-lặp-for-trong-javascript"><a class="header" href="#vòng-lặp-for-trong-javascript">Vòng lặp For trong JavaScript</a></h3>
<p><code>for</code> loop có cú pháp: <code>for (initialization; condition; increment/decrement) { ... }</code></p>
<ul>
<li><code>initialization</code>: Khởi tạo biến đếm (chạy một lần đầu tiên).</li>
<li><code>condition</code>: Điều kiện lặp (kiểm tra trước mỗi lần lặp, nếu <code>true</code> thì lặp tiếp, <code>false</code> thì dừng).</li>
<li><code>increment/decrement</code>: Tăng/giảm biến đếm sau mỗi lần lặp.</li>
</ul>
<p><strong>Ví dụ:</strong></p>
<pre><code class="language-javascript">for (let i = 1; i &lt;= 5; i++) { // Lặp 5 lần, i từ 1 đến 5
    console.log(&quot;Lần lặp thứ &quot; + i);
}
</code></pre>
<p><code>for...in</code> loop lặp qua <strong>thuộc tính (key)</strong> của một object.</p>
<p><strong>Ví dụ:</strong></p>
<pre><code class="language-javascript">let person = {
    name: &quot;Gemini&quot;,
    age: 2,
    city: &quot;Internet&quot;
};

for (let key in person) { // Lặp qua key của object person
    console.log(key + &quot;: &quot; + person[key]);
}
// In ra:
// name: Gemini
// age: 2
// city: Internet
</code></pre>
<h3 id="vòng-lặp-forof-trong-javascript"><a class="header" href="#vòng-lặp-forof-trong-javascript">Vòng lặp For/of trong JavaScript</a></h3>
<p><code>for...of</code> loop lặp qua <strong>giá trị</strong> của một <strong>iterable object</strong> (mảng, chuỗi, Map, Set...).</p>
<p><strong>Ví dụ:</strong></p>
<pre><code class="language-javascript">let colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;];

for (let color of colors) { // Lặp qua giá trị của mảng colors
    console.log(color);
}
// In ra:
// red
// green
// blue

let message = &quot;Hello&quot;;
for (let char of message) { // Lặp qua ký tự của chuỗi message
    console.log(char);
}
// In ra:
// H
// e
// l
// l
// o
</code></pre>
<h3 id="vòng-lặp-while-trong-javascript"><a class="header" href="#vòng-lặp-while-trong-javascript">Vòng lặp While trong JavaScript</a></h3>
<p><code>while</code> loop lặp khi điều kiện còn đúng (<code>true</code>). Cú pháp: <code>while (condition) { ... }</code></p>
<p><strong>Ví dụ:</strong></p>
<pre><code class="language-javascript">let count = 1;
while (count &lt;= 5) { // Lặp khi count &lt;= 5
    console.log(&quot;Count: &quot; + count);
    count++; // Tăng count sau mỗi lần lặp
}
</code></pre>
<h3 id="vòng-lặp-dowhile-trong-javascript"><a class="header" href="#vòng-lặp-dowhile-trong-javascript">Vòng lặp Do/while trong JavaScript</a></h3>
<p><code>do...while</code> loop tương tự <code>while</code> loop, nhưng code trong block <code>do</code> được thực hiện <strong>ít nhất một lần</strong> trước khi kiểm tra điều kiện. Cú pháp: <code>do { ... } while (condition);</code></p>
<p><strong>Ví dụ:</strong></p>
<pre><code class="language-javascript">let num = 0;
do {
    console.log(&quot;Num: &quot; + num);
    num++;
} while (num &lt; 3); // Lặp khi num &lt; 3
// In ra:
// Num: 0
// Num: 1
// Num: 2
</code></pre>
<h3 id="break-và-continue-trong-vòng-lặp"><a class="header" href="#break-và-continue-trong-vòng-lặp">Break và Continue trong vòng lặp</a></h3>
<ul>
<li>
<p><strong>Tóm tắt:</strong></p>
</li>
<li>
<p><code>break</code>: Thoát khỏi vòng lặp ngay lập tức.</p>
</li>
<li>
<p><code>continue</code>: Bỏ qua lần lặp hiện tại và chuyển sang lần lặp tiếp theo.</p>
</li>
</ul>
<p><strong>Ví dụ:</strong></p>
<pre><code class="language-javascript">for (let i = 1; i &lt;= 10; i++) {
    if (i === 5) {
        break; // Thoát khỏi vòng lặp khi i = 5
    }
    console.log(&quot;i (break): &quot; + i); // In ra 1, 2, 3, 4
}

for (let j = 1; j &lt;= 5; j++) {
    if (j === 3) {
        continue; // Bỏ qua lần lặp khi j = 3
    }
    console.log(&quot;j (continue): &quot; + j); // In ra 1, 2, 4, 5 (bỏ qua 3)
}
</code></pre>
<h3 id="vòng-lặp-lồng-nhau-nested-loop"><a class="header" href="#vòng-lặp-lồng-nhau-nested-loop">Vòng lặp lồng nhau (Nested loop)</a></h3>
<p>Nested loop (vòng lặp lồng nhau) là vòng lặp bên trong vòng lặp khác. Thường dùng để xử lý dữ liệu đa chiều (ví dụ: ma trận, bảng).</p>
<p><strong>Ví dụ:</strong></p>
<pre><code class="language-javascript">for (let i = 1; i &lt;= 3; i++) { // Vòng lặp ngoài
    console.log(&quot;Vòng lặp ngoài lần &quot; + i);
    for (let j = 1; j &lt;= 2; j++) { // Vòng lặp trong (lặp 2 lần cho mỗi lần lặp ngoài)
        console.log(&quot;  Vòng lặp trong lần &quot; + j);
    }
}
// In ra:
// Vòng lặp ngoài lần 1
//   Vòng lặp trong lần 1
//   Vòng lặp trong lần 2
// Vòng lặp ngoài lần 2
//   Vòng lặp trong lần 1
//   Vòng lặp trong lần 2
// Vòng lặp ngoài lần 3
//   Vòng lặp trong lần 1
//   Vòng lặp trong lần 2
</code></pre>
<h3 id="ví-dụ-mở-rộng-về-vòng-lặp"><a class="header" href="#ví-dụ-mở-rộng-về-vòng-lặp">Ví dụ mở rộng về vòng lặp</a></h3>
<p>Tổng hợp các ví dụ phức tạp hơn về vòng lặp, có thể kết hợp với điều kiện, mảng, object... để giải quyết các bài toán thực tế.</p>
<h2 id="phần-4-làm-việc-với-mảng-nâng-cao"><a class="header" href="#phần-4-làm-việc-với-mảng-nâng-cao">Phần 4: Làm việc với Mảng nâng cao</a></h2>
<h3 id="làm-việc-với-mảng-trong-javascript-1"><a class="header" href="#làm-việc-với-mảng-trong-javascript-1">Làm việc với mảng trong JavaScript</a></h3>
<p>Tiếp tục về Array methods, giới thiệu các phương thức quan trọng để thao tác và xử lý mảng:</p>
<ul>
<li><code>concat(array2, array3, ...)</code>: Nối mảng với các mảng khác.</li>
<li><code>join(separator)</code>: Nối các phần tử mảng thành chuỗi, phân tách bằng separator.</li>
<li><code>slice(startIndex, endIndex)</code>: Trả về mảng con từ startIndex đến endIndex (không bao gồm endIndex).</li>
<li><code>splice(startIndex, deleteCount, item1, item2, ...)</code>: (Đã đề cập ở mục 24) Xóa và/hoặc thêm phần tử tại vị trí bất kỳ.</li>
<li><code>sort()</code>: Sắp xếp mảng (mặc định theo thứ tự bảng chữ cái hoặc số tăng dần). Cần custom function để sắp xếp số đúng cách.</li>
<li><code>reverse()</code>: Đảo ngược mảng.</li>
</ul>
<p><strong>Ví dụ:</strong></p>
<pre><code class="language-javascript">let arr1 = [1, 2, 3];
let arr2 = [4, 5, 6];
let combinedArray = arr1.concat(arr2); // Nối mảng
console.log(combinedArray); // [1, 2, 3, 4, 5, 6]

let fruits = [&quot;apple&quot;, &quot;banana&quot;, &quot;orange&quot;];
let fruitString = fruits.join(&quot;, &quot;); // Nối thành chuỗi
console.log(fruitString); // &quot;apple, banana, orange&quot;

let numbers = [1, 5, 2, 8, 3];
numbers.sort(); // Sắp xếp (mặc định theo chuỗi) -&gt; [1, 2, 3, 5, 8]
numbers.sort((a, b) =&gt; a - b); // Sắp xếp số tăng dần
console.log(numbers); // [1, 2, 3, 5, 8]
numbers.reverse(); // Đảo ngược mảng
console.log(numbers); // [8, 5, 3, 2, 1]
</code></pre>
<h3 id="array-map-method-trong-javascript"><a class="header" href="#array-map-method-trong-javascript">Array map method trong JavaScript</a></h3>
<p><code>map()</code> method tạo ra một <strong>mảng mới</strong> bằng cách gọi một function (callback) cho <strong>mỗi phần tử</strong> của mảng ban đầu. Callback function nhận vào phần tử hiện tại và trả về giá trị mới cho phần tử tương ứng trong mảng mới.</p>
<p><strong>Ví dụ:</strong></p>
<pre><code class="language-javascript">let numbers = [1, 2, 3, 4, 5];
let squaredNumbers = numbers.map(function(number) { // map() với anonymous function
    return number * number; // Bình phương mỗi số
});
console.log(squaredNumbers); // [1, 4, 9, 16, 25]

// Sử dụng arrow function cho ngắn gọn hơn:
let doubledNumbers = numbers.map(number =&gt; number * 2); // Nhân đôi mỗi số
console.log(doubledNumbers); // [2, 4, 6, 8, 10]
</code></pre>
<h3 id="phương-thức-reduce-khi-làm-việc-với-array"><a class="header" href="#phương-thức-reduce-khi-làm-việc-với-array">Phương thức reduce khi làm việc với array</a></h3>
<p><code>reduce()</code> method thực hiện một callback function &quot;reducer&quot; trên mỗi phần tử của mảng, và trả về một <strong>giá trị duy nhất</strong> (không phải mảng mới như <code>map()</code>). Thường dùng để tính tổng, tích, hoặc gom nhóm dữ liệu trong mảng.</p>
<ul>
<li>
<p><strong>Callback function của <code>reduce()</code> nhận 2 tham số chính:</strong></p>
</li>
<li>
<p><code>accumulator</code> (giá trị tích lũy): Giá trị được trả về từ lần gọi callback trước đó (hoặc <code>initialValue</code> nếu được cung cấp).</p>
</li>
<li>
<p><code>currentValue</code> (giá trị hiện tại): Phần tử mảng đang được xử lý.</p>
</li>
<li>
<p><strong>Cú pháp:</strong> <code>array.reduce(reducerFunction, initialValue);</code> (<code>initialValue</code> là giá trị khởi tạo cho <code>accumulator</code>, tùy chọn).</p>
</li>
<li>
<p><strong>Ví dụ (tính tổng mảng):</strong></p>
</li>
</ul>
<pre><code class="language-javascript">let numbers = [1, 2, 3, 4, 5];
let sum = numbers.reduce(function(accumulator, currentValue) { // reduce() với anonymous function
    return accumulator + currentValue; // Cộng dồn vào accumulator
}, 0); // initialValue = 0 (tổng ban đầu = 0)
console.log(sum); // 15 (tổng các số trong mảng)

// Sử dụng arrow function:
let product = numbers.reduce((accumulator, currentValue) =&gt; accumulator * currentValue, 1); // Tính tích
console.log(product); // 120 (tích các số trong mảng)
</code></pre>
<h3 id="phương-thức-reduce-khi-làm-việc-với-array---phần-2"><a class="header" href="#phương-thức-reduce-khi-làm-việc-với-array---phần-2">Phương thức reduce khi làm việc với array - phần 2</a></h3>
<p>Tiếp tục về <code>reduce()</code>, có thể đi sâu vào các ứng dụng phức tạp hơn như gom nhóm đối tượng trong mảng, flatten mảng đa chiều...</p>
<h3 id="phương-thức-includes"><a class="header" href="#phương-thức-includes">Phương thức includes</a></h3>
<p><code>includes()</code> method kiểm tra xem một chuỗi có chứa một substring (với chuỗi) hoặc một mảng có chứa một phần tử (với mảng) hay không. Trả về <code>true</code> nếu có, <code>false</code> nếu không.</p>
<p><strong>Ví dụ:</strong></p>
<pre><code class="language-javascript">let message = &quot;Hello World&quot;;
console.log(message.includes(&quot;World&quot;)); // true (chuỗi message chứa &quot;World&quot;)
console.log(message.includes(&quot;JavaScript&quot;)); // false

let fruits = [&quot;apple&quot;, &quot;banana&quot;, &quot;orange&quot;];
console.log(fruits.includes(&quot;banana&quot;)); // true (mảng fruits chứa &quot;banana&quot;)
console.log(fruits.includes(&quot;grape&quot;)); // false
</code></pre>
<h3 id="Đối-tượng-math"><a class="header" href="#Đối-tượng-math">Đối tượng math</a></h3>
<p>Math object là built-in object cung cấp các hằng số toán học và hàm toán học. Không cần tạo instance (không dùng <code>new Math()</code>). Truy cập trực tiếp qua <code>Math.property</code> hoặc <code>Math.method()</code>.</p>
<ul>
<li><strong>Hằng số:</strong> <code>Math.PI</code> (số Pi), <code>Math.E</code> (số e), ...</li>
<li><strong>Hàm:</strong> <code>Math.random()</code>, <code>Math.floor()</code>, <code>Math.ceil()</code>, <code>Math.round()</code>, <code>Math.max()</code>, <code>Math.min()</code>, <code>Math.pow()</code>, <code>Math.sqrt()</code>, ... (đã đề cập một số ở mục 22).</li>
</ul>
<p><strong>Ví dụ:</strong></p>
<pre><code class="language-javascript">console.log(Math.PI); // 3.141592653589793 (số Pi)
console.log(Math.sqrt(25)); // 5 (căn bậc hai)
console.log(Math.pow(2, 3)); // 8 (2 mũ 3)
console.log(Math.round(4.6)); // 5 (làm tròn gần nhất)
</code></pre>
<h3 id="hiểu-về-javascript-callback-functions"><a class="header" href="#hiểu-về-javascript-callback-functions">Hiểu về Javascript Callback Functions</a></h3>
<p>Callback function (hàm callback) là hàm được truyền vào làm đối số của một hàm khác, và sẽ được gọi lại (callback) sau khi hàm cha thực hiện xong một tác vụ nào đó (thường là tác vụ bất đồng bộ - asynchronous). Dùng nhiều trong xử lý sự kiện, AJAX, Promises...</p>
<ul>
<li><strong>Ví dụ (setTimeout với callback):</strong></li>
</ul>
<pre><code class="language-javascript">function doSomething(callback) { // Hàm doSomething nhận callback làm đối số
    console.log(&quot;Bắt đầu tác vụ...&quot;);
    setTimeout(function() { // Giả lập tác vụ bất đồng bộ (ví dụ: gọi API)
        console.log(&quot;Tác vụ hoàn thành!&quot;);
        callback(); // Gọi callback function sau khi tác vụ xong
    }, 2000);
}

doSomething(function() { // Truyền anonymous function làm callback
    console.log(&quot;Callback được gọi!&quot;);
});
</code></pre>
<h3 id="callback-trong-javascript"><a class="header" href="#callback-trong-javascript">Callback trong JavaScript</a></h3>
<p>Tiếp tục về callback, có thể đi sâu vào callback hell (callback lồng nhau quá sâu, code khó đọc, khó bảo trì) và cách khắc phục (Promises, async/await).</p>
<h3 id="xây-dựng-phương-thức-làm-việc-với-array"><a class="header" href="#xây-dựng-phương-thức-làm-việc-với-array">Xây dựng phương thức làm việc với array</a></h3>
<p>Có thể nói về việc tạo custom array methods (phương thức mảng tự định nghĩa) bằng cách thêm phương thức vào <code>Array.prototype</code>. Tuy nhiên, cách này ít dùng hiện nay vì có thể xung đột với các phương thức chuẩn hoặc thư viện khác. Nên ưu tiên dùng các phương thức mảng có sẵn.</p>
<h3 id="xây-dựng-phương-thức-foreach"><a class="header" href="#xây-dựng-phương-thức-foreach">Xây dựng phương thức forEach</a></h3>
<p><code>forEach()</code> method lặp qua từng phần tử của mảng và thực hiện callback function cho mỗi phần tử. Tương tự <code>for...of</code> loop, nhưng ngắn gọn hơn. Không tạo mảng mới, không trả về giá trị, chỉ thực hiện side effects (ví dụ: in ra console, sửa đổi mảng gốc...).</p>
<p><strong>Ví dụ:</strong></p>
<pre><code class="language-javascript">let colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;];
colors.forEach(function(color) { // forEach() với anonymous function
    console.log(&quot;Màu: &quot; + color);
});

// Sử dụng arrow function:
colors.forEach(color =&gt; console.log(&quot;Màu (arrow): &quot; + color));
</code></pre>
<h3 id="xây-dựng-phương-thức-filter"><a class="header" href="#xây-dựng-phương-thức-filter">Xây dựng phương thức filter</a></h3>
<p><code>filter()</code> method tạo ra một <strong>mảng mới</strong> chứa các phần tử thỏa mãn một điều kiện nào đó (được kiểm tra bởi callback function). Callback function trả về <code>true</code> nếu phần tử thỏa mãn điều kiện, <code>false</code> nếu không.</p>
<p><strong>Ví dụ:</strong></p>
<pre><code class="language-javascript">let numbers = [1, 2, 3, 4, 5, 6];
let evenNumbers = numbers.filter(function(number) { // filter() với anonymous function
    return number % 2 === 0; // Điều kiện: số chẵn
});
console.log(evenNumbers); // [2, 4, 6] (mảng mới chỉ chứa số chẵn)

// Sử dụng arrow function:
let oddNumbers = numbers.filter(number =&gt; number % 2 !== 0); // Lọc số lẻ
console.log(oddNumbers); // [1, 3, 5]
</code></pre>
<h3 id="xây-dựng-phương-thức-some"><a class="header" href="#xây-dựng-phương-thức-some">Xây dựng phương thức some</a></h3>
<p><code>some()</code> method kiểm tra xem <strong>ít nhất một</strong> phần tử trong mảng có thỏa mãn điều kiện (callback function) hay không. Trả về <code>true</code> nếu có ít nhất một phần tử thỏa mãn, <code>false</code> nếu không có phần tử nào thỏa mãn.</p>
<p><strong>Ví dụ:</strong></p>
<pre><code class="language-javascript">let numbers = [1, 2, 3, 4, 5];
let hasEvenNumber = numbers.some(function(number) { // some() với anonymous function
    return number % 2 === 0; // Điều kiện: số chẵn
});
console.log(hasEvenNumber); // true (mảng numbers có số chẵn)

let allOddNumbers = numbers.some(number =&gt; number % 2 !== 0); // Kiểm tra có số lẻ không
console.log(allOddNumbers); // true
</code></pre>
<h3 id="xây-dựng-phương-thức-every"><a class="header" href="#xây-dựng-phương-thức-every">Xây dựng phương thức every</a></h3>
<p><code>every()</code> method kiểm tra xem <strong>tất cả</strong> phần tử trong mảng có thỏa mãn điều kiện (callback function) hay không. Trả về <code>true</code> nếu <strong>tất cả</strong> phần tử thỏa mãn, <code>false</code> nếu có ít nhất một phần tử không thỏa mãn.</p>
<p><strong>Ví dụ:</strong></p>
<pre><code class="language-javascript">let numbers = [2, 4, 6, 8];
let allEvenNumbers = numbers.every(function(number) { // every() với anonymous function
    return number % 2 === 0; // Điều kiện: số chẵn
});
console.log(allEvenNumbers); // true (tất cả số trong mảng đều chẵn)

let allPositiveNumbers = numbers.every(number =&gt; number &gt; 0); // Kiểm tra tất cả số dương
console.log(allPositiveNumbers); // true
</code></pre>
<h3 id="Đệ-quy-là-gì-học-về-đệ-quy-trong-javascript"><a class="header" href="#Đệ-quy-là-gì-học-về-đệ-quy-trong-javascript">Đệ quy là gì? Học về đệ quy trong JavaScript</a></h3>
<p>Đệ quy (recursion) là kỹ thuật lập trình mà một hàm tự gọi lại chính nó. Dùng để giải quyết các bài toán có cấu trúc lặp lại, hoặc bài toán có thể chia nhỏ thành các bài toán con tương tự. Cần có điều kiện dừng (base case) để tránh lặp vô hạn.</p>
<ul>
<li><strong>Ví dụ (tính giai thừa):</strong></li>
</ul>
<pre><code class="language-javascript">function factorial(n) {
    if (n === 0) { // Base case: giai thừa của 0 là 1
        return 1;
    } else {
        return n * factorial(n - 1); // Gọi lại hàm factorial với n-1 (đệ quy)
    }
}

console.log(factorial(5)); // 120 (5! = 5 * 4 * 3 * 2 * 1)
</code></pre>
<h2 id="phần-5-dom-và-events"><a class="header" href="#phần-5-dom-và-events">Phần 5: DOM và Events</a></h2>
<h3 id="html-dom-là-gì"><a class="header" href="#html-dom-là-gì">HTML DOM là gì?</a></h3>
<p>HTML DOM (Document Object Model) là mô hình biểu diễn cấu trúc HTML dưới dạng cây các đối tượng (nodes). JavaScript có thể truy cập và thao tác với DOM để thay đổi nội dung, cấu trúc, style của trang web.</p>
<h3 id="html-dom-và-dom-api-là-gì"><a class="header" href="#html-dom-và-dom-api-là-gì">HTML DOM và DOM API là gì?</a></h3>
<p>DOM API (Application Programming Interface) là tập hợp các đối tượng, thuộc tính, phương thức do trình duyệt cung cấp để JavaScript tương tác với DOM. Ví dụ: <code>document.getElementById()</code>, <code>element.innerHTML</code>, <code>element.style.color</code>, <code>element.addEventListener()</code>.</p>
<h3 id="dom-document-object-trong-javascript"><a class="header" href="#dom-document-object-trong-javascript">DOM Document Object trong JavaScript</a></h3>
<p><code>document</code> object là entry point (điểm bắt đầu) để truy cập DOM từ JavaScript. Đại diện cho toàn bộ trang HTML. Các phương thức và thuộc tính của <code>document</code> cho phép truy cập và thao tác với các phần tử HTML trên trang.</p>
<h3 id="lấy-element-trong-dom"><a class="header" href="#lấy-element-trong-dom">Lấy element trong DOM</a></h3>
<p>Các phương thức chính để lấy element (phần tử HTML) từ DOM:</p>
<ul>
<li><code>document.getElementById(id)</code>: Lấy element có <code>id</code> attribute tương ứng (trả về 1 element hoặc <code>null</code>).</li>
<li><code>document.getElementsByClassName(className)</code>: Lấy danh sách (HTMLCollection) các element có <code>class</code> attribute tương ứng (trả về HTMLCollection rỗng nếu không tìm thấy).</li>
<li><code>document.getElementsByTagName(tagName)</code>: Lấy danh sách (HTMLCollection) các element có tag name tương ứng (ví dụ: &quot;p&quot;, &quot;div&quot;, &quot;a&quot;...) (trả về HTMLCollection rỗng nếu không tìm thấy).</li>
<li><code>document.querySelector(selector)</code>: Lấy <strong>element đầu tiên</strong> phù hợp với CSS selector (trả về 1 element hoặc <code>null</code>).</li>
<li><code>document.querySelectorAll(selector)</code>: Lấy danh sách (NodeList) <strong>tất cả</strong> element phù hợp với CSS selector (trả về NodeList rỗng nếu không tìm thấy). Nên dùng <code>querySelector</code> và <code>querySelectorAll</code> vì linh hoạt hơn (dùng CSS selector).</li>
</ul>
<p><strong>Ví dụ:</strong></p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Ví dụ DOM Get Element&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h1 id=&quot;title&quot;&gt;Tiêu đề chính&lt;/h1&gt;
    &lt;p class=&quot;paragraph&quot;&gt;Đoạn văn 1.&lt;/p&gt;
    &lt;p class=&quot;paragraph&quot;&gt;Đoạn văn 2.&lt;/p&gt;
    &lt;ul&gt;
        &lt;li&gt;Item 1&lt;/li&gt;
        &lt;li&gt;Item 2&lt;/li&gt;
    &lt;/ul&gt;
    &lt;div id=&quot;container&quot;&gt;
        &lt;button&gt;Click me&lt;/button&gt;
    &lt;/div&gt;

    &lt;script&gt;
        let titleElement = document.getElementById(&quot;title&quot;); // Lấy theo ID
        console.log(titleElement); // &lt;h1 id=&quot;title&quot;&gt;...&lt;/h1&gt;

        let paragraphElements = document.getElementsByClassName(&quot;paragraph&quot;); // Lấy theo class
        console.log(paragraphElements); // HTMLCollection [p.paragraph, p.paragraph]

        let liElements = document.getElementsByTagName(&quot;li&quot;); // Lấy theo tag name
        console.log(liElements); // HTMLCollection [li, li]

        let firstParagraph = document.querySelector(&quot;.paragraph&quot;); // Lấy element đầu tiên theo CSS selector
        console.log(firstParagraph); // &lt;p class=&quot;paragraph&quot;&gt;...&lt;/p&gt;

        let allParagraphs = document.querySelectorAll(&quot;.paragraph&quot;); // Lấy tất cả element theo CSS selector
        console.log(allParagraphs); // NodeList [p.paragraph, p.paragraph]
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="lấy-element-trong-dom-1"><a class="header" href="#lấy-element-trong-dom-1">Lấy element trong DOM</a></h3>
<p>Tiếp tục về các phương thức lấy element, có thể tập trung vào <code>querySelector</code> và <code>querySelectorAll</code> và các loại CSS selector có thể dùng (class, id, tag name, attribute selectors, pseudo-classes...).</p>
<h3 id="lấy-element-trong-dom-2"><a class="header" href="#lấy-element-trong-dom-2">Lấy element trong DOM</a></h3>
<p>Có thể đi sâu vào performance khi chọn element, cách tối ưu selector, và sự khác biệt giữa HTMLCollection và NodeList (HTMLCollection là live collection - tự động cập nhật khi DOM thay đổi, NodeList có thể là static hoặc live tùy phương thức lấy).</p>
<h3 id="attribute-node-và-text-node-trong-html-dom"><a class="header" href="#attribute-node-và-text-node-trong-html-dom">Attribute node và Text node trong HTML DOM</a></h3>
<p>Trong DOM tree, mỗi element HTML là một element node. Bên trong element node có thể có attribute nodes (thuộc tính HTML) và text nodes (nội dung text).</p>
<h3 id="dom-attribute"><a class="header" href="#dom-attribute">DOM attribute</a></h3>
<p>DOM API cung cấp các phương thức để thao tác với attribute nodes:</p>
<ul>
<li><code>element.getAttribute(attributeName)</code>: Lấy giá trị attribute.</li>
<li><code>element.setAttribute(attributeName, value)</code>: Sửa đổi hoặc thêm attribute.</li>
<li><code>element.removeAttribute(attributeName)</code>: Xóa attribute.</li>
<li><code>element.hasAttribute(attributeName)</code>: Kiểm tra xem element có attribute không.</li>
</ul>
<p><strong>Ví dụ:</strong></p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Ví dụ DOM Attribute&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;a id=&quot;link&quot; href=&quot;https://f8.edu.vn&quot; target=&quot;_blank&quot;&gt;F8&lt;/a&gt;

    &lt;script&gt;
        let linkElement = document.getElementById(&quot;link&quot;);
        console.log(linkElement.getAttribute(&quot;href&quot;)); // &quot;https://f8.edu.vn&quot;
        linkElement.setAttribute(&quot;title&quot;, &quot;Học lập trình tại F8&quot;); // Thêm attribute title
        console.log(linkElement.getAttribute(&quot;title&quot;)); // &quot;Học lập trình tại F8&quot;
        linkElement.removeAttribute(&quot;target&quot;); // Xóa attribute target
        console.log(linkElement.hasAttribute(&quot;target&quot;)); // false
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="innertext--textcontent-property"><a class="header" href="#innertext--textcontent-property">InnerText &amp; textContent Property</a></h3>
<p><code>innerText</code> và <code>textContent</code> properties dùng để lấy hoặc set nội dung text của một element.</p>
<ul>
<li><code>innerText</code>: Chỉ lấy text &quot;hiển thị&quot; (sau khi render), không lấy text của các element ẩn (ví dụ: <code>display: none</code>).</li>
<li><code>textContent</code>: Lấy <strong>tất cả</strong> text content, kể cả text của element ẩn. Nên dùng <code>textContent</code> vì chuẩn hơn, nhất quán hơn.</li>
</ul>
<p><strong>Ví dụ:</strong></p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Ví dụ innerText &amp; textContent&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;content&quot;&gt;
        &lt;p&gt;Đoạn văn bản 1.&lt;/p&gt;
        &lt;p style=&quot;display: none;&quot;&gt;Đoạn văn bản 2 (ẩn).&lt;/p&gt;
    &lt;/div&gt;

    &lt;script&gt;
        let contentElement = document.getElementById(&quot;content&quot;);
        console.log(contentElement.innerText);
        // Đoạn văn bản 1.
        console.log(contentElement.textContent);
        // Đoạn văn bản 1.
        // Đoạn văn bản 2 (ẩn).
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="thêm-element-vào-element-trong-dom"><a class="header" href="#thêm-element-vào-element-trong-dom">Thêm element vào element trong DOM</a></h3>
<ul>
<li>
<p><strong>Tóm tắt:</strong></p>
</li>
<li>
<p><code>element.innerHTML</code>: Lấy hoặc set <strong>HTML content bên trong</strong> element (dạng chuỗi HTML). Có thể dùng để thêm HTML vào element.</p>
</li>
<li>
<p><code>element.outerHTML</code>: Lấy hoặc set <strong>HTML content của chính element và bên trong nó</strong> (dạng chuỗi HTML).</p>
</li>
</ul>
<p><strong>Ví dụ:</strong></p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Ví dụ innerHTML &amp; outerHTML&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;container&quot;&gt;
        &lt;p&gt;Đoạn văn bản ban đầu.&lt;/p&gt;
    &lt;/div&gt;

    &lt;script&gt;
        let containerElement = document.getElementById(&quot;container&quot;);
        console.log(containerElement.innerHTML); // &quot;&lt;p&gt;Đoạn văn bản ban đầu.&lt;/p&gt;&quot;

        containerElement.innerHTML = &quot;&lt;h2&gt;Tiêu đề mới&lt;/h2&gt;&lt;p&gt;Đoạn văn bản mới.&lt;/p&gt;&quot;; // Set HTML content mới
        console.log(containerElement.innerHTML);
        // &quot;&lt;h2&gt;Tiêu đề mới&lt;/h2&gt;&lt;p&gt;Đoạn văn bản mới.&lt;/p&gt;&quot;

        console.log(containerElement.outerHTML);
        // &quot;&lt;div id=&quot;container&quot;&gt;&lt;h2&gt;Tiêu đề mới&lt;/h2&gt;&lt;p&gt;Đoạn văn bản mới.&lt;/p&gt;&lt;/div&gt;&quot;
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="node-properties"><a class="header" href="#node-properties">Node properties</a></h3>
<p>Node properties (thuộc tính node) cung cấp thông tin về node trong DOM tree. Ví dụ:</p>
<ul>
<li><code>node.nodeName</code>: Tên node (tag name cho element node, &quot;#text&quot; cho text node...).</li>
<li><code>node.nodeType</code>: Loại node (1: element node, 3: text node...).</li>
<li><code>node.parentNode</code>: Node cha.</li>
<li><code>node.childNodes</code>: Danh sách node con (HTMLCollection/NodeList).</li>
<li><code>node.firstChild</code>, <code>node.lastChild</code>, <code>node.nextSibling</code>, <code>node.previousSibling</code>: Node con đầu, con cuối, node anh em kế tiếp, node anh em trước đó.</li>
</ul>
<h3 id="Đối-tượng-dom-style-trong-element-node"><a class="header" href="#Đối-tượng-dom-style-trong-element-node">Đối tượng DOM style trong Element node</a></h3>
<p><code>element.style</code> object cho phép truy cập và sửa đổi inline styles (style viết trực tiếp trong attribute <code>style</code>) của element từ JavaScript.</p>
<p><strong>Ví dụ:</strong></p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Ví dụ DOM Style&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;box&quot; style=&quot;background-color: lightblue; width: 200px; height: 100px;&quot;&gt;
        Khối hộp
    &lt;/div&gt;

    &lt;script&gt;
        let boxElement = document.getElementById(&quot;box&quot;);
        console.log(boxElement.style.backgroundColor); // &quot;lightblue&quot; (lấy style background-color)
        boxElement.style.color = &quot;red&quot;; // Set style color
        boxElement.style.border = &quot;2px solid black&quot;; // Set style border
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="classlist-property"><a class="header" href="#classlist-property">ClassList Property</a></h3>
<p><code>element.classList</code> property trả về một đối tượng <code>DOMTokenList</code> đại diện cho danh sách class của element. Cung cấp các phương thức để thao tác với class:</p>
<ul>
<li><code>classList.add(className)</code>: Thêm class.</li>
<li><code>classList.remove(className)</code>: Xóa class.</li>
<li><code>classList.toggle(className)</code>: Thêm class nếu chưa có, xóa class nếu đã có.</li>
<li><code>classList.contains(className)</code>: Kiểm tra xem element có class không.</li>
</ul>
<p><strong>Ví dụ:</strong></p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Ví dụ classList&lt;/title&gt;
    &lt;style&gt;
        .highlight {
            background-color: yellow;
            font-weight: bold;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;p id=&quot;text&quot;&gt;Đoạn văn bản.&lt;/p&gt;
    &lt;button id=&quot;toggleBtn&quot;&gt;Toggle Highlight&lt;/button&gt;

    &lt;script&gt;
        let textElement = document.getElementById(&quot;text&quot;);
        let toggleButton = document.getElementById(&quot;toggleBtn&quot;);

        toggleButton.addEventListener(&quot;click&quot;, function() {
            textElement.classList.toggle(&quot;highlight&quot;); // Toggle class &quot;highlight&quot;
        });
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="dom-events"><a class="header" href="#dom-events">DOM events</a></h3>
<p>DOM events (sự kiện DOM) là các hành động xảy ra trên trang web (click chuột, gõ phím, load trang...). JavaScript có thể lắng nghe (listen) và xử lý (handle) các sự kiện này để tạo tương tác.</p>
<h3 id="dom-events-example"><a class="header" href="#dom-events-example">DOM events example</a></h3>
<p>Ví dụ về các sự kiện DOM phổ biến:</p>
<ul>
<li>
<p><code>click</code>: Click chuột.</p>
</li>
<li>
<p><code>mouseover</code>, <code>mouseout</code>: Chuột di vào, di ra khỏi element.</p>
</li>
<li>
<p><code>keydown</code>, <code>keyup</code>: Phím được nhấn, phím được nhả.</p>
</li>
<li>
<p><code>submit</code>: Form được submit.</p>
</li>
<li>
<p><code>load</code>: Trang hoặc resource (ảnh, script...) đã load xong.</p>
</li>
<li>
<p><code>DOMContentLoaded</code>: DOM tree đã được parse xong.</p>
</li>
<li>
<p><strong>Ví dụ (sự kiện click):</strong></p>
</li>
</ul>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Ví dụ DOM Event&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;button id=&quot;myButton&quot;&gt;Click me&lt;/button&gt;
    &lt;p id=&quot;message&quot;&gt;&lt;/p&gt;

    &lt;script&gt;
        let buttonElement = document.getElementById(&quot;myButton&quot;);
        let messageElement = document.getElementById(&quot;message&quot;);

        buttonElement.addEventListener(&quot;click&quot;, function() { // Lắng nghe sự kiện click
            messageElement.textContent = &quot;Button đã được click!&quot;; // Xử lý sự kiện click
        });
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="preventdefault--stoppropagation"><a class="header" href="#preventdefault--stoppropagation">PreventDefault &amp; StopPropagation</a></h3>
<ul>
<li>
<p><strong>Tóm tắt:</strong></p>
</li>
<li>
<p><code>event.preventDefault()</code>: Ngăn chặn hành vi mặc định của sự kiện (ví dụ: ngăn link chuyển trang, ngăn form submit trang).</p>
</li>
<li>
<p><code>event.stopPropagation()</code>: Ngăn chặn sự kiện lan truyền lên các element cha (event bubbling).</p>
</li>
<li>
<p><strong>Ví dụ (<code>preventDefault</code> trên link):</strong></p>
</li>
</ul>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Ví dụ preventDefault&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;a href=&quot;https://f8.edu.vn&quot; id=&quot;link&quot;&gt;Link F8&lt;/a&gt;
    &lt;script&gt;
        let linkElement = document.getElementById(&quot;link&quot;);
        linkElement.addEventListener(&quot;click&quot;, function(event) {
            event.preventDefault(); // Ngăn link chuyển trang
            alert(&quot;Link click bị chặn!&quot;);
        });
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="event-listener"><a class="header" href="#event-listener">Event listener</a></h3>
<p>Event listener (bộ lắng nghe sự kiện) dùng để đăng ký (attach) một function (event handler) để xử lý một sự kiện trên một element.</p>
<ul>
<li><code>element.addEventListener(eventType, eventHandler, useCapture)</code>: Đăng ký event listener.</li>
<li><code>element.removeEventListener(eventType, eventHandler, useCapture)</code>: Gỡ bỏ event listener.</li>
</ul>
<pre><code class="language-js">const button = document.querySelector(&quot;.btn&quot;)
button.addEventListener(&quot;click&quot;, function(event) {
  console.log(&quot;Hello!&quot;);
})

// OR using Javascript one-liners
button.addEventListener(&quot;click&quot;, event =&gt; console.log(&quot;Hello!&quot;))
</code></pre>
<h2 id="phần-6-json-promise-es6"><a class="header" href="#phần-6-json-promise-es6">Phần 6: JSON, Promise, ES6+</a></h2>
<h3 id="json-là-gì-Được-sử-dụng-ra-sao-trong-js"><a class="header" href="#json-là-gì-Được-sử-dụng-ra-sao-trong-js">JSON là gì? Được sử dụng ra sao trong JS?</a></h3>
<p>JSON (JavaScript Object Notation) là định dạng dữ liệu text nhẹ, dễ đọc, dễ parse, dựa trên cú pháp object của JavaScript. Dùng phổ biến để trao đổi dữ liệu giữa server và client trong web development (ví dụ: API).</p>
<ul>
<li>
<p>Cấu trúc: key-value pairs, key là chuỗi, value có thể là string, number, boolean, null, array, object.</p>
</li>
<li>
<p>Ví dụ JSON:</p>
</li>
</ul>
<pre><code class="language-json">    {
        &quot;name&quot;: &quot;Gemini&quot;,
        &quot;age&quot;: 2,
        &quot;isRobot&quot;: true,
        &quot;skills&quot;: [&quot;learning&quot;, &quot;coding&quot;, &quot;talking&quot;]
    }
</code></pre>
<ul>
<li>
<p><strong>JavaScript built-in object <code>JSON</code> cung cấp:</strong></p>
</li>
<li>
<p><code>JSON.stringify(object)</code>: Chuyển đổi object JavaScript sang chuỗi JSON.</p>
</li>
<li>
<p><code>JSON.parse(jsonString)</code>: Chuyển đổi chuỗi JSON sang object JavaScript.</p>
</li>
</ul>
<p><strong>Ví dụ:</strong></p>
<pre><code class="language-javascript">let personObject = { name: &quot;Gemini&quot;, age: 2 };
let jsonString = JSON.stringify(personObject); // Chuyển object sang JSON string
console.log(jsonString); // '{&quot;name&quot;:&quot;Gemini&quot;,&quot;age&quot;:2}'

let parsedObject = JSON.parse(jsonString); // Chuyển JSON string sang object
console.log(parsedObject.name); // &quot;Gemini&quot;
</code></pre>
<h3 id="promise-sync-async-trong-javascript"><a class="header" href="#promise-sync-async-trong-javascript">Promise (sync async) trong JavaScript</a></h3>
<p>Promise là object đại diện cho kết quả (thành công hoặc thất bại) của một tác vụ <strong>bất đồng bộ</strong> (asynchronous) và có thể chưa hoàn thành ngay lập tức (ví dụ: gọi API, đọc file...). Giúp xử lý bất đồng bộ một cách dễ đọc, dễ quản lý hơn so với callback.</p>
<ul>
<li><strong>Trạng thái Promise:</strong>
<ul>
<li><code>pending</code> (chờ xử lý): Tác vụ chưa hoàn thành.</li>
<li><code>fulfilled</code> (thành công): Tác vụ hoàn thành thành công.</li>
<li><code>rejected</code> (thất bại): Tác vụ hoàn thành thất bại.</li>
</ul>
</li>
</ul>
<h3 id="promise-nỗi-đau"><a class="header" href="#promise-nỗi-đau">Promise (nỗi đau)</a></h3>
<p>Có thể nói về &quot;callback hell&quot; và tại sao Promise ra đời để giải quyết vấn đề callback hell. Promise giúp code bất đồng bộ dễ đọc, dễ maintain hơn bằng cách &quot;chaining&quot; các tác vụ bất đồng bộ tuần tự hoặc song song.</p>
<h3 id="promise-trong-javascript"><a class="header" href="#promise-trong-javascript">Promise trong Javascript</a></h3>
<p>Cách tạo Promise: <code>new Promise((resolve, reject) =&gt; { ... });</code></p>
<ul>
<li>
<p><code>resolve(value)</code>: Gọi khi tác vụ thành công, truyền giá trị kết quả.</p>
</li>
<li>
<p><code>reject(error)</code>: Gọi khi tác vụ thất bại, truyền lỗi.</p>
</li>
<li>
<p><strong>Cách xử lý kết quả Promise:</strong></p>
</li>
<li>
<p><code>.then(onFulfilled)</code>: Xử lý khi Promise fulfilled (thành công).</p>
</li>
<li>
<p><code>.catch(onRejected)</code>: Xử lý khi Promise rejected (thất bại).</p>
</li>
<li>
<p><code>.finally(onFinally)</code>: Thực hiện code sau khi Promise fulfilled hoặc rejected (không quan tâm kết quả), thường dùng để cleanup (ví dụ: tắt loading indicator).</p>
</li>
<li>
<p><strong>Ví dụ (Promise đơn giản):</strong></p>
</li>
</ul>
<pre><code class="language-javascript">let myPromise = new Promise((resolve, reject) =&gt; {
    setTimeout(function() {
        let success = true; // Giả lập tác vụ thành công/thất bại
        if (success) {
            resolve(&quot;Dữ liệu thành công!&quot;); // Gọi resolve khi thành công
        } else {
            reject(&quot;Lỗi xảy ra!&quot;); // Gọi reject khi thất bại
        }
    }, 2000);
});

myPromise.then(function(result) { // Xử lý khi thành công
    console.log(&quot;Thành công:&quot;, result); // &quot;Thành công: Dữ liệu thành công!&quot;
}).catch(function(error) { // Xử lý khi thất bại
    console.log(&quot;Lỗi:&quot;, error); // &quot;Lỗi: Lỗi xảy ra!&quot; (nếu success = false)
}).finally(function() { // Thực hiện sau khi Promise xong (dù thành công hay thất bại)
    console.log(&quot;Promise đã hoàn thành.&quot;);
});
</code></pre>
<h3 id="promise-chain"><a class="header" href="#promise-chain">Promise chain</a></h3>
<p>Promise chaining (chuỗi Promise) cho phép liên kết các tác vụ bất đồng bộ tuần tự. <code>.then()</code> có thể trả về một Promise mới, tạo thành chuỗi. Giúp xử lý các tác vụ phụ thuộc lẫn nhau một cách tuần tự.</p>
<ul>
<li><strong>Ví dụ (Promise chain):</strong></li>
</ul>
<pre><code class="language-javascript">function fetchData(url) {
    return new Promise((resolve, reject) =&gt; {
        // Giả lập fetch API
        setTimeout(function() {
            let data = &quot;Dữ liệu từ &quot; + url;
            resolve(data);
        }, 1000);
    });
}

fetchData(&quot;url1&quot;).then(function(data1) { // Gọi API 1
    console.log(&quot;Dữ liệu 1:&quot;, data1); // Xử lý dữ liệu 1
    return fetchData(&quot;url2&quot;); // Trả về Promise mới để gọi API 2
}).then(function(data2) { // Chạy khi Promise trả về từ .then() trước đó fulfilled
    console.log(&quot;Dữ liệu 2:&quot;, data2); // Xử lý dữ liệu 2
    return fetchData(&quot;url3&quot;); // Tiếp tục chain
}).then(function(data3) {
    console.log(&quot;Dữ liệu 3:&quot;, data3);
}).catch(function(error) { // Bắt lỗi nếu có lỗi ở bất kỳ Promise nào trong chuỗi
    console.log(&quot;Lỗi:&quot;, error);
});
</code></pre>
<h3 id="promise-methods-resolve-reject-all"><a class="header" href="#promise-methods-resolve-reject-all">Promise methods (resolve, reject, all)</a></h3>
<p>Các static methods của <code>Promise</code> object:</p>
<ul>
<li>
<p><code>Promise.resolve(value)</code>: Trả về một Promise đã fulfilled với giá trị <code>value</code>.</p>
</li>
<li>
<p><code>Promise.reject(error)</code>: Trả về một Promise đã rejected với lỗi <code>error</code>.</p>
</li>
<li>
<p><code>Promise.all(promises)</code>: Nhận vào một mảng các Promises, trả về một Promise mới fulfilled khi <strong>tất cả</strong> Promises trong mảng fulfilled, hoặc rejected ngay lập tức nếu có <strong>ít nhất một</strong> Promise rejected. Dùng để chạy các tác vụ bất đồng bộ song song và đợi tất cả hoàn thành.</p>
</li>
<li>
<p><strong>Ví dụ (<code>Promise.all</code>):</strong></p>
</li>
</ul>
<pre><code class="language-javascript">let promise1 = Promise.resolve(&quot;Promise 1 thành công&quot;);
let promise2 = new Promise(resolve =&gt; setTimeout(() =&gt; resolve(&quot;Promise 2 thành công&quot;), 1000));
let promise3 = Promise.resolve(&quot;Promise 3 thành công&quot;);

Promise.all([promise1, promise2, promise3]).then(function(results) { // Chạy song song, đợi tất cả xong
    console.log(&quot;Tất cả Promises thành công:&quot;, results); // [&quot;Promise 1 thành công&quot;, &quot;Promise 2 thành công&quot;, &quot;Promise 3 thành công&quot;]
}).catch(function(error) {
    console.log(&quot;Có lỗi:&quot;, error);
});
</code></pre>
<h3 id="học-về-javascript-ecmascript-6"><a class="header" href="#học-về-javascript-ecmascript-6">Học về JavaScript ECMAScript 6</a></h3>
<p>ECMAScript 6 (ES6) hoặc ES2015 là phiên bản JavaScript ra mắt năm 2015, giới thiệu nhiều tính năng mới, hiện đại, giúp code JavaScript mạnh mẽ và dễ viết hơn. Các tính năng ES6 quan trọng: <code>let</code>, <code>const</code>, arrow function, template literals, classes, modules, destructuring, spread operator...</p>
<p>Sẽ được cập nhật dần bên dưới </p>
<h3 id="let--const-keyword"><a class="header" href="#let--const-keyword">Let &amp; Const keyword</a></h3>
<p>(Đã đề cập ở mục 5) Ôn lại và so sánh <code>let</code> và <code>const</code> với <code>var</code>. Nên ưu tiên dùng <code>let</code> và <code>const</code> thay cho <code>var</code> vì có phạm vi block-scoped rõ ràng hơn, tránh lỗi hoisting.</p>
<h3 id="arrow-function-trong-javascript-es6"><a class="header" href="#arrow-function-trong-javascript-es6">Arrow function trong JavaScript ES6</a></h3>
<p>(Đã đề cập ở mục 29) Ôn lại arrow function, cú pháp ngắn gọn hơn cho anonymous function, đặc biệt hữu ích trong callback functions.</p>
<pre><code class="language-js">const multiplyByTwo = (num) =&gt; {
    return num * 2;
}
</code></pre>
<h3 id="template-literals-template-string-trong-javascript-es6"><a class="header" href="#template-literals-template-string-trong-javascript-es6">Template literals (Template string) trong javascript ES6</a></h3>
<p>Template literals (template string) dùng backtick `` để khai báo chuỗi, cho phép nhúng biến trực tiếp vào chuỗi bằng cú pháp <code>${variable}</code> (string interpolation), và hỗ trợ chuỗi nhiều dòng dễ dàng.</p>
<p><strong>Ví dụ:</strong></p>
<pre><code class="language-javascript">let name = &quot;Gemini&quot;;
let age = 2;
let message = `Xin chào, tôi là ${name}, ${age} tuổi.
Tôi là một robot.`; // Template literals, chuỗi nhiều dòng
console.log(message);
// Xin chào, tôi là Gemini, 2 tuổi.
// Tôi là một robot.
</code></pre>
<h3 id="classes-trong-javascript-es6"><a class="header" href="#classes-trong-javascript-es6">Classes trong JavaScript ES6</a></h3>
<p>Classes trong ES6 cung cấp cú pháp mới để định nghĩa object và kế thừa, gần gũi hơn với các ngôn ngữ hướng đối tượng khác (nhưng vẫn dựa trên prototype-based inheritance của JavaScript).</p>
<ul>
<li><strong>Ví dụ (Class cơ bản):</strong></li>
</ul>
<pre><code class="language-javascript">class Animal { // Định nghĩa class Animal
    constructor(name) { // Constructor
        this.name = name;
    }

    speak() { // Method speak
        console.log(this.name + &quot; makes a sound.&quot;);
    }
}

class Dog extends Animal { // Class Dog kế thừa từ Animal
    constructor(name, breed) {
        super(name); // Gọi constructor của class cha
        this.breed = breed;
    }

    bark() { // Method bark riêng của Dog
        console.log(&quot;Woof!&quot;);
    }
}

let animal = new Animal(&quot;Generic Animal&quot;);
animal.speak(); // &quot;Generic Animal makes a sound.&quot;

let dog = new Dog(&quot;Lucky&quot;, &quot;Golden Retriever&quot;);
dog.speak(); // &quot;Lucky makes a sound.&quot; (kế thừa từ Animal)
dog.bark(); // &quot;Woof!&quot; (method của Dog)
</code></pre>
<h3 id="enhanced-object-literals-trong-javascript-es6"><a class="header" href="#enhanced-object-literals-trong-javascript-es6">Enhanced object literals trong javascript ES6</a></h3>
<p>Enhanced object literals (object literals cải tiến) trong ES6 cung cấp cú pháp ngắn gọn hơn để tạo object:</p>
<ul>
<li>Shorthand property names: Nếu key và value có cùng tên biến, có thể viết tắt <code>key</code> thay vì <code>key: key</code>.</li>
<li>Method shorthand: Bỏ từ khóa <code>function</code> khi định nghĩa method trong object.</li>
<li>Computed property names: Key có thể là biểu thức được tính toán trong ngoặc vuông <code>[...]</code>.</li>
</ul>
<p><strong>Ví dụ:</strong></p>
<pre><code class="language-javascript">let name = &quot;Gemini&quot;;
let age = 2;

let person = {
    name, // Shorthand property name (tương đương name: name)
    age,  // Shorthand property name (tương đương age: age)
    greet() { // Method shorthand (bỏ function keyword)
        console.log(&quot;Xin chào, tôi là &quot; + this.name);
    },
    [&quot;skill&quot; + &quot;1&quot;]: &quot;learning&quot; // Computed property name (key được tính toán)
};

console.log(person.name); // &quot;Gemini&quot;
person.greet(); // &quot;Xin chào, tôi là Gemini&quot;
console.log(person.skill1); // &quot;learning&quot;
</code></pre>
<h3 id="default-parameter-values-trong-javascript-es6"><a class="header" href="#default-parameter-values-trong-javascript-es6">Default parameter values trong JavaScript ES6</a></h3>
<p>Default parameter values (giá trị tham số mặc định) trong ES6 cho phép gán giá trị mặc định cho tham số của hàm. Nếu khi gọi hàm không truyền đối số cho tham số đó, tham số sẽ nhận giá trị mặc định.</p>
<p><strong>Ví dụ:</strong></p>
<pre><code class="language-javascript">function greet(name = &quot;Guest&quot;) { // Tham số name có giá trị mặc định &quot;Guest&quot;
    console.log(&quot;Xin chào, &quot; + name + &quot;!&quot;);
}

greet(&quot;Gemini&quot;); // &quot;Xin chào, Gemini!&quot; (truyền đối số)
greet(); // &quot;Xin chào, Guest!&quot; (không truyền đối số, dùng giá trị mặc định)
</code></pre>
<h3 id="destructuring-trong-javascript-es6"><a class="header" href="#destructuring-trong-javascript-es6">Destructuring trong JavaScript ES6</a></h3>
<p>Destructuring (phân rã cấu trúc) trong ES6 cho phép &quot;giải nén&quot; giá trị từ mảng hoặc object vào các biến riêng biệt một cách ngắn gọn.</p>
<ul>
<li><strong>Ví dụ (destructuring mảng):</strong></li>
</ul>
<pre><code class="language-javascript">let colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;];
let [firstColor, secondColor, thirdColor] = colors; // Destructuring mảng

console.log(firstColor); // &quot;red&quot;
console.log(secondColor); // &quot;green&quot;
console.log(thirdColor); // &quot;blue&quot;
</code></pre>
<ul>
<li><strong>Ví dụ (destructuring object):</strong></li>
</ul>
<pre><code class="language-javascript">let person = { name: &quot;Gemini&quot;, age: 2, city: &quot;Internet&quot; };
let { name, age } = person; // Destructuring object (lấy thuộc tính name và age)

console.log(name); // &quot;Gemini&quot;
console.log(age); // 2
</code></pre>
<h3 id="spread-trong-javascript-es6"><a class="header" href="#spread-trong-javascript-es6">Spread trong JavaScript ES6</a></h3>
<p>Spread operator (<code>...</code>) trong ES6 có nhiều ứng dụng:</p>
<ul>
<li>
<p><strong>Copy mảng/object:</strong> Tạo bản sao nông (shallow copy) của mảng hoặc object.</p>
</li>
<li>
<p><strong>Nối mảng:</strong> Nối nhiều mảng thành một mảng mới.</p>
</li>
<li>
<p><strong>Truyền đối số hàm:</strong> Truyền các phần tử của mảng làm đối số riêng lẻ cho hàm.</p>
</li>
<li>
<p><strong>Rest parameters (tham số rest):</strong> Thu thập các đối số còn lại của hàm vào một mảng.</p>
</li>
<li>
<p><strong>Ví dụ (copy mảng, nối mảng):</strong></p>
</li>
</ul>
<pre><code class="language-javascript">let arr1 = [1, 2, 3];
let arr2 = [...arr1]; // Copy mảng arr1
console.log(arr2); // [1, 2, 3]
arr2.push(4); // Thay đổi arr2 không ảnh hưởng arr1 (shallow copy)
console.log(arr1); // [1, 2, 3]

let arr3 = [4, 5, 6];
let combinedArray = [...arr1, ...arr3]; // Nối mảng arr1 và arr3
console.log(combinedArray); // [1, 2, 3, 4, 5, 6]
</code></pre>
<h3 id="khái-niệm-tagged-template-literals-ít-người-biết"><a class="header" href="#khái-niệm-tagged-template-literals-ít-người-biết">Khái niệm tagged template literals (ít người biết)</a></h3>
<p>Tagged template literals là một tính năng nâng cao của template literals. Cho phép bạn định nghĩa một &quot;tag function&quot; để xử lý template literal theo cách tùy chỉnh. Ít dùng trong thực tế hàng ngày, nhưng hữu ích trong một số trường hợp đặc biệt (ví dụ: sanitizing input, i18n...).</p>
<h3 id="module-trong-javascript-es6"><a class="header" href="#module-trong-javascript-es6">Module trong JavaScript ES6</a></h3>
<p>Modules trong ES6 cho phép chia code JavaScript thành các file (module) riêng biệt, giúp code có cấu trúc tốt hơn, dễ tái sử dụng, dễ bảo trì.</p>
<ul>
<li><code>export</code>: Để export (xuất) các biến, hàm, class từ module.</li>
<li><code>import</code>: Để import (nhập) các module khác vào module hiện tại.</li>
</ul>
<p><strong>Ví dụ:</strong></p>
<ul>
<li><strong><code>module1.js</code> (module 1):</strong></li>
</ul>
<pre><code class="language-javascript">    export const message = &quot;Xin chào từ module 1!&quot;; // Export biến
    export function greet(name) { // Export hàm
        console.log(message + &quot; &quot; + name);
    }
</code></pre>
<ul>
<li><strong><code>main.js</code> (module chính):</strong></li>
</ul>
<pre><code class="language-javascript">    import { message, greet } from './module1.js'; // Import từ module1.js

    console.log(message); // &quot;Xin chào từ module 1!&quot;
    greet(&quot;User&quot;); // &quot;Xin chào từ module 1! User&quot;
</code></pre>
<ul>
<li><strong>Trong HTML, cần thêm <code>type=&quot;module&quot;</code> vào thẻ <code>&lt;script&gt;</code>:</strong></li>
</ul>
<pre><code class="language-html">    &lt;script type=&quot;module&quot; src=&quot;main.js&quot;&gt;&lt;/script&gt;
</code></pre>
<h3 id="khái-niệm-optional-chaining"><a class="header" href="#khái-niệm-optional-chaining">Khái niệm Optional chaining</a></h3>
<p>Optional chaining operator <code>?.</code> (ES2020+) giúp truy cập thuộc tính của object một cách an toàn, tránh lỗi khi object hoặc thuộc tính trung gian có thể <code>null</code> hoặc <code>undefined</code>. Nếu giá trị trước <code>?.</code> là <code>null</code> hoặc <code>undefined</code>, biểu thức trả về <code>undefined</code> ngay lập tức, không gây lỗi.</p>
<p><strong>Ví dụ:</strong></p>
<pre><code class="language-javascript">let user = {
    name: &quot;Gemini&quot;,
    address: {
        city: &quot;Internet&quot;
    }
};

console.log(user.address?.city); // &quot;Internet&quot; (truy cập an toàn, nếu address có tồn tại)
console.log(user.profile?.email); // undefined (user.profile không tồn tại, không lỗi)

// Không dùng optional chaining, có thể gây lỗi:
// console.log(user.profile.email); // Lỗi: Cannot read property 'email' of undefined
</code></pre>
<h3 id="fetch"><a class="header" href="#fetch">Fetch</a></h3>
<p>Fetch API là built-in API hiện đại trong JavaScript để thực hiện các request HTTP (gọi API) một cách bất đồng bộ (dựa trên Promise). Thay thế cho <code>XMLHttpRequest</code> cũ.</p>
<ul>
<li><strong>Ví dụ (GET request với Fetch API):</strong></li>
</ul>
<pre><code class="language-javascript">fetch('https://jsonplaceholder.typicode.com/todos/1') // Gọi API GET
    .then(response =&gt; response.json()) // Parse response body thành JSON (trả về Promise)
    .then(data =&gt; { // Chạy khi Promise từ response.json() fulfilled
        console.log(data); // In ra dữ liệu JSON
    })
    .catch(error =&gt; { // Bắt lỗi nếu có lỗi trong quá trình fetch hoặc parse JSON
        console.error(&quot;Lỗi fetch:&quot;, error);
    });
</code></pre>
<h3 id="json-server"><a class="header" href="#json-server">JSON server</a></h3>
<p>JSON Server là thư viện Node.js giúp tạo nhanh REST API giả lập từ file JSON. Dùng để test frontend, làm backend demo, học API... Cài đặt bằng npm: <code>npm install -g json-server</code>. Chạy server: <code>json-server --watch db.json</code>.</p>
<h3 id="phương-thức-reduce-có-logic-như-thế-nào"><a class="header" href="#phương-thức-reduce-có-logic-như-thế-nào">Phương thức reduce có logic như thế nào?</a></h3>
<p>(Đã đề cập ở mục 51, 52) Ôn lại và đi sâu hơn về logic hoạt động của <code>reduce()</code> method, cách accumulator và currentValue thay đổi qua mỗi lần lặp, và các ứng dụng khác nhau của <code>reduce()</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="bài-1-gioi-thieu-java-jvm-va-hellooo-world"><a class="header" href="#bài-1-gioi-thieu-java-jvm-va-hellooo-world">Bài 1: Giới thiệu Java, JVM và Hellooo world</a></h1>
<p>Đọc bài gốc của Loda đi nhá, cái này chỉ ghi lại một số ý để cho mình quay lại tham khảo thôi.</p>
<h3 id="cài-đặt-môi-trường"><a class="header" href="#cài-đặt-môi-trường">Cài đặt môi trường</a></h3>
<p><code>Java</code> hoạt động như vậy, nó chỉ nói 1 ngôn ngữ duy nhất thôi, tuy nhiên nó có một thằng anh bá đạo, tên ông ý nôm na là môi trường ảo hay tên chuẩn là <code>Java virtual machine (JVM)</code>. Nhiệm vụ của <code>JVM</code> là nó phụ đề (thuyết minh) cho từng loại OS khác nhau rằng thằng <code>Java</code> đang làm gì, nói gì, làm gì.</p>
<p>Vì chúng ta là Developer nên sẽ cài gói <code>JDK</code> (<code>Java Development Kit</code>), nó chứa các công cụ giúp lập trình <code>Java</code>. Ngoài ra trong quá trình cài, nó sẽ cài môi trường <code>JRE</code> (<code>Java Runtime Enviroment</code>, bao gồm cả thằng <code>JVM</code> ở trên) luôn.</p>
<h3 id="hello-world"><a class="header" href="#hello-world">Hello World</a></h3>
<p>Tạo Project trong Intellij chẳng hạn, xong rồi thì cùng nhìn vào cấu trúc của project thì sẽ thấy có 3 thư mục:</p>
<ul>
<li><code>.idea</code>: Thằng này là thư mục do <code>Intellij</code> tự tạo ra để chứa các file config của phần mềm này, bạn sẽ k cần quan tâm đến.</li>
<li><code>src</code>: Đây là thư mục chính bạn sẽ làm việc, tất cả <code>code</code> bạn để trong này</li>
<li><code>{project-name}.iml</code>: File này cũng do <code>Intellj</code> tạo ra và quản lý module, bạn không cần quan tâm nó.</li>
</ul>
<h3 id="một-số-thông-tin-khác"><a class="header" href="#một-số-thông-tin-khác">Một số thông tin khác</a></h3>
<ul>
<li><code>public static void main(String[] args)</code>: (Gọi tắt là <code>psvm</code> nhé) Cái thằng này sẽ là nơi <code>Java</code> tìm tới đầu tiên, và đọc toàn bộ các đoạn code trong cái thằng tên là <code>psvm</code> này. Dù nó ở bất cứ đâu, nó sẽ được tìm tới.</li>
<li>2 cái dấu <code>{``}</code>: Đánh dấu đoạn bắt đầu và kết thúc của cái <code>public static void main(String[] args)</code> kia.</li>
</ul>
<p>Vậy là thằng <code>Java</code> sẽ đi lùng tìm, xem cái thằng <code>psvm</code> xem nó ở đâu. Rồi đọc hết tất cả những thứ nằm trong cái 2 dấu <code>{``}</code> của thằng này.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bien-phạm-vi-kiểu-dữ-liệu-toán-tử-trong-java"><a class="header" href="#bien-phạm-vi-kiểu-dữ-liệu-toán-tử-trong-java">Biến, phạm vi, kiểu dữ liệu, toán tử trong Java</a></h1>
<h3 id="biến--kiểu-dữ-liệu"><a class="header" href="#biến--kiểu-dữ-liệu">Biến &amp; Kiểu dữ liệu</a></h3>
<pre><code class="language-java">public class Calculation{
    public static void main(String[] args){
        // khai bao so nguyen
        int a = 5;
        int b = 10;
        int x = 10 + 5;
        System.out.println(x);

    }
}
</code></pre>
<p>Thứ nhất là cái <code>// khai bao so nguyen</code>, cái này gọi là <code>Comment</code>, tức các bạn viết gì sau 2 cái dấu <code>//</code> thì nó sẽ không ảnh hưởng tới <code>code</code> của chương trình, nó chỉ mang ý nghĩa chú thích thôi.</p>
<p>Thứ hai là cái này:</p>
<pre><code class="language-java">int a = 5;
</code></pre>
<p>Nói về <code>Biến</code> (<code>Variable</code>) các bạn có liên tưởng tới liên tưởng tới biến <code>x</code> trong đồ thị hàm số <code>ax + b = 0</code> không. Thì chính là nó đấy.</p>
<blockquote>
<p>Biến sẽ giúp chúng ta lưu trữ và quản lý các giá trị trong chương trình.</p>
</blockquote>
<p>Trong <code>Java</code>, <code>Biến</code> cũng là đại diện cho một đối tượng và đối tượng này phải được xác định là thuộc <code>Kiểu dữ liệu</code> nào. Có các kiểu dữ liệu <code>nguyên thuỷ</code> (<code>primitive</code>) như sau:</p>
<ul>
<li><code>boolean</code>: là kiểu logic, chỉ có 2 giá trị <code>true</code> hoặc <code>false</code></li>
<li><code>char</code>: kiểu ký tự, chỉ chứa đc được một ký tự, được định nghĩa trong dấu ngoặc đơn <code>'</code></li>
<li><code>int</code> : số nguyên (<code>1,2,3, ..</code>)</li>
<li><code>long</code>: số nguyên, lớn hơn <code>int</code>. (sẽ giải thích ở dưới)</li>
<li><code>float</code>: số thực (<code>1.5, 2.5, ..</code>).</li>
<li><code>double</code>: số thực, lớn hơn <code>float</code>.</li>
</ul>
<p>Ngoài ra còn 2 kiểu dữ liệu nhỏ hơn <code>int</code> là <code>byte</code> và <code>short</code>.</p>
<p>Kiểu dữ liệu cao cấp hơn gọi là <code>Object</code> mà đặc trưng nhất là <code>String</code>.</p>
<ul>
<li><code>String</code>: Một chuỗi các ký tự, được định nghĩa trong dấu ngoặc kép <code>&quot;&quot;</code>. vd <code>String a = &quot;Hellooo world~~~&quot;</code></li>
</ul>
<h3 id="cách-khai-báo"><a class="header" href="#cách-khai-báo">Cách khai báo</a></h3>
<p>Để khai báo biến, bắt buộc trước đó bạn phải chỉ cho nó <code>kiểu dữ liệu</code> mà nó sẽ nhận, ngoài ra có thể có giá trị hoặc không.</p>
<ul>
<li>Cách 1: <code>[kiểu_dữ_liệu][tên_biến];</code></li>
<li>Cách 2: <code>[kiểu_dữ_liệu][tên_biến] = [giá_trị];</code></li>
</ul>
<pre><code class="language-java">int a, b, c; // Khai báo 3 biến có kiểu dữ liệu int
float b = 4.5f, c = 4f; // Khai báo 2 biến có kiểu dữ liệu float với giá trị ban đầu. ở đây biến `c` sẽ được hiểu là c = 4.0
double c = 4444.3;
char t = 'c';
String e = &quot;Hello&quot;;
</code></pre>
<h3 id="cách-đặt-tên"><a class="header" href="#cách-đặt-tên">Cách đặt tên</a></h3>
<p>Tên biến phải tuân theo <code>quy tắc lạc đà (Camel Case)</code>: đó là chữ cái đầu tiên của từ đầu tiên phải viết thường và chữ cái đầu tiên của các từ tiếp theo phải viết hoa, ví dụ: <code>listStudent</code>, <code>minScore</code>.</p>
<h3 id="phạm-vi-sử-dụng"><a class="header" href="#phạm-vi-sử-dụng">Phạm vi sử dụng</a></h3>
<p>Một khi bạn đã khai báo biến, thì bạn có thể sử dụng nó trong những <code>Phạm vi</code> mà nó khả dụng. ?? 😀?? Cùng nhìn ví dụ ở dưới nhé.</p>
<p>Ví dụ:</p>
<pre><code class="language-java">public static void main(String[] args){
    // khai bao so nguyen `a`
    int a;
    // Gán giá trị cho a, bạn sử dụng toán tử `=`
    // Sử dụng biến a bình thường
    a = 124214;

    // lấy a và cộng thêm 1,, rồi gán ngược lại giá trị đó vào a :D
    // Sử dụng biến a bình thường
    a = a + 1;

}
// Gán lại giá trị cho a = 100 - 10;
// Chương trình lỗi
a = 100 - 10;
</code></pre>
<p><code>Phạm vi</code> (<code>Scope</code>) là đây các bạn ạ, chính là 2 cái dấu <code>{}</code>, khi bạn khai báo một biến <code>a</code> trong 2 cái dấu <code>{``}</code> thì bạn chỉ có thể sử dụng ở trong nó thôi, ra ngoài nó sẽ không hiểu <code>a</code> là thằng nào và từ đâu chui ra.</p>
<blockquote>
<p>Biến không thể sử dụng ngoài, nhưng nó có thể được sử dụng ở bên trong những scope mà nó chứa hoặc cùng cấp với nó.</p>
</blockquote>
<pre><code class="language-java">public class Calculation{
    // Khai báo a ở ngoài main, cái `public static` là cần thiết nhé, còn chi tiết thì chúng ta sẽ học ở các bài sau.
    public static int a = 5;
    public static void main(String[] args){
        // thay đổi a, ở trong, vẫn okie.
        a = 10;

        // Biến a có thể sử dụng trong các `scope` con của nó
        // Làm gì biến a ở đây cũng được, biến đổi nó.

        // gán giá trị biến a vào b;
        int b = a;

        System.out.println(b);
    }
}
</code></pre>
<h3 id="toán-tử"><a class="header" href="#toán-tử">Toán tử</a></h3>
<p>Khi đã xác định các <code>Biến</code> trong chương trình, bạn có thể sử dụng <code>toán tử</code> để thay đổi các giá trị. Các <code>toán tử</code> thì khá đơn giản, giống môn toán bình thường thôi. Với các kiểu <code>nguyên thuỷ (primitive)</code> ta có:</p>
<pre><code class="language-java">public class Calculation{
    public static void main(String[] args){
      int a;
      int b = 5;
      int c = a + b; // c = 0 + 5 cộng
      int d = a - b; // d = 0 - 5 trừ
      int f = a * 5; // f = 0 x 5 nhân
      int g = a / 5; // g = 0 : 5; chia
    }
}
</code></pre>
<p>Còn với <code>String</code> thì bạn có thể sử dụng <code>+</code> để ghép 2 chuỗi mà thôi. Còn các toàn tử còn lại không được sử dụng với <code>String</code></p>
<pre><code class="language-java">public class Calculation{
    public static void main(String[] args){
      String a = &quot;Hello&quot;
      String b = &quot;World&quot;
      // Mình đã nối 3 xâu là &quot;Hello&quot; + &quot; &quot; (Khoảng trắng) + &quot;World&quot; lại với nhau
      System.out.println(a + &quot; &quot; + b);

      String c = a + 5; // String cộng với một số nguyên?
      System.out.println(c); // Kết quả sẽ là: &quot;Hello 5&quot; :V
      // Bạn sẽ hiểu là khi cộng String với một số, số đó sẽ bị chuyển thành String và nối vào sau.

    }
}
</code></pre>
<h3 id="Ép-kiểu-dữ-liệu"><a class="header" href="#Ép-kiểu-dữ-liệu">Ép kiểu dữ liệu</a></h3>
<p>Nhìn vào ví dụ sau, bạn sẽ rõ.</p>
<pre><code class="language-java">public class Calculation{
    public static void main(String[] args){
      int a = 2;
      float b = 3.5f; // dùng chữ f để nó hiểu đây là 3,5 float chứ k phải 3,5 double

      float c = a + b; // c = 5.5

      int d = a + b; // báo lỗi. Vì sao?
      // vì java đang hiểu 2 + 3.5 nó sẽ ép thành 5.5 là float. Bây giờ gán nó vào số nguyên thì sẽ như này int = float?

      // Để gán được bạn cần sử dụng ép kiểu
      int d = (int) a + b; // d = 5
      // a + b = 5.5 =&gt; ép thành (int) =&gt; 5 (lấy phần nguyên thôi)

      char character = '5';
      int number = (int) character; // number = 53. Why?

      // Vì ép `char` thành `int` thì nó sẽ không chuyển chữ thành số, mà nó sẽ kiếm tra '5' là ký tự ASCII thứ bao nhiêu trong máy tính, và trả lại số thứ tự đó.

      float = (float) 5; // =&gt; 5.0
    }
}
</code></pre>
<h3 id="bản-chất-của-biến-nói-thêm"><a class="header" href="#bản-chất-của-biến-nói-thêm">Bản chất của biến (Nói thêm)</a></h3>
<p>Khi các bạn khai báo một biến <code>int</code> trong chương trình của mình và sử dụng lung tung khắp mọi nơi, thì bạn có biết cái biến <code>int</code> ý ở đâu lòi ra không :))</p>
<p>Về bản chất, <code>Biến</code> sẽ là một vùng nhớ trong thiết bị vật lý mà dễ nhất là để trong <code>ram</code>. và khi bạn cho nó một giá trị, nó sẽ lưu trữ số đó vào <code>ram</code>, và cần thì lấy lên.</p>
<p>Vậy để <code>ram</code> biết bạn muốn lưu cái gì thì bạn phải khai báo cho nó. Ví dụ bạn bảo tôi cần một số nguyên <code>int</code>. Thì máy tính hiểu là mình cần lưu trữ một số nguyên bình thường, không quá lớn, nó sẽ cho bạn <code>4 byte</code> trong <code>Ram</code> thích lưu gì thì lưu. nhưng <code>không được vượt quá 4 byte</code>.</p>
<blockquote>
<p>4 byte = 32 bit, bỏ đi 1 bit đầu tiên để đánh dấu là số âm hay dương, thì còn 31 bit =&gt; số lớn nhất mà biến int lưu trữ được là 2^31 - 1 = 2147483647</p>
</blockquote>
<p>Từ đây, bạn sẽ hiểu vì sao có số <code>long</code>, vì nhu cầu lưu số lớn hơn thì <code>long</code> được cấp tận <code>8 byte</code>.</p>
<p>Còn trường hợp đặc biệt như <code>String</code> thì tuỳ giá trị của nó có bao nhiêu ký tự, mà <code>Ram</code> sẽ cấp tương ứng bấy nhiêu <code>byte</code></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bài-3-ham-va-cau-lenh-đieu-kien"><a class="header" href="#bài-3-ham-va-cau-lenh-đieu-kien">Bài 3: Hàm và câu lệnh điều kiện</a></h1>
<h2 id="1-câu-lệnh-rẽ-nhánh"><a class="header" href="#1-câu-lệnh-rẽ-nhánh">#1 Câu lệnh rẽ nhánh</a></h2>
<h3 id="if"><a class="header" href="#if">if</a></h3>
<p>Các bạn nhìn qua ví dụ này:</p>
<pre><code class="language-java">public static void main(String[] args){
    // khai bao so nguyen
    int a = 9;

    // Kiểm tra xem a có bằng 9 không
    if (a == 9) {
        // nếu bằng 9, in ra màn hình &quot;Hello&quot;
        System.out.println(&quot;Hello&quot;);
    }

// Kết quả trên màn hình:
// Hello
}
</code></pre>
<p>Thì các cần biết như sau, câu lệnh <code>if</code> là một câu lệnh điều kiện, và nhận vào là một điều kiện <code>true</code> hoặc <code>false</code>. Có cú pháp như sau:</p>
<pre><code class="language-java">if ([điều kiện]){
    // Thực hiện đoạn code nếu [điều kiện] là `true`. Nếu `false` bỏ qa đi xuống dưới.
}
// Tiếp tục thực hiện đoạn code phía dưới
</code></pre>
<p>Vậy đấy, nên để so sánh bạn cần dùng <code>toán tử quan hệ</code> mình liệt kê dưới đây:</p>
<ul>
<li><code>==</code>: Kiểm tra 2 toán hạng có <code>bằng nhau</code> không? (<code>if(a==b)</code>)</li>
<li><code>!=</code>: Kiểm tra 2 toán hạng có <code>khác nhau</code> không? (<code>if(a!=b)</code>)</li>
<li><code>&gt;</code>: Kiểm tra toàn hạng A có <code>lớn hơn</code> B không? (<code>if(a&gt;b)</code>)</li>
<li><code>&lt;</code>: Kiểm tra toàn hạng A có <code>nhỏ hơn</code> B không? (<code>if(a&lt;b)</code>)</li>
<li><code>&gt;=</code>: Kiểm tra toàn hạng A có <code>lớn hơn hoặc bằng</code> B không? (<code>if(a&gt;=b)</code>)</li>
<li><code>&lt;=</code>: Kiểm tra toàn hạng A có <code>nhỏ hơn hoặc bằng</code> B không? (<code>if(a&lt;=b)</code>)</li>
</ul>
<p>Tất cả <code>toán tử quan hệ</code> ở trên, khi thực hiện xong nó sẽ trả về là kiểu <code>boolean</code>, nên bạn có thể gán nó vào một biến bất kỳ, như lày:</p>
<pre><code class="language-java">int a = 5;
int b = 6;

boolean result = a == b; // false

System.out.println(&quot;Result: &quot; + result);

// Kết quả in ra trên màn hình:
// &quot;Result: false&quot;

if(result){ // viết tắt của if(result == true)
    System.out.println(&quot;Result is true&quot;);
}
</code></pre>
<p>Đến đây, có thể nói câu lệnh <code>if</code> thực chất nhận vào một giá trị <code>boolean</code>.</p>
<h3 id="else"><a class="header" href="#else">else</a></h3>
<p>Tiếp theo, chúng ta tới với dạng đầy đủ của <code>if</code> chính là cấu trúc <code>if else</code>.</p>
<pre><code class="language-java">if ([điều kiện]){
    // Thực hiện đoạn code nếu [điều kiện] là `true`.
} else {
    // Thực hiện đoạn code trong này nếu [điều kiện] là `false`
}
//Các đoạn code ở dưới thực hiện bình thường sau khi if hoặc else diễn ra
</code></pre>
<p>Ví dụ:</p>
<pre><code class="language-java">int a = 5;
if ( (a + 2) == 7 ){
    System.out.println(&quot;Bằng 7&quot;);
    // Sử dụng biến `a` ở ngay trong scope {} của `if`,, như bài #2 mình có nói, biến được sử dụng trong các scope con hoặc bằng cấp
    System.out.println(&quot;Giá trị lúc này của a = &quot; + a);
}else{
    System.out.println(&quot;Khác 7&quot;);
    System.out.println(&quot;Giá trị lúc này của a = &quot; + a);
    int b = 7; // Tạo ra 1 biến b trong else
}

b = 50; // Lỗi, không biết b là gì, vì b ở scope nhỏ hơn, bên ngoài không hiểu.
</code></pre>
<h3 id="toán-tử-logic"><a class="header" href="#toán-tử-logic">Toán tử logic</a></h3>
<p>Toán tử logic là những toán tử giúp chúng ta kết hợp nhiều [điều kiện] lại với nhau.</p>
<p>Ví dụ mình nói: <code>&quot;Nếu ab = 3 VÀ ac = 4 VÀ bc = 5 thì abc là tam giác vuông&quot;</code></p>
<p>Thì trong code cần viết chương trình như thế nào?</p>
<p>Cách 1: Sử dụng <code>if</code> thông thường.</p>
<pre><code class="language-java">int ab = 3;
int ac = 4;
int bc = 5;

if(ab == 3){
    if(ac == 4){
        if(bc == 5){
            System.out.println(&quot;abc là tam giác cực vuông&quot;);
        }
    }
}
</code></pre>
<p>Cách 2: Sử dụng <code>if</code> và <code>toán tử logic</code></p>
<pre><code class="language-java">int ab = 3;
int ac = 4;
int bc = 5;

// Nếu ab = 3 VÀ ac = 4 VÀ bc = 5
if(ab == 3 &amp;&amp; ac == 4 &amp;&amp; bc==5){
    // thì abc là tam giác vuông
    System.out.println(&quot;abc là tam giác cực vuông&quot;);
}
</code></pre>
<p>Các bạn nhìn ví dụ cũng đoán ra <code>&amp;&amp;</code> chính là <code>toán tử logic</code> đại diện cho khái niệm <code>AND</code>. Chúng ta có tất cả các loại <code>toán tử logic</code> như sau:</p>
<ul>
<li><code>&amp;&amp;</code>: AND</li>
<li><code>||</code>: OR</li>
<li><code>!</code>: NOT</li>
</ul>
<p>Mục tiêu của các <code>toán tử logic</code> là tác động lên các biểu thức <code>boolean</code> để cho ra mộ biến <code>boolean</code> mới.</p>
<h3 id="phép-and-"><a class="header" href="#phép-and-">Phép AND (&amp;&amp;)</a></h3>
<p>Phép <code>&amp;&amp;</code> hoạt động theo nguyên tắc, <code>chỉ cần có 1 cái sai, thì tất cả đều sai</code> hay <code>Tất cả đều phải đúng, mới là đúng</code></p>
<p>Nếu <code>&quot;A đúng và B đúng và C sai thì kết quả vẫn là sai&quot;</code></p>
<pre><code class="language-java">// Bạn chạy thử xem nó đi vào phần nào nhé
if(true &amp;&amp; true &amp;&amp; true &amp;&amp; false){
    System.out.println(&quot;true&quot;);
}else{
    System.out.println(&quot;false&quot;);
}
</code></pre>
<h3 id="phép-or-"><a class="header" href="#phép-or-">Phép OR (||)</a></h3>
<p>Phép <code>||</code> thì rất dễ dãi, <code>Chỉ 1 cái đúng là đủ</code></p>
<pre><code class="language-java">// Bạn chạy thử xem nó đi vào phần nào nhé
if(false || false || true || false){
    System.out.println(&quot;true&quot;);
}else{
    System.out.println(&quot;false&quot;);
}
</code></pre>
<h3 id="phép-not-"><a class="header" href="#phép-not-">Phép NOT (!)</a></h3>
<p>Phép <code>!</code> làm phủ định giá trị của biểu thức, nếu nó đang <code>true</code> thì biến nó thành <code>false</code> và ngược lại.</p>
<pre><code class="language-java">int a = 7;
if(!(a == 7)){ // (a==7) =&gt; true gặp thằng ! lại bị chuyển thành false. =&gt; vào vế else
    System.out.println(&quot;Đáng nhẽ ra nên vào đây&quot;);
}else{
    System.out.println(&quot;But nope, nó lại vào đây&quot;);
}
</code></pre>
<h2 id="hàm-function"><a class="header" href="#hàm-function">Hàm (Function)</a></h2>
<pre><code class="language-java">public class Calculation {
    public static void main(String[] args){
        f(5,6);
        f(2,3);
        f(1,10);
    }

    public static void f(int x, int y){
        int a = x + y;
        System.out.println(&quot;In a ra màn hình: &quot; + a);
    }
}
// Kết quả khi chạy:

// In a ra màn hình: 11
// In a ra màn hình: 5
// In a ra màn hình: 11
</code></pre>
<h3 id="cách-khai-báo-1"><a class="header" href="#cách-khai-báo-1">Cách khai báo</a></h3>
<p>Cách khai báo một phương thức như sau:</p>
<p><code>[kiểu_truy_cập] [kiểu_trả_về] [tên_phương_thức] ([danh_sách_tham_số]){}</code></p>
<p>ví dụ:</p>
<pre><code class="language-java">public static void f(int x, int y){
    // Code của bạn
}

public static void main(String[] args){

}
</code></pre>
<p>Và khai báo ở ngoài hàm <code>main()</code>. Tới đây, bạn hiểu <code>main()</code> cũng là một <code>hàm (function)</code>. Tuy nhiên nó đặc biệt vì cú pháp của nó là cố định và được <code>Java</code> tìm tới để đọc đầu tiên.</p>
<p>1 - <code>[kiểu_truy_cập]</code>:</p>
<p>Trong ví dụ trên <code>[kiểu_truy_cập]</code> chính là vế <code>public static</code>. Nó định nghĩa phạm vi <code>hàm</code> được sử dụng. chúng ta sẽ tìm hiểu ở các bài sau nhé các bạn, bây giờ bạn hãy mặc định sử dụng <code>public static</code> ở trước mỗi hàm khai báo để có thể sử dụng được nhé. Ở bài này, chúng ta tạm hiểu với nhau: <code>public static</code> là <code>&quot;truy cập ở bất cứ đâu&quot;</code> tức có thể gọi hàm này ở bất kì chỗ nào.</p>
<p>2 - <code>[kiểu_trả_về]</code>:</p>
<p>Tương đương với phần <code>void</code> ở ví dụ trên, kiểu trả về là giá trị chúng ta nhận được sau khi gọi hàm.</p>
<p>Bạn hãy nhớ lại, khi truyền <code>x</code> vào <code>f(x)</code> chúng ta sẽ nhận lại là <code>y</code>. Thì hàm cũng vậy, chúng ta có thể trả lại một giá trị gì đó. ví dụ:</p>
<pre><code class="language-java">// [kiểu trả về]: int
public static int tong(int x, int y){
    int t = x + y; // Tính tổng 2 só x, y
    return t; // trả số đó ra sử dụng câu lệnh `return {biến}`
}

public static void main(String[] args){
    int t = tong(5,6); // Lấy giá trị trả ra, gán nó vào t;
}
</code></pre>
<p>Tôi định nghĩa một hàm tính tổng <code>tong(x,y)</code> nhận vào 2 số nguyên, và yêu cầu nó trả ra một số <code>int</code>.</p>
<p>Các kiểu trả về:</p>
<ul>
<li><code>primitive</code>: <code>int</code>, <code>boolean</code>, <code>char</code>, ...</li>
<li><code>Object</code>: <code>String</code>, (còn rất nhiều, sẽ học ở bài tiếp theo)</li>
<li><code>void</code>: Không trả về gì cả</li>
</ul>
<p>Ở ví dụ đầu tiên mình đã sử dụng <code>void</code> để định nghĩa hàm.</p>
<pre><code class="language-java">public static void f(int x, int y){
    int a = x + y;
    System.out.println(&quot;In a ra màn hình: &quot; + a);
}
</code></pre>
<p>Điều này nói là hàm của chúng ta thực hiện một hoạt động khép kín, và không có nhu cầu trả ra ngoài cái gì cả. Mình chỉ tính tổng rồi in luôn ra màn hình thôi, không cần đưa gì ra ngoài cả.</p>
<p>3 - <code>[danh_sách_tham_số]</code></p>
<p>Tham số đầu vào, là những thứ chúng ta đưa vào hàm, định nghĩa tham số đầu vào bao gồm <code>[kiểu_dữ_liệu] [tên_biến]</code>. Chúng ta có truyền nhiều tham số vào <code>hàm</code> bằng cách đặt dầu phẩy <code>,</code> giữa mỗi tham số.</p>
<pre><code class="language-java">public static int f(int x, int y, int z, ... ){
    // code
}
</code></pre>
<p>Ở đây lưu ý phần <code>[tên_biến]</code> bạn có thể đặt tên bất kỳ. chẳng hạn:</p>
<pre><code class="language-java">// Hàm nhận vào 2 biến `x`, `y` và trả ra kết quả `boolean` xem nó có bằng nhau hay không
public static boolean bangnhau(int x, int y){
    return x == y;
}

public static void main(String[] args){
    int a = 5; // tên biến là `a`
    int b = 6; // tên biến là `b`

    boolean ketqua = bangnhau(a,b); // đưa `a` , `b` vào hàm.
    // bản chất khi gọi hàm `bangnhau`:
    // int x = a;
    // int y = b;
    // return x == y;
    //
    System.out.println(&quot;Kết quả: &quot; + ketqua);
}
</code></pre>
<p>Bạn định nghĩa <code>tham số đầu vào</code> là <code>x</code> và <code>y</code> thì nó chỉ hiểu trong ở hàm đó thôi, và những giá trị truyền vào sẽ gán vào các biến <code>x</code> và <code>y</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nhap-xuat-du-lieu-trong-java"><a class="header" href="#nhap-xuat-du-lieu-trong-java">Nhập xuất dữ liệu trong Java</a></h1>
<h3 id="nhập-xuất-từ-bàn-phím"><a class="header" href="#nhập-xuất-từ-bàn-phím">Nhập xuất từ bàn phím</a></h3>
<pre><code class="language-java">public class Calculation {
    public static void main(String[] args) {
        // Chúng ta khai báo 3 biến a,b,c không có giá trị.
        int a, b, c;

        //Khai báo đối tượng Scanner, giúp chúng ta nhận thông tin từ keyboard
        Scanner sc = new Scanner(System.in);
        System.out.print(&quot;Nhập a: &quot;); //print thay vì println, nó sẽ in ra, nhưng không xuống dòng

        a = sc.nextInt(); // sc.nextInt() là cách để lấy giá trị từ bàn phím, nó sẽ chờ tới khi chúng ta nhập một số.
        System.out.print(&quot;Nhập b: &quot;);
        b = sc.nextInt();
         System.out.print(&quot;Nhập c: &quot;);
        c = sc.nextInt();
        // In các giá trị ra màn hình
        System.out.println(&quot;a = &quot; + a + &quot;, b = &quot; + b + &quot;, c = &quot; + c);
        //  Đây là phép cộng String mình đã nói trong Bài #1.
}
</code></pre>
<p>Cái dòng lệnh này <code>a = sc.nextInt()</code>. Nó sẽ chờ cho tới khi bạn nhập 1 số nguyên và gõ <code>Enter</code> thì thôi. Giả sử mình nhập <code>5</code></p>
<p>Chương trình lại tiếp tục chạy cho tới khi gặp câu lệnh <code>sc.nextInt()</code> tiếp theo. Và cứ tiếp tục như vậy cho tới dòng lệnh cuối cùng.</p>
<p>Từ đây, các bạn có thể hiểu là đối tượng <code>Scanner</code> đã làm nhiệm vụ là nhận dữ liệu người dùng nhập từ bàn phím, và gán nó vào biến, bằng câu lệnh <code>nextInt</code>.</p>
<p>Bây giờ quay trở ngược lên trên 1 chút, ở câu lệnh:</p>
<pre><code class="language-java">Scanner sc = new Scanner(System.in);
</code></pre>
<p>các bạn sẽ thấy một khái niệm là <code>new</code>. cái này thì [Bài #5][link-bai5] mình sẽ nói chi tiết, còn ở đây thì bạn hiểu nó được sử dụng để tạo ra 1 đối tượng <code>Scanner</code>. </p>
<h3 id="các-phương-thức-nhập-xuất"><a class="header" href="#các-phương-thức-nhập-xuất">Các phương thức nhập xuất</a></h3>
<p><code>Scanner</code> có một loạt các hàm hỗ trợ như sau:</p>
<ul>
<li><code>next()</code>: Nhận vào một <code>String token</code> (nhận vào 1 từ đầu tiên thay cả câu)</li>
<li><code>nextInt()</code>: Nhận vào một số <code>int</code></li>
<li><code>nextLong()</code>: Nhận vào một số <code>long</code></li>
<li><code>nextFloat()</code>: Nhận vào một số <code>float</code></li>
<li><code>nextDouble()</code>: Nhận vào một số <code>double</code></li>
<li><code>sc.nextLine()</code>: Nhận vào một <code>chuỗi String</code> (Cả 1 câu)</li>
<li><code>nextByte()</code>: Nhận vào một <code>byte</code></li>
<li><code>nextBoolean()</code>: Nhận vào một <code>boolean</code></li>
</ul>
<p>Các hàm trên bạn hiểu nguyên lý là nó đều sẽ <code>chờ</code> cho tới khi bạn nhập kiểu dữ liệu nó muốn vào.</p>
<p>Có <code>next()</code> và <code>nextLine()</code> khá đặc biệt, mình sẽ ví dụ:</p>
<pre><code class="language-java">Scanner sc = new Scanner(System.in); //Tạo đối tượng Scanner
System.out.print(&quot;Nhập gì đó: &quot;);
String a = sc.nextLine(); // nhận vào 1 string
System.out.println(&quot;Bạn vừa nhập: &quot;+a);

System.out.print(&quot;Nhập thêm gì đi: &quot;);
String b = sc.next(); // cũng nhận vào 1 String
System.out.println(&quot;Bạn vừa nhập: &quot;+b);
</code></pre>
<p><code>nextLine</code> thì nhận vào cả 1 chuỗi dài <code>String</code>, cho tới khi bạn nhấn <code>Enter</code>. Còn <code>next</code> dù bạn có nhập dài như nào, nó cũng nhận 1 từ đầu tiên thôi.</p>
<h3 id="bản-chất-củanext"><a class="header" href="#bản-chất-củanext">Bản chất của<code>next</code></a></h3>
<p>Bạn để ý là các hàm lấy giá trị từ bàn phím đều có chữ <code>next</code>. Bây giờ bạn chạy cho mình ví dụ này, bạn sẽ hiểu:</p>
<pre><code class="language-java">public static void main(String[] args) {
    int a,b,c;
    Scanner sc = new Scanner(System.in); // Tạo đối tượng Scanner
    System.out.print(&quot;Nhập a: &quot;);
    a = sc.nextInt();
    b = sc.nextInt();
    c = sc.nextInt();
    System.out.println(&quot;a = &quot;+a);
    System.out.println(&quot;b = &quot;+b);
    System.out.println(&quot;c = &quot;+c);
}
</code></pre>
<p>Bạn sẽ thấy là, nó đưa tuần tự các giá trị hiện có trên bàn phím vào các biến. bản chất của chữ <code>next</code> chính là tuần tự. Nó sẽ chờ bạn nhập nếu không có giá trị gì trên màn hình, nhưng nếu đã có sẵn giá trị rồi, nó sẽ ghi nhớ trong <code>bộ đệm</code> và khi gặp hàm <code>nextInt()</code> nó không chờ nữa, mà nó lấy luôn cái giá trị còn thừa ra, chưa sử dụng đến để gắn luôn vào biến 😂</p>
<p>Nhìn như như này cho dễ hiểu:</p>
<pre><code class="language-java">public static void main(String[] args) {
    int a,b,c;
    Scanner sc = new Scanner(System.in); // Tạo đối tượng Scanner
    System.out.print(&quot;Nhập a: &quot;);
    a = sc.nextInt(); // Chờ bạn nhập.
    // bạn nhập: 5 6 7 8 9 10
    // bộ đệm = 5 6 7 8 9 10
    // lấy 5 ra, gắn vào a
    // bộ đệm còn: 6 7 8 9 10
    b = sc.nextInt(); // gặp lệnh nextInt()
    // thấy bộ đệm còn, lấy 6 ra, gắn vào b
    // bộ đệm còn: 7 8 9 10
    c = sc.nextInt(); // gặp lệnh nextInt()
    // thấy bộ đệm còn thừa, lấy 7 ra, gắn vào b
    // bộ đệm còn: 8 9 10
    System.out.println(&quot;a = &quot;+a); // in a
    System.out.println(&quot;b = &quot;+b); // in b
    System.out.println(&quot;c = &quot;+c); // in c
}
</code></pre>
<h3 id="inpụt-outpụt-từ-file"><a class="header" href="#inpụt-outpụt-từ-file">Inpụt/ outpụt từ File</a></h3>
<p>Để cho thuận tiện trong việc đọc ghi, thì ngoài bàn phím, một trong những yêu cầu quan trọng khi lập trình đó là nhập xuất dữ liệu từ File, phần này sẽ không khác nhiều với từ bàn phím đâu các bạn, mình sẽ hướng dẫn.</p>
<p>Tại thư mục gốc của project, bạn click <code>New</code> &gt; <code>File</code>. Tạo 1 tệp tên là <code>input.txt</code>. Như hình:</p>
<pre><code class="language-java">public static void main(String[] args) throws FileNotFoundException { // Thêm cái này vào đây
    int a,b,c;
    Scanner sc = new Scanner(new File(&quot;input.txt&quot;)); // Tạo đối tượng Scanner đọc tới cái file vừa tạo
    System.out.print(&quot;Nhập a: &quot;);
    a = sc.nextInt();
    b = sc.nextInt();
    c = sc.nextInt();
    System.out.println(&quot;a = &quot;+a); // in a
    System.out.println(&quot;b = &quot;+b); // in b
    System.out.println(&quot;c = &quot;+c); // in c
}
// Kết quả chạy:
// Nhập a: a = 5
// b = 7
// c = 8
</code></pre>
<p>Đoạn <code>throws FileNotFoundException</code>. Ở đây thì bạn hiểu nó là lỗi có thể xảy ra, nếu nó không tìm thấy file <code>input.txt</code> thì nó sẽ xảy ra cái lỗi kia. Chúng ta sẽ xử lý lỗi đó sau, hiện tại thì nếu bạn nhập đúng tên File thì không thể lỗi được.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vi-sao-nen-su-dung-stringbuffer"><a class="header" href="#vi-sao-nen-su-dung-stringbuffer">Vì sao nên sử dụng StringBuffer</a></h1>
<p>Cùng xem ví dụ này nhé:</p>
<pre><code class="language-java">long start = System.nanoTime();

String s = &quot;Hello&quot;;
for (int i = 0; i &lt; 1000; i++) {
    s += &quot; world&quot;;
}
long end = System.nanoTime();
System.out.println(&quot;Total time: &quot;+(end-start));

// Kết quả:
// Total time: 17495917 ns
// = 17.4 ms (Milliseconds)
</code></pre>
<p>Bây giờ, vẫn là chương trình tương tự, mình sử sụng <code>String Buffer</code></p>
<pre><code class="language-java">long start = System.nanoTime();

StringBuffer sb = new StringBuffer(&quot;Hello&quot;);
for (int i = 0; i &lt; 1000; i++) {
    sb.append(&quot; world&quot;);
}
String s = sb.toString();
long end = System.nanoTime();
System.out.println(&quot;Total time: &quot;+(end-start));

// Kết quả:
// Total time: 461198 ns
// = 0.46 ms
</code></pre>
<p><code>String Buffer</code> nhanh hơn gấp 38 lần.</p>
<p>Hiệu năng được chạy trên Mac Pro 2017, tại máy bạn có thể sẽ khác, nhưng chắc chắn rằng <code>StringBuffer</code> luôn nhanh hơn!</p>
<h3 id="góc-giải-thích"><a class="header" href="#góc-giải-thích">Góc giải thích</a></h3>
<p>Có một điều ít bạn học lập trình <code>Java</code> để ý, đó là <code>String</code> là <code>immutable</code>. Tức nội dung trong <code>String</code> là không được quyền thay đổi.</p>
<p>Nhiều bạn lầm tưởng rằng việc nối xâu là bạn thay đổi nội dung của <code>String</code>, nhưng thực chất bạn đang tạo ra một đối tượng hoàn toàn mới:</p>
<pre><code class="language-java">String s = &quot;A&quot;;
s += &quot;B&quot;;
// Complier sẽ tạo ra một đối tượng mới là &quot;AB&quot;
// Và gán vào `s`
// Bản chất `s` bây giờ là một đối tượng mới chứ bạn không hề thay đổi nội dung ban đầu của `s`.
// Đây là những gì ở dưới Compiler sẽ làm:
StringBuffer sb = new StringBuffer(&quot;A&quot;); // Compiler Vẫn phải xài tới StringBuffer
sb.append(&quot;B&quot;);
s = sb.toString();
</code></pre>
<p>Vì vậy khi nối xâu trong <code>Java</code>, việc bạn thực hiện nó liên tục, sẽ tương đương với việc khởi tạo liên tục và nối 2 xâu lại rồi trả về đối tượng <code>String</code> mới dẫn tới chi phí lớn.</p>
<p><code>StringBuffer</code> cho phép chúng ta thao tác trên một đối tượng duy nhất và thay đổi được nội dung trong nó. Nếu ban đầu nội dung là <code>&quot;A&quot;</code>, bạn muốn nối thêm <code>&quot;B&quot;</code> vào. Thì nó chỉ cần gắn chuỗi <code>bytes</code> của <code>&quot;B&quot;</code> vào liền kề ngay sau <code>&quot;A&quot;</code> là xong. (Vì nó có thể thay đổi, khác với <code>String</code> là <code>immutable</code>).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="huong-dan-java-reflection"><a class="header" href="#huong-dan-java-reflection">Hướng dẫn Java Reflection</a></h1>
<h3 id="giới-thiệu"><a class="header" href="#giới-thiệu">Giới thiệu</a></h3>
<p><code>Java Relection</code> là một core package trong thư viện chuẩn của <code>Java</code>. Mục đích của nó là cho phép chúng ta truy cập vào gần như mọi thứ bên trong đối tượng. &quot;Dưới một góc độ khác&quot;!</p>
<p>Chúng ta thường biết tới <code>Java</code> thông qua khái niệm hướng đối tượng như sau:</p>
<pre><code class="language-java">String str = &quot;Hello Loda&quot;;
str.toUpperCase(); // Chúng ta gọi hàm toUpperCase() thông qua toán tử &quot;.&quot;
// Mọi thứ trong đối tượng là khép kín, chúng ta phải gọi thông qua hàm public
</code></pre>
<p>Hoặc</p>
<pre><code class="language-java">public class Girl {
    String name;
    int age;
    int atk;
    int agi;
    int def;
    // ... Và 1000 thuộc tính khác

    public static void main(String[] args) {
        Girl girl = new Girl();
        // Chúng ta thường phải nhớ tên thuộc tính để gọi nó ra
        girl.name = &quot;Ngoc Trinh&quot;;

        // Giá sử class này có 100 thuộc tính là String.
        // Bạn muốn set giá trị của tất cả trường String là &quot;Ngoc Trinh&quot;
        // Bạn sẽ rất bối rối vs việc gọi từng thuộc tính bằng việc &quot;.{tên thuộc tính}&quot; như này.

        // Có cách nào cho code duyệt tìm toàn bộ thuộc tính, cái nào là String thì đổi nó thành &quot;Ngoc Trinh&quot;?
    }
}
</code></pre>
<p>Đúng vậy, khi chúng ta muốn gọi tên thuộc tính, mà lại không muốn gõ <code>.</code> và nhớ ra tên thuộc tính, thì làm như nào?</p>
<p>Bây giờ, chúng ta phải tiếp cận từ góc nhìn khác. Chúng ta sẽ ước mình có thể duyệt hết tất cả các thuộc tính của 1 class bằng vòng lặp. Rồi check xem thuộc tính có là <code>String</code> không? nếu có thì gán giá trị mới là &quot;Ngoc Trinh&quot;!</p>
<p>Để làm được điều này, chúng ta cần đào sâu vào <code>Class</code> và phá vỡ giới hạn của java truyền thống. Đây là lúc <code>Java Reflection</code> (Sự phản chiếu) vào trận.</p>
<h3 id="java-reflection"><a class="header" href="#java-reflection">Java Reflection</a></h3>
<p><code>Java Reflecion</code> cho phép bạn đánh giá, sửa đổi cấu trúc và hành vi của một đối tượng tại thời gian chạy (runtime) của chương trình. Đồng thời nó cho phép bạn truy cập vào các thành viên private (private member) tại mọi nơi trong ứng dụng, điều này không được phép với cách tiếp cận truyền thống.</p>
<h3 id="lấy-ra-thuộc-tính-field"><a class="header" href="#lấy-ra-thuộc-tính-field">Lấy ra Thuộc tính (Field)</a></h3>
<p>Quay trở lại ví dụ trên, Chúng ta sẽ lấy ra toàn bộ thuộc tính của <code>Girl</code>. Tìm xem cái nào tên <code>name</code> và bổ sung giá trị mới cho nó.</p>
<pre><code class="language-java">public class Girl {
    private String name;

    public Girl() {

    }

    public Girl(String name) {
        this.name = name;
    }

    public void setName(String name){
        this.name = name;
    }

    @Override
    public String toString() {
        return &quot;Girl{&quot; +
               &quot;name='&quot; + name + '\'' +
               '}';
    }

    public static void main(String[] args) throws Exception {
        Girl girl = new Girl(); // KHởi tạo đối tượng Girl
        girl.setName(&quot;Ngoc trinh&quot;);

        // Lay ra tat ca field cua object
        // Chỉ để bạn xem ví dụ thôi, bỏ qua phần này nhé!
        for(Field field : girl.getClass().getDeclaredFields()){
            System.out.println();
            System.out.println(&quot;Field: &quot; +field.getName());
            System.out.println(&quot;Type: &quot; +field.getType());
        }

        // PHẦN CHÍNH
        Field nameField = girl.getClass().getDeclaredField(&quot;name&quot;); // Lấy ra field có tên &quot;name&quot; (nếu không tìm thấy, nó sẽ bắn NoSuchFieldException)
        nameField.setAccessible(true); // Cho phép truy cập tạm thời. (Vì nó đang là Private mà)

        // Bây giờ cái &quot;nameField&quot; đại diện cho thuộc tính &quot;name&quot; của mọi object có class Girl.
        nameField.set(girl, &quot;Bella&quot;); // thay giá trị mới của `girl` bằng nameField.

        System.out.println(girl);
    }
}
// Output:
// Field: name
// Type: class java.lang.String
// Girl{name='Bella'}
</code></pre>
<h3 id="lấy-ra-hàm-method"><a class="header" href="#lấy-ra-hàm-method">Lấy ra Hàm (Method)</a></h3>
<p>Vấn đề đặt ra, giống với <code>field</code>. Chúng ta cũng sẽ có nhu cầu duyệt tìm một <code>method</code> nào đó và sử dụng nó:</p>
<pre><code class="language-java">public static void main(String[] args) throws Exception {
    Class&lt;Girl&gt; girlClass = Girl.class;

    // Su dung getDeclaredMethods de lay ra nhung method cua class va cha no.
    Method[] methods = girlClass.getDeclaredMethods();
    for(Method method : methods){
        System.out.println();
        System.out.println(&quot;Method: &quot; + method.getName());
        System.out.println(&quot;Parameters: &quot; + Arrays.toString(method.getParameters()));
    }

    // Lay ra method ten la setName va co 1 tham so truyen vao -&gt;
    // =&gt; chính là: setName(String name)
    Method methodSetName = girlClass.getMethod(&quot;setName&quot;, String.class);
    // Bây giờ methodSetName sẽ đại diện cho method setName(String name) của mọi object có class là Girl

    Girl girl = new Girl(); // Tạo ra đối tượng Girl

    // Thực hiện hàm setName() trên đối tượng girl, giá trị truyền vào là &quot;Ngoc Trinh&quot;
    methodSetName.invoke(girl, &quot;Ngoc Trinh&quot;);
    System.out.println(girl);
}
</code></pre>
<h3 id="lấy-ra-constructor"><a class="header" href="#lấy-ra-constructor">Lấy ra Constructor</a></h3>
<p>Lấy ra hàm khởi tạo của một class. Từ đó cho phép chúng ta cách tạo ra đối tượng từ theo một cách khác, thay vì <code>new Class()</code> như bình thường</p>
<pre><code class="language-java">public static void main(String[] args) {
    Class&lt;Girl&gt; girlClass = Girl.class;
    System.out.println(&quot;Class: &quot; + girlClass.getSimpleName());
    System.out.println(&quot;Constructors: &quot; + Arrays.toString(girlClass.getConstructors())); // Lấy ra toàn bộ Constructor của class này
    try {
        // Tạo ra một object Girl từ class. (Khởi tạo không tham số)
        Girl girl1 = girlClass.newInstance();
        System.out.println(&quot;Girl1: &quot; + girl1);

        // Lấy ra hàm constructor với tham số là 1 string
        // Chính là -&gt; public Girl(String name) {}
        Constructor&lt;Girl&gt; girlConstructor = girlClass.getConstructor(String.class);
        Girl girl2 = girlConstructor.newInstance(&quot;Hello&quot;);

        System.out.println(&quot;Girl2: &quot; + girl2);
    } catch (Exception e) {
        // Exception xay ra khi constructor khong ton tai hoac tham so truyen vao khong dung
        e.printStackTrace();
    }
}
</code></pre>
<h3 id="lấy-ra-annotation-trên-field-method-class"><a class="header" href="#lấy-ra-annotation-trên-field-method-class">Lấy ra Annotation trên Field, Method, Class</a></h3>
<p>Đúng vậy, đây cũng chính là một trong những phần quan trọng bậc nhất của <code>Java Reflection</code>. Cho phép chúng ta kiểm tra <code>Class</code> hiện tại đang được chú thích bởi những <code>Annotation</code> nào.</p>
<pre><code class="language-java">@SuppressWarnings(&quot;deprecation&quot;)
@Deprecated
public class Girl {
    private String name;

    public Girl() {

    }

    public Girl(String name) {
        this.name = name;
    }

    @Nullable
    public void setName(String name){
        this.name = name;
    }

    @Override
    public String toString() {
        return &quot;Girl{&quot; +
               &quot;name='&quot; + name + '\'' +
               '}';
    }

    public static void main(String[] args) {
        Class&lt;Girl&gt; girlClass = Girl.class;
        System.out.println(&quot;Class: &quot;+girlClass.getSimpleName()); // Lấy ra tên Class
        for(Annotation annotation : girlClass.getDeclaredAnnotations()){
            System.out.println(&quot;Annotation: &quot; + annotation.annotationType()); // Lấy ra tên các Annatation trên class này
        }

        for(Method method: girlClass.getDeclaredMethods()){ // Lấy ra các method của class
            System.out.println(&quot;\nMethod: &quot; + method.getName()); //Tên method
            for(Annotation annotation : method.getAnnotations()){
                System.out.println(&quot;Annotation: &quot; + annotation.annotationType()); // Lấy ra tên các Annatation trên method này
            }
        }
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="huong-dan-tu-tao-mot-annotations"><a class="header" href="#huong-dan-tu-tao-mot-annotations">Hướng dẫn tự tạo một Annotations</a></h1>
<h3 id="khái-niệm"><a class="header" href="#khái-niệm">Khái niệm</a></h3>
<p><code>Annotation</code> (Chú thích) được sử dụng để chú thích trên một <code>class</code>, một trường (<code>field</code>) hoặc một <code>method</code> để cung cấp hoặc bổ sung các thông tin. Nó hoàn toàn không ảnh hưởng tới code của bạn.</p>
<p>Trong bài có sử dụng các kiến thức:</p>
<ol>
<li>Optional</li>
<li>Functional Interface &amp; Lambda</li>
<li>Java Reflection</li>
</ol>
<p><code>Annotation</code> được sử dụng ở 3 dạng:</p>
<ul>
<li>Chú thích cho trình biên dịch (Compiler)</li>
<li>Chú thích cho quá trình build</li>
<li>Chú thích trong quá trình chạy chương trình (Runtime)</li>
</ul>
<p>Hẳn bạn đã 1 lần từng thấy cái <code>@Override</code> phải không? nó là một <em>Annotation chú thích cho trình biên dịch</em>, để cho trình biên dịch biết hàm đó đã bị ghi đè.</p>
<p>Còn <em>chú thích cho quá trình build</em> thì không hẳn có ví dụ cụ thể, nhưng bạn hãy nghĩ tới <code>Maven</code>, <code>Gradle</code> những công cụ build này sẽ có thêm thông tin khi build ứng dụng của bạn khi gặp một số <code>Annotation</code> đặc biệt, và sẽ bổ sung thêm code vào đó.</p>
<p><em>Chú thích trong quá trình chạy chương trình</em> sẽ là nội dung chính của chúng ta hôm nay. Đây là những <code>Annotation</code> mà chỉ khi bạn chạy chương trình rồi thì nó mới tác động tới code. Cùng vào ví dụ để dễ hiểu nhé!</p>
<h3 id="khai-báo-annotation"><a class="header" href="#khai-báo-annotation">Khai báo Annotation</a></h3>
<p>Cách khai báo <code>Annotation</code> là sử dụng <code>@interface</code></p>
<p>vậy là bạn đã có 1 <code>Annotation</code>. Giờ gọi nó ra và sử dụng:</p>
<h3 id="khai-báo-phạm-vi-cho-annotation"><a class="header" href="#khai-báo-phạm-vi-cho-annotation">Khai báo phạm vi cho Annotation</a></h3>
<p>Chúng ta có thể quy định phạm vi sử dụng của <code>Annotation</code> bằng cách:</p>
<p><code>@Retention</code>: Dùng để chú thích mức độ tồn tại của một annotation nào đó. Cụ thể có 3 mức nhận thức tồn tại của vật được chú thích:</p>
<ol>
<li><code>RetentionPolicy.SOURCE</code>: Tồn tại trên code nguồn, và không được bộ dịch (compiler) nhận ra.</li>
<li><code>RetentionPolicy.CLASS</code>: Mức tồn tại được bộ dịch nhận ra, nhưng không được nhận biết bởi máy ảo tại thời điểm chạy (Runtime).</li>
<li><code>RetentionPolicy.RUNTIME</code>: Mức tồn tại lớn nhất, được bộ dịch (compiler) nhận biết, và máy ảo (jvm) cũng nhận ra khi chạy chương trình.</li>
</ol>
<p><code>@Target</code>: Dùng để chú thích phạm vi sử dụng của một <code>Annotation</code></p>
<ol>
<li><code>ElementType.TYPE</code> - Cho phép chú thích trên Class, interface, enum, annotation.</li>
<li><code>ElementType.FIELD</code> - Cho phép chú thích trường (field), bao gồm cả các hằng số enum.</li>
<li><code>ElementType.METHOD</code> - Cho phép chú thích trên method.</li>
<li><code>ElementType.PARAMETER</code> - Cho phép chú thích trên parameter</li>
<li><code>ElementType.CONSTRUCTOR</code> - Cho phép chú thích trên constructor</li>
<li><code>ElementType.LOCAL_VARIABLE</code> - Cho phép chú thích trên biến địa phương.</li>
<li><code>ElementType.ANNOTATION_TYPE</code> - Cho phép chú thích trên Annotation khác</li>
<li><code>ElementType.PACKAGE</code> - Cho phép chú thích trên package.</li>
</ol>
<h3 id="xử-lý-annotation"><a class="header" href="#xử-lý-annotation">Xử lý Annotation</a></h3>
<p>Bước 1: Chú thích bất kì chỗ nào bạn muốn.</p>
<p>Bước 2: Viết class xử lý <code>@JsonName</code></p>
<p>Bước 3: Chạy thử:</p>
<pre><code class="language-java">public @interface JsonName {
    String value(); // các giá trị trong @interface đều dạng hàm abstract, không tham số
}
</code></pre>
<pre><code class="language-java">@JsonName(value = &quot;super_man&quot;)
public class SuperMan extends Person {
    private String name;
}
</code></pre>
<pre><code class="language-java">@Retention(RetentionPolicy.RUNTIME) // Tồn tại trong lúc chạy chương trình
@Target({ ElementType.TYPE, ElementType.FIELD, ElementType.METHOD}) // Được sử dụng trên class, interface, method, biến
public @interface JsonName {
    String value();
}
</code></pre>
<pre><code class="language-java">@JsonName(value = &quot;super_man&quot;)
public class SuperMan {
    // Không chú thích, thì chúng ta sẽ coi như lấy tên field là `name` luôn
    private String name;

    @JsonName(&quot;date_of_birth&quot;)
    private LocalDateTime dateOfBirth;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public LocalDateTime getDateOfBirth() {
        return dateOfBirth;
    }

    public void setDateOfBirth(LocalDateTime dateOfBirth) {
        this.dateOfBirth = dateOfBirth;
    }
}
</code></pre>
<pre><code class="language-java">public class JsonNameProcessor {
    public static String toJson(Object object) throws IllegalAccessException {
        StringBuilder sb = new StringBuilder(); // Dùng StringBuilder de tao json tu class

        Class&lt;?&gt; clazz = object.getClass();
        JsonName jsonClassName = clazz.getDeclaredAnnotation(JsonName.class); // Lay ra annotation @JsonName tren Class

        sb.append(&quot;{\n&quot;)
          .append(&quot;\t\&quot;&quot;)
          // Lay gia tri cua Annotation, neu annotation la null thi lay ten Class de thay the
          .append(Optional.ofNullable(jsonClassName).map(JsonName::value).orElse(clazz.getSimpleName()))
          .append(&quot;\&quot;: {\n&quot;); //

        Field fields[] = clazz.getDeclaredFields();
        for (int i = 0; i &lt; fields.length; i++) {
            fields[i].setAccessible(true); // Set setAccessible = true. De co the truy cap vao private field
            JsonName jsonFieldName = fields[i].getDeclaredAnnotation(JsonName.class); // get annotation tren field
            sb.append(&quot;\t\t\&quot;&quot;)
              // Lay gia tri cua Annotation, neu annotation la null thi lay ten field thay the
              .append(Optional.ofNullable(jsonFieldName).map(JsonName::value).orElse(fields[i].getName())) // L
              .append(&quot;\&quot;: &quot;)
              // Neu field la String hoac Object. thi append dau ngoac kep vao
              .append(fields[i].getType() == String.class || !fields[i].getType().isPrimitive() ? &quot;\&quot;&quot; : &quot;&quot;)
              // Lay gia tri cua field
              .append(fields[i].get(object))
              // Neu field la String hoac Object. thi append dau ngoac kep vao
              .append(fields[i].getType() == String.class || !fields[i].getType().isPrimitive()? &quot;\&quot;&quot; : &quot;&quot;)
              // Nếu là field cuối cùng, thì không append dấu &quot;,&quot;
              .append(i != fields.length -1 ? &quot;,\n&quot; : &quot;\n&quot;);
        }
        sb.append(&quot;\t}\n&quot;);
        sb.append(&quot;}&quot;);

        return sb.toString();
    }
}
</code></pre>
<pre><code class="language-java">public static void main(String[] args) throws IllegalAccessException {
    SuperMan superMan = new SuperMan(); // Tao doi tuong super man
    superMan.setDateOfBirth(LocalDateTime.now());
    superMan.setName(&quot;loda&quot;);

    String json =JsonNameProcessor.toJson(superMan);
    System.out.println(json);
}
// OUTPUT:
/*
{
	&quot;super_man&quot;: {
		&quot;name&quot;: &quot;loda&quot;,
		&quot;date_of_birth&quot;: &quot;2019-04-03T21:07:23.983&quot;
	}
}
*/
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="java-8functional-interfaces--lambda-expressions-cuc-de-hieu"><a class="header" href="#java-8functional-interfaces--lambda-expressions-cuc-de-hieu">「Java 8」Functional Interfaces &amp; Lambda Expressions cực dễ hiểu</a></h1>
<h3 id="giới-thiệu-1"><a class="header" href="#giới-thiệu-1">Giới thiệu</a></h3>
<p>Khái niệm <code>Functional Interfaces</code> được <code>Java</code> đưa ra cùng với phiên bản <code>Java 8</code>. về cơ bản, có thể hiểu:</p>
<blockquote>
<p>Functional Interfaces là interface nhưng chỉ có một 1 abstract function duy nhất.</p>
</blockquote>
<p>Ví dụ:</p>
<pre><code class="language-java">interface Runable {
    public void run(); // Chỉ có duy nhất một abstract function.
}
</code></pre>
<h3 id="functional-programming"><a class="header" href="#functional-programming">Functional Programming</a></h3>
<p>Trước khi đi vào chi tiết, chúng ta cùng tìm hiểu khái niệm <code>Lập trình hướng hàm</code>.</p>
<p>Cùng xem ví dụ dưới đây:</p>
<pre><code class="language-java">public static void main(String[] args) {
    // Mình muốn xử lý dữ liệu trước khi ỉn ra màn hình.
    System.out.println(process(&quot;Hey Loda!!!&quot;));
}

public static String process(String input){
    // Cho tất cả viết hoa lên.
    return input.toUpperCase();
}

// Output:
HEY LODA!!!
</code></pre>
<p>Tuy nhiên bạn sẽ thấy cách làm này không <code>flexible</code>, vì các bạn chỉ có thể xử lý cho chữ thành <code>UPPER CASE</code>. Muốn làm gì đó khác, như <code>toLowerCase</code> chẳng hạn, mình sẽ phải viết một <code>function</code> mới.</p>
<p>Chúng ta giải quyết cách cách này bằng <code>Anonymous function (Hàm ẩn danh)</code></p>
<p>Sửa code chút:</p>
<pre><code class="language-java">public interface StringProcessor{
    public String process(String input);
}

// StringProcessor ở đây là một Interface, hay Functional Interface
public static String getStr(String input, StringProcessor processor){
    return processor.process(input);
}

public static void main(String[] args) {
    // In ra chữ hoa
    System.out.println(getStr(&quot;Hello Loda!&quot;, new StringProcessor() {
        @Override
        public String process(String input) {
            return input.toUpperCase();
        }
    }));

    // In ra chữ thường
    System.out.println(getStr(&quot;Hey Loda!&quot;, new StringProcessor() {
        @Override
        public String process(String input) {
            return input.toLowerCase();
        }
    }));
}
// Output:
// HELLO LODA!
// hey loda!
</code></pre>
<h3 id="lambda-expressions"><a class="header" href="#lambda-expressions">Lambda Expressions</a></h3>
<p>Quay lại ví dụ ở trên, chúng ta thấy là <code>StringProcessor</code> chỉ có duy nhất một <code>function process(x)</code>. Nên mọi đoạn code đều sẽ giống hệt nhau ở việc <code>implement function</code> này.</p>
<pre><code class="language-java">new StringProcessor() {
    @Override
    public String process(String input) {
        // Do something here
        // Chỉ khác nhau đoạn code ở giữa
        return x;
    }
}
</code></pre>
<p>Thực ra cái chúng ta quan tâm là: <code>Input -&gt; Process -&gt; Output</code>. Hãy thử nhìn ở ví dụ dưới cho Lambda Expressions:</p>
<pre><code class="language-java">// (input) -&gt; input.toUpperCase()
// đầu vào -&gt; đầu ra
System.out.println(getStr(&quot;Hello Loda!&quot;, input -&gt; input.toUpperCase()));

// Cấu trúc của một lambda như sau:
// parameter -&gt; expression body
</code></pre>
<p>Trong đó:</p>
<ul>
<li><code>parameter</code> là những tham số đầu vào của hàm (một hoặc nhiều)</li>
<li><code>expression body</code> là phần xử lý <code>parameter</code>, bạn cần trả ra đúng kiểu dữ liệu đã khai báo trong <code>Functional Interface</code></li>
</ul>
<p>Nếu <code>code</code> bạn chỉ cần 1 thao tác, thì không cần <code>return</code> giống ví dụ ở trên. Còn nếu <code>code</code> yêu cầu xử lý nhiều, thì dạng đầy đủ của nó như sau:</p>
<pre><code>parameter -&gt; {
    expression body
    [return] // (không trả về nếu là void)
}
</code></pre>
<p>ví dụ:</p>
<pre><code class="language-java">System.out.println(getStr(&quot;Hello Loda!&quot;, input -&gt; {
    String temp =  input + &quot; Oke!!!&quot;;
    return temp.toLowerCase();
}));
</code></pre>
<h3 id="functional-interface"><a class="header" href="#functional-interface">Functional Interface</a></h3>
<p>Tới đây, bạn đã hiểu ý nghĩa của việc cho ra đời khái niệm <code>Functional Interface</code>, nó là một quy định chung phải có để có thể viết code dưới dạng biểu thức <code>Lambda</code>. Một số điều cần lưu ý với <code>Functional Interface</code> như sau:</p>
<h4 id="functionalinterface"><a class="header" href="#functionalinterface">@FunctionalInterface</a></h4>
<p><code>Annotation</code> này chỉ để bổ sung, nó đánh dấu một <code>interface</code> là <code>Functional Interface</code>. Lúc này bạn khai báo 2 <code>abtract function</code> bên trong <code>interface</code> thì sẽ báo lỗi.</p>
<pre><code class="language-java">@FunctionalInterface // Gắn cái này lên interface, nó đánh dấu interface chỉ được phép có 1 funtion thôi
public interface StringProcessor{
    public String process(String input);
    public String preProcess(String input); // lỗi
}
</code></pre>
<h4 id="default-function--static-funtion"><a class="header" href="#default-function--static-funtion">default function &amp; static funtion</a></h4>
<p><code>Java 8</code> cải tiến cho phép <code>interface</code> được khai báo <code>code</code> bên trong nó, với điều kiện <code>code</code> phải nằm trong <code>default</code> hoặc <code>static</code>. <code>default</code> và <code>static</code> không phá vỡ quy luật của <code>@FunctionInterfaces</code></p>
<pre><code class="language-java">@FunctionalInterface // Gắn cái này lên interface, nó đánh dấu interface chỉ được phép có 1 funtion thôi
public interface StringProcessor{
    public String process(String input);

    // Mọi class implement StringProcessor đều có thể gọi hàm này để sử dụng luôn
    public default void printf(Object t){
        System.out.println(t);
    }

    // Là hàm static, gọi từ class cũng được.         
    // StringProcessor.concat(a,b)
    public static String concat(String a, String b){
        return a + b;
    }
}
</code></pre>
<h3 id="method-reference"><a class="header" href="#method-reference">Method reference</a></h3>
<p>Phần này chỉ để bổ sung, không có nó, bạn vẫn có thể sử dụng <code>Lambda Expressions</code> bình thường. Nhưng với <code>Method reference</code>, code của bạn sẽ còn sạch sẽ hơn nữa.</p>
<p>Ví dụ:</p>
<pre><code class="language-java">System.out.println(getStr(&quot;Hello Loda!&quot;, input -&gt; input.toUpperCase()));
// Tương đương với việc viết như này:
System.out.println(getStr(&quot;Hello Loda!&quot;, String::toUpperCase));
</code></pre>
<p>hoặc</p>
<pre><code class="language-java">System.out.println(getStr(&quot;Hello Loda!&quot;, input -&gt; new String(input));
// Tương đương với việc viết như này:
System.out.println(getStr(&quot;Hello Loda!&quot;, String::new));
</code></pre>
<p><code>Method reference</code> là cách viết ngắn gọn, sẽ bỏ qua luôn cả phần <code>parameter</code> vì bản thân tên hàm đã biết nó sẽ nhận vào gì và trả ra cái gì rồi. Việc còn lại để <code>Compiler</code> lo thôi kakaka. Có các cách để gọi <code>Method reference</code> như sau:</p>
<ul>
<li><code>[Tên Class]::[Tên method]</code>: Giống với ví dụ ở trên <code>String::toUpperCase</code>.</li>
<li><code>[Tên Class]::new</code>: Tạo ra một đối tượng mới, từ tham số được truyền vào</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="huong-dan-stream-api"><a class="header" href="#huong-dan-stream-api">Hướng dẫn Stream API</a></h1>
<h3 id="khái-quát"><a class="header" href="#khái-quát">Khái quát</a></h3>
<p><code>Stream</code> là một abtract layer cho phép bạn xử lý một dòng dữ liệu dựa trên các thao tác đã định nghĩa trước. Bạn có thể tạo <code>Stream</code> từ các nguồn dữ liệu như <code>Collections</code>, <code>Arrays</code> hoặc <code>I/O resources</code>. Mặc định các lớp kế thừa của <code>Collection</code> đều có hàm <code>.stream()</code>:</p>
<pre><code class="language-java">Collection&lt;String&gt; collection = Arrays.asList(&quot;hello&quot;, &quot;loda&quot;, &quot;kaka&quot;);
Stream&lt;String&gt; streamOfCollection = collection.stream(); // Tạo ra một stream từ collection
List&lt;String&gt; list = new ArrayList&lt;&gt;();
Stream&lt;String&gt; stream = list.stream(); // tạo ra 1 luồng
Stream&lt;String&gt; parallelStream = list.parallelStream(); // luồng dữ liệu song song (xử lý trên nhiều thread cùng lúc)
</code></pre>
<h3 id="cách-sử-dụng"><a class="header" href="#cách-sử-dụng">Cách sử dụng</a></h3>
<p>Chức năng của <code>Stream</code> là cực kì đa dạng giúp bạn thao tác dữ liệu dễ dàng hơn.</p>
<h4 id="foreach-duyệt-qua-toàn-bộ-dữ-liệu-của-bạn"><a class="header" href="#foreach-duyệt-qua-toàn-bộ-dữ-liệu-của-bạn"><code>forEach()</code>: Duyệt qua toàn bộ dữ liệu của bạn</a></h4>
<pre><code class="language-java">list.stream().forEach(s -&gt; System.out.println(s));
</code></pre>
<h4 id="map-tạo-ra-các-giá-trị-mới-từ-dữ-liệu-hiện-có"><a class="header" href="#map-tạo-ra-các-giá-trị-mới-từ-dữ-liệu-hiện-có"><code>map()</code>: Tạo ra các giá trị mới từ dữ liệu hiện có</a></h4>
<pre><code class="language-java">Arrays.asList(3, 5, 7)
    .stream() // tạo ra Stream từ List&lt;Integer&gt;
    .map(i -&gt; &quot;loda-&quot;+i) // biến đổi từng phần tử thành String
    .map(String::toUpperCase) // biến đổi từng phần tử thành Upper case
    .forEach(System.out::println); // in ra xem thử
</code></pre>
<h4 id="filter-gíup-chúng-ta-thao-tác-với-những-dữ-liệu-mong-muốn"><a class="header" href="#filter-gíup-chúng-ta-thao-tác-với-những-dữ-liệu-mong-muốn"><code>filter()</code> gíup chúng ta thao tác với những dữ liệu mong muốn.</a></h4>
<pre><code class="language-java">Arrays.asList(2, 3, 5, 7)
    .stream()
    .filter(i -&gt; i % 2 != 0) //từ đây trở đi, chúng ta chỉ muốn làm việc với số lẻ
    .map(i -&gt; &quot;loda-&quot; + i)
    .map(String::toUpperCase)
    .forEach(System.out::println);
</code></pre>
<h4 id="limit-giới-hạn-số-lượng-dữ-liệu-cần-xử-lý"><a class="header" href="#limit-giới-hạn-số-lượng-dữ-liệu-cần-xử-lý"><code>limit()</code>: Giới hạn số lượng dữ liệu cần xử lý</a></h4>
<pre><code class="language-java">IntStream.range(1, 1000).boxed() // Tạo ra Stream có dữ liệu từ 1-&gt;999
            .filter(i -&gt; i % 2 != 0)
            .map(i -&gt; &quot;loda-&quot; + i)
            .map(String::toUpperCase)
            .limit(10) // Chúng ta giới hạn lấy 10 cái rồi in ra
            .forEach(System.out::println);
</code></pre>
<h4 id="sorted-sắp-xếp-stream-bạn-có-thể-tự-định-nghĩa-cách-sort-bằng-cách-thêm-comparator-vào"><a class="header" href="#sorted-sắp-xếp-stream-bạn-có-thể-tự-định-nghĩa-cách-sort-bằng-cách-thêm-comparator-vào"><code>sorted()</code>: sắp xếp <code>Stream</code>. Bạn có thể tự định nghĩa cách sort bằng cách thêm Comparator vào</a></h4>
<pre><code class="language-java">sorted((o1, o2) -&gt; o1.compareTo(o2))
</code></pre>
<pre><code class="language-java">List&lt;String&gt; result = IntStream.range(1, 1000).boxed()
                                .filter(i -&gt; i % 2 != 0)
                                .map(i -&gt; &quot;loda-&quot; + i)
                                .map(String::toUpperCase)
                                .limit(10)
                                .sorted(Comparator.naturalOrder()) // một cách khác để sort
                                .collect(Collectors.toList());
</code></pre>
<h4 id="collect-giúp-chúng-ta-lấy-toàn-bộ-dữ-liệu-đã-biến-đổi-trong-stream-thành-đối-tượng-mình-mong-muốn"><a class="header" href="#collect-giúp-chúng-ta-lấy-toàn-bộ-dữ-liệu-đã-biến-đổi-trong-stream-thành-đối-tượng-mình-mong-muốn"><code>collect()</code> giúp chúng ta lấy toàn bộ dữ liệu đã biến đổi trong <code>Stream</code> thành đối tượng mình mong muốn.</a></h4>
<pre><code class="language-java">List&lt;String&gt; result = Stream.of(&quot;bạn&quot;, &quot;hãy&quot;, &quot;like&quot;, &quot;Fanpage&quot;, &quot;loda&quot;,&quot;dể&quot;,&quot;cập&quot;,&quot;nhật&quot;,&quot;nhiều&quot;,&quot;hơn&quot;)
                            .filter(s -&gt; {
                                System.out.println(&quot;[filtering] &quot; + s);
                                return s.length()&gt;=4;
                            })
                            .map(s -&gt; {
                                System.out.println(&quot;[mapping] &quot; + s);
                                return s.toUpperCase();
                            })
                            .limit(3)
                            .collect(Collectors.toList());
System.out.println(&quot;----------------------&quot;);
System.out.println(&quot;Result:&quot;);
result.forEach(System.out::println);
</code></pre>
<pre><code class="language-makefile">[filtering] bạn // không thoả mãn
[filtering] hãy // tiếp tục tìm, cũng k thoả mãn
[filtering] like // thoả mãn
[mapping] like // mapping nó luôn
[filtering] Fanpage // lại quay lại filter tìm tiếp, thoả mãn
[mapping] Fanpage // mapping
[filtering] loda // thoả mãn
[mapping] loda // mapping
// Đủ 3 trường hợp thoả mãn, dừng.
----------------------
Result:
LIKE
FANPAGE
LODA
</code></pre>
<h3 id="bản-chất-của-stream"><a class="header" href="#bản-chất-của-stream">Bản chất của Stream</a></h3>
<p>(Có ví dụ trong bài gốc nữa)</p>
<p><code>Stream</code> là <code>Lazy evaluation</code>. Hiểu đơn giản là nó sẽ không xử lý dữ liệu trực tiếp qua từng bước, mà chờ bạn khai báo xong tất cả các thao tác <code>operation</code> như <code>map</code>, <code>filter</code>,v.v.. cho tới khi gặp lệnh <code>.collect()</code> thì nó thực hiện toàn bộ trong một vòng lặp duy nhất.</p>
<p>Hàm <code>.collect()</code> và một số hàm như <code>min()</code>, <code>max()</code>, <code>count()</code> được gọi là <code>terminal operation</code>. Khi gọi những function có dạng <code>terminal</code> thì <code>Stream</code> mới chính thức hoạt động. </p>
<p>Một lưu ý khi sử dụng là Stream không được tái sử dụng. Vì <code>Stream</code> được tạo ra để xử lý dữ liệu chứ không phải để lưu trữ! Nên muốn sử dụng, mỗi lần bạn sẽ cần tạo ra 1 <code>Stream</code> mới.</p>
<pre><code class="language-java">Stream&lt;String&gt; stream =
  Stream.of(&quot;loda&quot;, &quot;.&quot;, &quot;me&quot;,&quot;like&quot;).filter(element -&gt; element.contains(&quot;e&quot;));
Optional&lt;String&gt; anyElement = stream.findAny(); //Lấy ra một phần tử bất kỳ trong Stream, nó sẽ trả ra Optional

// Thực hiện dòng lệnh tiếp theo sẽ bắn ra IllegalStateException
Optional&lt;String&gt; firstElement = stream.findFirst();
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="khai-niem-threadpool-va-executor-trong-java"><a class="header" href="#khai-niem-threadpool-va-executor-trong-java">Khái niệm ThreadPool và Executor trong Java</a></h1>
<p>Một ví dụ đơn giản nhé (Trong thực tế sẽ khác, hãy coi đây là ví dụ nha):</p>
<p>Bây giờ, giả sử bạn có một Server Web. Nếu chúng ta nhận 1 request từ client, chúng ta sẽ xử lý mất 0.5s và trả về kết quả cho người dùng.</p>
<p>Thế nếu có 2 người request cùng lúc? =&gt; giải quyết bằng cách mỗi một request sẽ xử lý ở 1 thread, đơn giản.</p>
<p>Thế nếu có 100 người request cùng lúc? =&gt; mỗi người tạo một thre... wait a minute.... (nếu 1 tháng có 10M lượt request =&gt; tạo ra 10M thread)</p>
<p>Nếu bạn tạo 1-2 thread mới, chả ai trách gì bạn cả. Nhưng nếu bạn tạo liên tục và tới hàng trăm cái mới mỗi lần nhưng lại giải quyết cùng 1 vấn đề thì có lỗ hổng đấy. Vì chi phí của việc tạo 1 thread là tương đối lớn, thường dẫn tới các vấn đề về hiệu năng và cấp phát dữ liệu.</p>
<p>Với việc xử lý các tác vụ liên tục như vậy, có một giải pháp là sử dụng <code>Thread Pool</code>.</p>
<p>Ở ví dụ trên, Bây giờ tôi sẽ chỉ sử dụng 30 thread thôi! Và đặt 30 thread này ở trạng thái không làm gì và vứt vào 1 cái <code>Pool</code> (1 cái bể chứa, kiểu vậy). Với mỗi request đến, tôi sẽ lấy trong <code>Pool</code> ra 1 thread và xử lý công việc, xử lý xong, thì cất thread vào ngược trở lại pool. Đơn giản vậy thôi, như thế chúng ta sẽ không phải tạo mới Thread nữa. Tránh tình tốn chi phí và hiệu năng.</p>
<p>Vấn đề là giả sử có hơn 31 request tới cùng lúc thì sao? rất đúng, trường hợp này là chắc chắn có. Lúc này <code>Pool</code> sẽ không còn thread nào sẵn có nữa. Nên 1 request còn lại sẽ bị đẩy vào 1 hàng đợi <code>BlockingQueue</code>. Nó sẽ đợi ở đó, bao giờ <code>Pool</code> có 1 thread rảnh rỗi thì sẽ quay lại xử lý nốt.</p>
<h3 id="cách-tạo-threadpool-trong-java"><a class="header" href="#cách-tạo-threadpool-trong-java">Cách tạo ThreadPool trong Java</a></h3>
<p>Java Concurrency API hỗ trợ một vài loại <code>ThreadPool</code> sau:</p>
<ul>
<li><strong>Cached thread pool</strong>: Mỗi nhiệm vụ sẽ tạo ra thread mới nếu cần, nhưng sẽ tái sử dụng lại các thread cũ. (Cái này vẫn nguy hiểm nhé, nên áp dụng với các task nhỏ, tốn ít tính toán)</li>
<li><strong>Fixed thread pool</strong>: giới hạn số lượng tối đa của các Thread được tạo ra. Các task khác đến sau phải chờ trong hàng đợi (BlockingQueue). (Ví dụ đầu bài)</li>
<li><strong>Single-threaded pool</strong>: chỉ giữ một Thread thực thi một nhiệm vụ một lúc.</li>
<li><strong>Fork/Join pool</strong>: một Thread đặc biệt sử dụng Fork/ Join Framework bằng cách tự động chia nhỏ công việc tính toán cho các core xử lý. (Tính toán song song)</li>
</ul>
<h3 id="executor"><a class="header" href="#executor"><strong>Executor</strong></a></h3>
<p><code>Executor</code> là một class đi kèm trong gói <code>java.util.concurrent</code>, là một đối tượng chịu trách nhiệm quản lý các luồng và thực hiện các tác vụ Runnable được yêu cầu xử lý. Nó tách riêng các chi tiết của việc tạo Thread, lập kế hoạch (scheduling), … để chúng ta có thể tập trung phát triển logic của tác vụ mà không quan tâm đến các chi tiết quản lý Thread.</p>
<p>Nói chung nó là thằng wrapper các các bước mình nói ở trên, và quản lý hộ chúng ta.</p>
<p>Chúng có thể tạo một Executor bằng cách sử dụng một trong các phương thức được cung cấp bởi lớp tiện ích <code>Executors</code> như sau:</p>
<ul>
<li><strong>newSingleThreadExecutor()</strong>: trong ThreadPool chỉ có 1 Thread và các task (nhiệm vụ) sẽ được xử lý một cách tuần tự.</li>
<li><strong>newCachedThreadPool()</strong>: như giải thích ở trên, nó sẽ có 1 số lượng nhất định thread để sử dụng lại, nhưng vẫn sẽ tạo mới thread nếu cần. Mặc định nếu một Thread không được sử dụng trong vòng 60 giây thì Thread đó sẽ bị tắt.</li>
<li><strong>newFixedThreadPool(int n)</strong>: trong Pool chỉ có n Thread để xử lý nhiệm vụ, các yêu cầu tới sau bị đẩy vào hàng đợi</li>
<li><strong>newScheduledThreadPool(int corePoolSize)</strong>: tương tự như <code>newCachedThreadPool()</code> nhưng sẽ có thời gian delay giữa các Thread.</li>
<li><strong>newSingleThreadScheduledExecutor()</strong>: tương tự như <code>newSingleThreadExecutor()</code> nhưng sẽ có khoảng thời gian delay giữa các Thread.</li>
</ul>
<h3 id="code-chạy-thử"><a class="header" href="#code-chạy-thử"><strong>Code chạy thử</strong></a></h3>
<p>Chúng ta sẽ lấy ví dụ đầu bài để code luôn nhé.</p>
<p>Tạo một class implement <code>Runnable</code> để xử lý request đến. (phân biệt <code>Runnable</code> và <code>Thread</code> nhé các bạn)</p>
<pre><code class="language-java">public class RequestHandler implements Runnable {
    String name;
    public RequestHandler(String name){
        this.name = name;
    }

    @Override
    public void run() {
        try {
            // Bắt đầu xử lý request đến
            System.out.println(Thread.currentThread().getName() + &quot; Starting process &quot; + name);
            // cho ngủ 500 milis để ví dụ là quá trình xử lý mất 0,5 s
            Thread.sleep(500);
            // Kết thúc xử lý request
            System.out.println(Thread.currentThread().getName() + &quot; Finished process &quot; + name);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
</code></pre>
<h3 id="newsinglethreadexecutor"><a class="header" href="#newsinglethreadexecutor"><strong>newSingleThreadExecutor</strong></a></h3>
<pre><code class="language-java">import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class SingleThreadPoolExample {
    public static void main(String[] args) {
        ExecutorService executor = Executors.newSingleThreadExecutor();

        // Có 100 request tới cùng lúc
        for (int i = 0; i &lt; 100; i++) {
            executor.execute(new RequestHandler(&quot;request-&quot; + i));
        }
        executor.shutdown(); // Không cho threadpool nhận thêm nhiệm vụ nào nữa

        while (!executor.isTerminated()) {
            // Chờ xử lý hết các request còn chờ trong Queue ...
        }
    }
}
// OUTPUT:
/*
..
..
pool-1-thread-1 Starting process request-98
pool-1-thread-1 Finished process request-98
pool-1-thread-1 Starting process request-99
pool-1-thread-1 Finished process request-99
*/
</code></pre>
<p>Cả chương trình chỉ có 1 pool, 1 thread duy nhất, xử lý toàn bộ request đến. Cái nào đến sau thì đợi thôi.</p>
<h3 id="newfixedthreadpool"><a class="header" href="#newfixedthreadpool"><strong>newFixedThreadPool()</strong></a></h3>
<pre><code class="language-java">public class FixedThreadPoolExample {
    public static void main(String[] args) throws InterruptedException {
        ExecutorService executor = Executors.newFixedThreadPool(5);

        // Có 100 request tới cùng lúc

        for (int i = 0; i &lt; 100; i++) {
            executor.execute(new RequestHandler(&quot;request-&quot; + i));
        }
        executor.shutdown(); // Không cho threadpool nhận thêm nhiệm vụ nào nữa

        while (!executor.isTerminated()) {
            // Chờ xử lý hết các request còn chờ trong Queue ...
        }
    }
}
// OUTPUT:
/*
..
..
pool-1-thread-2 Finished process request-96
pool-1-thread-5 Starting process request-99
pool-1-thread-3 Finished process request-97
pool-1-thread-4 Finished process request-98
pool-1-thread-5 Finished process request-99
*/
</code></pre>
<p>Loại này thì chúng ta cố định 5 thread, và nó cử mặc định như vậy mà xài thôi, thiếu thread thì phải chờ tới khi có</p>
<h3 id="newcachedthreadpool"><a class="header" href="#newcachedthreadpool"><strong>newCachedThreadPool()</strong></a></h3>
<pre><code class="language-java">public class CachedThreadPoolExample {
    public static void main(String[] args) throws InterruptedException {
        ExecutorService executor = Executors.newCachedThreadPool();

        // Có 100 request tới cùng lúc

        for (int i = 0; i &lt; 100; i++) {
            executor.execute(new RequestHandler(&quot;request-&quot; + i));
            Thread.sleep(200);
        }
        executor.shutdown(); // Không cho threadpool nhận thêm nhiệm vụ nào nữa

        while (!executor.isTerminated()) {
            // Chờ xử lý hết các request còn chờ trong Queue ...
        }
    }
}

//OUTPUT:
/*
..
..
pool-1-thread-3 Starting process request-98
pool-1-thread-1 Finished process request-96
pool-1-thread-1 Starting process request-99
pool-1-thread-2 Finished process request-97
pool-1-thread-3 Finished process request-98
pool-1-thread-1 Finished process request-99
*/
</code></pre>
<p>Có chút khởi sắc, chương trình chạy nhanh hơn hẳn. Vì nó được tạo số thread thoải mái nếu cần :)))) Rất nguy hiểm. Nhưng bạn sẽ thấy là có chỗ nó sử dụng lại các thread đã xong trước đó.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="threadpoolexecutor-va-nguyen-tac-quan-ly-pool-size"><a class="header" href="#threadpoolexecutor-va-nguyen-tac-quan-ly-pool-size">ThreadPoolExecutor và nguyên tắc quản lý pool size</a></h1>
<ul>
<li>Khái niệm</li>
<li>Nguyên tắc vận hành</li>
<li>Code ví dụ</li>
</ul>
<h3 id="giới-thiệu-2"><a class="header" href="#giới-thiệu-2"><strong>Giới thiệu</strong></a></h3>
<p><code>ThreadPoolExecutor</code> là một class nâng cao hơn của các <code>ThreadPool</code> cơ bản trong gói java concurrent. Cụ thể các thể loại ThreadPool khác bạn xem ở đây:</p>
<ol>
<li>Khái niệm ThreadPool và Executor trong Java</li>
</ol>
<p>Đặc điểm của các loại <code>ThreadPool</code> thông thường được cung cấp trong <code>ExecutorService</code> là không đủ linh động theo tình huống. điển hình là bị fix số lượng thread, hoặc cho phép tạo quá nhiều thread. Nó thực sự chưa phải phương án tối ưu.</p>
<p><code>ThreadPoolExecutor</code> thì khác, một phiên bản nâng cấp hơn, cho phép chúng ta tùy biến số lượng Thread theo kịch bản. Giúp nó thông minh hơn mấy cái kia một chút.</p>
<p>Ngoài ra còn có <code>ThreadPoolTaskExecutor</code> do <code>Spring Framework</code> cung cấp cũng hoạt động tương tự</p>
<h3 id="khái-niệm-1"><a class="header" href="#khái-niệm-1"><strong>Khái niệm</strong></a></h3>
<p><code>ThreadPoolExecutor</code> và <code>ThreadPoolTaskExecutor</code> cũng là <code>Executor</code> nhưng nó có thêm các tham số như sau:</p>
<ul>
<li><code>corePoolSize</code>: Số lượng Thread mặc định trong <code>Pool</code></li>
<li><code>maxPoolSize</code>: Số lượng tối đa Thread trong <code>Pool</code></li>
<li><code>queueCapacity</code>: Số lượng tối da của <code>BlockingQueue</code></li>
</ul>
<h3 id="nguyên-tắc-vận-hành"><a class="header" href="#nguyên-tắc-vận-hành"><strong>Nguyên tắc vận hành</strong></a></h3>
<p>Ví dụ với <code>ThreadPoolExecutor</code> có:</p>
<ul>
<li><code>corePoolSize</code>: 5</li>
<li><code>maxPoolSize</code>: 15</li>
<li><code>queueCapacity</code>: 100</li>
</ul>
<ol>
<li>Khi có request, nó sẽ tạo trong Pool tối đa 5 thread (<code>corePoolSize</code>).</li>
<li>Khi số lượng thread vượt quá 5 thread. Nó sẽ cho vào hàng đợi.</li>
<li>Khi số lượng hàng đợi full 100 (<code>queueCapacity</code>). Lúc này mới bắt đầu tạo thêm Thread mới.</li>
<li>Số thread mới được tạo tối đa là 15 (<code>maxPoolSize</code>).</li>
<li>Khi Request vượt quá số lượng 15 thread. Request sẽ bị từ chối!</li>
</ol>
<p>Với kịch bản như thế này, bạn sẽ luôn tiết kiệm được số lượng thread sử dụng là 5 trong trường hợp bình thường. Nhưng vẫn có thể handle lên tới 15 thread nếu server quá tải.</p>
<p>Điểm chúng ta hay nhầm lẫn là điều kiện để tạo thêm thread đó là khi <strong>hàng đợi phải full</strong>. Đúng vậy, nếu hàng đợi chưa full, thì có nghĩa chúng ta chưa quá tải.</p>
<h3 id="code-ví-dụ"><a class="header" href="#code-ví-dụ"><strong>Code ví dụ</strong></a></h3>
<p>Tạo ra một Runnable để xử lý các nhiệm vụ.</p>
<pre><code class="language-java">public class RequestHandler implements Runnable {
    String name;
    public RequestHandler(String name){
        this.name = name;
    }

    @Override
    public void run() {
        try {
            System.out.println(Thread.currentThread().getName() + &quot; Starting process &quot; + name);
            // Giả sử nhiệm vụ xử lý hết 0.5s
            Thread.sleep(500);
            System.out.println(Thread.currentThread().getName() + &quot; Finished process &quot; + name);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
</code></pre>
<p>Tạo ra <code>ThreadPoolExecutor</code> để xử lý 1000 request tới dồn dập.</p>
<pre><code class="language-java">public class ThreadPoolExecutorExample {
    public static void main(String[] args) {
        int corePoolSize = 5;
        int maximumPoolSize = 10;
        int queueCapacity = 100;
        ThreadPoolExecutor executor = new ThreadPoolExecutor(corePoolSize, // Số corePoolSize
                                                             maximumPoolSize, // số maximumPoolSize
                                                             10, // thời gian một thread được sống nếu không làm gì
                                                             TimeUnit.SECONDS,
                                                             new ArrayBlockingQueue&lt;&gt;(queueCapacity)); // Blocking queue để cho request đợi
        // 1000 request đến dồn dập, liền 1 phát, không nghỉ
        for (int i = 0; i &lt; 1000; i++) {
            executor.execute(new RequestHandler(&quot;request-&quot; + i));
        }
        executor.shutdown(); // Không cho threadpool nhận thêm nhiệm vụ nào nữa

        while (!executor.isTerminated()) {
            // Chờ xử lý hết các request còn chờ trong Queue ...
        }
    }
}

// OUTPUT
/*
..
..
pool-1-thread-3 Finished process request-96
pool-1-thread-5 Finished process request-97
pool-1-thread-4 Finished process request-98
pool-1-thread-8 Finished process request-100
pool-1-thread-2 Finished process request-99
pool-1-thread-6 Finished process request-102
pool-1-thread-7 Finished process request-101
pool-1-thread-9 Finished process request-104
pool-1-thread-10 Finished process request-103
*/
</code></pre>
<p>Bạn sẽ thấy là chương trình đã phải sử dụng tới 10 thread để xử lý hết 1000 request cùng 1 lúc. Nhớ là cùng 1 lúc nhé các bạn, thế là nhiều rồi đó. Và theo nguyên tắc. Nó đã tận dụng hết <code>maxPoolSize</code> rồi. Mà <code>queue</code> vẫn full. Nên các request không ở trong <code>queue</code> sẽ bị reject. Dẫn tới chỉ sử lý được <code>104 request</code> mà thôi.</p>
<p>Bây giờ, vẫn là ví dụ này, nhưng mỗi request cách nhau <code>50 milliseconds</code> thì sẽ như nào, dễ thở hơn k? chỉ 0.05s thôi.</p>
<pre><code class="language-java">for (int i = 0; i &lt; 1000; i++) {
    executor.execute(new RequestHandler(&quot;request-&quot; + i));
    Thread.sleep(50);
}
// OUTPUT:
/*
..
..
pool-1-thread-2 Finished process request-993
pool-1-thread-1 Finished process request-994
pool-1-thread-3 Finished process request-995
pool-1-thread-4 Finished process request-996
pool-1-thread-5 Finished process request-997
pool-1-thread-9 Finished process request-998
pool-1-thread-10 Finished process request-999
*/
</code></pre>
<p>Xử lý gọn gàng, sạch sẽ các bạn ạ. Sức mạnh của <code>ThreadPoolExecutor</code> phát huy rõ rệt hơn. Tận dụng được 10 thread và queue vẫn còn chỗ nên rất nhanh, khác biệt trong một hệ thống có thể đc tính bằng <code>milliseconds</code> như vậy đó. nếu mỗi request cách nhau <code>100 milliseconds</code> thì nó chỉ cần sử dụng 5 thread thôi.</p>
<p>toàn bộ code mình để tại Github: CODE</p>
<p>Chúc các bạn học tập tốt! ohoho</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gioi-thieu-reactive-programming-voi-reactor"><a class="header" href="#gioi-thieu-reactive-programming-voi-reactor">Giới thiệu Reactive Programming với Reactor</a></h1>
<h3 id="giới-thiệu-3"><a class="header" href="#giới-thiệu-3"><strong>Giới thiệu</strong></a></h3>
<p>Các ứng dụng hiện nay yêu cầu một tốc độ phản hồi cao để nâng cao trải nghiệm người dùng, giúp hệ thống mượt mà, linh hoạt, không bị đóng băng luồng. Các yêu cầu này cũng là kết quả hướng tới khi chúng ta sử dụng mô hình lập trình theo <strong>Reactive Programming</strong>.</p>
<p>Trong bài viết này, chúng ta sẽ cố gắng làm sáng tỏ mô hình lập trình này thông qua một số khái niệm <code>Synchronous</code> và <code>Asynchronous</code> , <code>Blocking</code> và <code>Non-Blocking</code> trước.</p>
<h3 id="synchronous-và-asynchronous"><a class="header" href="#synchronous-và-asynchronous"><strong>Synchronous và Asynchronous</strong></a></h3>
<p><code>Synchronous</code> (Xử lý đồng bộ): là xử lý mà chương trình sẽ chạy theo từng bước, nghĩa là thực hiện xong đoạn code trên mới tới đoạn code kế tiếp và sẽ theo thứ tự từ trên xuống dưới, từ trái qua phải. Đây cũng là nguyên tắc cơ bản mà các bạn đã được học.</p>
<p><code>Asynchronous</code> (Xử lý bất đồng bộ): Ngược lại với xử lý đồng bộ, nghĩa là chương trình có thể hoạt động nhảy cóc, function phía dưới có thể hoạt động mà không cần phải chờ function hay một đoạn code nào đó phía trên thực hiện xong. Dưới đây là minh họa cho việc làm việc với dữ liệu đồng bộ và bất đồng bộ :</p>
<p>!image</p>
<p>Như ta thấy nếu các công việc không liên quan đến nhau thì bất đồng bộ giúp ta tiết kiệm thời gian xử lý hơn và mang lại cho người dùng trải nghiệm tốt hơn.</p>
<h3 id="blocking-và-non-blocking"><a class="header" href="#blocking-và-non-blocking"><strong>Blocking và Non-Blocking</strong></a></h3>
<p>Chúng ta có thể hiểu một cách đơn giản khi chúng ta muốn dấy một danh sách <code>Student</code>.</p>
<p>Lập trình theo mô hình <code>Blocking</code> thì phải chờ đợi chương trình thực hiện lấy tất cả <code>Student</code> rồi mới thực hiện các thao tác tiếp theo, hay được gọi là bị đóng băng luồng chờ quá trình đóng gói tất cả <code>Student</code> hoàn tất. Do đó sẽ dẫn tốn thời gian chờ đợi nếu số lượng danh sách rất lớn.</p>
<p>Lập trình theo mô hình <code>Non-Blocking</code> thì hoạt động ngược lại, không cần phải chờ đợi hoàn thiện cả danh sách <code>Student</code> mà với mỗi <code>Student</code> nào được đưa ra thì thực hiện thao tác luôn với nó. Điều này dẫn tới không bị đóng băng luồng, kể cả số lượng danh sách lớn.</p>
<h3 id="reactive-programming"><a class="header" href="#reactive-programming"><strong>Reactive Programming</strong></a></h3>
<p>Nói một cách ngắn gọn, <strong>Reactive Programming</strong> là mô hình lập trình mà ở đó dữ liệu được truyền tải dưới dạng luồng ( stream). Mô hình này dưa trên nguyên tắc <code>Asynchronous</code> và <code>Non-Blocking</code> để làm việc với dữ liệu.</p>
<p>Dưới đây là một số khái niệm mà bạn cần phải biết khi làm việc với mô hình này:</p>
<p><strong>Publisher:</strong> Là nhà cung cấp dữ liệu, hoặc là nơi phát ra nguồn dữ liệu.</p>
<p><strong>Subscriber:</strong> Lắng nghe <strong>Publisher</strong>, yêu cầu dữ liệu mới. Hay được gọi Là người tiêu thụ dữ liệu.</p>
<p><strong>Backpressure:</strong> Là khả năng mà <strong>Subscriber</strong> cho phép <strong>Publisher</strong> có thể xử lý bao nhiêu yêu cầu tại thời điểm đó. Bởi vì <strong>Subscriber</strong> chịu trách nhiệm về luồng dữ liệu, không phải <strong>Publisher</strong> vì nó chỉ cung cấp dữ liệu.</p>
<p><strong>Stream:</strong> Luồng dữ liệu bao gồm các dữ liệu trả về , các lỗi xảy ra và luồng này phải là luồng bất đồng bộ.</p>
<p>Như vậy dữ liệu của chúng ra sẽ được chuyển thành một dòng (data stream) do đó tránh được việc bị blocking và các dữ liệu phát ra thì đều được subcriber lắng nghe dẫn đến quá trình xử lý và báo lỗi diễn ra một cách đơn giản hơn.</p>
<h3 id="reactor"><a class="header" href="#reactor"><strong>Reactor</strong></a></h3>
<p><strong>Reactor</strong> là một nền tảng để ta triển khai việc lập trình theo phong cách <strong>reactive programming</strong>. Nó được tích hợp trực tiếp với Java 8 funcion APIs như <code>CompletableFuture</code>, <code>Stream</code>, <code>Duration</code>.</p>
<p><strong>Reactor</strong> cung cấp 2 loại về <strong>Publisher</strong> :</p>
<p><code>Flux</code>: là một steam phát ra từ 0...n phần tử.</p>
<p>!image</p>
<p><code>Mono</code>: là một steam phát ra từ 0...1 phần tử.</p>
<p>!image</p>
<p>Vậy là các bạn có thể hiểu được <strong>Reactive Programming</strong> phải không nào :D. Các bài viết tới chúng ta sẽ đi sâu hơn về các thực thi cũng như các <code>function</code> mà <strong>Reactor</strong> hỗ trợ. Hãy chú ý theo dõi và đừng quên nhận xét để chúng tôi có thể cải thiện các bài viết tốt hơn.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gioi-thieu-reactor-core"><a class="header" href="#gioi-thieu-reactor-core">Giới thiệu Reactor Core</a></h1>
<ul>
<li>Maven Dependencies</li>
<li>Tạo ra một luồng dữ liệu</li>
<li>Subscribe()</li>
<li>So sánh với Streams Java 8</li>
<li>Backpressure</li>
<li>Concurrency</li>
<li>Kết luận</li>
</ul>
<h3 id="tổng-quan"><a class="header" href="#tổng-quan"><strong>Tổng Quan</strong></a></h3>
<p><strong>Reactor Core</strong> là một thự viện Java 8 implement mô hình <strong>Reactive Programming</strong>. Nó được xây dựng dựa trên <strong>Reactive Streams Specification</strong> - một tiêu chuẩn để xây dựng ứng dụng <code>Reactive</code>.</p>
<p>Trong bài viết này, chúng ta sẽ đi từng bước nhỏ thông qua <code>Reactor</code> cho đến khi có cái nhìn toàn cảnh cũng như cách thực thi của <strong>Reactor core</strong>.</p>
<h3 id="maven-dependencies"><a class="header" href="#maven-dependencies"><strong>Maven Dependencies</strong></a></h3>
<p>Đây là thư viện của <code>Reactor</code>, chúng ta có thể lấy thư viện mới nhất tại đây</p>
<pre><code>&lt;dependency&gt;&lt;groupId&gt;io.projectreactor&lt;/groupId&gt;
    &lt;artifactId&gt;reactor-core&lt;/artifactId&gt;
    &lt;version&gt;3.2.8.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h3 id="tạo-ra-một-luồng-dữ-liệu"><a class="header" href="#tạo-ra-một-luồng-dữ-liệu"><strong>Tạo ra một luồng dữ liệu</strong></a></h3>
<p>Để có một ứng dựng phản ứng (reactive), điều đầu tiên chúng ta cần phải làm là tạo ra một luồng dữ liệu. Không có dữ liệu này chúng ta sẽ không có bất cứ điều gì để phản ứng, đó là lý do tại sao đây là bước đầu tiên.</p>
<p><code>Reactor core</code> cung cấp 2 loại dữ liệu cho phép chúng ta thực hiện điều này.</p>
<p><strong>Flux</strong></p>
<p>Cách đầu tiên đó là dùng <code>Flux</code>. <code>Flux</code> là một luồng có thể phát ra <strong>0..n</strong> phần tử. Ví dụ tạo đơn giản:</p>
<pre><code class="language-java">Flux&lt;Integer&gt; just = Flux.just(1,2,3,4);
</code></pre>
<p><strong>Mono</strong></p>
<p>Cách thứ hai đó là <code>Mono</code>. <code>Mono</code> là một luồng có thể phát ra <strong>0..1</strong> phần tử. Nó hoạt động gần giống hệ như <code>Flux</code>, chỉ là bị giới hạn không quá một phần tử. Ví dụ:</p>
<pre><code class="language-java">Mono&lt;String&gt; just = Mono.just(&quot;atomPtit&quot;);
</code></pre>
<p>Điều lưu ý rằng cả <code>Flux</code> và <code>Mono</code> đề được triển khai từ interface <code>Publisher</code>. Cả hai đều tuần thủ tiêu chuẩn <code>Reactive</code>, chúng ta có thể sử dụng interface như sau:</p>
<pre><code class="language-java">Publisher&lt;String&gt; just = Mono.just(&quot;foo&quot;);
</code></pre>
<h3 id="subscribe"><a class="header" href="#subscribe"><strong>Subscribe()</strong></a></h3>
<p>Hãy luôn ghi nhớ rằng: <strong>Không có gì xảy ra cho đến khi subscribe()</strong> .</p>
<p>Trong <code>reactor</code>, khi bạn viết một <code>Publisher</code>, dữ liệu không bắt đầu được bơm vào theo mặc định. Thay vào đó, bạn tạo một mô tả trừu tượng về quy định không đồng bộ của bạn(hỗ trợ tái sử dụng).</p>
<p>Để hiểu rõ luồng hoạt động hãy theo dõi qua ví dụ đơn giản sau.</p>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;io.projectreactor&lt;/groupId&gt;
    &lt;artifactId&gt;reactor-core&lt;/artifactId&gt;
    &lt;version&gt;3.2.8.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;
    &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;
    &lt;version&gt;1.1.3&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>Chúng ta thêm thư viện <code>logback</code>. Điều này sẽ giúp chúng ta ghi nhật ký đầu ra của quá trình hoạt động <code>reactor</code> từ đó hiểu rõ hơn về luồng dữ liệu.</p>
<pre><code class="language-java">public class ReactorCode {
    public static void main(String[] args) {
        List&lt;Integer&gt; elements = new ArrayList&lt;&gt;();
        Flux.just(1, 2, 3, 4)
                .log()
                .subscribe(elements::add);
    }
}

// OUTPUT:
/*
23:02:16.996 [main] DEBUG reactor.util.Loggers$LoggerFactory - Using Slf4j logging framework
23:02:17.014 [main] INFO  reactor.Flux.Array.1 - | onSubscribe([Synchronous Fuseable] FluxArray.ArraySubscription)
23:02:17.017 [main] INFO  reactor.Flux.Array.1 - | request(unbounded)
23:02:17.018 [main] INFO  reactor.Flux.Array.1 - | onNext(1)
23:02:17.018 [main] INFO  reactor.Flux.Array.1 - | onNext(2)
23:02:17.018 [main] INFO  reactor.Flux.Array.1 - | onNext(3)
23:02:17.018 [main] INFO  reactor.Flux.Array.1 - | onNext(4)
23:02:17.019 [main] INFO  reactor.Flux.Array.1 - | onComplete()
*/
</code></pre>
<p>Hãy nhìn vào phần output, mọi thứ đều chạy trên main thread. Bây giờ chugn ta đi xem rõ từng dòng thực thi: 1. <code>onSubscribe()</code> - Điều này được gọi thi chúng ra đăng ký (subscriber()) luồng</p>
<ol>
<li><code>request(unbounded)</code> - Khi chúng ta gọi đăng ký, thì hàm này được chạy ngầm nhằm ý nghĩa tạo đăng ký. Trong trường hợp này chạy mặc định là unbounded (không giới hạn), nghĩa là nó yêu cầu mọi phần tử có sẵn.</li>
<li><code>onNext()</code> - Hàm này được gọi cho mọi phần tử đơn.</li>
<li><code>onComplete()</code> - Hàm này được gọi sau cùng sau khi nhận được phần tử cuối cùng. Trong thực có thể xảy ra các hàm khác như <code>onError()</code>, cái mà có thể được gọi khi xảy ra một exception.</li>
</ol>
<h3 id="so-sánh-với-streams-java-8"><a class="header" href="#so-sánh-với-streams-java-8"><strong>So sánh với Streams Java 8</strong></a></h3>
<p>Có vẻ nhiều người vẫn đang nghĩ sự tương đồng với Stream trong Java 8:</p>
<pre><code class="language-java">List&lt;Integer&gt; collected = Stream.of(1, 2, 3, 4)
  .collect(toList());
</code></pre>
<p>Sự khác biết cốt lõi là <code>Reactive</code> là một hình <strong>push</strong> (đẩy) , trong khi Stream Java 8 là mô hình <strong>pull</strong> (kéo)</p>
<p>Streams Java 8 là <code>terminal</code> - kéo tất cả dữ liệu và trả về một kết quả. Với <code>Reactive</code>, chúng ta có một luồng vô hạn đến từ một nguồi tài nguyên bên ngoài, với nhiều người subscribe(). Chúng ta cũng có thể làm những việc như kết hợp các luồng, tiều tiết luồng và <code>backpressure</code>.</p>
<h3 id="backpressure"><a class="header" href="#backpressure"><strong>Backpressure</strong></a></h3>
<p>Trong ví dụ trên, người đăng ký nói với <code>Publisher</code> đẩy từng phần tử một. Điều này có thể trở nên quá tải cho người đăng ký phải tiêu thụ hết tất cả tài nguyên của nó.</p>
<p><strong>Backpressure</strong> đơn giản chỉ là bảo với <code>Publisher</code> gửi cho nó ít dữ liệu hơn để ngăn chặn nó bị quá tải.</p>
<p>Ví dụ dưới đây, chúng ta sẽ yêu cầu chỉ gửi 2 phần từ cùng một lúc bằng cách sử dụng <code>request ()</code>:</p>
<pre><code class="language-java">Flux.just(1, 2, 3, 4)
  .log()
  .subscribe(new Subscriber&lt;Integer&gt;() {
    private Subscription s;
    int onNextAmount;

    @Override
    public void onSubscribe(Subscription s) {
        this.s = s;
        s.request(2);
    }

    @Override
    public void onNext(Integer integer) {
        elements.add(integer);
        onNextAmount++;
        if (onNextAmount % 2 == 0) {
            s.request(2);
        }
    }

    @Override
    public void onError(Throwable t) {}

    @Override
    public void onComplete() {}
});

//OUTPUT
/*
23:31:15.395 [main] INFO  reactor.Flux.Array.1 - | onSubscribe([Synchronous Fuseable] FluxArray.ArraySubscription)
23:31:15.397 [main] INFO  reactor.Flux.Array.1 - | request(2)
23:31:15.397 [main] INFO  reactor.Flux.Array.1 - | onNext(1)
23:31:15.398 [main] INFO  reactor.Flux.Array.1 - | onNext(2)
23:31:15.398 [main] INFO  reactor.Flux.Array.1 - | request(2)
23:31:15.398 [main] INFO  reactor.Flux.Array.1 - | onNext(3)
23:31:15.398 [main] INFO  reactor.Flux.Array.1 - | onNext(4)
23:31:15.398 [main] INFO  reactor.Flux.Array.1 - | request(2)
23:31:15.398 [main] INFO  reactor.Flux.Array.1 - | onComplete()
*/
</code></pre>
<p>Bây giờ chúng ta nhìn thấy hàm <code>request()</code> được gọi trước, tiếp theo đó là 2 hàm <code>onNext()</code> thực hiện, sau đó lại là <code>request()</code>.</p>
<h3 id="concurrency"><a class="header" href="#concurrency"><strong>Concurrency</strong></a></h3>
<p>Tất cả các ví dụ trên chúng ta đều đang chạy trên một luồng chính. Tuy nhiên, chúng ta có thể kiểm soát luồng nào mà code của chúng ta chạy nếu chúng ta muốn. Các inteface <code>Scheduler</code> cung cấp một sự trừu tượng với <code>asynchronous</code>.</p>
<pre><code class="language-java">public class ReactorCode {
    public static void main(String[] args) {
        ExecutorService service = Executors.newFixedThreadPool(10);
        Flux.just(1, 2, 3, 4)
                .log()
                .subscribeOn(Schedulers.fromExecutorService(service))
                .subscribe();

        Flux.just(5, 6, 7, 8)
                .log()
                .subscribeOn(Schedulers.fromExecutorService(service))
                .subscribe();
    }
}

//OUTPUT
/*
23:48:02.972 [main] DEBUG reactor.util.Loggers$LoggerFactory - Using Slf4j logging framework
23:48:02.996 [pool-1-thread-2] INFO  reactor.Flux.Array.2 - | onSubscribe([Synchronous Fuseable] FluxArray.ArraySubscription)
23:48:02.996 [pool-1-thread-1] INFO  reactor.Flux.Array.1 - | onSubscribe([Synchronous Fuseable] FluxArray.ArraySubscription)
23:48:03.000 [pool-1-thread-2] INFO  reactor.Flux.Array.2 - | request(unbounded)
23:48:03.000 [pool-1-thread-1] INFO  reactor.Flux.Array.1 - | request(unbounded)
23:48:03.001 [pool-1-thread-1] INFO  reactor.Flux.Array.1 - | onNext(1)
23:48:03.001 [pool-1-thread-2] INFO  reactor.Flux.Array.2 - | onNext(5)
23:48:03.001 [pool-1-thread-1] INFO  reactor.Flux.Array.1 - | onNext(2)
23:48:03.001 [pool-1-thread-2] INFO  reactor.Flux.Array.2 - | onNext(6)
23:48:03.001 [pool-1-thread-1] INFO  reactor.Flux.Array.1 - | onNext(3)
23:48:03.001 [pool-1-thread-2] INFO  reactor.Flux.Array.2 - | onNext(7)
23:48:03.001 [pool-1-thread-1] INFO  reactor.Flux.Array.1 - | onNext(4)
23:48:03.001 [pool-1-thread-2] INFO  reactor.Flux.Array.2 - | onNext(8)
23:48:03.002 [pool-1-thread-1] INFO  reactor.Flux.Array.1 - | onComplete()
23:48:03.002 [pool-1-thread-2] INFO  reactor.Flux.Array.2 - | onComplete()
*/
</code></pre>
<p>Ở đây chúng ta dùng ExecutorService, 2 luồng code thực hiện song song trên 2 thread khác nhau, điều mà đã chứng minh bằng output.</p>
<h3 id="kết-luận"><a class="header" href="#kết-luận"><strong>Kết luận</strong></a></h3>
<p>Sau bài viết này, chúng tôi đã có cái nhìn tổng quan về <code>Reactor Core</code>. Từ các tạo một <code>Publisher</code> , các đăng ký, backpressure cũng như xử lý không đồng bộ. Đây cũng là nền tảng để cho chúng tôi viết cái bài viết khác liên quan về <code>Reactor Core</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bạn-thực-sự-đã-biết-khi-nào-dùng-interface-khi-nào-dùng-abstract"><a class="header" href="#bạn-thực-sự-đã-biết-khi-nào-dùng-interface-khi-nào-dùng-abstract">Bạn thực sự đã biết khi nào dùng Interface khi nào dùng Abstract?</a></h1>
<h3 id="tổng-quan-1"><a class="header" href="#tổng-quan-1">Tổng quan</a></h3>
<p>Trong java, chúng ta có <code>class</code> <code>abstract</code> và một <code>Interface</code>, ai cũng biết một class có thể <code>impements</code> nhiều <code>Interface</code> và chỉ kế thừa được một <code>class</code> <code>abstract</code>. Nhưng bạn thực sự đã biết khi nào thì ta dùng <code>Interface</code>, khi nào dùng <code>Abstract</code>. Chưa kể bắt đầu từ Java 8 có sự thay đổi về <code>Interface</code> càng làm khó phân biệt giữa hai loại này.</p>
<p>Trong bài viết này chúng tôi sẽ đi so sánh một số tính chất của 2 loại này, sau đó là đưa ra ví dụ đơn giải để các bạn hình dung rõ nhất. Cuối cùng là hiểu khi nào thì dùng chúng.</p>
<h3 id="sự-khác-nhau-giữa-interface-và-abstract"><a class="header" href="#sự-khác-nhau-giữa-interface-và-abstract">Sự khác nhau giữa Interface và Abstract</a></h3>
<ol>
<li>Methods: Class <code>abstract</code> có các phương thức abstract và non-abstract. Trong khi <code>Interface</code> chỉ có phương thức abstract, từ Java 8, thì Interface có thêm 2 loại phương thức là <code>default</code> và <code>static</code>.</li>
<li>Variables: Class <code>abstract</code> có thể có các biến final, non-final, static và non-static. Trong khi <code>Interface</code> chỉ có các biến static và final.</li>
<li>Implementation: Class <code>abstract</code> có thể implement các Interface. Trong khi <code>Interface</code> thì không thể implement class abstract.</li>
<li>Inheritance: Class <code>abstract</code> có thể kế thừa được một class khác. Trong khi <code>Interface</code> có thể kế thừa được nhiều Interface khác.</li>
<li>Accessibility: các thành viên trong <code>Interface</code> kiếu mặc định là <code>public</code>. Trong khi class <code>abstract</code> thì lại có thể là private, protected,..</li>
</ol>
<p><strong><em>Nguồn: <a href="https://loda.me">https://loda.me</a> - còn nhiều cái hay ho lắm!</em></strong></p>
<h3 id="abstract-là-gì"><a class="header" href="#abstract-là-gì">Abstract là gì?</a></h3>
<p>Abstract(trừu tượng) nghĩa là một cái gì đó không hoàn toàn cụ thể, nó chỉ là một ý tưởng hoặc ý chính của một cái gì đó mà không có bản triển khai cụ thể. Vì vậy Class abstract chỉ là một cấu trúc hoặc hướng dẫn được tạo cho các class cụ thể khác.</p>
<p>Chúng ta có thể nói rằng một class abstract là linh hồn của một class cụ thể, và rõ ràng một cơ thể (class) không thể có hai linh hồn. Đây cũng là lý do Java không hỗ trợ nhiều kế thừa cho các class abstract.</p>
<p>Hãy nhìn vào class abstract sau:
<em>Xe.class</em></p>
<pre><code>public abstract class Xe {
    private String dongCo;
     abstract void khoiDongDongCo();
     abstract void dungDongco();
}

</code></pre>
<p>Chúng tôi tạo một class abstract <code>Xe</code> có thuộc tính là <code>động cơ</code>, và các phương thức khởi động/ dừng động cơ. <code>Xe</code> là một cái gì đó không cụ thể, nó có thể là ô tô, xe máy, ... và rõ ràng không có <code>Xe</code> nào mà không tồn tại động cơ và cơ chế khởi động/dừng động cơ cả.</p>
<p><em>Oto.class</em></p>
<pre><code>public class Oto extends Xe {
    @Override
    void khoiDongDongCo() {
        System.out.println(&quot;Khởi động động cơ của ôtô&quot;);
    }

    @Override
    void dungDongco() {
        System.out.println(&quot;Dừng động cơ của ôtô&quot;);
    }
}

</code></pre>
<h3 id="interface-là-gì"><a class="header" href="#interface-là-gì">Interface là gì?</a></h3>
<p>Interface (Giao diện) là một hình thức, giống như một hợp đồng, nó không thể tự làm bất cứ điều gì. Nhưng khi có một class ký kết hợp đồng (implement Interface) này, thì class đó phải tuân theo hợp đồng này.</p>
<p>Trong Interface, chúng tôi định nghĩa các hành vi của một class sẽ thực hiện. Một class có thể có một số cách hành vi khác nhau, cũng giống như nó có thể ký kết được với nhiều hợp đồng khác nhau. Đó cũng là lý do tại sao Java cho phép implement nhiều Interface.</p>
<p>Tiếp nối ví dụ trên, <code>Xe</code> có thể di chuyển, vì vậy chúng tôi tạo một Interface Hành động di chuyển và class <code>Oto</code> implement nó.</p>
<p><em>HanhDongDiChuyen.class</em></p>
<pre><code>public interface HanhDongDiChuyen {
    void diChuyen();
}

</code></pre>
<p>Đây là những hành vi của <code>Oto</code>, chứ không thuộc tính sẵn có của nó: <strong>Ôtô là xe hơi, ngay cả khi nó không thể di chuyển được!</strong></p>
<p><em>Oto.class</em></p>
<pre><code>public class Oto extends Xe implements HanhDongDiChuyen{
    @Override
    void khoiDongDongCo() {
        System.out.println(&quot;Khởi động động cơ của ôtô&quot;);
    }

    @Override
    void dungDongco() {
        System.out.println(&quot;Dừng động cơ của ôtô&quot;);
    }

    @Override
    public void diChuyen() {
        System.out.println(&quot;Ôtô đang di chuyển&quot;);
    }
}

</code></pre>
<h3 id="khi-nào-nên-dùng"><a class="header" href="#khi-nào-nên-dùng">Khi nào nên dùng?</a></h3>
<ol>
<li>Class abstract đại diện cho mối quan hệ &quot;IS - A&quot; (Ôtô là Xe)</li>
<li>Interface đại diện cho mối quan hệ &quot;like - A&quot; (Ô tô có thể chuyển động).</li>
<li>Tạo một class abstract khi bạn đang cung cấp các hướng dẫn cho một class cụ thể.</li>
<li>Tạo Interface khi chúng ta cung cấp các hành vi bổ sung cho class cụ thể và những hành vì này không bắt buộc đối với clas đó.</li>
</ol>
<h3 id="kết-luận-1"><a class="header" href="#kết-luận-1">Kết luận</a></h3>
<p>Mục đích của bài viết này là để giúp bạn hiểu và nắm vững class abstract, Interface và kịch bản sử dụng. Thông qua nổ lực toàn bộ bài viết của chúng tôi, chúng tôi tin chắc rằng bạn đã hiểu được điều gì đó. Cuối cùng, cảm ơn bạn đã đọc bài viết.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="java-concurrency-phần-1-thread"><a class="header" href="#java-concurrency-phần-1-thread">Java Concurrency (Phần 1): Thread</a></h1>
<p>Source: <a href="https://viblo.asia/p/java-concurrency-phan-1-thread-GAWVpevY405">Java Concurrency (Phần 1): Thread</a></p>
<h2 id="1-giới-thiệu"><a class="header" href="#1-giới-thiệu">1. Giới thiệu</a></h2>
<p>Lập trình đồng thời (concurrency) trong Java đề cập đến khả năng của một chương trình Java thực thi nhiều tác vụ đồng thời hoặc song song, tận dụng tối đa các bộ xử lý (CPU) đa lõi (core) hiện đại. Khi các ứng dụng ngày càng trở nên phức tạp và đòi hỏi hiệu suất cao hơn, lập trình đồng thời trở thành yếu tố thiết yếu để cải thiện hiệu năng, khả năng phản hồi và khả năng mở rộng.
Java cung cấp một bộ công cụ và các thư viện phong phú giúp các nhà phát triển tạo ra các ứng dụng đồng thời, quản lý nhiều luồng (threads) và điều phối các tác vụ một cách hiệu quả. Trong bài viết này, chúng sẽ khám phá các khái niệm cơ bản về lập trình đồng thời trong Java.</p>
<p><img src="https://images.viblo.asia/full/dab66ffc-6006-45b9-a745-5e5a9f09d9da.png" alt="image.png" /></p>
<h2 id="2-Định-nghĩa-thread"><a class="header" href="#2-Định-nghĩa-thread">2. Định nghĩa Thread</a></h2>
<p>Một thread là một đơn vị thực thi nhỏ hơn một process. <strong>Một process có thể tạo ra nhiều thread trong quá trình thực thi</strong>. Tất cả các thread trong cùng một process sẽ chia sẻ, <strong>dùng chung một số vùng nhớ với nhau</strong> (heap memory, static variables, metaspace, … phần này mình sẽ chia sẻ cụ thể hơn ở một bài viết khác). Vì vậy, việc giao tiếp giữa các thread khá đơn giản và dễ dàng hơn so với giao tiếp giữa các process. Ngoài ra, việc tạo mới/hủy thread đơn giản và tốn ít công hơn so với việc tạo mới/hủy một process. Vì các lý do này, thread còn được gọi là lightweight process.</p>
<p><img src="https://images.viblo.asia/full/cb4fb02e-990b-4290-bdb3-c7b3e9d030a1.png" alt="image.png" /></p>
<h2 id="3-cách-khởi-tạo-thread"><a class="header" href="#3-cách-khởi-tạo-thread">3. Cách khởi tạo thread</a></h2>
<p>Đây là một câu hỏi thường hay gặp trong phỏng vấn. Bạn có thể tham khảo hoặc trả lời như sau:
Ta có thể phân loại các cách khởi tạo thread như sau:</p>
<h3 id="31-tạo-trực-tiếp-thread"><a class="header" href="#31-tạo-trực-tiếp-thread">3.1. Tạo trực tiếp thread</a></h3>
<p>sử dụng <code>new Thread().start()</code>.</p>
<pre><code>new Thread(() -&gt; resource.counter++).start();

</code></pre>
<h3 id="32-khai-báo-thread-execution-method"><a class="header" href="#32-khai-báo-thread-execution-method">3.2. Khai báo Thread execution method</a></h3>
<h4 id="321-kế-thừa-class-thread"><a class="header" href="#321-kế-thừa-class-thread">3.2.1. Kế thừa class Thread</a></h4>
<p>Đây là một cách phổ biến. Chúng ta tạo ra một class mới kế thừa class Thread và ghi đè method run như sau:</p>
<pre><code>public class ExtendsThread extends Thread {
    @Override
    public void run() {
        System.out.println(&quot;Do something&quot;);
    }

    public static void main(String[] args) {
        new ExtendsThread().start();
    }
}

</code></pre>
<h4 id="322-triển-khai-interface-runnable"><a class="header" href="#322-triển-khai-interface-runnable">3.2.2. Triển khai interface Runnable</a></h4>
<p>Đây cũng là một cách phổ biến, implement Runnable interface và override method run, như sau:</p>
<pre><code>public class ImplementsRunnable implements Runnable {
    @Override
    public void run() {
        System.out.println(&quot;Do something&quot;);
    }

    public static void main(String[] args) {
        ImplementsRunnable runnable = new ImplementsRunnable();
        new Thread(runnable).start();
    }
}

</code></pre>
<h4 id="323-triển-khai-interface-callable"><a class="header" href="#323-triển-khai-interface-callable">3.2.3. Triển khai interface Callable</a></h4>
<p>Tương tự như method trước, ngoại trừ method này có thể nhận giá trị trả về sau khi Thread được thực thi, như sau:</p>
<pre><code>public class ImplementsCallable implements Callable&lt;String&gt; {
    @Override
    public String call() throws Exception {
        System.out.println(&quot;Do something&quot;);
        return &quot;test&quot;;
    }

    public static void main(String[] args) throws Exception {
        ImplementsCallable callable = new ImplementsCallable();
        FutureTask&lt;String&gt; futureTask = new FutureTask&lt;&gt;(callable);
        new Thread(futureTask).start();
        System.out.println(futureTask.get());
    }
}

</code></pre>
<h4 id="324-sử-dụng-class-ẩn-danh-hoặc-biểu-thức-lambda"><a class="header" href="#324-sử-dụng-class-ẩn-danh-hoặc-biểu-thức-lambda">3.2.4. Sử dụng class ẩn danh hoặc biểu thức Lambda</a></h4>
<pre><code>public class UseAnonymousClass {
    public static void main(String[] args) {
        new Thread(new Runnable() {
            @Override
            public void run() {
                System.out.println(&quot;AnonymousClass&quot;);
            }
        }).start();

        new Thread(() -&gt;
                System.out.println(&quot;Lambda&quot;)
        ).start();
    }
}

</code></pre>
<h3 id="33-tạo-gián-tiếp-thread"><a class="header" href="#33-tạo-gián-tiếp-thread">3.3. Tạo gián tiếp thread</a></h3>
<h4 id="331-sử-dụng-thread-pool-của-executorservice"><a class="header" href="#331-sử-dụng-thread-pool-của-executorservice">3.3.1. Sử dụng thread pool của ExecutorService</a></h4>
<pre><code>public class UseExecutorService {
    public static void main(String[] args) {
        ExecutorService poolA = Executors.newFixedThreadPool(2);
        poolA.execute(() -&gt; {
            System.out.println(&quot;do something&quot;);
        });
}

</code></pre>
<h4 id="332-sử-dụng-thread-pool-hoặc-stream-song-song-parallel-stream"><a class="header" href="#332-sử-dụng-thread-pool-hoặc-stream-song-song-parallel-stream">3.3.2. Sử dụng thread pool hoặc Stream song song (parallel stream)</a></h4>
<pre><code>public class UseForkJoinPool {
    public static void main(String[] args) {
        ForkJoinPool forkJoinPool = new ForkJoinPool();
        forkJoinPool.execute( () -&gt; {
            System.out.println(&quot;Do something&quot;);
        });

        List&lt;String&gt; list = Arrays.asList(&quot;e1&quot;);
        list.parallelStream().forEach(System.out::println);
    }
}

</code></pre>
<h4 id="333-sử-dụng-completablefuture"><a class="header" href="#333-sử-dụng-completablefuture">3.3.3. Sử dụng CompletableFuture</a></h4>
<pre><code>public class UseCompletableFuture {
    public static void main(String[] args) throws InterruptedException {
        CompletableFuture&lt;String&gt; cf = CompletableFuture.supplyAsync(() -&gt; {
            System.out.println(&quot;5......&quot;);
            return &quot;test&quot;;
        });
        Thread.sleep(1000);
    }
}

</code></pre>
<h4 id="334-sử-dụng-class-timer"><a class="header" href="#334-sử-dụng-class-timer">3.3.4. Sử dụng class Timer</a></h4>
<pre><code>public class UseTimer {
    public static void main(String[] args) {
        Timer timer = new Timer();

        timer.schedule(new TimerTask() {
            @Override
            public void run() {
                System.out.println(&quot;9......&quot;);
            }
        }, 0, 1000);
    }
}

</code></pre>
<p>Java chỉ có một cách để tạo thread một cách trực tiếp, đó là thông qua việc tạo new Thread().start(). Do đó, cho dù sử dụng phương thức nào thì cuối cùng nó cũng phụ thuộc vào new Thread().start(). Các đối tượng Runnable, Callable, … chỉ là phần thân của Thread, tức là tác vụ được cung cấp cho Thread để thực thi.</p>
<h2 id="4-trạng-thái-của-thread"><a class="header" href="#4-trạng-thái-của-thread">4. Trạng thái của thread</a></h2>
<p><img src="https://images.viblo.asia/full/9e0a1831-55d3-48d9-8f04-21ab8bb96b91.png" alt="thread-status.png" /></p>
<p>Tại một thời điểm, một thread trong Java chỉ có thể ở một trong sáu trạng thái trong vòng đời của nó:</p>
<ul>
<li><code>NEW</code>: Khi đối tượng thread được tạo, nó sẽ chuyển sang trạng thái NEW, chẳng hạn như: Thread t = new MyThread();</li>
<li><code>RUNNABLE</code>: Trạng thái sẵn sàng để chạy. Ta có thể hiểu, nó sẽ được chia thành 2 trường hợp nhỏ hơn: <strong>đang chạy hoặc đang chờ để chạy</strong>. Ví dụ, khi sau, ta gọi method start(), thread đó có thể chưa chạy được ngay mà phải đợi CPU schedule để chạy.</li>
<li><code>BLOCKED</code>: Trạng thái bị chặn, thread A đang cố giành khóa (lock) nhưng khoá đang giữa bởi thread B, thread A phải đợi, bị blocked cho đến khi khoá được giải phóng.</li>
<li><code>TIME_WAITING</code>: Trạng thái chờ có thời gian chờ, có thể tự động quay trở lại trạng thái RUNNABLE sau khoảng thời gian xác định.</li>
<li><code>WAITING</code>: Trạng thái chờ, biểu thị rằng thread A đang chờ các thread khác thực hiện một số hành động cụ thể, như (notification) thông báo cho thread A hoặc (interruption) ngắt thread A. Khác với TIME_WAITING, trạng thái WAITING không có thời gian timeout, chỉ được wakeup khi có thông báo từ thread khác.</li>
<li><code>TERMINATED</code>: Trạng thái kết thúc, biểu thị rằng thread đã hoàn thành công việc hoặc dừng lai do gặp exception.</li>
</ul>
<h2 id="5-các-method-cơ-bản-của-thread"><a class="header" href="#5-các-method-cơ-bản-của-thread">5. Các method cơ bản của thread</a></h2>
<h3 id="51-start"><a class="header" href="#51-start">5.1. start()</a></h3>
<p>Method start() khởi tạo việc thực thi một thread. Nó gọi phương thức run() được xác định trong class thread hoặc runnable object. Thread sẽ chuyển từ trạng thái NEW sang trạng thái RUNNABLE sau khi method này được gọi.</p>
<pre><code>public class Main {
    public static void main(String[] args) {
        Thread myThread = new Thread(new MyRunnable());
        myThread.start();
    }
}

</code></pre>
<h3 id="52-run"><a class="header" href="#52-run">5.2. run()</a></h3>
<p>Method run() chứa mã sẽ được thực thi trong luồng.</p>
<pre><code>class MyRunnable implements Runnable {
    public void run() {
        System.out.println(&quot;This is a runnable.&quot;);
    }
}

</code></pre>
<h3 id="53-sleep-và-wait"><a class="header" href="#53-sleep-và-wait">5.3. sleep() và wait()</a></h3>
<p>Method <code>sleep()</code> làm cho thread hiện đang thực thi ở chế độ ngủ (TIMED_WAITING) trong 1 khoảng thời gian được chỉ định (tính bằng milliseconds).</p>
<p>Method wait() khiến thread hiện tại đợi cho đến khi một thread khác gọi notify() hoặc notifyAll() trên cùng một object. Thread sẽ chuyển từ trạng thái RUNNABLE sang trạng thái WAITING nếu dùng wait() không truyền thêm thời gian timeout, còn nếu truyền thêm thời gian timeout - wait(timeout) thì thread sẽ ở trạng thái <code>TIMED_WAITING</code>.</p>
<p>Sự khác biệt giữa 2 method:</p>
<ul>
<li><strong>Method wait() cần được đặt trong synchronized code, còn sleep() thì không.</strong></li>
<li>Method sleep() không giải phóng khóa, trong khi method wait() sẽ giải phóng khóa.</li>
<li>Method wait() thường được sử dụng cho tương tác/giao tiếp giữa các thread, còn sleep() thường được sử dụng để tạm dừng thực thi.</li>
<li>Sau khi method wait() được gọi, thread sẽ không tự động thức dậy; cần một luồng khác gọi method notify() hoặc notifyAll() trên cùng một đối tượng để đánh thức luồng đó. Sau khi method sleep() được thực thi, thread sẽ tự động thức dậy (RUNNABLE).</li>
<li>sleep() là một method static của class Thread, còn wait() là một method của class Object.</li>
</ul>
<h3 id="54-notify-và-notifyall"><a class="header" href="#54-notify-và-notifyall">5.4. notify() và notifyAll()</a></h3>
<p>notify(): đối với tất cả các thread đang chờ object monitor bằng cách sử dụng bất kỳ method wait() nào, method notify() thông báo cho một trong số các thread đó thức dậy. <strong>Việc lựa chọn chính xác thread nào được đánh thức là mẫu nhiên và chúng ta không thể kiểm soát được</strong> thread được đánh thức.
notifyAll(): Phương pháp này chỉ đơn giản đánh thức tất cả các thread đang chờ trên object monitor.
Mình sẽ nói chi tiết hơn về các method này trong bài giao tiếp giữa các threads.</p>
<h3 id="55-yield"><a class="header" href="#55-yield">5.5. yield()</a></h3>
<p>Method yield() làm cho thread hiện đang thực thi tạm dừng và cho phép các thread khác thực thi.
Mọi người lưu ý, đây chỉ là hint cho scheduler tạm dừng thread, scheduler có thể bỏ qua cái hint này.
Method này có thể dùng để tái hiện bug do race condition. Tuy nhiên, method này hiếm khi được sử dụng và <strong>mình recommend không dùng method này trong production code</strong>.</p>
<h3 id="56-join"><a class="header" href="#56-join">5.6. join()</a></h3>
<p>Method <code>join()</code> cho phép một thread chờ đợi một thread khác hoàn thành. Điều này có thể hữu ích khi bạn cần đảm bảo hoàn thành một số nhiệm vụ nhất định trước khi tiếp tục. Khi thread A gọi method <code>join()</code> của thread B, thread A sẽ chuyển sang trạng thái chờ ( <code>RUNNABLE → WAITING</code>). Nó vẫn ở trạng thái chờ cho đến khi thread B kết thúc.</p>
<p>Giả sử bạn cần thực hiện một số lệnh gọi API đến các endpoints khác nhau lấy dữ liệu đồng thời. Mỗi lệnh gọi API được thực hiện trong một thread riêng biệt và bạn muốn đợi cho đến khi tất cả các thread hoàn thành yêu cầu API của chúng trước khi tổng hợp (aggregate) kết quả.</p>
<pre><code>String[] apiEndpoints = {
    &quot;https://api.example.com/data1&quot;,
    &quot;https://api.example.com/data2&quot;,
    &quot;https://api.example.com/data3&quot;
};

List&lt;Thread&gt; threads = new ArrayList&lt;&gt;();

List&lt;String&gt; results = new ArrayList&lt;&gt;();

for (String endpoint : apiEndpoints) {
    Thread thread = new Thread(() -&gt; {
        String response = makeApiCall(endpoint);
        synchronized (results) {
            results.add(response);
        }
    });
    threads.add(thread);
    thread.start();
}

// Wait for all threads to complete
try {
    for (Thread thread : threads) {
        thread.join();
    }
} catch (InterruptedException e) {
    e.printStackTrace();
}

// Process and aggregate results
results.forEach(response -&gt; System.out.println(&quot;API response: &quot; + response));

</code></pre>
<p>Nếu mọi người thấy bài viết hữu ích thì nhờ mọi người share để nội dung của Ronin được nhiều người biết hơn.</p>
<p>Cám ơn mọi người. 🙏</p>
<hr />
<p>🧑‍💻 150+ Ronin Engineers: <a href="https://roninhub.com/">https://roninhub.com/</a></p>
<p>✏️ System Design VN: <a href="https://fb.com/groups/systemdesign.vn">https://fb.com/groups/systemdesign.vn</a></p>
<p>📚 Tài liệu khác: <a href="https://roninhub.com/tai-lieu">https://roninhub.com/tai-lieu</a></p>
<p>🎬 Youtube: <a href="https://youtube.com/@ronin-engineer">https://youtube.com/@ronin-engineer</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="java-8optional"><a class="header" href="#java-8optional">「Java 8」Optional</a></h1>
<p><code>Java 8</code> ra đời cùng với một class mới tên là <code>Optional</code>. Nhiệm vụ của nó là kiểm soát <code>null</code> hộ chúng ta.</p>
<h3 id="khái-niệm-optional"><a class="header" href="#khái-niệm-optional"><strong>Khái niệm Optional</strong></a></h3>
<p><code>Optional&lt;T&gt;</code> là một đối tượng <code>Generic</code>, nhiệm vụ chính của nó là <strong>bọc</strong> hay <strong>wrapper</strong> lấy một object khác. Nó chỉ chứa được một object duy nhất bên trong.</p>
<p>Việc bạn lấy giá trị của object bây giờ sẽ thông qua <code>Optional</code> và nếu object đó <code>null</code> cũng không sao, vì thằng <code>Optional</code> kiểm soát nó chặt chẽ hơn là <code>if else</code>.</p>
<p>Ví dụ bạn có một đối tượng bất kỳ:</p>
<p>Khi chúng ta thực hiện các thao tác, chúng ta có thể kiểm tra như thế này:</p>
<p>Hmmm..... trông thế này thì khác đếch gì <code>if (str != null)</code> =))) Nhiều bạn sẽ tự nghĩ. Đúng là như vậy, nếu nó chỉ làm được đến đây, thì thôi.. nghỉ mịa đee huhu :((</p>
<p>Bây giờ mình sẽ giới thiệu từng tính năng lần lượt của <code>Optional</code> để bạn thấy nó kì diệu như nào.</p>
<h3 id="ifpresent"><a class="header" href="#ifpresent"><strong>ifPresent</strong></a></h3>
<p><code>ifPresent</code> nhận vào một <code>Consumer</code>, nó cũng chỉ là <code>Functional Interface</code> thôi các bạn. Nhận vào một đối tượng và thao tác trên nó, không return gì cả.</p>
<p>Nếu bạn chưa rõ <code>Functional Interface</code> và <code>Lambda Expression</code> thì bạn có thể xem ngay đây, dễ hiểu lém:</p>
<p>Functional Interfaces &amp; Lambda Expressions cực dễ hiểu</p>
<h3 id="orelse-và-orelseget"><a class="header" href="#orelse-và-orelseget"><strong>orElse() và orElseGet()</strong></a></h3>
<p><code>orElse()</code> lấy ra object trong <code>Optional</code>. Nếu <code>null</code>, trả về giá trị mặc định do bạn quy định</p>
<p><code>orElseGet()</code> Tương tự <code>orElse()</code> nhưng trả ra bằng <code>Supplier interface</code></p>
<h3 id="map"><a class="header" href="#map"><strong>map()</strong></a></h3>
<p><code>map()</code> giúp chúng ta biến đổi đối tượng bên trong <code>Optional</code>.</p>
<p>mình sẽ ví dụ bằng code dễ hiểu hơn.</p>
<p><code>code</code> trông sáng sủa hơn nhiều phải không bạn :3</p>
<p>Trong code ở trên sử dụng <code>Method reference</code>, khái niệm này mình đã nói chi tiết tại đây:</p>
<p>Hướng dẫn Method Reference và Lambda Expressions</p>
<p>Khái niệm <code>map()</code> mình có nói chi tiết tại đây:</p>
<p>Stream Trong Java 8 cực dễ hiểu!</p>
<h3 id="filter"><a class="header" href="#filter"><strong>filter()</strong></a></h3>
<p><code>filter()</code> giúp chúng ta kiểm tra giá trị trong <code>Optional</code> nếu không thỏa mãn điều kiện, trả về <code>empty()</code></p>
<p>Tới đây mình đã giới thiệu xong với các bạn các tính năng khá hay ho của <code>Optional</code>. Ngoài việc giúp chúng ta kiểm soát <code>NullException</code> thì còn giúp <code>code</code> của chúng ta sáng sủa hơn rất nhiều và thuận tiện hơn trong nhiều trường hợp yêu cầu điều kiện phức tạp</p>
<p>Chúc các bạn học tập thành công. Và chớ quên like và share ủng hộ nhá ahihi :3</p>
<pre><code class="language-java">String str = null;
// Tạo ra một đối tượng Optional
Optional&lt;String&gt; optional = Optional.ofNullable(str);
// Bây giờ Optional đã wrap lấy cái str.
</code></pre>
<pre><code class="language-java">if (optional.isPresent()) {
    System.out.println(opt.get()); // lấy ra cái str mình đã wrapper
}
</code></pre>
<pre><code class="language-java">optional.ifPresent(s -&gt; System.out.println(s));
</code></pre>
<pre><code class="language-java">String b = optional.orElse(&quot;Giá trị mặc định&quot;);
</code></pre>
<pre><code class="language-java">String b = optional.orElseGet(() -&gt; {
    StringBuilder sb = new StringBuilder();
    // Thao tác phức tạp
    return sb.toString();
});
</code></pre>
<pre><code class="language-java">class Outfit{
    public String type;

    public String getType() { return type; }
}

class Girl{
    private Outfit outfit;

    public Outfit getOutfit() { return outfit; }
}

public String getOutfitType(Girl girl){
    return Optional.ofNullable(girl) // Tạo ra Optional wrap lấy girl
        .map(Girl::getOutfit) // nếu girl != null thì lấy outfit ra xem kakaka :3 ngược lại trả ra Optional.empty()
        .map(Outfit::getType) // nếu outfit != null thì lấy ra xem type của nó
        .orElse(&quot;Không mặc gì&quot;); // Nếu cuối cùng là Optional.empty() thì trả ra ngoài Không mặc gì.
}
</code></pre>
<pre><code class="language-java">public String getOutfitType(Girl girl){
    return Optional.ofNullable(girl) // Tạo ra Optional wrap lấy girl
        .map(Girl::getOutfit)
        .map(Outfit::getType)
        .filter(s -&gt; s.contains(&quot;bikini&quot;)) // Nó chỉ chấp nhận giá trị bikini, còn lại dù khác null thì vẫn trả ra ngoài là Optiional.empty()
        .orElse(&quot;Không mặc gì&quot;); // Nếu cuối cùng là Optional.empty() thì trả ra ngoài &quot;Không mặc gì&quot;.
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kho-lưu-trữ-java-snippets"><a class="header" href="#kho-lưu-trữ-java-snippets">Kho lưu trữ Java snippets</a></h1>
<p>Lấy từ <a href="https://github.com/iluwatar/30-seconds-of-java">iluwatar/30-seconds-of-java</a> và rất nhiều nguồn khác nhau để tổng hợp và sử dụng.</p>
<p>Repo này sẽ không chứa đầy đủ toàn bộ các phần tệp và thư mục khác của dự án (Bao gồm <code>src/test</code>, <code>pom.xml</code> và tương tự). Bạn vui lòng ghé qua Repository gốc để nghịch nha.</p>
<p>Một số các <em>kho lưu trữ</em> khác:</p>
<ul>
<li><a href="java/snippets/kho-khac/van-de-hang-ngay.html">Một số đoạn Java cho các vấn đề hàng ngày</a></li>
<li><a href="https://java-design-patterns.com/">Java Design Patterns</a></li>
<li><a href="https://groups.inf.ed.ac.uk/cup/javaGithub/">GitHub Java Corpus</a> - Rất nhiều dự án Java để học. Bạn có thể tải luôn <a href="https://groups.inf.ed.ac.uk/cup/javaGithub/top_projects.tar.gz">top_projects.tar.gz 5.3MB</a> hoặc nếu đường dẫn trên không được thì <a href="java/snippets/archive/top_projects.tar.gz">bấm vào đây</a></li>
</ul>
<p><strong>Lưu ý:</strong> Các phần nội dung được lưu trong Repository này chỉ mang tính chất lưu trữ và chia sẻ. Mình chỉ là người tổng hợp lại thôi.</p>
<h2 id="algorithm"><a class="header" href="#algorithm">Algorithm</a></h2>
<h3 id="binary-search-in-2d-array"><a class="header" href="#binary-search-in-2d-array">Binary Search In 2d Array</a></h3>
<pre><code class="language-java">public class BinarySearchIn2dArraySnippet {

  /**
  * Search an item with binarySearch algorithm.
  *
  * @param matrix should be sorted
  * @param target an item to search
  * @return if location of item is found, otherwise return {-1,-1}
  */
  public static int[] binarySearchIn2darr(int[][] matrix, int target) {
    int rows = matrix.length - 1;
    int cols = matrix[0].length - 1;

    if (rows == 1) {
      return binarySearch(matrix, target, 0, 0, cols);
    }

    int rstart = 0;
    int rend = rows;
    int cmid = cols / 2;

    while (rstart &lt; rend - 1) {
      int rmid = rstart + (rend - rstart) / 2;
      if (matrix[rmid][cmid] &gt; target) {
        rend = rmid;
      } else if (matrix[rmid][cmid] &lt; target) {
        rstart = rmid;
      } else {
        return new int[]{rmid, cmid};
      }
    }
    if (matrix[rstart][cmid] == target) {
      return new int[]{rstart, cmid};
    }
    if (matrix[rend][cmid] == target) {
      return new int[]{rend, cmid};
    }
    if (target &lt;= matrix[rstart][cmid - 1]) {
      return binarySearch(matrix, target, rstart, 0, cmid - 1);
    }
    if (target &gt;= matrix[rstart][cmid + 1]) {
      return binarySearch(matrix, target, rstart, cmid + 1, cols);
    }
    if (target &lt;= matrix[rend][cmid - 1]) {
      return binarySearch(matrix, target, rend, 0, cmid - 1);
    }
    if (target &lt;= matrix[rend][cmid + 1]) {
      return binarySearch(matrix, target, rend, cmid + 1, cols);
    }
    return new int[]{-1, -1};
  }

  static int[] binarySearch(int[][] matrix, int target, int row, int cstart, int cend) {
    while (cstart &lt;= cend) {
      int cmid = cstart + (cend - cstart) / 2;
      if (matrix[row][cmid] &gt; target) {
        cend = cmid - 1;
      } else if (matrix[row][cmid] &lt; target) {
        cstart = cend + 1;
      } else {
        return new int[]{row, cmid};
      }
    }
    return new int[]{-1, -1};
  }
}
</code></pre>
<h3 id="binary-search"><a class="header" href="#binary-search">Binary Search</a></h3>
<pre><code class="language-java">public class BinarySearchSnippet {

  /**
   * Search an item with binarySearch algorithm.
   *
   * @param arr sorted array to search
   * @param item an item to search
   * @return if item is found, return the index position of the array item otherwise return -1
   */

  public static int binarySearch(int[] arr, int left, int right, int item) {
    if (right &gt;= left) {
      int mid = left + (right - left) / 2;
      if (arr[mid] == item) {
        return mid;
      }

      if (arr[mid] &gt; item) {
        return binarySearch(arr, left, mid - 1, item);
      }

      return binarySearch(arr, mid + 1, right, item);
    }
    return -1;
  }   
}
</code></pre>
<h3 id="bubble-sort"><a class="header" href="#bubble-sort">Bubble Sort</a></h3>
<pre><code class="language-java">public class BubbleSortSnippet {

  /**
   * Sort an array with bubbleSort algorithm.
   *
   * @param arr array to sort
   */
  public static void bubbleSort(int[] arr) {
    var lastIndex = arr.length - 1;

    for (var j = 0; j &lt; lastIndex; j++) {
      for (var i = 0; i &lt; lastIndex - j; i++) {
        if (arr[i] &gt; arr[i + 1]) {
          var tmp = arr[i];
          arr[i] = arr[i + 1];
          arr[i + 1] = tmp;
        }
      }
    }
  }
}
</code></pre>
<h3 id="counting-sort"><a class="header" href="#counting-sort">Counting Sort</a></h3>
<pre><code class="language-java">public class CountingSortSnippet {

  /**
   * Sort an array having zero or positive numbers with countingSort algorithm.
   *
   * @param arr array to sort
   */
  public static void countingSort(int[] arr) {
    var max = Arrays.stream(arr).max().getAsInt();

    var count = new int[max + 1];

    for (var num : arr) {
      count[num]++;
    }

    for (var i = 1; i &lt;= max; i++) {
      count[i] += count[i - 1];
    }

    var sorted = new int[arr.length];
    for (var i = arr.length - 1; i &gt;= 0; i--) {
      var cur = arr[i];
      sorted[count[cur] - 1] = cur;
      count[cur]--;
    }

    var index = 0;
    for (var num : sorted) {
      arr[index++] = num;
    }
  }
}
</code></pre>
<h3 id="cycle-sort"><a class="header" href="#cycle-sort">Cycle Sort</a></h3>
<pre><code class="language-java">public class CycleSortSnippet {

  /**
   * Sort an array with cycleSort algorithm.
   *
   * @param arr array to sort
   */
  public static int[] cycleSort(int[] arr) {
    int n = arr.length;
    int i = 0;
    while (i &lt; n) {
      int correctpos = arr[i] - 1;
      if (arr[i] != arr[correctpos]) {
        int temp = arr[i];
        arr[i] = arr[correctpos];
        arr[correctpos] = temp;
      } else {
        i++;
      }
    }
    return arr;
  }
}
</code></pre>
<h3 id="insertion-sort"><a class="header" href="#insertion-sort">Insertion Sort</a></h3>
<pre><code class="language-java">public class InsertionSortSnippet {

  /**
   * Sort an array with insertionSort algorithm.
   *
   * @param arr array to sort
   */
  public static void insertionSort(int[] arr) {
    for (var i = 1; i &lt; arr.length; i++) {
      var tmp = arr[i];
      var j = i - 1;

      while (j &gt;= 0 &amp;&amp; arr[j] &gt; tmp) {
        arr[j + 1] = arr[j];
        j--;
      }
      arr[j + 1] = tmp;
    }
  }
}
</code></pre>
<h3 id="linear-search-in-2d-array"><a class="header" href="#linear-search-in-2d-array">Linear Search In 2d Array</a></h3>
<pre><code class="language-java">public class LinearSearchIn2dArraySnippet {

  /**
   * Search an item with linearSearch algorithm.
   *
   * @param arr    array to search
   * @param target an item to search
   * @return if location of target is found,otherwise return {-1,-1}
   */

  public static int[] linearSearch2dArray(int[][] arr, int target) {

    for (int i = 0; i &lt; arr.length; i++) {
      for (int j = 0; j &lt; arr[i].length; j++) {
        if (arr[i][j] == target) {
          return new int[]{i, j};
        }
      }
    }
    return new int[]{-1, -1};
  }
}
</code></pre>
<h3 id="linear-search"><a class="header" href="#linear-search">Linear Search</a></h3>
<pre><code class="language-java">public class LinearSearchSnippet {

  /**
   * Search an item with linearSearch algorithm.
   *
   * @param arr array to search
   * @param item an item to search
   * @return if item is found, return the index position of the array item otherwise return -1
   */
  public static int linearSearch(int[] arr, int item) {
    for (int i = 0; i &lt; arr.length; i++) {
      if (item == arr[i]) {
        return i;
      }
    }
    return -1;
  }
}
</code></pre>
<h3 id="luhn-mod-n"><a class="header" href="#luhn-mod-n">Luhn Mod N</a></h3>
<pre><code class="language-java">public class LuhnModnSnippet {

  private static final String CODE_POINTS = &quot;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;;

  /**
   * Generates a check character using the Luhn mod N algorithm.
   *
   * @param character the input string consisting of valid alphanumeric characters
   * @return the generated check character
   * @throws IllegalArgumentException if the input contains invalid characters
   */
  public static int codePointFromCharacter(char character) {
    if (CODE_POINTS.indexOf(character) == -1) {
      throw new IllegalArgumentException(&quot;Invalid character: &quot; + character);
    }
    return CODE_POINTS.indexOf(character);
  }

  /**
   * Converts a code point to its corresponding character.
   *
   * @param codePoint the code point to be converted
   * @return the character representation of the code point
   * @throws IllegalArgumentException if the code point is out of range.
   */
  public static char characterFromCodePoint(int codePoint) {
    if (codePoint &lt; 0 || codePoint &gt;= CODE_POINTS.length()) {
      throw new IllegalArgumentException(&quot;Invalid code point: &quot; + codePoint);
    }
    return CODE_POINTS.charAt(codePoint);
  }

  public static int numberOfValidInputCharacters() {
    return CODE_POINTS.length();
  }

  /**
   * Helper method to calculate the sum for both check character generation and validation.
   *
   * @param input the input string
   * @param factorStart the initial factor to start with (1 or 2)
   * @return the calculated sum, reminder, and the numberOfValidInputCharacters
   */
  private static int[] calculateSum(String input, int factorStart) {
    if (input == null || input.isEmpty()) {
      throw new IllegalArgumentException(&quot;Input cannot be empty&quot;);
    }

    int factor = factorStart;
    int sum = 0;
    int n = numberOfValidInputCharacters();

    for (int i = input.length() - 1; i &gt;= 0; i--) {
      int codePoint = codePointFromCharacter(input.charAt(i));
      int addend = factor * codePoint;
      factor = (factor == 2) ? 1 : 2;
      addend = (addend / n) + (addend % n);
      sum += addend;
    }
    return new int[]{sum, sum % n, n};
  }

  /**
   * Generates a check character for the given input string using the Luhn mod N algorithm.
   *
   * @param input the input string (non-empty)
   * @return the generated check character
   * @throws IllegalArgumentException if the input is null or empty
   */
  public static char generateCheckCharacter(String input) {
    int[] result = calculateSum(input, 2);
    return characterFromCodePoint((result[2] - result[1]) % result[2]);
  }

  /**
   * Validates a check character by applying the Luhn mod N algorithm.
   *
   * @param input the input string (including the check character)
   * @return true if the input passes validation, false otherwise
   * @throws IllegalArgumentException if the input is null or empty
   */
  public static boolean validateCheckCharacter(String input) {
    int[] result = calculateSum(input, 1);
    return (result[1] == 0);
  }
}
</code></pre>
<h3 id="merge-sort"><a class="header" href="#merge-sort">Merge Sort</a></h3>
<pre><code class="language-java">public class MergeSortSnippet {
  /**
   * Sort an array with qmergesort algorithm.
   *
   * @param arr   array to sort
   * @low low index where to begin sort (e.g. 0)
   * @high high index where to end sort (e.g. array length - 1)
   */

  public static void mergeSort(int[] arr, int low, int high) {
    if (low &gt;= high) {
      return;
    }
    var mid = (low + high) / 2;
    mergeSort(arr, low, mid);
    mergeSort(arr, mid + 1, high);
    merge(arr, low, high, mid);
  }

  private static void merge(int[] arr, int low, int high, int mid) {
    int[] temp = new int[(high - low + 1)];
    var i = low;
    var j = mid + 1;
    var k = 0;

    while (i &lt;= mid &amp;&amp; j &lt;= high) {
      if (arr[i] &lt; arr[j]) {
        temp[k++] = arr[i];
        i++;
      } else {
        temp[k++] = arr[j];
        j++;
      }
    }

    while (i &lt;= mid) {
      temp[k++] = arr[i];
      i++;
    }

    while (j &lt;= high) {
      temp[k++] = arr[j];
      j++;
    }

    for (int m = 0, n = low; m &lt; temp.length; m++, n++) {
      arr[n] = temp[m];
    }
  }
}
</code></pre>
<h3 id="quick-sort"><a class="header" href="#quick-sort">Quick Sort</a></h3>
<pre><code class="language-java">public class QuickSortSnippet {

  /**
   * Sort an array with quicksort algorithm.
   *
   * @param arr   array to sort
   * @param left  left index where to begin sort (e.g. 0)
   * @param right right index where to end sort (e.g. array length - 1)
   */
  public static void quickSort(int[] arr, int left, int right) {
    var pivotIndex = left + (right - left) / 2;
    var pivotValue = arr[pivotIndex];
    var i = left;
    var j = right;
    while (i &lt;= j) {
      while (arr[i] &lt; pivotValue) {
        i++;
      }
      while (arr[j] &gt; pivotValue) {
        j--;
      }
      if (i &lt;= j) {
        var tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
        i++;
        j--;
      }
      if (left &lt; i) {
        quickSort(arr, left, j);
      }
      if (right &gt; i) {
        quickSort(arr, i, right);
      }
    }
  }
}
</code></pre>
<h3 id="selection-sort"><a class="header" href="#selection-sort">Selection Sort</a></h3>
<pre><code class="language-java">public class SelectionSortSnippet {

  /**
   * Sort an array with selectionSort algorithm.
   *
   * @param arr array to sort
   */
  public static void selectionSort(int[] arr) {
    var len = arr.length;

    for (var i = 0; i &lt; len - 1; i++) {
      var minIndex = i;

      for (var j = i + 1; j &lt; len; j++) {
        if (arr[j] &lt; arr[minIndex]) {
          minIndex = j;
        }
      }

      var tmp = arr[minIndex];
      arr[minIndex] = arr[i];
      arr[i] = tmp;
    }
  }
}
</code></pre>
<h3 id="sieve-of-eratosthenes"><a class="header" href="#sieve-of-eratosthenes">Sieve of Eratosthenes</a></h3>
<pre><code class="language-java">public class SieveOfEratosthenesSnippet {
  /**
   * Search an item with binarySearch algorithm.
   *
   * @param n range of number.
   * @return isPrime boolean array where prime number 0 to n are mark true.
   */
  public static boolean[] sieveOfEratosthenes(int n) {
    boolean[] isPrime = new boolean[n + 1];
    for (int i = 0; i &lt; isPrime.length; i++) {
      isPrime[i] = true;
    }

    for (int i = 2; i * i &lt;= n; i++) {
      if (isPrime[i] == true) {
        for (int j = i * i; j &lt;= n; j += i) {
          isPrime[j] = false;
        }
      }
    }

    return isPrime;
  }
}
</code></pre>
<h3 id="verhoeff"><a class="header" href="#verhoeff">Verhoeff</a></h3>
<pre><code class="language-java">public class VerhoeffSnippet {

    private static final int[][] d = {
            {0, 1, 2, 3, 4, 5, 6, 7, 8, 9},
            {1, 0, 3, 2, 5, 4, 7, 6, 9, 8},
            {2, 3, 0, 1, 6, 7, 4, 5, 8, 9},
            {3, 2, 1, 0, 7, 6, 5, 4, 9, 8},
            {4, 5, 6, 7, 0, 1, 2, 3, 8, 9},
            {5, 4, 7, 6, 1, 0, 3, 2, 9, 8},
            {6, 7, 4, 5, 2, 3, 0, 1, 8, 9},
            {7, 6, 5, 4, 3, 2, 1, 0, 9, 8},
            {8, 9, 8, 9, 8, 9, 8, 9, 0, 1},
            {9, 8, 9, 8, 9, 8, 9, 8, 1, 0}
    };

    private static final int[][] p = {
            {0, 1, 2, 3, 4, 5, 6, 7, 8, 9},
            {1, 5, 7, 6, 2, 8, 3, 0, 9, 4},
            {5, 8, 0, 3, 7, 9, 6, 1, 4, 2},
            {8, 9, 1, 6, 0, 4, 3, 5, 2, 7},
            {9, 4, 5, 3, 1, 2, 6, 8, 7, 0},
            {4, 2, 8, 6, 5, 7, 3, 9, 0, 1},
            {2, 7, 9, 3, 8, 0, 6, 4, 1, 5},
            {7, 0, 4, 6, 9, 1, 3, 2, 5, 8}
    };

    private static final int[] inv = {0, 4, 3, 2, 1, 5, 6, 7, 8, 9};

    /**
     * Validates a number using the Verhoeff checksum algorithm.
     *
     * @param num the numeric string to validate
     * @return true if the number is valid according to Verhoeff algorithm, false otherwise
     */
    public static boolean validateVerhoeff(String num) {
        int c = 0;
        int length = num.length();

        // Adjust index for validation of the full number (including check digit)
        for (int i = 0; i &lt; length; i++) {
            int digit = Character.getNumericValue(num.charAt(length - i - 1));
            c = d[c][p[(i + 1) % 8][digit]]; // Correct permutation index
        }

        return c == 0; // Final checksum must be zero
    }

    /**
     * Generates a Verhoeff check digit for a given numeric string.
     *
     * @param num the numeric string for which to generate the check digit
     * @return the generated Verhoeff check digit as a string
     */
    public static String generateVerhoeff(String num) {
        int c = 0;
        int length = num.length();

        for (int i = 0; i &lt; length; i++) {
            int digit = Character.getNumericValue(num.charAt(length - i - 1));
            c = d[c][p[(i % 8)][digit]];
        }

        return Integer.toString(inv[c]);
    }

}
</code></pre>
<h2 id="array"><a class="header" href="#array">Array</a></h2>
<h3 id="all-equal"><a class="header" href="#all-equal">All Equal</a></h3>
<pre><code class="language-java">public class AllEqualSnippet {

  /**
   * Returns true if all elements in array are equal.
   *
   * @param arr the array to check (not null)
   * @param &lt;T&gt; the element type
   * @return true if all elements in the array are equal
   */
  public static &lt;T&gt; boolean allEqual(T[] arr) {
    return Arrays.stream(arr).distinct().count() == 1;
  }
}
</code></pre>
<h3 id="array-concat"><a class="header" href="#array-concat">Array Concat</a></h3>
<pre><code class="language-java">public class ArrayConcatSnippet {

  /**
   * Generic 2 array concatenation Credits: Joachim Sauer https://stackoverflow.com/questions/80476/how-can-i-concatenate-two-arrays-in-java
   *
   * @param first  is the first array (not null)
   * @param second is the second array (not null)
   * @param &lt;T&gt;    the element type
   * @return concatenated array
   */
  public static &lt;T&gt; T[] arrayConcat(T[] first, T[] second) {
    var result = Arrays.copyOf(first, first.length + second.length);
    System.arraycopy(second, 0, result, first.length, second.length);
    return result;
  }
}
</code></pre>
<h3 id="array-mean"><a class="header" href="#array-mean">Array Mean</a></h3>
<pre><code class="language-java">public class ArrayMeanSnippet {

  /**
   * Returns the mean of the integers in the array.
   *
   * @param arr the array of integers (not null)
   * @return a double representing the mean of the array
   */
  public static double arrayMean(int[] arr) {
    return (double) Arrays.stream(arr).sum() / arr.length;
  }
}
</code></pre>
<h3 id="array-median"><a class="header" href="#array-median">Array Median</a></h3>
<pre><code class="language-java">public class ArrayMedianSnippet {

  /**
   * Returns the median of the array.
   *
   * @param arr the array of integers (not null)
   * @return a double representing the median of the array
   */
  public static double arrayMedian(int[] arr) {
    Arrays.sort(arr);
    var mid = arr.length / 2;
    return arr.length % 2 != 0 ? (double) arr[mid] : (double) (arr[mid] + arr[mid - 1]) / 2;
  }
}
</code></pre>
<h3 id="array-mode-in-place"><a class="header" href="#array-mode-in-place">Array Mode In Place</a></h3>
<pre><code class="language-java">public class ArrayModeInPlaceSnippet {

  /**
  * Returns the mode of the array.
  *
  * @param arr array to find mode in it
  * @return mode of array
  */
  public static int modeArrayInPlace(int[] arr) {
    if (arr.length == 0) {
      return 0;
    }

    Arrays.sort(arr);

    int mode = arr[0];
    int maxcount = 1;
    int count = 1;

    for (int i = 1; i &lt; arr.length; i++) {
      if (arr[i] == arr[i - 1]) {
        count++;
      } else {
        if (count &gt; maxcount) {
          maxcount = count;
          mode = arr[i - 1];
        }
        count = 1;
      }
    }
    if (count &gt; maxcount) {
      mode = arr[arr.length - 1];
    }
    return mode;
  }
}
</code></pre>
<h3 id="array-mode"><a class="header" href="#array-mode">Array Mode</a></h3>
<pre><code class="language-java">public class ArrayModeSnippet {

    /**
     * Private constructor to prevent instantiation.
     */
    private ArrayModeSnippet() {
        throw new IllegalStateException(&quot;Utility class&quot;);
    }

    /**
     * Returns the mode(s) of the array.
     * If multiple modes exist, it returns them in a list.
     */
    public static List&lt;Integer&gt; modeArray(int[] arr) {
        int maxCount = 0;
        HashMap&lt;Integer, Integer&gt; frequencyMap = new HashMap&lt;&gt;();
        for (int num : arr) {
            frequencyMap.put(num, frequencyMap.getOrDefault(num, 0) + 1);
            maxCount = Math.max(maxCount, frequencyMap.get(num));
        }
        List&lt;Integer&gt; modes = new ArrayList&lt;&gt;();
        for (Map.Entry&lt;Integer, Integer&gt; entry : frequencyMap.entrySet()) {
            if (entry.getValue() == maxCount) {
                modes.add(entry.getKey());
            }
        }
        return modes;
    }
}
</code></pre>
<h3 id="array-sum"><a class="header" href="#array-sum">Array Sum</a></h3>
<pre><code class="language-java">public class ArraySumSnippet {

  /**
   * Returns sum of the integers in the array.
   *
   * @param arr the array of integers (not null)
   * @return the sum of the elements from the array
   */
  public static int arraySum(int[] arr) {
    return Arrays.stream(arr).sum();
  }
}
</code></pre>
<h3 id="find-max"><a class="header" href="#find-max">Find Max</a></h3>
<pre><code class="language-java">public class FindMaxSnippet {

  /**
   * Returns the maximum integer from the array using reduction.
   *
   * @param arr the array of integers (not null)
   * @return the maximum element from the array
   */
  public static int findMax(int[] arr) {
    return Arrays.stream(arr).reduce(Integer.MIN_VALUE, Integer::max);
  }
}
</code></pre>
<h3 id="find-min"><a class="header" href="#find-min">Find Min</a></h3>
<pre><code class="language-java">public class FindMinSnippet {
 
  /**
    * Returns the minimum integer from the array using reduction.
    *
    * @param arr the array of integers (not null)
    * @return the minimum element from the array
    */
  public static int findMin(int[] arr) {
    return Arrays.stream(arr).reduce(Integer.MAX_VALUE, Integer::min);
  }
}
</code></pre>
<h3 id="multi-array-concatenation"><a class="header" href="#multi-array-concatenation">Multi Array Concatenation</a></h3>
<pre><code class="language-java">public class MultiArrayConcatenationSnippet {

  /**
   * Generic N array concatenation Credits: Joachim Sauer https://stackoverflow.com/questions/80476/how-can-i-concatenate-two-arrays-in-java
   *
   * @param first is the first array (not null)
   * @param rest  the rest of the arrays (optional)
   * @param &lt;T&gt;   the element type
   * @return concatenated array
   */
  public static &lt;T&gt; T[] multiArrayConcat(T[] first, T[]... rest) {
    var totalLength = first.length;
    for (var array : rest) {
      totalLength += array.length;
    }
    var result = Arrays.copyOf(first, totalLength);
    var offset = first.length;
    for (var array : rest) {
      System.arraycopy(array, 0, result, offset, array.length);
      offset += array.length;
    }
    return result;
  }
}
</code></pre>
<h3 id="reverse-array"><a class="header" href="#reverse-array">Reverse Array</a></h3>
<pre><code class="language-java">public class ReverseArraySnippet {

  /**
   * The function then reverses the elements of the array between the starting and ending
   * indices using a while loop and a temporary variable `temp`. Finally, the function returns
   * the reversed array.
   *
   * @param array a array
   * @param start start index array
   * @param end end index array
   * @return reverses elements in the array
   * @throws IllegalArgumentException if the [start] index is greater
   *         than the [end] index or if the array is null
   **/
  public static &lt;T&gt; T[] reverseArray(T[] array, int start, int end) {
    if (start &gt; end || array == null) {
      throw new
              IllegalArgumentException(&quot;Invalid argument!&quot;);
    }
    int minimumSizeArrayForReversal = 2;
    if (start == end || array.length &lt; minimumSizeArrayForReversal) {
      return array;
    }
    while (start &lt; end) {
      T temp = array[start];
      array[start] = array[end];
      array[end] = temp;
      start++;
      end--;
    }
    return array;
  }
}
</code></pre>
<h2 id="class"><a class="header" href="#class">Class</a></h2>
<h3 id="creating-object"><a class="header" href="#creating-object">Creating Object</a></h3>
<pre><code class="language-java">public class CreatingObjectSnippet {

  /**
   * Create object using reflection.
   *
   * @param cls fully qualified name of class includes the package name as String
   * @return object
   * @throws NoSuchMethodException if a method that does not exist at runtime.
   * @throws IllegalAccessException &lt;p&gt;if an currently executing method does not have access to
   *     the definition of the specified class, field, method or constructor&lt;/p&gt;
   * @throws InvocationTargetException &lt;p&gt;InvocationTargetException is a checked exception
   *     that wraps an exception thrown by an invoked method or constructor.&lt;/p&gt;
   * @throws InstantiationException &lt;p&gt;when an method tries to create an instance of a class
   *     using the newInstance method in class Class.&lt;/p&gt;
   * @throws ClassNotFoundException &lt;p&gt;when an application tries to load in a class
   *     through its string name.&lt;/p&gt;
   */
  public static Object createObject(String cls)
          throws NoSuchMethodException,
          IllegalAccessException,
          InvocationTargetException,
          InstantiationException,
          ClassNotFoundException {
    var objectClass = Class.forName(cls);
    var objectConstructor = objectClass.getConstructor();
    return objectConstructor.newInstance();
  }
}
</code></pre>
<h3 id="get-all-field-names"><a class="header" href="#get-all-field-names">Get All Field Names</a></h3>
<pre><code class="language-java">public class GetAllFieldNamesSnippet {

  /**
   * Print all declared field names of the class or the interface the class extends.
   *
   * @param clazz Tested class
   * @return list of names of all fields
   */
  public static List&lt;String&gt; getAllFieldNames(final Class&lt;?&gt; clazz) {
    var fields = new ArrayList&lt;String&gt;();
    var currentClazz = clazz;
    while (currentClazz != null) {
      fields.addAll(
          Arrays.stream(currentClazz.getDeclaredFields())
              .filter(field -&gt; !field.isSynthetic())
              .map(Field::getName)
              .collect(Collectors.toList()));
      currentClazz = currentClazz.getSuperclass();
    }
    return fields;
  }
}
</code></pre>
<h3 id="get-all-methods"><a class="header" href="#get-all-methods">Get All Methods</a></h3>
<pre><code class="language-java">public class GetAllMethodsSnippet {

  /**
   * Print all declared methods of the class.
   *
   * @param cls Tested class
   * @return list of methods name
   */
  public static List&lt;String&gt; getAllMethods(final Class&lt;?&gt; cls) {
    return Arrays.stream(cls.getDeclaredMethods())
        .map(Method::getName)
        .collect(Collectors.toList());
  }
}
</code></pre>
<h3 id="get-all-public-field-names"><a class="header" href="#get-all-public-field-names">Get All Public Field Names</a></h3>
<pre><code class="language-java">public class GetAllPublicFieldNamesSnippet {

  /**
   * Print all declared public field names of the class or the interface the class extends.
   *
   * @param clazz Tested class
   * @return list of name of public fields
   */
  public static List&lt;String&gt; getAllPublicFieldNames(final Class&lt;?&gt; clazz) {
    return Arrays.stream(clazz.getFields())
        .map(Field::getName)
        .collect(Collectors.toList());
  }
}
</code></pre>
<h2 id="date"><a class="header" href="#date">Date</a></h2>
<h3 id="add-days-to-date"><a class="header" href="#add-days-to-date">Add Days To Date</a></h3>
<pre><code class="language-java">public class AddDaysToDateSnippet {

  /**
   * Add days to given date.
   *
   * @param date given date
   * @param noOfDays number of days to add
   * @return modified date
   */
  public static Date addDaysToDate(Date date, int noOfDays) {
    if (date != null) {
      Calendar cal = Calendar.getInstance();
      cal.setTime(date);
      cal.add(Calendar.DAY_OF_MONTH, noOfDays);
      return cal.getTime();
    }
    return null;
  }

  /**
   * Add days to local date.
   *
   * @param date given local date
   * @param noOfDays number of days to add
   * @return modified date
   */
  public static LocalDate addDaysToLocalDate(LocalDate date, long noOfDays) {
    return date != null ? date.plusDays(noOfDays) : null;
  }
}
</code></pre>
<h3 id="date-difference"><a class="header" href="#date-difference">Date Difference</a></h3>
<pre><code class="language-java">public class DateDifferenceSnippet {

  /**
  * This function calculates the number of years between two LocalDate objects.
  * If the result is negative, it returns the absolute value of the difference.
  *
  * @param firstTime  The first LocalDate object representing the starting date
  * @param secondTime The second LocalDate object representing the ending date
  * @return The number of years between the two LocalDate objects as a long data type
  */
  public static long getYearsDifference(LocalDate firstTime, LocalDate secondTime) {
    var yearsDifference = ChronoUnit.YEARS.between(firstTime, secondTime);
    return Math.abs(yearsDifference);
  }

  /**
   * This function calculates the number of months between two LocalDate objects.
   * If the result is negative, it returns the absolute value of the difference.
   *
   * @param firstTime  The first LocalDate object representing the starting date
   * @param secondTime The second LocalDate object representing the ending date
   * @return The number of months between the two LocalDate objects as a long data type
   */
  public static long getMonthsDifference(LocalDate firstTime, LocalDate secondTime) {
    var monthsDifference = ChronoUnit.MONTHS.between(firstTime, secondTime);
    return Math.abs(monthsDifference);
  }

  /**
   * This function calculates the number of days between two LocalDate objects.
   * If the result is negative, it returns the absolute value of the difference.
   *
   * @param firstTime  The first LocalDate object representing the starting date
   * @param secondTime The second LocalDate object representing the ending date
   * @return The number of days between the two LocalDate objects as a long data type
   */
  public static long getDaysDifference(LocalDate firstTime, LocalDate secondTime) {
    var daysDifference = ChronoUnit.DAYS.between(firstTime, secondTime);
    return Math.abs(daysDifference);
  }
}
</code></pre>
<h2 id="encoding"><a class="header" href="#encoding">Encoding</a></h2>
<h3 id="base64decode"><a class="header" href="#base64decode">Base64Decode</a></h3>
<pre><code class="language-java">public class Base64DecodeSnippet {

  /**
   * Decodes a Base64 encoded string to the actual representation.
   *
   * @param input base64 encoded string
   * @return decoded string
   */
  public static String decodeBase64(String input) {
    return new String(Base64.getDecoder().decode(input.getBytes()));
  }
}
</code></pre>
<h3 id="base64encode"><a class="header" href="#base64encode">Base64Encode</a></h3>
<pre><code class="language-java">public class Base64EncodeSnippet {
  /**
   * Encodes the input string to a Base64 encoded string.
   *
   * @param input string to be encoded
   * @return base64 encoded string
   */
  public static String encodeBase64(String input) {
    return Base64.getEncoder().encodeToString(input.getBytes());
  }
}
</code></pre>
<h2 id="file"><a class="header" href="#file">File</a></h2>
<h3 id="list-all-files"><a class="header" href="#list-all-files">List All Files</a></h3>
<pre><code class="language-java">public class ListAllFilesSnippet {

  /**
   * Recursively list all the files in directory.
   *
   * @param path the path to start the search from
   * @return list of all files
   */
  public static List&lt;File&gt; listAllFiles(String path) {
    var all = new ArrayList&lt;File&gt;();
    var list = new File(path).listFiles();
    if (list != null) {  // In case of access error, list is null
      for (var f : list) {
        if (f.isDirectory()) {
          all.addAll(listAllFiles(f.getAbsolutePath()));
        } else {
          all.add(f.getAbsoluteFile());
        }
      }
    }
    return all;
  }
}
</code></pre>
<h3 id="list-directories"><a class="header" href="#list-directories">List Directories</a></h3>
<pre><code class="language-java">public class ListDirectoriesSnippet {

  /**
   * List directories.
   *
   * @param path the path where to look
   * @return array of File
   */
  public static File[] listDirectories(String path) {
    return new File(path).listFiles(File::isDirectory);
  }
}
</code></pre>
<h3 id="list-files-in-directory"><a class="header" href="#list-files-in-directory">List Files In Directory</a></h3>
<pre><code class="language-java">public class ListFilesInDirectorySnippet {

  /**
   * List files in directory.
   *
   * @param folder the path where to look
   * @return array of File
   */
  public static File[] listFilesInDirectory(String folder) {
    return new File(folder).listFiles(File::isFile);
  }
}
</code></pre>
<h3 id="read-lines"><a class="header" href="#read-lines">Read Lines</a></h3>
<pre><code class="language-java">public class ReadLinesSnippet {

  /**
   * Read file as list of strings.
   *
   * @param filename the filename to read from
   * @return list of strings
   * @throws IOException if an I/O error occurs
   */
  public static List&lt;String&gt; readLines(String filename) throws IOException {
    return Files.readAllLines(Paths.get(filename));
  }
}
</code></pre>
<h3 id="zip-directory"><a class="header" href="#zip-directory">Zip Directory</a></h3>
<pre><code class="language-java">public class ZipDirectorySnippet {

  /**
   * Zip a complete directory.
   *
   * @param srcDirectoryName The path to the directory to be zipped
   * @param zipFileName The location and name of the zipped file.
   * @throws IOException if an I/O error occurs
   * */
  public static void zipDirectory(String srcDirectoryName, String zipFileName) throws IOException {
    var srcDirectory = new File(srcDirectoryName);
    try (
        var fileOut = new FileOutputStream(zipFileName);
        var zipOut = new ZipOutputStream(fileOut)
    ) {
      zipFile(srcDirectory, srcDirectory.getName(), zipOut);
    }
  }

  /**
   * Utility function which either zips a single file, or recursively calls itself for 
   * a directory to traverse down to the files contained within it.
   *
   * @param fileToZip The file as a resource
   * @param fileName The actual name of the file
   * @param zipOut The output stream to which all data is being written
   * */
  public static void zipFile(File fileToZip, String fileName, ZipOutputStream zipOut) 
      throws IOException {
    if (fileToZip.isHidden()) { // Ignore hidden files as standard
      return;
    }
    if (fileToZip.isDirectory()) {
      if (fileName.endsWith(&quot;/&quot;)) {
        zipOut.putNextEntry(new ZipEntry(fileName)); // To be zipped next
        zipOut.closeEntry();
      } else {
        // Add the &quot;/&quot; mark explicitly to preserve structure while unzipping action is performed
        zipOut.putNextEntry(new ZipEntry(fileName + &quot;/&quot;));
        zipOut.closeEntry();
      }
      var children = fileToZip.listFiles();
      for (var childFile : children) { // Recursively apply function to all children
        zipFile(childFile, fileName + &quot;/&quot; + childFile.getName(), zipOut);
      }
      return;
    }
    try (
        var fis = new FileInputStream(fileToZip) // Start zipping once we know it is a file
    ) {
      var zipEntry = new ZipEntry(fileName);
      zipOut.putNextEntry(zipEntry);
      var bytes = new byte[1024];
      var length = 0;
      while ((length = fis.read(bytes)) &gt;= 0) {
        zipOut.write(bytes, 0, length);
      }
    }
  }
}
</code></pre>
<h3 id="zip-file"><a class="header" href="#zip-file">Zip File</a></h3>
<pre><code class="language-java">public class ZipFileSnippet {

  /**
   * Zip single file.
   *
   * @param srcFilename the filename of the source file
   * @param zipFilename the filename of the destination zip file
   * @throws IOException if an I/O error occurs
   */
  public static void zipFile(String srcFilename, String zipFilename) throws IOException {
    var srcFile = new File(srcFilename);
    try (
            var fileOut = new FileOutputStream(zipFilename);
            var zipOut = new ZipOutputStream(fileOut);
            var fileIn = new FileInputStream(srcFile)
    ) {
      var zipEntry = new ZipEntry(srcFile.getName());
      zipOut.putNextEntry(zipEntry);
      final var bytes = new byte[1024];
      int length;
      while ((length = fileIn.read(bytes)) &gt;= 0) {
        zipOut.write(bytes, 0, length);
      }
    }
  }
}
</code></pre>
<h3 id="zip-files"><a class="header" href="#zip-files">Zip Files</a></h3>
<pre><code class="language-java">public class ZipFilesSnippet {

  /**
   * Zip multiples files.
   *
   * @param srcFilenames array of source file names
   * @param zipFilename  the filename of the destination zip file
   * @throws IOException if an I/O error occurs
   */
  public static void zipFiles(String[] srcFilenames, String zipFilename) throws IOException {
    try (
            var fileOut = new FileOutputStream(zipFilename);
            var zipOut = new ZipOutputStream(fileOut)
    ) {
      for (String srcFilename : srcFilenames) {
        var srcFile = new File(srcFilename);
        try (var fileIn = new FileInputStream(srcFile)) {
          var zipEntry = new ZipEntry(srcFile.getName());
          zipOut.putNextEntry(zipEntry);
          final var bytes = new byte[1024];
          int length;
          while ((length = fileIn.read(bytes)) &gt;= 0) {
            zipOut.write(bytes, 0, length);
          }
        }
      }
    }
  }
}
</code></pre>
<h2 id="io"><a class="header" href="#io">I/O</a></h2>
<h3 id="inputstream-to-string"><a class="header" href="#inputstream-to-string">InputStream To String</a></h3>
<pre><code class="language-java">public class InputStreamToStringSnippet {

  /**
   * Convert InputStream to String.
   *
   * @param inputStream InputStream to convert
   * @return String
   */
  public static String inputStreamToString(InputStream inputStream) {
    return new BufferedReader(new InputStreamReader(inputStream, StandardCharsets.UTF_8))
            .lines().collect(Collectors.joining(System.lineSeparator()));
  }
}
</code></pre>
<h3 id="read-file-snippet"><a class="header" href="#read-file-snippet">Read File Snippet</a></h3>
<pre><code class="language-java">public class ReadFileSnippet {

  /**
   * Read file using stream and return list of string lines.
   *
   * @param fileName file to read
   * @throws FileNotFoundException if an I/O error occurs
   */
  public static List&lt;String&gt; readFile(String fileName) throws FileNotFoundException {
    try (Stream&lt;String&gt; stream = new BufferedReader(new FileReader(fileName)).lines()) {
      return stream.collect(Collectors.toList());
    }
  }
}
</code></pre>
<h2 id="math"><a class="header" href="#math">Math</a></h2>
<h3 id="dice-throw"><a class="header" href="#dice-throw">Dice Throw</a></h3>
<pre><code class="language-java">public class DiceThrow {

  private static Random random = new Random();

  /**
  * Enum for standardized sided dice (4,6,8,10,12 and 20).
  */
  public enum DiceSides {

    FOUR(4), SIX(6), EIGHT(8), TEN(10), TWELVE(12), TWENTY(20);

    private final int diSides;

    DiceSides(int diceSides) {
      this.diSides = diceSides;
    }

    /**
     * Returns the number of sides of a dice.
     *
     * @return int denoting number of sides of a dice
     */
    public int getDiceSides() {
      return this.diSides;
    }

  }

  /**
  * Returns the sum of sides for the given number of sides of each dice.
  *
  * @param noOfDice number of dice
  * @param sides sides of a dice
  * @return int sum of sides for number of dice
  */
  public static int throwDice(int noOfDice, DiceSides sides) {

    int sum = 0;
    for (int i = 0; i &lt; noOfDice; i++) {
      sum = sum + (1 + random.nextInt(sides.getDiceSides()));
    }
    return sum;
  }
}
</code></pre>
<h3 id="elo-rating"><a class="header" href="#elo-rating">Elo Rating</a></h3>
<pre><code class="language-java">public class EloRatingSnippet {

  static final int BASE = 400; //Two types are popular - 400 and 480. We will choose 400 here
  static final int RATING_ADJUSTMENT_FACTOR = 32; //32 is the standard for Beginner Games

  /**
   * Elo Rating Snippet to calculate result after a single match.
   *
   * @param firstPlayerRating Rating of the first player.
   * @param secondPlayerRating Rating of the second player.
   * @param result Result of the match, always considered with respect to the first player.
   *               1 indicates a win, 0.5 indicates a draw and 0 indicates a loss.
   * @return Returns the new rating of the first player.
   */
  public static double calculateMatchRating(double firstPlayerRating, double secondPlayerRating,
      double result) {
    double ratingDiff = ((secondPlayerRating - firstPlayerRating) * 1.0) / BASE;
    double logisticDiff = Math.pow(10, ratingDiff);
    double firstPlayerExpectedScore = 1.0 / (1 + logisticDiff);
    double firstPlayerActualScore = result;
    double newRating = firstPlayerRating + RATING_ADJUSTMENT_FACTOR * (firstPlayerActualScore 
                       - firstPlayerExpectedScore);
    return newRating;
  }
}
</code></pre>
<h3 id="even-odd"><a class="header" href="#even-odd">Even Odd</a></h3>
<pre><code class="language-java">public class EvenOdd {

  /**
   * Returns string denoting number is odd or even.
   *
   * @param num To check whether its even or odd
   * @return string denoting its even or odd
   */
  public static String evenodd(int num) {
    if (num % 2 == 0) {
      return &quot;even&quot;;
    } else {
      return &quot;odd&quot;;
    }
  }
}
</code></pre>
<h3 id="factorial"><a class="header" href="#factorial">Factorial</a></h3>
<pre><code class="language-java">public class FactorialSnippet {

  /**
   * Factorial. Works only for small numbers
   *
   * @param number for which factorial is to be calculated for
   * @return factorial
   */
  public static int factorial(int number) {
    var result = 1;
    for (var factor = 2; factor &lt;= number; factor++) {
      result *= factor;
    }
    return result;
  }

  /**
   * Factorial. Example of what the recursive implementation looks like.
   *
   * @param number for which factorial is to be calculated for
   * @return factorial
   */
  public static int recursiveFactorial(int number) {
    var initial = 0;
    if (number == initial) {
      return initial + 1;
    }
    return number * recursiveFactorial(number - 1);
  }
}
</code></pre>
<h3 id="fibonacci"><a class="header" href="#fibonacci">Fibonacci</a></h3>
<pre><code class="language-java">public class FibonacciSnippet {

  /**
   * Recursive Fibonacci series. Works only for small n and is spectacularly inefficient
   *
   * @param n given number
   * @return fibonacci number for given n
   */
  public static int fibonacci(int n) {
    if (n &lt;= 1) {
      return n;
    } else {
      return fibonacci(n - 1) + fibonacci(n - 2);
    }
  }

  /**
   * Fibonacci series using dynamic programming. Works for larger ns as well.
   *
   * @param n given number
   * @return fibonacci number for given n
   */
  public static int fibonacciBig(int n) {
      int previous = 0;
      int current = 1;
      for (int i = 0; i &lt; n - 1; i++) {
          int t = previous + current;
          previous = current;
          current = t;
      }

      return current;
  }

  /**
   * Example of what an iterative implementation of Fibonacci looks like.
   *
   * @param number given number
   * @return fibonacci number for given n
   */
  public static int iterativeFibonacci(int number) {
    List&lt;Integer&gt; list = new ArrayList&lt;&gt;();
    list.add(0);
    list.add(1);
    for (int i = 2; i &lt; number + 1; i++) {
      list.add(list.get(i - 2) + list.get(i - 1));
    }
    return list.get(number);
  }
}
</code></pre>
<h3 id="greatest-common-divisor"><a class="header" href="#greatest-common-divisor">Greatest Common Divisor</a></h3>
<pre><code class="language-java">public class GreatestCommonDivisorSnippet {

  /**
   * Greatest common divisor calculation.
   *
   * @param a one of the numbers whose gcd is to be computed
   * @param b other number whose gcd is to be computed
   * @return gcd of the two numbers
   */
  public static int gcd(int a, int b) {
    if (b == 0) {
      return a;
    }
    return gcd(b, a % b);
  }
}
</code></pre>
<h3 id="haversine-formula"><a class="header" href="#haversine-formula">Haversine Formula</a></h3>
<pre><code class="language-java">public class HaversineFormulaSnippet {

  // Radius of sphere on which the points are, in this case Earth.
  private static final double SPHERE_RADIUS_IN_KM = 6372.8;

  /**
   * Haversine formula for calculating distance between two latitude, longitude points.
   *
   * @param latA Latitude of point A
   * @param longA Longitude of point A
   * @param latB Latitude of point B
   * @param longB Longitude of point B
   * @return the distance between the two points.
   */
  public static double findHaversineDistance(double latA, double longA, double latB, double longB) {
    if (!isValidLatitude(latA)
        || !isValidLatitude(latB)
        || !isValidLongitude(longA)
        || !isValidLongitude(longB)) {
      throw new IllegalArgumentException();
    }

    // Calculate the latitude and longitude differences
    var latitudeDiff = Math.toRadians(latB - latA);
    var longitudeDiff = Math.toRadians(longB - longA);

    var latitudeA = Math.toRadians(latA);
    var latitudeB = Math.toRadians(latB);

    // Calculating the distance as per haversine formula
    var a = Math.pow(Math.sin(latitudeDiff / 2), 2)
            + Math.pow(Math.sin(longitudeDiff / 2), 2) * Math.cos(latitudeA) * Math.cos(latitudeB);
    var c = 2 * Math.asin(Math.sqrt(a));
    return SPHERE_RADIUS_IN_KM * c;
  }

  // Check for valid latitude value
  private static boolean isValidLatitude(double latitude) {
    return latitude &gt;= -90 &amp;&amp; latitude &lt;= 90;
  }

  // Check for valid longitude value
  private static boolean isValidLongitude(double longitude) {
    return longitude &gt;= -180 &amp;&amp; longitude &lt;= 180;
  }
}
</code></pre>
<h3 id="least-common-multiple"><a class="header" href="#least-common-multiple">Least Common Multiple</a></h3>
<pre><code class="language-java">public class LeastCommonMultipleSnippet {
  /**
   * Least common multiple  calculation.
   *
   * @param a one of the numbers whose lcm is to be computed
   * @param b other number whose lcm is to be computed
   * @return lcm of the two numbers
   */
  public static int lcm(int a, int b) {
    int max = a &gt; b ? a : b;
    int min = a &lt; b ? a : b;
    for (int i = 1; i &lt;= min; i += 1) {
      int prod = max * i;
      if (prod % min == 0) {
        return prod;
      }
    }
    return max * min;
  }
}
</code></pre>
<h3 id="luhn"><a class="header" href="#luhn">Luhn</a></h3>
<pre><code class="language-java">public class LuhnSnippet {

  /**
   * Calculates checksum for a given number with Luhn's algorithm. Works only on non-negative
   * integers not greater than {@link Long#MAX_VALUE} i.e., all numbers with a maximum of 18
   * digits, plus 19-digit-long numbers start with 1..8 (also some with 9, too). For
   * demonstration purposes, algorithm is not optimized for efficiency.
   *
   * @param num number whose checksum is to be calculated
   * @return checksum value for num
   * @see &lt;a href=&quot;https://patents.google.com/patent/US2950048A&quot;&gt;Hans P. LUHN's patent US2950048A&lt;/a&gt;
   * @see &lt;a href=&quot;https://en.wikipedia.org/wiki/Luhn_algorithm&quot;&gt;Luhn algorithm on Wikipedia&lt;/a&gt;
   */
  public static int calculateLuhnChecksum(long num) {
    if (num &lt; 0) {
      throw new IllegalArgumentException(&quot;Non-negative numbers only.&quot;);
    }
    final var numStr = String.valueOf(num);

    var sum = 0;
    var isOddPosition = true;
    // Loop on digits of numStr from right to left.
    for (var i = numStr.length() - 1; i &gt;= 0; i--) {
      final var digit = Integer.parseInt(Character.toString(numStr.charAt(i)));
      final var substituteDigit = (isOddPosition ? 2 : 1) * digit;

      final var tensPlaceDigit = substituteDigit / 10;
      final var onesPlaceDigit = substituteDigit % 10;
      sum += tensPlaceDigit + onesPlaceDigit;

      isOddPosition = !isOddPosition;
    }
    final var checksumDigit = (10 - (sum % 10)) % 10;
    // Outermost modulus handles edge case `num = 0`.
    return checksumDigit;
  }
}
</code></pre>
<h3 id="natural-number-binary-conversion"><a class="header" href="#natural-number-binary-conversion">Natural Number Binary Conversion</a></h3>
<pre><code class="language-java">public class NaturalNumberBinaryConversionSnippet {

  /**
   * Convert natural number to binary string. Only supports positive integers.Throws exception
   * for negative integers
   *
   * @param naturalNumber given number
   * @return Binary string representation of naturalNumber
   */
  public static String toBinary(long naturalNumber) {
    if (naturalNumber &lt; 0) {
      throw new NumberFormatException(&quot;Negative Integer, this snippet only accepts &quot;
              + &quot;positive integers&quot;);
    }
    if (naturalNumber == 0) {
      return &quot;0&quot;;
    }
    final Stack&lt;Long&gt; binaryBits =
            Stream.iterate(naturalNumber, n -&gt; n &gt; 0, n -&gt; n / 2).map(n -&gt; n % 2)
                    .collect(Stack::new, Stack::push, Stack::addAll);
    return Stream.generate(binaryBits::pop)
            .limit(binaryBits.size()).map(String::valueOf).collect(Collectors.joining());
  }

  /**
   * Convert binary string representation to Long valued Integer. Throws exception if input
   * string contains characters other than '0' and '1'
   *
   * @param binary given number
   * @return Unsigned Long value for the binary number
   */
  public static Long fromBinary(String binary) {
    binary.chars().filter(c -&gt; c != '0' &amp;&amp; c != '1').findFirst().ifPresent(in -&gt; {
      throw new NumberFormatException(
              &quot;Binary string contains values other than '0' and '1'&quot;);
    });
    return IntStream.range(0, binary.length())
            .filter(in -&gt; binary.charAt(binary.length() - 1 - in) == '1')
            .mapToLong(in -&gt; ((long) 0b1) &lt;&lt; in).sum();
  }
}
</code></pre>
<h3 id="perform-lottery"><a class="header" href="#perform-lottery">Perform Lottery</a></h3>
<pre><code class="language-java">public class PerformLotterySnippet {

  /**
   * Generate random lottery numbers.
   *
   * @param numNumbers    how many performLottery numbers are available (e.g. 49)
   * @param numbersToPick how many numbers the player needs to pick (e.g. 6)
   * @return array with the random numbers
   */
  public static Integer[] performLottery(int numNumbers, int numbersToPick) {
    var numbers = new ArrayList&lt;Integer&gt;();
    for (var i = 0; i &lt; numNumbers; i++) {
      numbers.add(i + 1);
    }
    Collections.shuffle(numbers);
    return numbers.subList(0, numbersToPick).toArray(new Integer[numbersToPick]);
  }
}
</code></pre>
<h3 id="prime-number"><a class="header" href="#prime-number">Prime Number</a></h3>
<pre><code class="language-java">public class PrimeNumberSnippet {

  /**
   * Checks if given number is a prime number. Prime number is a number that is greater than 1 and
   * divided by 1 or itself only Credits: https://en.wikipedia.org/wiki/Prime_number
   *
   * @param number number to check prime
   * @return true if prime
   */
  public static boolean isPrime(int number) {
    //if number &lt; 2 its not a prime number
    if (number &lt; 2) {
      return false;
    }
    // 2 and 3 are prime numbers
    if (number &lt; 3) {
      return true;
    }
    // check if n is a multiple of 2
    if (number % 2 == 0) {
      return false;
    }
    // if not, then just check the odds
    for (var i = 3; i * i &lt;= number; i += 2) {
      if (number % i == 0) {
        return false;
      }
    }
    return true;
  }
}
</code></pre>
<h3 id="random-number"><a class="header" href="#random-number">Random Number</a></h3>
<pre><code class="language-java">public class RandomNumber {

  private RandomNumber() {}
    
  private static Random random = new Random();
    
  /**
   * Return a random number between two given numbers.
   *
   * @param start Starting point to find the random number
   * @param end Ending point to find the random number
   * @return Number denoting the random number generated
   */
  public static &lt;T extends Number&gt; Number getRandomNumber(T start, T end) {
    
      if (start instanceof Byte &amp;&amp; end instanceof Byte) {
        return (byte) (start.byteValue()
                + random.nextInt(end.byteValue() - start.byteValue() + 1));
      } else if (start instanceof Short &amp;&amp; end instanceof Short) {
        return (short) (start.shortValue()
                + random.nextInt(end.shortValue() - start.shortValue() + 1));
      } else if (start instanceof Integer &amp;&amp; end instanceof Integer) {
        return start.intValue()
                + random.nextInt(end.intValue() - start.intValue() + 1);
      } else if (start instanceof Long &amp;&amp; end instanceof Long) {
        return start.longValue()
                + (long) (random.nextDouble() * end.longValue() - start.longValue() + 1);
      } else if (start instanceof Float &amp;&amp; end instanceof Float) {
        return start.floatValue()
                + random.nextFloat() * (end.floatValue() - start.floatValue());
      } else if (start instanceof Double &amp;&amp; end instanceof Double) {
        return start.doubleValue()
                + random.nextDouble() * (end.doubleValue() - start.doubleValue());
      } else {
        throw new IllegalArgumentException(&quot;Invalid Numbers As Arguments &quot;
                + start.getClass() + &quot; and &quot; + end.getClass());
        }
    }
}
</code></pre>
<h3 id="square-root"><a class="header" href="#square-root">Square Root</a></h3>
<pre><code class="language-java">public class SquareRoot {

  /**
   * Returns square root of a number.
   *
   * @param num To find SquareRoot
   * @param p   precision till how many decimal numbers we want accurate ans
   */
  public static double sqrt(int num, int p) {
    int start = 0;
    int end = num;
    double root = 0.0;

    while (start &lt;= end) {
      int mid = start + (end - start) / 2;

      if ((mid * mid) &gt; num) {
        end = mid - 1;
      } else if ((mid * mid) &lt; num) {
        start = mid + 1;
      } else {
        return mid;
      }
    }
    double incr = 0.1;
    for (int i = 0; i &lt; p; i++) {
      while (root * root &lt; num) {
        root = root + incr;
      }
      root = root - incr;
      incr = incr / 10;
    }
    return root;
  }
}
</code></pre>
<h2 id="media"><a class="header" href="#media">Media</a></h2>
<h3 id="capture-screen"><a class="header" href="#capture-screen">Capture Screen</a></h3>
<pre><code class="language-java">public class CaptureScreenSnippet {

  /**
   * Capture screenshot and save it to PNG file. Credits: https://viralpatel.net/blogs/how-to-take-screen-shots-in-java-taking-screenshots-java/
   *
   * @param filename the name of the file
   * @throws AWTException if the platform configuration does not allow low-level input control
   * @throws IOException  if an I/O error occurs
   */
  public static void captureScreen(String filename) throws AWTException, IOException {
    var screenSize = Toolkit.getDefaultToolkit().getScreenSize();
    var screenRectangle = new Rectangle(screenSize);
    var robot = new Robot();
    var image = robot.createScreenCapture(screenRectangle);
    ImageIO.write(image, &quot;png&quot;, new File(filename));
  }
}
</code></pre>
<h2 id="network"><a class="header" href="#network">Network</a></h2>
<h3 id="http-get"><a class="header" href="#http-get">HTTP GET</a></h3>
<pre><code class="language-java">public class HttpGetSnippet {

  /**
   * Performs HTTP GET request.
   *
   * @param uri the URI of the connection
   * @return response object
   * @throws Exception i/o error, interruption error, etc
   */
  public static HttpResponse&lt;String&gt; httpGet(String uri) throws Exception {
    var client = HttpClient.newHttpClient();
    var request = HttpRequest.newBuilder()
            .uri(URI.create(uri))
            .build();
    return client.send(request, HttpResponse.BodyHandlers.ofString());
  }
}
</code></pre>
<h3 id="http-post"><a class="header" href="#http-post">HTTP POST</a></h3>
<pre><code class="language-java">public class HttpPostSnippet {

  /**
   * Performs HTTP POST request. Credits https://stackoverflow.com/questions/3324717/sending-http-post-request-in-java
   *
   * @param address   the URL of the connection in String format, like &quot;http://www.google.com&quot;
   * @param arguments the body of the POST request, as a HashMap
   * @return response object
   * @throws IOException          if an I/O error occurs
   * @throws InterruptedException if the operation is interrupted
   */
  public static HttpResponse&lt;String&gt; httpPost(String address, HashMap&lt;String, String&gt; arguments)
          throws IOException, InterruptedException {
    var sj = new StringJoiner(&quot;&amp;&quot;);
    for (var entry : arguments.entrySet()) {
      sj.add(URLEncoder.encode(entry.getKey(), StandardCharsets.UTF_8) + &quot;=&quot;
              + URLEncoder.encode(entry.getValue(), StandardCharsets.UTF_8));
    }

    var out = sj.toString().getBytes(StandardCharsets.UTF_8);
    var request = HttpRequest.newBuilder()
            .uri(URI.create(address))
            .headers(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded; charset=UTF-8&quot;)
            .POST(HttpRequest.BodyPublishers.ofByteArray(out))
            .build();

    return HttpClient.newHttpClient().send(request, HttpResponse.BodyHandlers.ofString());
  }
}
</code></pre>
<h2 id="string"><a class="header" href="#string">String</a></h2>
<h3 id="anagram"><a class="header" href="#anagram">Anagram</a></h3>
<pre><code class="language-java">public class AnagramSnippet {

  /**
   * Checks if two words are anagrams (contains same characters with same frequency in any order).
   *
   * @param s1 The first string to be checked
   * @param s2 The second string to be checked
   * @return true if they are anagrams of each other
   */
  public static boolean isAnagram(String s1, String s2) {
    var l1 = s1.length();
    var l2 = s2.length();

    if (l1 != l2) {
      return false;
    }

    var arr1 = new int[256];
    var arr2 = new int[256];
    
    for (var i = 0; i &lt; l1; i++) {
      arr1[s1.charAt(i)]++;
      arr2[s2.charAt(i)]++;
    }
    return Arrays.equals(arr1, arr2);
  }
}
</code></pre>
<h3 id="common-letters"><a class="header" href="#common-letters">Common Letters</a></h3>
<pre><code class="language-java">public class CommonLettersSnippet {

  /**
   * Find Common Characters inside given two strings.
   *
   * @param firstStr  first string
   * @param secondStr second string
   * @return Common Characters.
   */
  public static String getCommonLetters(String firstStr, String secondStr) {
    Set&lt;String&gt; commonLetters = new HashSet&lt;&gt;();
    for (Character currentCharacter : firstStr.toCharArray()) {
      if (isCommonLetter(secondStr, currentCharacter)) {
        commonLetters.add(currentCharacter.toString());
      }
    }
    return String.join(&quot; &quot;, commonLetters);
  }

  private static boolean isCommonLetter(String str, Character character) {
    return str.contains(character.toString()) &amp;&amp; Character.isLetter(character);
  }
}
</code></pre>
<h3 id="compare-version"><a class="header" href="#compare-version">Compare Version</a></h3>
<pre><code class="language-java">public class CompareVersionSnippet {

  private static final String EXTRACT_VERSION_REGEX = &quot;.*?((?&lt;!\\w)\\d+([.-]\\d+)*).*&quot;;

  /**
   * Compares two version strings.
   * Credits: https://stackoverflow.com/a/6702000/6645088 and https://stackoverflow.com/a/44592696/6645088
   *
   * @param v1 the first version string to compare
   * @param v2 the second version string to compare
   * @return the value {@code 0} if the two strings represent same versions;
   *     a value less than {@code 0} if {@code v1} is greater than {@code v2}; and
   *     a value greater than {@code 0} if {@code v2} is greater than {@code v1}
   */
  public static int compareVersion(String v1, String v2) {
    var components1 = getVersionComponents(v1);
    var components2 = getVersionComponents(v2);
    int length = Math.max(components1.length, components2.length);
    for (int i = 0; i &lt; length; i++) {
      Integer c1 = i &lt; components1.length ? Integer.parseInt(components1[i]) : 0;
      Integer c2 = i &lt; components2.length ? Integer.parseInt(components2[i]) : 0;
      int result = c1.compareTo(c2);
      if (result != 0) {
        return result;
      }
    }
    return 0;
  }

  private static String[] getVersionComponents(String version) {
    return version.replaceAll(EXTRACT_VERSION_REGEX, &quot;$1&quot;).split(&quot;\\.&quot;);
  }
}
</code></pre>
<h3 id="duplicate-character"><a class="header" href="#duplicate-character">Duplicate Character</a></h3>
<pre><code class="language-java">public class DuplicateCharacterSnippet {

  /**
   * Remove Duplicate Characters from a string.
   *
   * @param str The string to be processed
   * @return A string with no duplicate characters
   */

  public static String removeDuplicateCharacters(String str) {
    char[] charsOfStr = str.toCharArray();
    Set&lt;String&gt; uniqueCharacters = new HashSet&lt;&gt;();
    for (char character : charsOfStr) {
      uniqueCharacters.add(String.valueOf(character));
    }
    return String.join(&quot;&quot;, uniqueCharacters);
  }
}
</code></pre>
<h3 id="levenshtein-distance"><a class="header" href="#levenshtein-distance">Levenshtein Distance</a></h3>
<pre><code class="language-java">public class LevenshteinDistanceSnippet {

  /**
   * Find the Levenshtein distance between two words. https://en.wikipedia.org/wiki/Levenshtein_distance
   *
   * @param word1 first word
   * @param word2 second word
   * @return distance
   */
  public static int findLevenshteinDistance(String word1, String word2) {
    // If word2 is empty, removing
    int[][] ans = new int[word1.length() + 1][word2.length() + 1];
    for (int i = 0; i &lt;= word1.length(); i++) {
      ans[i][0] = i;
    }
    // if word1 is empty, adding
    for (int i = 0; i &lt;= word2.length(); i++) {
      ans[0][i] = i;
    }
    // None is empty
    for (int i = 1; i &lt;= word1.length(); i++) {
      for (int j = 1; j &lt;= word2.length(); j++) {
        int min = Math.min(Math.min(ans[i][j - 1], ans[i - 1][j]), ans[i - 1][j - 1]);
        ans[i][j] = word1.charAt(i - 1) == word2.charAt(j - 1) ? ans[i - 1][j - 1] : min + 1;
      }
    }
    return ans[word1.length()][word2.length()];
  }
}
</code></pre>
<h3 id="lindenmayer-system"><a class="header" href="#lindenmayer-system">Lindenmayer System</a></h3>
<pre><code class="language-java">public class LindenmayerSystemSnippet {
  /**
   * Generates an L-system string based on axiom, production rules, and a number of iterations.
   *
   * @param axiom           initial string to begin the L-system
   * @param productionRules map of character rules where each symbol can be replaced with a string
   * @param iterations      number of iterations to apply the production rules
   * @return the generated string after all iterations
   */
  public static String generateLindenmayerSystem(
          String axiom,
          Map&lt;Character, String&gt; productionRules,
          int iterations
  ) {
    String current = axiom;

    for (int i = 0; i &lt; iterations; i++) {
      StringBuilder nextIteration = new StringBuilder(current.length() * 2);

      // Replace each symbol with the corresponding production rule or the symbol itself
      current.chars()
          .mapToObj(c -&gt; (char) c)
          .forEach(symbol -&gt;
                  nextIteration.append(
                          productionRules.getOrDefault(symbol, String.valueOf(symbol))
                  )
          );

      current = nextIteration.toString();
    }
    return current;
  }
}
</code></pre>
<h3 id="max-character-count"><a class="header" href="#max-character-count">Max Character Count</a></h3>
<pre><code class="language-java">public class MaxCharacterCountSnippet {

  /**
   * The maximum count of times a specific character appears in a string.
   *
   * @param str َA specific string
   * @param character A specific character
   * @return the maximum count of one character
   */

  public static int getMaxCharacterCount(String str, char character) {
    int characterCount = 0;
    int maxCharacterCount = 0;
    for (int i = 0; i &lt; str.length(); i++) {
      if ((str.charAt(i)) == character) {
        characterCount++;
        maxCharacterCount = Math.max(maxCharacterCount, characterCount);
      } else {
        characterCount = 0;
      }
    }
    return maxCharacterCount;
  }
}
</code></pre>
<h3 id="palindrome-check"><a class="header" href="#palindrome-check">Palindrome Check</a></h3>
<pre><code class="language-java">public class PalindromCheckSnippet {

  /**
   * Checks if given string is palindrome (same forward and backward). Skips non-letter characters
   * Credits: https://github.com/kousen/java_8_recipes
   *
   * @param s string to check
   * @return true if palindrome
   */
  public static boolean isPalindrome(String s) {
    for (int i = 0, j = s.length() - 1; i &lt; j; i++, j--) {
      while (i &lt; j &amp;&amp; !Character.isLetter(s.charAt(i))) {
        i++;
      }
      while (i &lt; j &amp;&amp; !Character.isLetter(s.charAt(j))) {
        j--;
      }

      if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) {
        return false;
      }
    }

    return true;
  }
}
</code></pre>
<h3 id="reverse-string"><a class="header" href="#reverse-string">Reverse String</a></h3>
<pre><code class="language-java">public class ReverseStringSnippet {

  /**
   * Reverse string.
   *
   * @param s the string to reverse
   * @return reversed string
   */
  public static String reverseString(String s) {
    return new StringBuilder(s).reverse().toString();
  }
}
</code></pre>
<h3 id="string-to-date"><a class="header" href="#string-to-date">String To Date</a></h3>
<pre><code class="language-java">public class StringToDateSnippet {

  /**
   * Convert string to date.
   *
   * @param date   the date string
   * @param format expected date format
   * @return Date
   * @throws ParseException in case of an unparseable date string
   */
  public static Date stringToDate(String date, String format) throws ParseException {
    var simpleDateFormat = new SimpleDateFormat(format);
    return simpleDateFormat.parse(date);
  }
}
</code></pre>
<h3 id="kmp-substring-search-algorithm"><a class="header" href="#kmp-substring-search-algorithm">KMP Substring Search Algorithm</a></h3>
<pre><code class="language-java">public class KMPSubstringSearchSnippet {

    /**
     * Implements the Knuth-Morris-Pratt (KMP) algorithm to find the index of the first occurrence of a substring in a given text.
     *
     * @param text The text in which the substring is to be searched.
     * @param pattern The substring pattern to search for.
     * @return The index of the first occurrence of the pattern in the text, or -1 if the pattern is not found.
     */
    public static int kmpSearch(String text, String pattern) {
        if (pattern == null || pattern.length() == 0) {
            return 0; // Trivial case: empty pattern
        }

        int[] lps = computeLPSArray(pattern);
        int i = 0; // index for text
        int j = 0; // index for pattern

        while (i &lt; text.length()) {
            if (pattern.charAt(j) == text.charAt(i)) {
                i++;
                j++;
            }

            if (j == pattern.length()) {
                return i - j; // Found pattern at index (i - j)
            } else if (i &lt; text.length() &amp;&amp; pattern.charAt(j) != text.charAt(i)) {
                if (j != 0) {
                    j = lps[j - 1]; // Use the LPS array to skip characters
                } else {
                    i++; // If no match and j is 0, move to the next character in text
                }
            }
        }
        return -1; // Pattern not found
    }

    /**
     * Computes the LPS (Longest Prefix Suffix) array for the pattern, which indicates the longest proper prefix which is also a suffix.
     *
     * @param pattern The pattern for which the LPS array is to be computed.
     * @return The LPS array.
     */
    private static int[] computeLPSArray(String pattern) {
        int length = 0;
        int i = 1;
        int[] lps = new int[pattern.length()];
        lps[0] = 0; // LPS for the first character is always 0

        while (i &lt; pattern.length()) {
            if (pattern.charAt(i) == pattern.charAt(length)) {
                length++;
                lps[i] = length;
                i++;
            } else {
                if (length != 0) {
                    length = lps[length - 1]; // Fall back to the previous LPS value
                } else {
                    lps[i] = 0;
                    i++;
                }
            }
        }
        return lps;
    }
}
</code></pre>
<h2 id="thread"><a class="header" href="#thread">Thread</a></h2>
<h3 id="thread-pool"><a class="header" href="#thread-pool">Thread Pool</a></h3>
<h3 id="thread-1"><a class="header" href="#thread-1">Thread</a></h3>
<pre><code class="language-java">public class ThreadSnippet {

  /**
   * Creates and returns a new thread with the task assigned to it (task will be performed parallel to the main thread).
   *
   * @param task the task to be executed by this thread
   * @return new thread with task assigned to it.
   */
  public static Thread createThread(Runnable task) {
    return new Thread(task);
  }
}
</code></pre>
<pre><code class="language-java">public class ThreadPool {

  /**
   * &lt;p&gt;Creates pool of threads. Where the pool is the size of the number of processors
   * available to the Java virtual machine.&lt;/p&gt;
   *
   * @return the newly created thread pool
   */
  public static ExecutorService createFixedThreadPool() {
    return Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());
  }
}
</code></pre>
<h3 id="damm-algorithm"><a class="header" href="#damm-algorithm">Damm Algorithm</a></h3>
<pre><code class="language-java">public class DammSnippet {

  /**
   * Private constructor to prevent instantiation of utility class.
   */
  private DammSnippet() {
    throw new UnsupportedOperationException(&quot;Utility class - instantiation is not allowed.&quot;);
  }
  private static final int[][] matrix = new int[][] {
          { 0, 3, 1, 7, 5, 9, 8, 6, 4, 2 },
          { 7, 0, 9, 2, 1, 5, 4, 8, 6, 3 },
          { 4, 2, 0, 6, 8, 7, 1, 3, 5, 9 },
          { 1, 7, 5, 0, 9, 8, 3, 4, 2, 6 },
          { 6, 1, 2, 3, 0, 4, 5, 9, 7, 8 },
          { 3, 6, 7, 4, 2, 0, 9, 5, 8, 1 },
          { 5, 8, 6, 9, 7, 2, 0, 1, 3, 4 },
          { 8, 9, 4, 5, 3, 6, 2, 0, 1, 7 },
          { 9, 4, 3, 8, 6, 1, 7, 2, 0, 5 },
          { 2, 5, 8, 1, 4, 3, 6, 7, 9, 0 }
  };
  public static int calculateCheckSumDigit(String number) {
    if (number == null || number.isEmpty()) {
      throw new IllegalArgumentException(&quot;Input number cannot be null or empty.&quot;);
    }

    int interim = 0;
    for (int index = 0; index &lt; number.length(); index++) {
      char currCh = number.charAt(index);
      if (!Character.isDigit(currCh)) {
        throw new IllegalArgumentException(&quot;Input number contains invalid characters: &quot; + number);
      }

      int currentIndex = currCh - '0';
      interim = matrix[interim][currentIndex];
    }

    return interim;
  }
  public static int calculateCheckSumDigit(int number) {
    return calculateCheckSumDigit(String.valueOf(number));
  }
  public static int calculateCheckSumDigit(long number) {
    return calculateCheckSumDigit(String.valueOf(number));
  }
  public static String generateCheckSum(String number) {
    int checkSumDigit = calculateCheckSumDigit(number);
    return number + checkSumDigit;
  }
  public static int generateCheckSum(int number) {
    int checkSumDigit = calculateCheckSumDigit(number);
    return (number * 10) + checkSumDigit;
  }
  public static long generateCheckSum(long number) {
    int checkSumNumber = calculateCheckSumDigit(number);
    return (number * 10) + checkSumNumber;
  }
  public static boolean validate(String number) {
    return calculateCheckSumDigit(number) == 0;
  }
  public static boolean validate(int number) {
    return calculateCheckSumDigit(number) == 0;
  }
  public static boolean validate(long number) {
    return calculateCheckSumDigit(number) == 0;
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="binarysearchin2darraysnippet"><a class="header" href="#binarysearchin2darraysnippet">BinarySearchIn2dArraySnippet</a></h3>
<pre><code class="language-java">package algorithm;

/**
 * BinarySearchIn2dArraySnippet.
 */
public class BinarySearchIn2dArraySnippet {

  /**
  * Search an item with binarySearch algorithm.
  *
  * @param matrix should be sorted
  * @param target an item to search
  * @return if location of item is found, otherwise return {-1,-1}
  */
  public static int[] binarySearchIn2darr(int[][] matrix, int target) {
    int rows = matrix.length - 1;
    int cols = matrix[0].length - 1;

    if (rows == 1) {
      return binarySearch(matrix, target, 0, 0, cols);
    }

    int rstart = 0;
    int rend = rows;
    int cmid = cols / 2;

    while (rstart &lt; rend - 1) {
      int rmid = rstart + (rend - rstart) / 2;
      if (matrix[rmid][cmid] &gt; target) {
        rend = rmid;
      } else if (matrix[rmid][cmid] &lt; target) {
        rstart = rmid;
      } else {
        return new int[]{rmid, cmid};
      }
    }
    if (matrix[rstart][cmid] == target) {
      return new int[]{rstart, cmid};
    }
    if (matrix[rend][cmid] == target) {
      return new int[]{rend, cmid};
    }
    if (target &lt;= matrix[rstart][cmid - 1]) {
      return binarySearch(matrix, target, rstart, 0, cmid - 1);
    }
    if (target &gt;= matrix[rstart][cmid + 1]) {
      return binarySearch(matrix, target, rstart, cmid + 1, cols);
    }
    if (target &lt;= matrix[rend][cmid - 1]) {
      return binarySearch(matrix, target, rend, 0, cmid - 1);
    }
    if (target &lt;= matrix[rend][cmid + 1]) {
      return binarySearch(matrix, target, rend, cmid + 1, cols);
    }
    return new int[]{-1, -1};
  }

  static int[] binarySearch(int[][] matrix, int target, int row, int cstart, int cend) {
    while (cstart &lt;= cend) {
      int cmid = cstart + (cend - cstart) / 2;
      if (matrix[row][cmid] &gt; target) {
        cend = cmid - 1;
      } else if (matrix[row][cmid] &lt; target) {
        cstart = cend + 1;
      } else {
        return new int[]{row, cmid};
      }
    }
    return new int[]{-1, -1};
  }
}
</code></pre>
<h3 id="binarysearchsnippet"><a class="header" href="#binarysearchsnippet">BinarySearchSnippet</a></h3>
<pre><code class="language-java">package algorithm;

/**
 * BinarySearchSnippet.
 */
public class BinarySearchSnippet {

  /**
   * Search an item with binarySearch algorithm.
   *
   * @param arr sorted array to search
   * @param item an item to search
   * @return if item is found, return the index position of the array item otherwise return -1
   */

  public static int binarySearch(int[] arr, int left, int right, int item) {
    if (right &gt;= left) {
      int mid = left + (right - left) / 2;
      if (arr[mid] == item) {
        return mid;
      }

      if (arr[mid] &gt; item) {
        return binarySearch(arr, left, mid - 1, item);
      }

      return binarySearch(arr, mid + 1, right, item);
    }
    return -1;
  }
}
</code></pre>
<h3 id="bubblesortsnippet"><a class="header" href="#bubblesortsnippet">BubbleSortSnippet</a></h3>
<pre><code class="language-java">package algorithm;

/**
 * BubbleSortSnippet.
 */
public class BubbleSortSnippet {

  /**
   * Sort an array with bubbleSort algorithm.
   *
   * @param arr array to sort
   */
  public static void bubbleSort(int[] arr) {
    var lastIndex = arr.length - 1;

    for (var j = 0; j &lt; lastIndex; j++) {
      for (var i = 0; i &lt; lastIndex - j; i++) {
        if (arr[i] &gt; arr[i + 1]) {
          var tmp = arr[i];
          arr[i] = arr[i + 1];
          arr[i + 1] = tmp;
        }
      }
    }
  }
}
</code></pre>
<h3 id="countingsortsnippet"><a class="header" href="#countingsortsnippet">CountingSortSnippet</a></h3>
<pre><code class="language-java">package algorithm;

import java.util.Arrays;

/**
 * CountingSortSnippet.
 */
public class CountingSortSnippet {

  /**
   * Sort an array having zero or positive numbers with countingSort algorithm.
   *
   * @param arr array to sort
   */
  public static void countingSort(int[] arr) {
    var max = Arrays.stream(arr).max().getAsInt();

    var count = new int[max + 1];

    for (var num : arr) {
      count[num]++;
    }

    for (var i = 1; i &lt;= max; i++) {
      count[i] += count[i - 1];
    }

    var sorted = new int[arr.length];
    for (var i = arr.length - 1; i &gt;= 0; i--) {
      var cur = arr[i];
      sorted[count[cur] - 1] = cur;
      count[cur]--;
    }

    var index = 0;
    for (var num : sorted) {
      arr[index++] = num;
    }
  }
}
</code></pre>
<h3 id="cyclesortsnippet"><a class="header" href="#cyclesortsnippet">CycleSortSnippet</a></h3>
<pre><code class="language-java">package algorithm;

/**
 * CycleSortSnippet.
 */
public class CycleSortSnippet {

  /**
   * Sort an array with cycleSort algorithm.
   *
   * @param arr array to sort
   */
  public static int[] cycleSort(int[] arr) {
    int n = arr.length;
    int i = 0;
    while (i &lt; n) {
      int correctpos = arr[i] - 1;
      if (arr[i] != arr[correctpos]) {
        int temp = arr[i];
        arr[i] = arr[correctpos];
        arr[correctpos] = temp;
      } else {
        i++;
      }
    }
    return arr;
  }
}
</code></pre>
<h3 id="dammsnippet"><a class="header" href="#dammsnippet">DammSnippet</a></h3>
<pre><code class="language-java">package algorithm;

/**
 * The implementation of the Damm algorithm based on the details on
 * &lt;a href=&quot;https://en.wikipedia.org/wiki/Damm_algorithm&quot;&gt;Wikipedia&lt;/a&gt;.
 *
 * &lt;p&gt;The Damm algorithm is used for error detection and generates a checksum
 * that can detect single-digit errors and adjacent transposition errors.&lt;/p&gt;
 *
 */
public class DammSnippet {

  /**
   * Private constructor to prevent instantiation of utility class.
   */
  private DammSnippet() {
    throw new UnsupportedOperationException(&quot;Utility class - instantiation is not allowed.&quot;);
  }

  /**
   * The quasigroup table used by the Damm algorithm.
   */
  private static final int[][] matrix = new int[][] {
          { 0, 3, 1, 7, 5, 9, 8, 6, 4, 2 },
          { 7, 0, 9, 2, 1, 5, 4, 8, 6, 3 },
          { 4, 2, 0, 6, 8, 7, 1, 3, 5, 9 },
          { 1, 7, 5, 0, 9, 8, 3, 4, 2, 6 },
          { 6, 1, 2, 3, 0, 4, 5, 9, 7, 8 },
          { 3, 6, 7, 4, 2, 0, 9, 5, 8, 1 },
          { 5, 8, 6, 9, 7, 2, 0, 1, 3, 4 },
          { 8, 9, 4, 5, 3, 6, 2, 0, 1, 7 },
          { 9, 4, 3, 8, 6, 1, 7, 2, 0, 5 },
          { 2, 5, 8, 1, 4, 3, 6, 7, 9, 0 }
  };

  /**
   * Calculates the Damm checksum digit for the given number.
   *
   * @param number the input number as a string
   * @return the calculated checksum digit
   * @throws IllegalArgumentException if the input is null, empty, or contains non-digit characters
   */
  public static int calculateCheckSumDigit(String number) {
    if (number == null || number.isEmpty()) {
      throw new IllegalArgumentException(&quot;Input number cannot be null or empty.&quot;);
    }

    int interim = 0;
    for (int index = 0; index &lt; number.length(); index++) {
      char currCh = number.charAt(index);
      if (!Character.isDigit(currCh)) {
        throw new IllegalArgumentException(&quot;Input number contains invalid characters: &quot; + number);
      }

      int currentIndex = currCh - '0';
      interim = matrix[interim][currentIndex];
    }

    return interim;
  }

  /**
   * Calculates the Damm checksum digit for the given number.
   *
   * @param number the input number as an integer
   * @return the calculated checksum digit
   */
  public static int calculateCheckSumDigit(int number) {
    return calculateCheckSumDigit(String.valueOf(number));
  }

  /**
   * Calculates the Damm checksum digit for the given number.
   *
   * @param number the input number as a long
   * @return the calculated checksum digit
   */
  public static int calculateCheckSumDigit(long number) {
    return calculateCheckSumDigit(String.valueOf(number));
  }

  /**
   * Appends the calculated checksum digit to the given number as a string.
   *
   * @param number the input number as a string
   * @return the original number with the checksum digit appended
   * @throws IllegalArgumentException if the input is null, empty, or contains non-digit characters
   */
  public static String generateCheckSum(String number) {
    int checkSumDigit = calculateCheckSumDigit(number);
    return number + checkSumDigit;
  }

  /**
   * Appends the calculated checksum digit to the given number as an integer.
   *
   * @param number the input number as an integer
   * @return the original number with the checksum digit appended
   */
  public static int generateCheckSum(int number) {
    int checkSumDigit = calculateCheckSumDigit(number);
    return (number * 10) + checkSumDigit;
  }

  /**
   * Appends the calculated checksum digit to the given number as a long.
   *
   * @param number the input number as a long
   * @return the original number with the checksum digit appended
   */
  public static long generateCheckSum(long number) {
    int checkSumNumber = calculateCheckSumDigit(number);
    return (number * 10) + checkSumNumber;
  }

  /**
   * Validates the given number by checking if the checksum digit is correct.
   *
   * @param number the input number as a string
   * @return {@code true} if the number is valid, {@code false} otherwise
   * @throws IllegalArgumentException if the input is null, empty, or contains non-digit characters
   */
  public static boolean validate(String number) {
    return calculateCheckSumDigit(number) == 0;
  }

  /**
   * Validates the given number by checking if the checksum digit is correct.
   *
   * @param number the input number as an integer
   * @return {@code true} if the number is valid, {@code false} otherwise
   */
  public static boolean validate(int number) {
    return calculateCheckSumDigit(number) == 0;
  }

  /**
   * Validates the given number by checking if the checksum digit is correct.
   *
   * @param number the input number as a long
   * @return {@code true} if the number is valid, {@code false} otherwise
   */
  public static boolean validate(long number) {
    return calculateCheckSumDigit(number) == 0;
  }
}
</code></pre>
<h3 id="insertionsortsnippet"><a class="header" href="#insertionsortsnippet">InsertionSortSnippet</a></h3>
<pre><code class="language-java">package algorithm;

/**
 * InsertionSortSnippet.
 */
public class InsertionSortSnippet {

  /**
   * Sort an array with insertionSort algorithm.
   *
   * @param arr array to sort
   */
  public static void insertionSort(int[] arr) {
    for (var i = 1; i &lt; arr.length; i++) {
      var tmp = arr[i];
      var j = i - 1;

      while (j &gt;= 0 &amp;&amp; arr[j] &gt; tmp) {
        arr[j + 1] = arr[j];
        j--;
      }
      arr[j + 1] = tmp;
    }
  }
}
</code></pre>
<h3 id="linearsearchin2darraysnippet"><a class="header" href="#linearsearchin2darraysnippet">LinearSearchIn2dArraySnippet</a></h3>
<pre><code class="language-java">package algorithm;

/**
 * LinearSearchIn2dArraySnippet.
 */
public class LinearSearchIn2dArraySnippet {

  /**
   * Search an item with linearSearch algorithm.
   *
   * @param arr    array to search
   * @param target an item to search
   * @return if location of target is found,otherwise return {-1,-1}
   */

  public static int[] linearSearch2dArray(int[][] arr, int target) {

    for (int i = 0; i &lt; arr.length; i++) {
      for (int j = 0; j &lt; arr[i].length; j++) {
        if (arr[i][j] == target) {
          return new int[]{i, j};
        }
      }
    }
    return new int[]{-1, -1};
  }
}
</code></pre>
<h3 id="linearsearchsnippet"><a class="header" href="#linearsearchsnippet">LinearSearchSnippet</a></h3>
<pre><code class="language-java">package algorithm;

/**
 * LinearSearchSnippet.
 */
public class LinearSearchSnippet {

  /**
   * Search an item with linearSearch algorithm.
   *
   * @param arr array to search
   * @param item an item to search
   * @return if item is found, return the index position of the array item otherwise return -1
   */
  public static int linearSearch(int[] arr, int item) {
    for (int i = 0; i &lt; arr.length; i++) {
      if (item == arr[i]) {
        return i;
      }
    }
    return -1;
  }
}
</code></pre>
<h3 id="luhnmodnsnippet"><a class="header" href="#luhnmodnsnippet">LuhnModnSnippet</a></h3>
<pre><code class="language-java">package algorithm;

/**
 * LuhnModnSnippet.
 */
public class LuhnModnSnippet {

  private static final String CODE_POINTS = &quot;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;;

  /**
   * Generates a check character using the Luhn mod N algorithm.
   *
   * @param character the input string consisting of valid alphanumeric characters
   * @return the generated check character
   * @throws IllegalArgumentException if the input contains invalid characters
   */
  public static int codePointFromCharacter(char character) {
    if (CODE_POINTS.indexOf(character) == -1) {
      throw new IllegalArgumentException(&quot;Invalid character: &quot; + character);
    }
    return CODE_POINTS.indexOf(character);
  }

  /**
   * Converts a code point to its corresponding character.
   *
   * @param codePoint the code point to be converted
   * @return the character representation of the code point
   * @throws IllegalArgumentException if the code point is out of range.
   */
  public static char characterFromCodePoint(int codePoint) {
    if (codePoint &lt; 0 || codePoint &gt;= CODE_POINTS.length()) {
      throw new IllegalArgumentException(&quot;Invalid code point: &quot; + codePoint);
    }
    return CODE_POINTS.charAt(codePoint);
  }

  public static int numberOfValidInputCharacters() {
    return CODE_POINTS.length();
  }

  /**
   * Helper method to calculate the sum for both check character generation and validation.
   *
   * @param input the input string
   * @param factorStart the initial factor to start with (1 or 2)
   * @return the calculated sum, reminder, and the numberOfValidInputCharacters
   */
  private static int[] calculateSum(String input, int factorStart) {
    if (input == null || input.isEmpty()) {
      throw new IllegalArgumentException(&quot;Input cannot be empty&quot;);
    }

    int factor = factorStart;
    int sum = 0;
    int n = numberOfValidInputCharacters();

    for (int i = input.length() - 1; i &gt;= 0; i--) {
      int codePoint = codePointFromCharacter(input.charAt(i));
      int addend = factor * codePoint;
      factor = (factor == 2) ? 1 : 2;
      addend = (addend / n) + (addend % n);
      sum += addend;
    }
    return new int[]{sum, sum % n, n};
  }

  /**
   * Generates a check character for the given input string using the Luhn mod N algorithm.
   *
   * @param input the input string (non-empty)
   * @return the generated check character
   * @throws IllegalArgumentException if the input is null or empty
   */
  public static char generateCheckCharacter(String input) {
    int[] result = calculateSum(input, 2);
    return characterFromCodePoint((result[2] - result[1]) % result[2]);
  }

  /**
   * Validates a check character by applying the Luhn mod N algorithm.
   *
   * @param input the input string (including the check character)
   * @return true if the input passes validation, false otherwise
   * @throws IllegalArgumentException if the input is null or empty
   */
  public static boolean validateCheckCharacter(String input) {
    int[] result = calculateSum(input, 1);
    return (result[1] == 0);
  }
}
</code></pre>
<h3 id="mergesortsnippet"><a class="header" href="#mergesortsnippet">MergeSortSnippet</a></h3>
<pre><code class="language-java">package algorithm;

/**
 * MergeSortSnippet.
 */
public class MergeSortSnippet {  
  /**
     * Sort an array with qmergesort algorithm.
     *
     * @param arr   array to sort
     * @low low index where to begin sort (e.g. 0)
     * @high high index where to end sort (e.g. array length - 1)
     */

  public static void mergeSort(int[] arr, int low, int high) {
    if (low &gt;= high) {
      return;
    }
    var mid = (low + high) / 2;
    mergeSort(arr, low, mid);
    mergeSort(arr, mid + 1, high);
    merge(arr, low, high, mid);
  }

  private static void merge(int[] arr, int low, int high, int mid) {
    int[] temp = new int[(high - low + 1)];
    var i = low;
    var j = mid + 1;
    var k = 0;

    while (i &lt;= mid &amp;&amp; j &lt;= high) {
      if (arr[i] &lt; arr[j]) {
        temp[k++] = arr[i];
        i++;
      } else {
        temp[k++] = arr[j];
        j++;
      }
    }

    while (i &lt;= mid) {
      temp[k++] = arr[i];
      i++;
    }

    while (j &lt;= high) {
      temp[k++] = arr[j];
      j++;
    }

    for (int m = 0, n = low; m &lt; temp.length; m++, n++) {
      arr[n] = temp[m];
    }
  }
}
</code></pre>
<h3 id="quicksortsnippet"><a class="header" href="#quicksortsnippet">QuickSortSnippet</a></h3>
<pre><code class="language-java">package algorithm;

/**
 * QuickSortSnippet.
 */
public class QuickSortSnippet {

  /**
   * Sort an array with quicksort algorithm.
   *
   * @param arr   array to sort
   * @param left  left index where to begin sort (e.g. 0)
   * @param right right index where to end sort (e.g. array length - 1)
   */
  public static void quickSort(int[] arr, int left, int right) {
    var pivotIndex = left + (right - left) / 2;
    var pivotValue = arr[pivotIndex];
    var i = left;
    var j = right;
    while (i &lt;= j) {
      while (arr[i] &lt; pivotValue) {
        i++;
      }
      while (arr[j] &gt; pivotValue) {
        j--;
      }
      if (i &lt;= j) {
        var tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
        i++;
        j--;
      }
      if (left &lt; i) {
        quickSort(arr, left, j);
      }
      if (right &gt; i) {
        quickSort(arr, i, right);
      }
    }
  }
}
</code></pre>
<h3 id="selectionsortsnippet"><a class="header" href="#selectionsortsnippet">SelectionSortSnippet</a></h3>
<pre><code class="language-java">package algorithm;

/**
 * SelectionSortSnippet.
 */
public class SelectionSortSnippet {

  /**
   * Sort an array with selectionSort algorithm.
   *
   * @param arr array to sort
   */
  public static void selectionSort(int[] arr) {
    var len = arr.length;

    for (var i = 0; i &lt; len - 1; i++) {
      var minIndex = i;

      for (var j = i + 1; j &lt; len; j++) {
        if (arr[j] &lt; arr[minIndex]) {
          minIndex = j;
        }
      }

      var tmp = arr[minIndex];
      arr[minIndex] = arr[i];
      arr[i] = tmp;
    }
  }
}
### SieveOfEratosthenesSnippet

```java
package algorithm;

/**
 * SieveOfEratosthenesSnippet.
 */
public class SieveOfEratosthenesSnippet {
  /**
   * Search an item with binarySearch algorithm.
   *
   * @param n range of number.
   * @return isPrime boolean array where prime number 0 to n are mark true.
   */
  public static boolean[] sieveOfEratosthenes(int n) {
    boolean[] isPrime = new boolean[n + 1];
    for (int i = 0; i &lt; isPrime.length; i++) {
      isPrime[i] = true;
    }

    for (int i = 2; i * i &lt;= n; i++) {
      if (isPrime[i] == true) {
        for (int j = i * i; j &lt;= n; j += i) {
          isPrime[j] = false;
        }
      }
    }

    return isPrime;
  }
}
</code></pre>
<h3 id="verhoeffsnippet"><a class="header" href="#verhoeffsnippet">VerhoeffSnippet</a></h3>
<pre><code class="language-java">package algorithm;

/**
 * VerhoeffSnippet.
 */
public class VerhoeffSnippet {

  private static final int[][] d = {
          {0, 1, 2, 3, 4, 5, 6, 7, 8, 9},
          {1, 0, 3, 2, 5, 4, 7, 6, 9, 8},
          {2, 3, 0, 1, 6, 7, 4, 5, 8, 9},
          {3, 2, 1, 0, 7, 6, 5, 4, 9, 8},
          {4, 5, 6, 7, 0, 1, 2, 3, 8, 9},
          {5, 4, 7, 6, 1, 0, 3, 2, 9, 8},
          {6, 7, 4, 5, 2, 3, 0, 1, 8, 9},
          {7, 6, 5, 4, 3, 2, 1, 0, 9, 8},
          {8, 9, 8, 9, 8, 9, 8, 9, 0, 1},
          {9, 8, 9, 8, 9, 8, 9, 8, 1, 0}
  };

  private static final int[][] p = {
          {0, 1, 2, 3, 4, 5, 6, 7, 8, 9},
          {1, 5, 7, 6, 2, 8, 3, 0, 9, 4},
          {5, 8, 0, 3, 7, 9, 6, 1, 4, 2},
          {8, 9, 1, 6, 0, 4, 3, 5, 2, 7},
          {9, 4, 5, 3, 1, 2, 6, 8, 7, 0},
          {4, 2, 8, 6, 5, 7, 3, 9, 0, 1},
          {2, 7, 9, 3, 8, 0, 6, 4, 1, 5},
          {7, 0, 4, 6, 9, 1, 3, 2, 5, 8}
  };

  private static final int[] inv = {0, 4, 3, 2, 1, 5, 6, 7, 8, 9};

  /**
   * Validates a number using the Verhoeff checksum algorithm.
   *
   * @param num the numeric string to validate
   * @return true if the number is valid according to Verhoeff algorithm, false otherwise
   */
  public static boolean validateVerhoeff(String num) {
    int c = 0;
    int length = num.length();

    // Adjust index for validation of the full number (including check digit)
    for (int i = 0; i &lt; length; i++) {
      int digit = Character.getNumericValue(num.charAt(length - i - 1));
      c = d[c][p[(i + 1) % 8][digit]]; // Correct permutation index
    }

    return c == 0; // Final checksum must be zero
  }

  /**
   * Generates a Verhoeff check digit for a given numeric string.
   *
   * @param num the numeric string for which to generate the check digit
   * @return the generated Verhoeff check digit as a string
   */
  public static String generateVerhoeff(String num) {
    int c = 0;
    int length = num.length();

    for (int i = 0; i &lt; length; i++) {
      int digit = Character.getNumericValue(num.charAt(length - i - 1));
      c = d[c][p[(i % 8)][digit]];
    }

    return Integer.toString(inv[c]);
  }

}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="array-1"><a class="header" href="#array-1">Array</a></h1>
<h3 id="allequalsnippet"><a class="header" href="#allequalsnippet">AllEqualSnippet</a></h3>
<pre><code class="language-java">package array;

import java.util.Arrays;

/**
 * AllEqualSnippet.
 */
public class AllEqualSnippet {

  /**
   * Returns true if all elements in array are equal.
   *
   * @param arr the array to check (not null)
   * @param &lt;T&gt; the element type
   * @return true if all elements in the array are equal
   */
  public static &lt;T&gt; boolean allEqual(T[] arr) {
    return Arrays.stream(arr).distinct().count() == 1;
  }
}
</code></pre>
<h3 id="arrayconcatsnippet"><a class="header" href="#arrayconcatsnippet">ArrayConcatSnippet</a></h3>
<pre><code class="language-java">package array;

import java.util.Arrays;

/**
 * ArrayConcatSnippet.
 */
public class ArrayConcatSnippet {

  /**
   * Generic 2 array concatenation Credits: Joachim Sauer https://stackoverflow.com/questions/80476/how-can-i-concatenate-two-arrays-in-java
   *
   * @param first  is the first array (not null)
   * @param second is the second array (not null)
   * @param &lt;T&gt;    the element type
   * @return concatenated array
   */
  public static &lt;T&gt; T[] arrayConcat(T[] first, T[] second) {
    var result = Arrays.copyOf(first, first.length + second.length);
    System.arraycopy(second, 0, result, first.length, second.length);
    return result;
  }
}
</code></pre>
<h3 id=""><a class="header" href="#"></a></h3>
<pre><code class="language-java">package array;

import java.util.Arrays;

/**
 * ArrayMeanSnippet.
 */
public class ArrayMeanSnippet {

  /**
   * Returns the mean of the integers in the array.
   *
   * @param arr the array of integers (not null)
   * @return a double representing the mean of the array
   */
  public static double arrayMean(int[] arr) {
    return (double) Arrays.stream(arr).sum() / arr.length;
  }
}
</code></pre>
<h3 id="arraymediansnippet"><a class="header" href="#arraymediansnippet">ArrayMedianSnippet</a></h3>
<pre><code class="language-java">package array;

import java.util.Arrays;

/**
 * ArrayMedianSnippet.
 */
public class ArrayMedianSnippet {

  /**
   * Returns the median of the array.
   *
   * @param arr the array of integers (not null)
   * @return a double representing the median of the array
   */
  public static double arrayMedian(int[] arr) {
    Arrays.sort(arr);
    var mid = arr.length / 2;
    return arr.length % 2 != 0 ? (double) arr[mid] : (double) (arr[mid] + arr[mid - 1]) / 2;
  }
}
</code></pre>
<h3 id="arraymodesnippet"><a class="header" href="#arraymodesnippet">ArrayModeSnippet</a></h3>
<pre><code class="language-java">package array;

import java.util.Arrays;

/**
 * ArrayModeSnippet.
 */
public class ArrayModeInPlaceSnippet {

  /**
  * Returns the mode of the array.
  *
  * @param arr array to find mode in it
  * @return mode of array
  */
  public static int modeArrayInPlace(int[] arr) {
    if (arr.length == 0) {
      return 0;
    }

    Arrays.sort(arr);

    int mode = arr[0];
    int maxcount = 1;
    int count = 1;

    for (int i = 1; i &lt; arr.length; i++) {
      if (arr[i] == arr[i - 1]) {
        count++;
      } else {
        if (count &gt; maxcount) {
          maxcount = count;
          mode = arr[i - 1];
        }
        count = 1;
      }
    }
    if (count &gt; maxcount) {
      mode = arr[arr.length - 1];
    }
    return mode;
  }
}
</code></pre>
<h3 id="arraymodesnippet-1"><a class="header" href="#arraymodesnippet-1">ArrayModeSnippet</a></h3>
<pre><code class="language-java">package array;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
/**
 * ArrayModeSnippet.
 */

public class ArrayModeSnippet {

  /**
   * Private constructor to prevent instantiation.
   */
  private ArrayModeSnippet() {
    throw new IllegalStateException(&quot;Utility class&quot;);
  }

  /**
   * Returns the mode(s) of the array.
   * If multiple modes exist, it returns them in a list.
   */
  public static List&lt;Integer&gt; modeArray(int[] arr) {
    int maxCount = 0;
    HashMap&lt;Integer, Integer&gt; frequencyMap = new HashMap&lt;&gt;();
    for (int num : arr) {
      frequencyMap.put(num, frequencyMap.getOrDefault(num, 0) + 1);
      maxCount = Math.max(maxCount, frequencyMap.get(num));
    }
    List&lt;Integer&gt; modes = new ArrayList&lt;&gt;();
    for (Map.Entry&lt;Integer, Integer&gt; entry : frequencyMap.entrySet()) {
      if (entry.getValue() == maxCount) {
        modes.add(entry.getKey());
      }
    }
    return modes;
  }
}
</code></pre>
<h3 id="arraysumsnippet"><a class="header" href="#arraysumsnippet">ArraySumSnippet</a></h3>
<pre><code class="language-java">package array;

import java.util.Arrays;

/**
 * ArraySumSnippet.
 */
public class ArraySumSnippet {

  /**
   * Returns sum of the integers in the array.
   *
   * @param arr the array of integers (not null)
   * @return the sum of the elements from the array
   */
  public static int arraySum(int[] arr) {
    return Arrays.stream(arr).sum();
  }
}
</code></pre>
<h3 id="findmaxsnippet"><a class="header" href="#findmaxsnippet">FindMaxSnippet</a></h3>
<pre><code class="language-java">package array;

import java.util.Arrays;

/**
 * FindMaxSnippet.
 */
public class FindMaxSnippet {

  /**
   * Returns the maximum integer from the array using reduction.
   *
   * @param arr the array of integers (not null)
   * @return the maximum element from the array
   */
  public static int findMax(int[] arr) {
    return Arrays.stream(arr).reduce(Integer.MIN_VALUE, Integer::max);
  }
}
</code></pre>
<h3 id="findminsnippet"><a class="header" href="#findminsnippet">FindMinSnippet</a></h3>
<pre><code class="language-java">package array;

import java.util.Arrays;
 
/**
  * FindMinSnippet.
  */
public class FindMinSnippet {
 
  /**
    * Returns the minimum integer from the array using reduction.
    *
    * @param arr the array of integers (not null)
    * @return the minimum element from the array
    */
  public static int findMin(int[] arr) {
    return Arrays.stream(arr).reduce(Integer.MAX_VALUE, Integer::min);
  }
}
 
### MultiArrayConcatenationSnippet

```java
package array;

import java.util.Arrays;

/**
 * MultiArrayConcatenationSnippet.
 */
public class MultiArrayConcatenationSnippet {

  /**
   * Generic N array concatenation Credits: Joachim Sauer https://stackoverflow.com/questions/80476/how-can-i-concatenate-two-arrays-in-java
   *
   * @param first is the first array (not null)
   * @param rest  the rest of the arrays (optional)
   * @param &lt;T&gt;   the element type
   * @return concatenated array
   */
  public static &lt;T&gt; T[] multiArrayConcat(T[] first, T[]... rest) {
    var totalLength = first.length;
    for (var array : rest) {
      totalLength += array.length;
    }
    var result = Arrays.copyOf(first, totalLength);
    var offset = first.length;
    for (var array : rest) {
      System.arraycopy(array, 0, result, offset, array.length);
      offset += array.length;
    }
    return result;
  }
}
</code></pre>
<h3 id="reversearraysnippet"><a class="header" href="#reversearraysnippet">ReverseArraySnippet</a></h3>
<pre><code class="language-java">package array;

/**
 * ReverseArraySnippet.
 */
public class ReverseArraySnippet {

  /**
   * The function then reverses the elements of the array between the starting and ending
   * indices using a while loop and a temporary variable `temp`. Finally, the function returns
   * the reversed array.
   *
   * @param array a array
   * @param start start index array
   * @param end end index array
   * @return reverses elements in the array
   * @throws IllegalArgumentException if the [start] index is greater
   *         than the [end] index or if the array is null
   **/
  public static &lt;T&gt; T[] reverseArray(T[] array, int start, int end) {
    if (start &gt; end || array == null) {
      throw new
              IllegalArgumentException(&quot;Invalid argument!&quot;);
    }
    int minimumSizeArrayForReversal = 2;
    if (start == end || array.length &lt; minimumSizeArrayForReversal) {
      return array;
    }
    while (start &lt; end) {
      T temp = array[start];
      array[start] = array[end];
      array[end] = temp;
      start++;
      end--;
    }
    return array;
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cls"><a class="header" href="#cls">CLS</a></h1>
<h3 id="creatingobjectsnippet"><a class="header" href="#creatingobjectsnippet">CreatingObjectSnippet</a></h3>
<pre><code class="language-java">package cls;

import java.lang.reflect.InvocationTargetException;

/**
 * CreatingObjectSnippet.
 */
public class CreatingObjectSnippet {

  /**
   * Create object using reflection.
   *
   * @param cls fully qualified name of class includes the package name as String
   * @return object
   * @throws NoSuchMethodException if a method that does not exist at runtime.
   * @throws IllegalAccessException &lt;p&gt;if an currently executing method does not have access to
   *     the definition of the specified class, field, method or constructor&lt;/p&gt;
   * @throws InvocationTargetException &lt;p&gt;InvocationTargetException is a checked exception
   *     that wraps an exception thrown by an invoked method or constructor.&lt;/p&gt;
   * @throws InstantiationException &lt;p&gt;when an method tries to create an instance of a class
   *     using the newInstance method in class Class.&lt;/p&gt;
   * @throws ClassNotFoundException &lt;p&gt;when an application tries to load in a class
   *     through its string name.&lt;/p&gt;
   */
  public static Object createObject(String cls)
          throws NoSuchMethodException,
          IllegalAccessException,
          InvocationTargetException,
          InstantiationException,
          ClassNotFoundException {
    var objectClass = Class.forName(cls);
    var objectConstructor = objectClass.getConstructor();
    return objectConstructor.newInstance();
  }
}
</code></pre>
<h3 id="getallfieldnamessnippet"><a class="header" href="#getallfieldnamessnippet">GetAllFieldNamesSnippet</a></h3>
<pre><code class="language-java">package cls;

import java.lang.reflect.Field;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

/**
 * GetAllFieldNamesSnippet.
 */
public class GetAllFieldNamesSnippet {

  /**
   * Print all declared field names of the class or the interface the class extends.
   *
   * @param clazz Tested class
   * @return list of names of all fields
   */
  public static List&lt;String&gt; getAllFieldNames(final Class&lt;?&gt; clazz) {
    var fields = new ArrayList&lt;String&gt;();
    var currentClazz = clazz;
    while (currentClazz != null) {
      fields.addAll(
          Arrays.stream(currentClazz.getDeclaredFields())
              .filter(field -&gt; !field.isSynthetic())
              .map(Field::getName)
              .collect(Collectors.toList()));
      currentClazz = currentClazz.getSuperclass();
    }
    return fields;
  }
}
</code></pre>
<h3 id="getallmethodssnippet"><a class="header" href="#getallmethodssnippet">GetAllMethodsSnippet</a></h3>
<pre><code class="language-java">package cls;

import java.lang.reflect.Method;
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

/**
 * GetAllMethodsSnippet.
 */
public class GetAllMethodsSnippet {

  /**
   * Print all declared methods of the class.
   *
   * @param cls Tested class
   * @return list of methods name
   */
  public static List&lt;String&gt; getAllMethods(final Class&lt;?&gt; cls) {
    return Arrays.stream(cls.getDeclaredMethods())
        .map(Method::getName)
        .collect(Collectors.toList());
  }
}
</code></pre>
<h3 id="getallpublicfieldnamessnippet"><a class="header" href="#getallpublicfieldnamessnippet">GetAllPublicFieldNamesSnippet</a></h3>
<pre><code class="language-java">package cls;

import java.lang.reflect.Field;
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

/**
 * GetAllPublicFieldNamesSnippet.
 */
public class GetAllPublicFieldNamesSnippet {

  /**
   * Print all declared public field names of the class or the interface the class extends.
   *
   * @param clazz Tested class
   * @return list of name of public fields
   */
  public static List&lt;String&gt; getAllPublicFieldNames(final Class&lt;?&gt; clazz) {
    return Arrays.stream(clazz.getFields())
        .map(Field::getName)
        .collect(Collectors.toList());
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="date-1"><a class="header" href="#date-1">Date</a></h1>
<h3 id="adddaystodatesnippet"><a class="header" href="#adddaystodatesnippet">AddDaysToDateSnippet</a></h3>
<pre><code class="language-java">package date;

import java.time.LocalDate;
import java.time.ZoneId;
import java.util.Calendar;
import java.util.Date;

/**
 * AddDaysToDateSnippet.
 */
public class AddDaysToDateSnippet {

  /**
   * Add days to given date.
   *
   * @param date given date
   * @param noOfDays number of days to add
   * @return modified date
   */
  public static Date addDaysToDate(Date date, int noOfDays) {
    if (date != null) {
      Calendar cal = Calendar.getInstance();
      cal.setTime(date);
      cal.add(Calendar.DAY_OF_MONTH, noOfDays);
      return cal.getTime();
    }
    return null;
  }

  /**
   * Add days to local date.
   *
   * @param date given local date
   * @param noOfDays number of days to add
   * @return modified date
   */
  public static LocalDate addDaysToLocalDate(LocalDate date, long noOfDays) {
    return date != null ? date.plusDays(noOfDays) : null;
  }
}
</code></pre>
<h3 id="datedifferencesnippet"><a class="header" href="#datedifferencesnippet">DateDifferenceSnippet</a></h3>
<pre><code class="language-java">package date;

import java.time.LocalDate;
import java.time.temporal.ChronoUnit;

/**
 * DateDifferenceSnippet.
 */

public class DateDifferenceSnippet {

  /**
  * This function calculates the number of years between two LocalDate objects.
  * If the result is negative, it returns the absolute value of the difference.
  *
  * @param firstTime  The first LocalDate object representing the starting date
  * @param secondTime The second LocalDate object representing the ending date
  * @return The number of years between the two LocalDate objects as a long data type
  */
  public static long getYearsDifference(LocalDate firstTime, LocalDate secondTime) {
    var yearsDifference = ChronoUnit.YEARS.between(firstTime, secondTime);
    return Math.abs(yearsDifference);
  }

  /**
   * This function calculates the number of months between two LocalDate objects.
   * If the result is negative, it returns the absolute value of the difference.
   *
   * @param firstTime  The first LocalDate object representing the starting date
   * @param secondTime The second LocalDate object representing the ending date
   * @return The number of months between the two LocalDate objects as a long data type
   */
  public static long getMonthsDifference(LocalDate firstTime, LocalDate secondTime) {
    var monthsDifference = ChronoUnit.MONTHS.between(firstTime, secondTime);
    return Math.abs(monthsDifference);
  }

  /**
   * This function calculates the number of days between two LocalDate objects.
   * If the result is negative, it returns the absolute value of the difference.
   *
   * @param firstTime  The first LocalDate object representing the starting date
   * @param secondTime The second LocalDate object representing the ending date
   * @return The number of days between the two LocalDate objects as a long data type
   */
  public static long getDaysDifference(LocalDate firstTime, LocalDate secondTime) {
    var daysDifference = ChronoUnit.DAYS.between(firstTime, secondTime);
    return Math.abs(daysDifference);
  }
}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="base64decodesnippet"><a class="header" href="#base64decodesnippet">Base64DecodeSnippet</a></h3>
<pre><code class="language-java">package encoding;

import java.util.Base64;

/**
 * Base64DecodeSnippet.
 */
public class Base64DecodeSnippet {

  /**
   * Decodes a Base64 encoded string to the actual representation.
   *
   * @param input base64 encoded string
   * @return decoded string
   */
  public static String decodeBase64(String input) {
    return new String(Base64.getDecoder().decode(input.getBytes()));
  }
}
</code></pre>
<h3 id="base64encodesnippet"><a class="header" href="#base64encodesnippet">Base64EncodeSnippet</a></h3>
<pre><code class="language-java">package encoding;

import java.util.Base64;

/**
 * Base64EncodeSnippet.
 */
public class Base64EncodeSnippet {
  /**
   * Encodes the input string to a Base64 encoded string.
   *
   * @param input string to be encoded
   * @return base64 encoded string
   */
  public static String encodeBase64(String input) {
    return Base64.getEncoder().encodeToString(input.getBytes());
  }
}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="listallfilessnippet"><a class="header" href="#listallfilessnippet">ListAllFilesSnippet</a></h3>
<pre><code class="language-java">package file;

import java.io.File;
import java.util.ArrayList;
import java.util.List;

/**
 * ListAllFilesSnippet.
 */
public class ListAllFilesSnippet {

  /**
   * Recursively list all the files in directory.
   *
   * @param path the path to start the search from
   * @return list of all files
   */
  public static List&lt;File&gt; listAllFiles(String path) {
    var all = new ArrayList&lt;File&gt;();
    var list = new File(path).listFiles();
    if (list != null) {  // In case of access error, list is null
      for (var f : list) {
        if (f.isDirectory()) {
          all.addAll(listAllFiles(f.getAbsolutePath()));
        } else {
          all.add(f.getAbsoluteFile());
        }
      }
    }
    return all;
  }
}
</code></pre>
<h3 id="listdirectoriessnippet"><a class="header" href="#listdirectoriessnippet">ListDirectoriesSnippet</a></h3>
<pre><code class="language-java">package file;

import java.io.File;

/**
 * ListDirectoriesSnippet.
 */
public class ListDirectoriesSnippet {

  /**
   * List directories.
   *
   * @param path the path where to look
   * @return array of File
   */
  public static File[] listDirectories(String path) {
    return new File(path).listFiles(File::isDirectory);
  }
}
</code></pre>
<h3 id="listfilesindirectorysnippet"><a class="header" href="#listfilesindirectorysnippet">ListFilesInDirectorySnippet</a></h3>
<pre><code class="language-java">package file;

import java.io.File;

/**
 * ListFilesInDirectorySnippet.
 */
public class ListFilesInDirectorySnippet {

  /**
   * List files in directory.
   *
   * @param folder the path where to look
   * @return array of File
   */
  public static File[] listFilesInDirectory(String folder) {
    return new File(folder).listFiles(File::isFile);
  }
}
</code></pre>
<h3 id="readlinessnippet"><a class="header" href="#readlinessnippet">ReadLinesSnippet</a></h3>
<pre><code class="language-java">package file;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.List;

/**
 * ReadLinesSnippet.
 */
public class ReadLinesSnippet {

  /**
   * Read file as list of strings.
   *
   * @param filename the filename to read from
   * @return list of strings
   * @throws IOException if an I/O error occurs
   */
  public static List&lt;String&gt; readLines(String filename) throws IOException {
    return Files.readAllLines(Paths.get(filename));
  }
}
</code></pre>
<h3 id="zipdirectorysnippet"><a class="header" href="#zipdirectorysnippet">ZipDirectorySnippet</a></h3>
<pre><code class="language-java">package file;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.zip.ZipEntry;
import java.util.zip.ZipOutputStream;

/**
 * ZipDirectorySnippet.
 */
public class ZipDirectorySnippet {

  /**
   * Zip a complete directory.
   *
   * @param srcDirectoryName The path to the directory to be zipped
   * @param zipFileName The location and name of the zipped file.
   * @throws IOException if an I/O error occurs
   * */
  public static void zipDirectory(String srcDirectoryName, String zipFileName) throws IOException {
    var srcDirectory = new File(srcDirectoryName);
    try (
        var fileOut = new FileOutputStream(zipFileName);
        var zipOut = new ZipOutputStream(fileOut)
    ) {
      zipFile(srcDirectory, srcDirectory.getName(), zipOut);
    }
  }

  /**
   * Utility function which either zips a single file, or recursively calls itself for 
   * a directory to traverse down to the files contained within it.
   *
   * @param fileToZip The file as a resource
   * @param fileName The actual name of the file
   * @param zipOut The output stream to which all data is being written
   * */
  public static void zipFile(File fileToZip, String fileName, ZipOutputStream zipOut) 
      throws IOException {
    if (fileToZip.isHidden()) { // Ignore hidden files as standard
      return;
    }
    if (fileToZip.isDirectory()) {
      if (fileName.endsWith(&quot;/&quot;)) {
        zipOut.putNextEntry(new ZipEntry(fileName)); // To be zipped next
        zipOut.closeEntry();
      } else {
        // Add the &quot;/&quot; mark explicitly to preserve structure while unzipping action is performed
        zipOut.putNextEntry(new ZipEntry(fileName + &quot;/&quot;));
        zipOut.closeEntry();
      }
      var children = fileToZip.listFiles();
      for (var childFile : children) { // Recursively apply function to all children
        zipFile(childFile, fileName + &quot;/&quot; + childFile.getName(), zipOut);
      }
      return;
    }
    try (
        var fis = new FileInputStream(fileToZip) // Start zipping once we know it is a file
    ) {
      var zipEntry = new ZipEntry(fileName);
      zipOut.putNextEntry(zipEntry);
      var bytes = new byte[1024];
      var length = 0;
      while ((length = fis.read(bytes)) &gt;= 0) {
        zipOut.write(bytes, 0, length);
      }
    }
  }
}
</code></pre>
<h3 id="zipfilesnippet"><a class="header" href="#zipfilesnippet">ZipFileSnippet</a></h3>
<pre><code class="language-java">package file;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.zip.ZipEntry;
import java.util.zip.ZipOutputStream;

/**
 * ZipFileSnippet.
 */
public class ZipFileSnippet {

  /**
   * Zip single file.
   *
   * @param srcFilename the filename of the source file
   * @param zipFilename the filename of the destination zip file
   * @throws IOException if an I/O error occurs
   */
  public static void zipFile(String srcFilename, String zipFilename) throws IOException {
    var srcFile = new File(srcFilename);
    try (
            var fileOut = new FileOutputStream(zipFilename);
            var zipOut = new ZipOutputStream(fileOut);
            var fileIn = new FileInputStream(srcFile)
    ) {
      var zipEntry = new ZipEntry(srcFile.getName());
      zipOut.putNextEntry(zipEntry);
      final var bytes = new byte[1024];
      int length;
      while ((length = fileIn.read(bytes)) &gt;= 0) {
        zipOut.write(bytes, 0, length);
      }
    }
  }
}
</code></pre>
<h3 id="zipfilessnippet"><a class="header" href="#zipfilessnippet">ZipFilesSnippet</a></h3>
<pre><code class="language-java">package file;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.zip.ZipEntry;
import java.util.zip.ZipOutputStream;

/**
 * ZipFilesSnippet.
 */
public class ZipFilesSnippet {

  /**
   * Zip multiples files.
   *
   * @param srcFilenames array of source file names
   * @param zipFilename  the filename of the destination zip file
   * @throws IOException if an I/O error occurs
   */
  public static void zipFiles(String[] srcFilenames, String zipFilename) throws IOException {
    try (
            var fileOut = new FileOutputStream(zipFilename);
            var zipOut = new ZipOutputStream(fileOut)
    ) {
      for (String srcFilename : srcFilenames) {
        var srcFile = new File(srcFilename);
        try (var fileIn = new FileInputStream(srcFile)) {
          var zipEntry = new ZipEntry(srcFile.getName());
          zipOut.putNextEntry(zipEntry);
          final var bytes = new byte[1024];
          int length;
          while ((length = fileIn.read(bytes)) &gt;= 0) {
            zipOut.write(bytes, 0, length);
          }
        }
      }
    }
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="io-1"><a class="header" href="#io-1">IO</a></h1>
<h3 id="inputstreamtostringsnippet"><a class="header" href="#inputstreamtostringsnippet">InputStreamToStringSnippet</a></h3>
<pre><code class="language-java">package io;

import java.io.BufferedReader;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.nio.charset.StandardCharsets;
import java.util.stream.Collectors;

/**
 * InputStreamToStringSnippet.
 */
public class InputStreamToStringSnippet {

  /**
   * Convert InputStream to String.
   *
   * @param inputStream InputStream to convert
   * @return String
   */
  public static String inputStreamToString(InputStream inputStream) {
    return new BufferedReader(new InputStreamReader(inputStream, StandardCharsets.UTF_8))
            .lines().collect(Collectors.joining(System.lineSeparator()));
  }
}
</code></pre>
<h3 id="readfilesnippet"><a class="header" href="#readfilesnippet">ReadFileSnippet</a></h3>
<pre><code class="language-java">package io;

import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.Stream;

/**
 * ReadFileSnippet.
 */
public class ReadFileSnippet {

  /**
   * Read file using stream and return list of string lines.
   *
   * @param fileName file to read
   * @throws FileNotFoundException if an I/O error occurs
   */
  public static List&lt;String&gt; readFile(String fileName) throws FileNotFoundException {
    try (Stream&lt;String&gt; stream = new BufferedReader(new FileReader(fileName)).lines()) {
      return stream.collect(Collectors.toList());
    }
  }
}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="dicethrow"><a class="header" href="#dicethrow">DiceThrow</a></h3>
<pre><code class="language-java">package math;

import java.util.Random;

/**
 * Sum of Dice throw (Eg. 3d6 - 3 dice having 6 sides).
 */
public class DiceThrow {

  private static Random random = new Random();

  /**
  * Enum for standardized sided dice (4,6,8,10,12 and 20).
  */
  public enum DiceSides {

    FOUR(4), SIX(6), EIGHT(8), TEN(10), TWELVE(12), TWENTY(20);

    private final int diSides;

    DiceSides(int diceSides) {
      this.diSides = diceSides;
    }

    /**
     * Returns the number of sides of a dice.
     *
     * @return int denoting number of sides of a dice
     */
    public int getDiceSides() {
      return this.diSides;
    }

  }

  /**
  * Returns the sum of sides for the given number of sides of each dice.
  *
  * @param noOfDice number of dice
  * @param sides sides of a dice
  * @return int sum of sides for number of dice
  */
  public static int throwDice(int noOfDice, DiceSides sides) {

    int sum = 0;
    for (int i = 0; i &lt; noOfDice; i++) {
      sum = sum + (1 + random.nextInt(sides.getDiceSides()));
    }
    return sum;
  }
}
</code></pre>
<h3 id="eloratingsnippet"><a class="header" href="#eloratingsnippet">EloRatingSnippet</a></h3>
<pre><code class="language-java">package math;

/**
 * EloRatingSnippet.
 */
public class EloRatingSnippet {

  static final int BASE = 400; //Two types are popular - 400 and 480. We will choose 400 here
  static final int RATING_ADJUSTMENT_FACTOR = 32; //32 is the standard for Beginner Games

  /**
   * Elo Rating Snippet to calculate result after a single match.
   *
   * @param firstPlayerRating Rating of the first player.
   * @param secondPlayerRating Rating of the second player.
   * @param result Result of the match, always considered with respect to the first player.
   *               1 indicates a win, 0.5 indicates a draw and 0 indicates a loss.
   * @return Returns the new rating of the first player.
   */
  public static double calculateMatchRating(double firstPlayerRating, double secondPlayerRating,
      double result) {
    double ratingDiff = ((secondPlayerRating - firstPlayerRating) * 1.0) / BASE;
    double logisticDiff = Math.pow(10, ratingDiff);
    double firstPlayerExpectedScore = 1.0 / (1 + logisticDiff);
    double firstPlayerActualScore = result;
    double newRating = firstPlayerRating + RATING_ADJUSTMENT_FACTOR * (firstPlayerActualScore 
                       - firstPlayerExpectedScore);
    return newRating;
  }
}
</code></pre>
<h3 id="evenodd"><a class="header" href="#evenodd">EvenOdd</a></h3>
<pre><code class="language-java">package math;

/**
 * EvenOdd.
 */
public class EvenOdd {

  /**
   * Returns string denoting number is odd or even.
   *
   * @param num To check whether its even or odd
   * @return string denoting its even or odd
   */
  public static String evenodd(int num) {
    if (num % 2 == 0) {
      return &quot;even&quot;;
    } else {
      return &quot;odd&quot;;
    }
  }
}
</code></pre>
<h3 id="factorialsnippet"><a class="header" href="#factorialsnippet">FactorialSnippet</a></h3>
<pre><code class="language-java">package math;

/**
 * FactorialSnippet.
 */
public class FactorialSnippet {

  /**
   * Factorial. Works only for small numbers
   *
   * @param number for which factorial is to be calculated for
   * @return factorial
   */
  public static int factorial(int number) {
    var result = 1;
    for (var factor = 2; factor &lt;= number; factor++) {
      result *= factor;
    }
    return result;
  }

  /**
   * Factorial. Example of what the recursive implementation looks like.
   *
   * @param number for which factorial is to be calculated for
   * @return factorial
   */
  public static int recursiveFactorial(int number) {
    var initial = 0;
    if (number == initial) {
      return initial + 1;
    }
    return number * recursiveFactorial(number - 1);
  }
}
</code></pre>
<h3 id="fibonaccisnippet"><a class="header" href="#fibonaccisnippet">FibonacciSnippet</a></h3>
<pre><code class="language-java">package math;

import java.util.ArrayList;
import java.util.List;

/**
 * FibonacciSnippet.
 */
public class FibonacciSnippet {

  /**
   * Recursive Fibonacci series. Works only for small n and is spectacularly inefficient
   *
   * @param n given number
   * @return fibonacci number for given n
   */
  public static int fibonacci(int n) {
    if (n &lt;= 1) {
      return n;
    } else {
      return fibonacci(n - 1) + fibonacci(n - 2);
    }
  }

  /**
   * Fibonacci series using dynamic programming. Works for larger ns as well.
   *
   * @param n given number
   * @return fibonacci number for given n
   */
  public static int fibonacciBig(int n) {
    int previous = 0;
    int current = 1;
    for (int i = 0; i &lt; n - 1; i++) {
      int t = previous + current;
      previous = current;
      current = t;
    }

    return current;
  }

  /**
   * Example of what an iterative implementation of Fibonacci looks like.
   *
   * @param number given number
   * @return fibonacci number for given n
   */
  public static int iterativeFibonacci(int number) {
    List&lt;Integer&gt; list = new ArrayList&lt;&gt;();
    list.add(0);
    list.add(1);
    for (int i = 2; i &lt; number + 1; i++) {
      list.add(list.get(i - 2) + list.get(i - 1));
    }
    return list.get(number);
  }
}
</code></pre>
<h3 id="greatestcommondivisorsnippet"><a class="header" href="#greatestcommondivisorsnippet">GreatestCommonDivisorSnippet</a></h3>
<pre><code class="language-java">package math;

/**
 * GreatestCommonDivisorSnippet.
 */
public class GreatestCommonDivisorSnippet {

  /**
   * Greatest common divisor calculation.
   *
   * @param a one of the numbers whose gcd is to be computed
   * @param b other number whose gcd is to be computed
   * @return gcd of the two numbers
   */
  public static int gcd(int a, int b) {
    if (b == 0) {
      return a;
    }
    return gcd(b, a % b);
  }
}
</code></pre>
<h3 id="haversineformulasnippet"><a class="header" href="#haversineformulasnippet">HaversineFormulaSnippet</a></h3>
<pre><code class="language-java">package math;

/**
 * HaversineFormulaSnippet.
 */
public class HaversineFormulaSnippet {

  // Radius of sphere on which the points are, in this case Earth.
  private static final double SPHERE_RADIUS_IN_KM = 6372.8;

  /**
   * Haversine formula for calculating distance between two latitude, longitude points.
   *
   * @param latA Latitude of point A
   * @param longA Longitude of point A
   * @param latB Latitude of point B
   * @param longB Longitude of point B
   * @return the distance between the two points.
   */
  public static double findHaversineDistance(double latA, double longA, double latB, double longB) {
    if (!isValidLatitude(latA)
        || !isValidLatitude(latB)
        || !isValidLongitude(longA)
        || !isValidLongitude(longB)) {
      throw new IllegalArgumentException();
    }

    // Calculate the latitude and longitude differences
    var latitudeDiff = Math.toRadians(latB - latA);
    var longitudeDiff = Math.toRadians(longB - longA);

    var latitudeA = Math.toRadians(latA);
    var latitudeB = Math.toRadians(latB);

    // Calculating the distance as per haversine formula
    var a = Math.pow(Math.sin(latitudeDiff / 2), 2)
            + Math.pow(Math.sin(longitudeDiff / 2), 2) * Math.cos(latitudeA) * Math.cos(latitudeB);
    var c = 2 * Math.asin(Math.sqrt(a));
    return SPHERE_RADIUS_IN_KM * c;
  }

  // Check for valid latitude value
  private static boolean isValidLatitude(double latitude) {
    return latitude &gt;= -90 &amp;&amp; latitude &lt;= 90;
  }

  // Check for valid longitude value
  private static boolean isValidLongitude(double longitude) {
    return longitude &gt;= -180 &amp;&amp; longitude &lt;= 180;
  }
}
</code></pre>
<h3 id="leastcommonmultiplesnippet"><a class="header" href="#leastcommonmultiplesnippet">LeastCommonMultipleSnippet</a></h3>
<pre><code class="language-java">package math;

/**
 * LeastCommonMultipleSnippet.
 */
public class LeastCommonMultipleSnippet {
  /**
   * Least common multiple  calculation.
   *
   * @param a one of the numbers whose lcm is to be computed
   * @param b other number whose lcm is to be computed
   * @return lcm of the two numbers
   */
  public static int lcm(int a, int b) {
    int max = a &gt; b ? a : b;
    int min = a &lt; b ? a : b;
    for (int i = 1; i &lt;= min; i += 1) {
      int prod = max * i;
      if (prod % min == 0) {
        return prod;
      }
    }
    return max * min;
  }
}
</code></pre>
<h3 id="luhnsnippet"><a class="header" href="#luhnsnippet">LuhnSnippet</a></h3>
<pre><code class="language-java">package math;

/**
 * LuhnSnippet.
 */
public class LuhnSnippet {

  /**
   * Calculates checksum for a given number with Luhn's algorithm. Works only on non-negative
   * integers not greater than {@link Long#MAX_VALUE} i.e., all numbers with a maximum of 18
   * digits, plus 19-digit-long numbers start with 1..8 (also some with 9, too). For
   * demonstration purposes, algorithm is not optimized for efficiency.
   *
   * @param num number whose checksum is to be calculated
   * @return checksum value for num
   * @see &lt;a href=&quot;https://patents.google.com/patent/US2950048A&quot;&gt;Hans P. LUHN's patent US2950048A&lt;/a&gt;
   * @see &lt;a href=&quot;https://en.wikipedia.org/wiki/Luhn_algorithm&quot;&gt;Luhn algorithm on Wikipedia&lt;/a&gt;
   */
  public static int calculateLuhnChecksum(long num) {
    if (num &lt; 0) {
      throw new IllegalArgumentException(&quot;Non-negative numbers only.&quot;);
    }
    final var numStr = String.valueOf(num);

    var sum = 0;
    var isOddPosition = true;
    // Loop on digits of numStr from right to left.
    for (var i = numStr.length() - 1; i &gt;= 0; i--) {
      final var digit = Integer.parseInt(Character.toString(numStr.charAt(i)));
      final var substituteDigit = (isOddPosition ? 2 : 1) * digit;

      final var tensPlaceDigit = substituteDigit / 10;
      final var onesPlaceDigit = substituteDigit % 10;
      sum += tensPlaceDigit + onesPlaceDigit;

      isOddPosition = !isOddPosition;
    }
    final var checksumDigit = (10 - (sum % 10)) % 10;
    // Outermost modulus handles edge case `num = 0`.
    return checksumDigit;
  }
}
</code></pre>
<h3 id="naturalnumberbinaryconversionsnippet"><a class="header" href="#naturalnumberbinaryconversionsnippet">NaturalNumberBinaryConversionSnippet</a></h3>
<pre><code class="language-java">package math;

import java.util.Stack;
import java.util.stream.Collectors;
import java.util.stream.IntStream;
import java.util.stream.Stream;

/**
 * NaturalNumberBinaryConversionSnippet.
 */
public class NaturalNumberBinaryConversionSnippet {

  /**
   * Convert natural number to binary string. Only supports positive integers.Throws exception
   * for negative integers
   *
   * @param naturalNumber given number
   * @return Binary string representation of naturalNumber
   */
  public static String toBinary(long naturalNumber) {
    if (naturalNumber &lt; 0) {
      throw new NumberFormatException(&quot;Negative Integer, this snippet only accepts &quot;
              + &quot;positive integers&quot;);
    }
    if (naturalNumber == 0) {
      return &quot;0&quot;;
    }
    final Stack&lt;Long&gt; binaryBits =
            Stream.iterate(naturalNumber, n -&gt; n &gt; 0, n -&gt; n / 2).map(n -&gt; n % 2)
                    .collect(Stack::new, Stack::push, Stack::addAll);
    return Stream.generate(binaryBits::pop)
            .limit(binaryBits.size()).map(String::valueOf).collect(Collectors.joining());
  }

  /**
   * Convert binary string representation to Long valued Integer. Throws exception if input
   * string contains characters other than '0' and '1'
   *
   * @param binary given number
   * @return Unsigned Long value for the binary number
   */
  public static Long fromBinary(String binary) {
    binary.chars().filter(c -&gt; c != '0' &amp;&amp; c != '1').findFirst().ifPresent(in -&gt; {
      throw new NumberFormatException(
              &quot;Binary string contains values other than '0' and '1'&quot;);
    });
    return IntStream.range(0, binary.length())
            .filter(in -&gt; binary.charAt(binary.length() - 1 - in) == '1')
            .mapToLong(in -&gt; ((long) 0b1) &lt;&lt; in).sum();
  }
}
</code></pre>
<h3 id="performlotterysnippet"><a class="header" href="#performlotterysnippet">PerformLotterySnippet</a></h3>
<pre><code class="language-java">package math;

import java.util.ArrayList;
import java.util.Collections;

/**
 * PerformLotterySnippet.
 */
public class PerformLotterySnippet {

  /**
   * Generate random lottery numbers.
   *
   * @param numNumbers    how many performLottery numbers are available (e.g. 49)
   * @param numbersToPick how many numbers the player needs to pick (e.g. 6)
   * @return array with the random numbers
   */
  public static Integer[] performLottery(int numNumbers, int numbersToPick) {
    var numbers = new ArrayList&lt;Integer&gt;();
    for (var i = 0; i &lt; numNumbers; i++) {
      numbers.add(i + 1);
    }
    Collections.shuffle(numbers);
    return numbers.subList(0, numbersToPick).toArray(new Integer[numbersToPick]);
  }
}
</code></pre>
<h3 id="primenumbersnippet"><a class="header" href="#primenumbersnippet">PrimeNumberSnippet</a></h3>
<pre><code class="language-java">package math;

/**
 * PrimeNumberSnippet.
 */
public class PrimeNumberSnippet {

  /**
   * Checks if given number is a prime number. Prime number is a number that is greater than 1 and
   * divided by 1 or itself only Credits: https://en.wikipedia.org/wiki/Prime_number
   *
   * @param number number to check prime
   * @return true if prime
   */
  public static boolean isPrime(int number) {
    //if number &lt; 2 its not a prime number
    if (number &lt; 2) {
      return false;
    }
    // 2 and 3 are prime numbers
    if (number &lt; 3) {
      return true;
    }
    // check if n is a multiple of 2
    if (number % 2 == 0) {
      return false;
    }
    // if not, then just check the odds
    for (var i = 3; i * i &lt;= number; i += 2) {
      if (number % i == 0) {
        return false;
      }
    }
    return true;
  }
}
</code></pre>
<h3 id="randomnumber"><a class="header" href="#randomnumber">RandomNumber</a></h3>
<pre><code class="language-java">package math;

import java.util.Random;

/**
 * Random Number between given two values.
 * Supported Data types - Byte, Short, Integer, Long, Float and Double.
 */
public class RandomNumber {

  private RandomNumber() {}

  private static Random random = new Random();

  /**
  * Return a random number between two given numbers.
  *
  * @param start Starting point to find the random number
  * @param end Ending point to find the random number
  * @return Number denoting the random number generated
  */
  public static &lt;T extends Number&gt; Number getRandomNumber(T start, T end) {

    if (start instanceof Byte &amp;&amp; end instanceof Byte) {
      return (byte) (start.byteValue()
              + random.nextInt(end.byteValue() - start.byteValue() + 1));
    } else if (start instanceof Short &amp;&amp; end instanceof Short) {
      return (short) (start.shortValue()
              + random.nextInt(end.shortValue() - start.shortValue() + 1));
    } else if (start instanceof Integer &amp;&amp; end instanceof Integer) {
      return start.intValue()
              + random.nextInt(end.intValue() - start.intValue() + 1);
    } else if (start instanceof Long &amp;&amp; end instanceof Long) {
      return start.longValue()
              + (long) (random.nextDouble() * end.longValue() - start.longValue() + 1);
    } else if (start instanceof Float &amp;&amp; end instanceof Float) {
      return start.floatValue()
              + random.nextFloat() * (end.floatValue() - start.floatValue());
    } else if (start instanceof Double &amp;&amp; end instanceof Double) {
      return start.doubleValue()
              + random.nextDouble() * (end.doubleValue() - start.doubleValue());
    } else {
      throw new IllegalArgumentException(&quot;Invalid Numbers As Arguments &quot;
              + start.getClass() + &quot; and &quot; + end.getClass());
    }
  }
}


### SquareRoot

```java
package math;

/**
 * SquareRoot.
 */
public class SquareRoot {

  /**
   * Returns square root of a number.
   *
   * @param num To find SquareRoot
   * @param p   precision till how many decimal numbers we want accurate ans
   */
  public static double sqrt(int num, int p) {
    int start = 0;
    int end = num;
    double root = 0.0;

    while (start &lt;= end) {
      int mid = start + (end - start) / 2;

      if ((mid * mid) &gt; num) {
        end = mid - 1;
      } else if ((mid * mid) &lt; num) {
        start = mid + 1;
      } else {
        return mid;
      }
    }
    double incr = 0.1;
    for (int i = 0; i &lt; p; i++) {
      while (root * root &lt; num) {
        root = root + incr;
      }
      root = root - incr;
      incr = incr / 10;
    }
    return root;
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="media-1"><a class="header" href="#media-1">Media</a></h1>
<h3 id="capturescreensnippet"><a class="header" href="#capturescreensnippet">CaptureScreenSnippet</a></h3>
<pre><code class="language-java">package media;

import java.awt.AWTException;
import java.awt.Rectangle;
import java.awt.Robot;
import java.awt.Toolkit;
import java.io.File;
import java.io.IOException;
import javax.imageio.ImageIO;

/**
 * CaptureScreenSnippet.
 */
public class CaptureScreenSnippet {

  /**
   * Capture screenshot and save it to PNG file. Credits: https://viralpatel.net/blogs/how-to-take-screen-shots-in-java-taking-screenshots-java/
   *
   * @param filename the name of the file
   * @throws AWTException if the platform configuration does not allow low-level input control
   * @throws IOException  if an I/O error occurs
   */
  public static void captureScreen(String filename) throws AWTException, IOException {
    var screenSize = Toolkit.getDefaultToolkit().getScreenSize();
    var screenRectangle = new Rectangle(screenSize);
    var robot = new Robot();
    var image = robot.createScreenCapture(screenRectangle);
    ImageIO.write(image, &quot;png&quot;, new File(filename));
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="httpgetsnippet"><a class="header" href="#httpgetsnippet">HttpGetSnippet</a></h3>
<pre><code class="language-java">package network;

import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;

/**
 * HttpGetSnippet.
 */
public class HttpGetSnippet {

  /**
   * Performs HTTP GET request.
   *
   * @param uri the URI of the connection
   * @return response object
   * @throws Exception i/o error, interruption error, etc
   */
  public static HttpResponse&lt;String&gt; httpGet(String uri) throws Exception {
    var client = HttpClient.newHttpClient();
    var request = HttpRequest.newBuilder()
            .uri(URI.create(uri))
            .build();
    return client.send(request, HttpResponse.BodyHandlers.ofString());
  }
}
</code></pre>
<h3 id="httppostsnippet"><a class="header" href="#httppostsnippet">HttpPostSnippet</a></h3>
<pre><code class="language-java">package network;

import java.io.IOException;
import java.net.URI;
import java.net.URLEncoder;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.nio.charset.StandardCharsets;
import java.util.HashMap;
import java.util.StringJoiner;

/**
 * HttpPostSnippet.
 */
public class HttpPostSnippet {

  /**
   * Performs HTTP POST request. Credits https://stackoverflow.com/questions/3324717/sending-http-post-request-in-java
   *
   * @param address   the URL of the connection in String format, like &quot;http://www.google.com&quot;
   * @param arguments the body of the POST request, as a HashMap
   * @return response object
   * @throws IOException          if an I/O error occurs
   * @throws InterruptedException if the operation is interrupted
   */
  public static HttpResponse&lt;String&gt; httpPost(String address, HashMap&lt;String, String&gt; arguments)
          throws IOException, InterruptedException {
    var sj = new StringJoiner(&quot;&amp;&quot;);
    for (var entry : arguments.entrySet()) {
      sj.add(URLEncoder.encode(entry.getKey(), StandardCharsets.UTF_8) + &quot;=&quot;
              + URLEncoder.encode(entry.getValue(), StandardCharsets.UTF_8));
    }

    var out = sj.toString().getBytes(StandardCharsets.UTF_8);
    var request = HttpRequest.newBuilder()
            .uri(URI.create(address))
            .headers(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded; charset=UTF-8&quot;)
            .POST(HttpRequest.BodyPublishers.ofByteArray(out))
            .build();

    return HttpClient.newHttpClient().send(request, HttpResponse.BodyHandlers.ofString());
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="anagramsnippet"><a class="header" href="#anagramsnippet">AnagramSnippet</a></h3>
<pre><code class="language-java">package string;

import java.util.Arrays;

/**
 * AnagramSnippet.
 */
public class AnagramSnippet {

  /**
   * Checks if two words are anagrams (contains same characters with same frequency in any order).
   *
   * @param s1 The first string to be checked
   * @param s2 The second string to be checked
   * @return true if they are anagrams of each other
   */
  public static boolean isAnagram(String s1, String s2) {
    var l1 = s1.length();
    var l2 = s2.length();

    if (l1 != l2) {
      return false;
    }

    var arr1 = new int[256];
    var arr2 = new int[256];
    
    for (var i = 0; i &lt; l1; i++) {
      arr1[s1.charAt(i)]++;
      arr2[s2.charAt(i)]++;
    }
    return Arrays.equals(arr1, arr2);
  }
}
</code></pre>
<h3 id="commonletterssnippet"><a class="header" href="#commonletterssnippet">CommonLettersSnippet</a></h3>
<pre><code class="language-java">package string;

import java.util.HashSet;
import java.util.Set;

/**
 * CommonLettersSnippet.
 */
public class CommonLettersSnippet {

  /**
   * Find Common Characters inside given two strings.
   *
   * @param firstStr  first string
   * @param secondStr second string
   * @return Common Characters.
   */
  public static String getCommonLetters(String firstStr, String secondStr) {
    Set&lt;String&gt; commonLetters = new HashSet&lt;&gt;();
    for (Character currentCharacter : firstStr.toCharArray()) {
      if (isCommonLetter(secondStr, currentCharacter)) {
        commonLetters.add(currentCharacter.toString());
      }
    }
    return String.join(&quot; &quot;, commonLetters);
  }

  private static boolean isCommonLetter(String str, Character character) {
    return str.contains(character.toString()) &amp;&amp; Character.isLetter(character);
  }
}
</code></pre>
<h3 id="compareversionsnippet"><a class="header" href="#compareversionsnippet">CompareVersionSnippet</a></h3>
<pre><code class="language-java">package string;

/**
 * CompareVersionSnippet.
 */
public class CompareVersionSnippet {

  private static final String EXTRACT_VERSION_REGEX = &quot;.*?((?&lt;!\\w)\\d+([.-]\\d+)*).*&quot;;

  /**
   * Compares two version strings.
   * Credits: https://stackoverflow.com/a/6702000/6645088 and https://stackoverflow.com/a/44592696/6645088
   *
   * @param v1 the first version string to compare
   * @param v2 the second version string to compare
   * @return the value {@code 0} if the two strings represent same versions;
   *     a value less than {@code 0} if {@code v1} is greater than {@code v2}; and
   *     a value greater than {@code 0} if {@code v2} is greater than {@code v1}
   */
  public static int compareVersion(String v1, String v2) {
    var components1 = getVersionComponents(v1);
    var components2 = getVersionComponents(v2);
    int length = Math.max(components1.length, components2.length);
    for (int i = 0; i &lt; length; i++) {
      Integer c1 = i &lt; components1.length ? Integer.parseInt(components1[i]) : 0;
      Integer c2 = i &lt; components2.length ? Integer.parseInt(components2[i]) : 0;
      int result = c1.compareTo(c2);
      if (result != 0) {
        return result;
      }
    }
    return 0;
  }

  private static String[] getVersionComponents(String version) {
    return version.replaceAll(EXTRACT_VERSION_REGEX, &quot;$1&quot;).split(&quot;\\.&quot;);
  }
}
</code></pre>
<h3 id="duplicatecharactersnippet"><a class="header" href="#duplicatecharactersnippet">DuplicateCharacterSnippet</a></h3>
<pre><code class="language-java">package string;

import java.util.HashSet;
import java.util.Set;

/**
 * DuplicateCharacterSnippet.
 */
public class DuplicateCharacterSnippet {

  /**
   * Remove Duplicate Characters from a string.
   *
   * @param str The string to be processed
   * @return A string with no duplicate characters
   */

  public static String removeDuplicateCharacters(String str) {
    char[] charsOfStr = str.toCharArray();
    Set&lt;String&gt; uniqueCharacters = new HashSet&lt;&gt;();
    for (char character : charsOfStr) {
      uniqueCharacters.add(String.valueOf(character));
    }
    return String.join(&quot;&quot;, uniqueCharacters);
  }
}
</code></pre>
<h3 id="kmpsubstringsearchsnippet"><a class="header" href="#kmpsubstringsearchsnippet">KmpSubstringSearchSnippet</a></h3>
<pre><code class="language-java">package string;

/**
 * KmpSubstringSearchSnippet.
 */

public class KmpSubstringSearchSnippet {
 
  /**
   * Implements the Knuth-Morris-Pratt (KMP) algorithm to find the of a substring.
   *
   * @param text The text in which the substring is to be searched.
   * @param pattern The substring pattern to search for.
   * @return The index of the first occurrence, or -1 if the pattern is not found.
   */
  public static int kmpSearch(String text, String pattern) {
    if (pattern == null || pattern.length() == 0) {
      return 0; // Trivial case: empty pattern
    }
 
    int[] lps = computeLpsArray(pattern);
    int i = 0; // index for text
    int j = 0; // index for pattern
 
    while (i &lt; text.length()) {
      if (pattern.charAt(j) == text.charAt(i)) {
        i++;
        j++;
      }
 
      if (j == pattern.length()) {
        return i - j; // Found pattern at index (i - j)
      } else if (i &lt; text.length() &amp;&amp; pattern.charAt(j) != text.charAt(i)) {
        if (j != 0) {
          j = lps[j - 1]; // Use the LPS array to skip characters
        } else {
          i++; // If no match and j is 0, move to the next character in text
        }
      }
    }
    return -1; // Pattern not found
  }
 
  /**
  * Computes the LPS (Longest Prefix Suffix) array, which indicates the longest proper prefix.
  *
  * @param pattern The pattern for which the LPS array is to be computed.
  * @return The LPS array.
  */
  private static int[] computeLpsArray(String pattern) {
    int length = 0;
    int i = 1;
    int[] lps = new int[pattern.length()];
    lps[0] = 0; // LPS for the first character is always 0
 
    while (i &lt; pattern.length()) {
      if (pattern.charAt(i) == pattern.charAt(length)) {
        length++;
        lps[i] = length;
        i++;
      } else {
        if (length != 0) {
          length = lps[length - 1]; // Fall back to the previous LPS value
        } else {
          lps[i] = 0;
          i++;
        }
      }
    }
    return lps;
  }
} 

### LevenshteinDistanceSnippet

```java
package string;

/**
 * LevenshteinDistanceSnippet.
 */
public class LevenshteinDistanceSnippet {

  /**
   * Find the Levenshtein distance between two words. https://en.wikipedia.org/wiki/Levenshtein_distance
   *
   * @param word1 first word
   * @param word2 second word
   * @return distance
   */
  public static int findLevenshteinDistance(String word1, String word2) {
    // If word2 is empty, removing
    int[][] ans = new int[word1.length() + 1][word2.length() + 1];
    for (int i = 0; i &lt;= word1.length(); i++) {
      ans[i][0] = i;
    }
    // if word1 is empty, adding
    for (int i = 0; i &lt;= word2.length(); i++) {
      ans[0][i] = i;
    }
    // None is empty
    for (int i = 1; i &lt;= word1.length(); i++) {
      for (int j = 1; j &lt;= word2.length(); j++) {
        int min = Math.min(Math.min(ans[i][j - 1], ans[i - 1][j]), ans[i - 1][j - 1]);
        ans[i][j] = word1.charAt(i - 1) == word2.charAt(j - 1) ? ans[i - 1][j - 1] : min + 1;
      }
    }
    return ans[word1.length()][word2.length()];
  }
}
</code></pre>
<h3 id="lsystemsnippet"><a class="header" href="#lsystemsnippet">LSystemSnippet</a></h3>
<pre><code class="language-java">package string;

import java.util.Map;

/**
 * LSystemSnippet.
 */
public class LindenmayerSystemSnippet {
  /**
   * Generates an L-system string based on axiom, production rules, and a number of iterations.
   *
   * @param axiom           initial string to begin the L-system
   * @param productionRules map of character rules where each symbol can be replaced with a string
   * @param iterations      number of iterations to apply the production rules
   * @return the generated string after all iterations
   */
  public static String generateLindenmayerSystem(
          String axiom,
          Map&lt;Character, String&gt; productionRules,
          int iterations
  ) {
    String current = axiom;

    for (int i = 0; i &lt; iterations; i++) {
      StringBuilder nextIteration = new StringBuilder(current.length() * 2);

      // Replace each symbol with the corresponding production rule or the symbol itself
      current.chars()
          .mapToObj(c -&gt; (char) c)
          .forEach(symbol -&gt;
                  nextIteration.append(
                          productionRules.getOrDefault(symbol, String.valueOf(symbol))
                  )
          );

      current = nextIteration.toString();
    }
    return current;
  }
}
</code></pre>
<h3 id="maxcharactercountsnippet"><a class="header" href="#maxcharactercountsnippet">MaxCharacterCountSnippet</a></h3>
<pre><code class="language-java">package string;

/**
 * MaxCharacterCountSnippet.
 */
public class MaxCharacterCountSnippet {

  /**
   * The maximum count of times a specific character appears in a string.
   *
   * @param str َA specific string
   * @param character A specific character
   * @return the maximum count of one character
   */

  public static int getMaxCharacterCount(String str, char character) {
    int characterCount = 0;
    int maxCharacterCount = 0;
    for (int i = 0; i &lt; str.length(); i++) {
      if ((str.charAt(i)) == character) {
        characterCount++;
        maxCharacterCount = Math.max(maxCharacterCount, characterCount);
      } else {
        characterCount = 0;
      }
    }
    return maxCharacterCount;
  }
}
</code></pre>
<h3 id="palindromchecksnippet"><a class="header" href="#palindromchecksnippet">PalindromCheckSnippet</a></h3>
<pre><code class="language-java">package string;

/**
 * PalindromCheckSnippet.
 */
public class PalindromCheckSnippet {

  /**
   * Checks if given string is palindrome (same forward and backward). Skips non-letter characters
   * Credits: https://github.com/kousen/java_8_recipes
   *
   * @param s string to check
   * @return true if palindrome
   */
  public static boolean isPalindrome(String s) {
    for (int i = 0, j = s.length() - 1; i &lt; j; i++, j--) {
      while (i &lt; j &amp;&amp; !Character.isLetter(s.charAt(i))) {
        i++;
      }
      while (i &lt; j &amp;&amp; !Character.isLetter(s.charAt(j))) {
        j--;
      }

      if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) {
        return false;
      }
    }

    return true;
  }
}
</code></pre>
<h3 id="reversstringsnippet"><a class="header" href="#reversstringsnippet">ReversStringSnippet</a></h3>
<pre><code class="language-java">package string;

/**
 * ReversStringSnippet.
 */
public class ReverseStringSnippet {

  /**
   * Reverse string.
   *
   * @param s the string to reverse
   * @return reversed string
   */
  public static String reverseString(String s) {
    return new StringBuilder(s).reverse().toString();
  }
}
</code></pre>
<h3 id="stringtodatesnippet"><a class="header" href="#stringtodatesnippet">StringToDateSnippet</a></h3>
<pre><code class="language-java">package string;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;

/**
 * StringToDateSnippet.
 */
public class StringToDateSnippet {

  /**
   * Convert string to date.
   *
   * @param date   the date string
   * @param format expected date format
   * @return Date
   * @throws ParseException in case of an unparseable date string
   */
  public static Date stringToDate(String date, String format) throws ParseException {
    var simpleDateFormat = new SimpleDateFormat(format);
    return simpleDateFormat.parse(date);
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="threadpool"><a class="header" href="#threadpool">ThreadPool</a></h3>
<pre><code class="language-java">package thread;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

/**
 * ThreadPool.
 */
public class ThreadPool {

  /**
   * &lt;p&gt;Creates pool of threads. Where the pool is the size of the number of processors
   * available to the Java virtual machine.&lt;/p&gt;
   *
   * @return the newly created thread pool
   */
  public static ExecutorService createFixedThreadPool() {
    return Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());
  }
}
</code></pre>
<h3 id="threadsnippet"><a class="header" href="#threadsnippet">ThreadSnippet</a></h3>
<pre><code class="language-java">package thread;

/**
 * ThreadSnippet.
 */
public class ThreadSnippet {

  /**
   * Creates and returns a new thread with the task assigned to it
   * (task will be performed parallel to the main thread).
   *
   * @param task the task to be executed by this thread
   * @return new thread with task assigned to it.
   */
  public static Thread createThread(Runnable task) {
    return new Thread(task);
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hướng-dẫn-spring-boot"><a class="header" href="#hướng-dẫn-spring-boot">Hướng dẫn Spring Boot</a></h1>
<p>Mình lưu lại một phần nội dung trang của loda-kun về, do trang đã không còn nữa nên đây là bản Backup lại. Bạn có thể truy cập vào <a href="https://github.com/loda-kun">trang Github của tác giả gốc</a>. Các bài viết trong đây đã được sửa lại và tối ưu về mặt nội dung để thuận tiện cho việc sử dụng cá nhân. Bạn có thể đọc toàn bộ nội dung khóa học này trên viblo của Nguyễn Hoàng Nam.</p>
<p>Một framework mạnh mẽ mà bất kì Java Developer nào cũng phải biết! Bắt đầu nào! Phần source code có thể đọc trên <a href="https://github.com/loda-kun/spring-boot-learning">loda-kun/spring-boot-learning</a></p>
<h3 id="bài-học"><a class="header" href="#bài-học">Bài học</a></h3>
<ul>
<li>🦽 [core] <a href="spring-boot/core1.html">Khái niệm tight-coupling (liên kết ràng buộc) và cách loosely coupled</a></li>
<li>🌛 [core] <a href="spring-boot/core2.html">Giải thích Dependency Injection (DI) và IoC bằng Ngọc Trinh</a></li>
<li>📖 [SB1] <a href="spring-boot/sb1.html">Hướng dẫn @Component và @Autowired</a></li>
<li>☎️ [SB2] <a href="spring-boot/sb2.html">@Autowired - @Primary - @Qualifier</a></li>
<li>🚤 [SB3] <a href="spring-boot/sb3.html">Spring Bean Life Cycle + @PostConstruct và @PreDestroy</a></li>
<li>🌟 [SB4] <a href="spring-boot/sb4.html">@Component vs @Service vs @Repository</a></li>
<li>📃 [SB5] <a href="spring-boot/sb5.html">Component Scan là gì?</a></li>
<li>📹 [SB6] <a href="spring-boot/sb6.html">@Configuration và @Bean</a></li>
<li>🚌 [SB7] <a href="spring-boot/sb7.html">Spring Boot Application Config và @Value</a></li>
<li>📞 [SB8] <a href="spring-boot/sb8.html">Tạo Web Helloworld với @Controller + Thymeleaf</a></li>
<li>🧵 [SB9] <a href="spring-boot/sb9.html">Giải thích cách Thymeleaf vận hành + Expression + Demo Full</a></li>
<li>🎲 [SB10] <a href="spring-boot/sb10.html">@RequestMapping + @PostMapping + @ModelAttribute + @RequestParam + Web To-Do với Thymeleaf</a></li>
<li>🎎 [SB11] <a href="spring-boot/sb11.html">Hướng dẫn Spring Boot JPA + MySQL</a></li>
<li>🎺 [SB12] <a href="spring-boot/sb12.html">Spring JPA Method + @Query</a></li>
<li>📺 [SB13] <a href="spring-boot/sb13.html">Chi tiết Spring Boot + Thymeleaf + MySQL + i18n + Web Demo</a></li>
<li>🖊️ [SB14] <a href="spring-boot/sb14.html">Restful API + @RestController + @PathVariable + @RequestBody</a></li>
<li>🚉 [SB15] <a href="spring-boot/sb15.html">Exception Handling @ExceptionHandler + @RestControllerAdvice / @ControllerAdvice + @ResponseStatus</a></li>
<li>📰 [SB16] <a href="spring-boot/sb16.html">Hướng dẫn sử dụng @ConfigurationPropertie</a></li>
<li>🌈 [SB17] <a href="spring-boot/sb17.html">Chạy nhiều môi trường với Spring Profile</a></li>
<li>🗺️ [SB18] <a href="spring-boot/sb18.html">Hướng dẫn chi tiết Test Spring Boot</a></li>
<li>🔩 [SB19] <a href="spring-boot/sb19.html">Hướng dẫn chi tiết Test Spring Boot (Phần 2)</a></li>
<li>📠 [SB20] <a href="spring-boot/sb20.html">Hướng dẫn toàn tập Mockito</a></li>
<li>🎷 [SB21] <a href="spring-boot/sb21.html">Hướng dẫn tạo Bean có điều kiện với @Conditional</a></li>
<li>🎯 [SB22] <a href="spring-boot/sb22.html">Hướng dẫn tự tạo custom @Conditional</a></li>
<li>🎗️ [SB23] <a href="spring-boot/sb23.html">Xử lý sự kiện với @EventListener + @Async</a></li>
<li>😅 [SB24] <a href="spring-boot/sb24.html">RESTful API Document Tạo với Spring Boot + Swagger</a></li>
<li>🛳️ [SB25] <a href="spring-boot/sb25.html">RESTful API Document với Spring Boot + OpenApi 3.0</a></li>
<li>⚔️「Jpa」<a href="spring-boot/jpa1.html">Hibernate là gì?</a></li>
<li>🎊「Jpa」<a href="spring-boot/jpa2.html">Hướng dẫn sử dụng Specification (Phần 1)</a></li>
<li>🪂「Jpa」<a href="spring-boot/jpa3.html">Hướng dẫn sử dụng @OneToOne</a></li>
<li>🚅「Jpa」<a href="spring-boot/jpa4.html">@OneToMany và @ManyToOne</a></li>
<li>🛵「Jpa」<a href="spring-boot/jpa5.html">Hướng dẫn @ManyToMany</a></li>
<li>🏆「Jpa」<a href="spring-boot/jpa6.html">Hướng dẫn Query phân trang bằng Pageable (Phần 1)</a></li>
<li>🪟「Jpa」<a href="spring-boot/jpa7.html">Hướng dẫn sử dụng Criteria API trong Hibernate</a></li>
<li>📈「Jpa」<a href="spring-boot/jpa8.html">Hướng dẫn sử dụng Criteria API trong Hibernate (Phần 2)</a></li>
<li>🧺「Jpa」<a href="spring-boot/jpa9.html">Hướng dẫn tự tạo Validator để kiểm tra Model &amp; Entity</a></li>
<li>🏟️ [SS] <a href="spring-boot/ss1.html">Hướng dẫn Spring Security cơ bản, dễ hiểu</a></li>
<li>⛳ [SS] <a href="spring-boot/ss2.html">Hướng dẫn Spring Security + Jpa Hibernate</a></li>
<li>🎐 [SS] <a href="spring-boot/ss3.html">Hướng dẫn Spring Security + JWT (Json Web Token) + Hibernate</a></li>
<li>⛽ <a href="spring-boot/redis.html">Hướng dẫn Spring Boot + Redis</a></li>
</ul>
<p>Chúc các bạn học tập hiệu quả!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="khái-niệm-tightly-coupled-liên-kết-ràng-buộc-và-cách-để-loosely-coupled"><a class="header" href="#khái-niệm-tightly-coupled-liên-kết-ràng-buộc-và-cách-để-loosely-coupled">Khái niệm tightly-coupled (liên kết ràng buộc) và cách để loosely-coupled</a></h1>
<h3 id="Định-nghĩa"><a class="header" href="#Định-nghĩa">Định nghĩa</a></h3>
<ul>
<li><strong>Tight-coupling</strong> hay &quot;liên kết ràng buộc&quot; là một khái niệm trong Java ám chỉ việc mối quan hệ giữa các Class quá chặt chẽ. Khi yêu cầu thay đổi logic hay một class bị lỗi sẽ dẫn tới ảnh hưởng tới toàn bộ các Class khác.</li>
<li><strong>loosely-coupled</strong> là cách ám chỉ việc làm giảm bớt sự phụ thuộc giữa các Class với nhau.</li>
</ul>
<h3 id="ví-dụ-dễ-hiểu"><a class="header" href="#ví-dụ-dễ-hiểu"><strong>Ví dụ dễ hiểu</strong></a></h3>
<p>Lấy một ví dụ:</p>
<p>Bạn có một Class thực thi một nhiệm vụ cực kỳ phức tạp, và một trong số đó là việc sắp xếp dữ liệu trước khi xử lý.</p>
<h3 id="cách-code-level-1"><a class="header" href="#cách-code-level-1"><strong>Cách code level 1:</strong></a></h3>
<pre><code>public class BubbleSortAlgorithm{

    public void sort(int[] array) {
        // TODO: Add your logic here
        System.out.println(&quot;Đã sắp xếp bằng thuật toán sx nổi bọt&quot;);
    }
}

public class VeryComplexService {
    private BubbleSortAlgorithm bubbleSortAlgorithm = new BubbleSortAlgorithm();
    
    public VeryComplexService(){

    }

    public void complexBusiness(int array[]){
        bubbleSortAlgorithm.sort(array);
        // TODO: more logic here
    }
}
</code></pre>
<p>Với cách làm ở trên, <code>VeryComplexService</code> đã hoàn thiện được nhiệm vụ, tuy nhiên, khi có yêu cầu <strong>thay đổi</strong> thuật toán sắp xếp sang <code>QuickSort</code> thì nghe vẻ chúng ta sẽ phải sửa lại hoàn toàn cả 2 Class trên.</p>
<p>Ngoài ra <code>BubbleSortAlgorithm</code> sẽ chỉ tồn tại nếu <code>VeryComplexService</code> tồn tại, vì <code>VeryComplexService</code> tạo đối tượng <code>BubbleSortAlgorithm</code> bên trong nó (hay nói cách khác là sự sống chết của <code>BubbleSortAlgorithm</code> sẽ do <code>VeryComplexService</code> quyết định), theo như cách implement này, nó là liên kết rất chặt với nhau.</p>
<h3 id="cách-làm-level-2"><a class="header" href="#cách-làm-level-2"><strong>Cách làm level 2:</strong></a></h3>
<pre><code>public interface SortAlgorithm {
    /**
     * Sắp xếp mảng đầu vào
     * @param array
     */
    public void sort(int array[]);
}

public class BubbleSortAlgorithm implements SortAlgorithm{

    @Override
    public void sort(int[] array) {
        // TODO: Add your logic here
        System.out.println(&quot;Đã sắp xếp bằng thuật toán sx nổi bọt&quot;);
    }
}

public class VeryComplexService {
    private SortAlgorithm sortAlgorithm;
    public VeryComplexService(){
        sortAlgorithm = new BubbleSortAlgorithm();
    }

    public void complexBusiness(int array[]){
        sortAlgorithm.sort(array);
        // TODO: more logic here
    }
}
</code></pre>
<p>Với cách làm này, <code>VeryComplexService</code> sẽ chỉ quan hệ với một interface <code>SortAlgorithm</code>. Với cách này thì mỗi quan hệ giảm bớt sự liên kết, nhưng nó không thay đổi được việc thuật toán vẫn đang là <code>BubbleSortAlgorithm</code>.</p>
<h3 id="cách-làm-level-3"><a class="header" href="#cách-làm-level-3"><strong>Cách làm level 3:</strong></a></h3>
<pre><code>public interface SortAlgorithm {
    /**
     * Sắp xếp mảng đầu vào
     * @param array
     */
    public void sort(int array[]);
}

public class BubbleSortAlgorithm implements SortAlgorithm{

    @Override
    public void sort(int[] array) {
        // TODO: Add your logic here
        System.out.println(&quot;Đã sắp xếp bằng thuật toán sx nổi bọt&quot;);
    }
}

public class QuicksortAlgorithm implements SortAlgorithm {
    @Override
    public void sort(int[] array) {
        // TODO: Add your logic here
        System.out.println(&quot;Đã sắp xếp bằng thuật sx nhanh&quot;);

    }
}

public class VeryComplexService {
    private SortAlgorithm sortAlgorithm;
    public VeryComplexService(SortAlgorithm sortAlgorithm){
        this.sortAlgorithm = sortAlgorithm;
    }

    public void complexBusiness(int array[]){
        sortAlgorithm.sort(array);
        // TODO: more logic here
    }
}

public static void main(String[] args) {
    SortAlgorithm bubbleSortAlgorithm = new BubbleSortAlgorithm();
    SortAlgorithm quickSortAlgorithm = new QuicksortAlgorithm();
    VeryComplexService business1 = new VeryComplexService(bubbleSortAlgorithm);
    VeryComplexService business2 = new VeryComplexService(quickSortAlgorithm);
}
</code></pre>
<p>Cách thứ ba này cũng là cách làm phổ biển nhất. Mối liên hệ giữa 2 Class đã &quot;lỏng lẻo&quot; hơn trước rất nhiều. <code>VeryComplexService</code> sẽ không quan tâm tới việc thuật toán sắp xép là gì nữa, mà chỉ cần tập trung vào nghiệp vụ. Còn <code>SortAlgorithm</code> sẽ được đưa vào từ bên ngoài tùy theo nhu cầu sử dụng.</p>
<h3 id="dependency-injection"><a class="header" href="#dependency-injection"><strong>Dependency Injection</strong></a></h3>
<p>Sau khi bạn đã nắm được 2 khái niệm <strong>tight-coupling</strong> và <strong>loosely-coupled</strong> thì sẽ có thể hiểu dễ dàng khái niệm <strong>Dependency Injection</strong>. Một trong những nhân tố chính giúp cuộc đời lập trình Java của bạn trở nên tươi sáng hơn.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="giải-thích-dependency-injection-di-và-ioc"><a class="header" href="#giải-thích-dependency-injection-di-và-ioc">Giải thích Dependency Injection (DI) và IoC</a></h1>
<p>Nhưng không phải dùng quả minh họa của Loda =)).</p>
<h3 id="dependency-injection-di"><a class="header" href="#dependency-injection-di">Dependency Injection (DI)</a></h3>
<p>Trong tài liệu có nói thế này: <em>Dependency Injection is a design pattern,...</em>. Thế thì bạn có thể hiểu nôm na nó là một phương pháp lập trình. Dưới đây là ví dụ (Khum thích ví dụ của Loda nên viết lại chút):</p>
<pre><code>public class BoDoi {
    private AK47 gun; // Mỗi chú bộ đội sẽ cầm AK47 khi đi ra ngoài chẳng hạn
    public BoDoi(){
      gun = new AK47(); // Khi anh bộ đội ra ngoài, anh sẽ vác theo khẩu AK47
    }
}
</code></pre>
<p>Trước hết, qua đoạn code này, bạn sẽ thấy là khi bạn tạo ra một anh <code>BoDoi</code>, bạn sẽ tạo ra thêm 1 khẩu <code>AK47</code> đi kèm với anh ấy. Lúc này,<code>AK47</code> tồn tại mang ý nghĩa là dependency (phụ thuộc) của <code>BoDoi</code>.</p>
<p>Khi khởi tạo thuộc tính như này, bạn vô tình tạo ra một điểm thắt nút trong chương trình của mình, giả sử, <code>BoDoi</code> muốn cầm M4A1 hay AWP hoặc cần gì cầm súng khi đi mua bia cơ chứ? Bạn sẽ phải thay class <code>AK47</code> thành <code>M4A1</code> hay <code>TayKhông</code> ư?</p>
<p>Hay nguy hiểm hơn, khẩu <code>AK47</code> bị hỏng? (code lớp <code>AK47</code> không hoạt động?) nó sẽ ảnh hưởng trực tiếp tới chú bộ đội <code>BoDoi</code>.</p>
<p>Vấn đề là ở đó, nguyên tắc là:</p>
<blockquote>
<p>Các Class không nên phụ thuộc vào các kế thừa cấp thấp, mà nên phụ thuộc vào Abstraction (lớp trừu tượng).</p>
</blockquote>
<p>Nghe hơi khó hiểu. Bây giờ mình thay đoạn code như này:</p>
<pre><code>// Một interface cho việc dùng súng
public interface EquipGun {
  public void equip();
}

// Một object cấp thấp, implement của EquipGun
public class AK47 implements EquipGun {
  public void equip() {
    System.out.println(&quot;Đã đeo AK47&quot;);
  }
}

// Bây giờ BoDoi chỉ phụ thuộc vào EquipGun. nếu muốn thay đổi súng của anh ấy, chúng ta chỉ cần cho EquipGun một thể hiện mới.

public class BoDoi {
    private EquipGun equipGun;
    public BoDoi() {
      equipGun = new AK47();
    }
}
</code></pre>
<p>Tới đây, chúng ta mới chỉ <code>Abtract</code> hóa thuộc tính của <code>BoDoi</code> mà thôi, còn thực tế, <code>BoDoi</code> vẫn đang bị gắn với một khẩu <code>AK47</code> duy nhất. Vậy muốn thay súng cho anh ấy, bạn phải làm như nào.</p>
<p>Phải sửa <code>code</code> thêm chút nữa:</p>
<pre><code>public class BoDoi{
    private EquipGun gun;
    public BoDoi(EquipGun anything){
      this.gun = anything // Tạo ra một anh BoDoi, với súng tùy biến
      // Không bị phụ thuộc quá nhiều vào thời điểm khởi tạo, hay code.
    }
}

public class Main {
  public static void main(String[] args) {
    EquipGun AK47 = new AK47(); // Tạo ra đối tượng AK47 ở ngoài đối tượng
    BoDoi truongAnhNgoc = new BoDoi(AK47); // Cho anh đeo súng khi được khởi tạo
  }
}
</code></pre>
<p>Với đoạn code ở trên, chúng ta đã_gần như tách được <code>AK47</code> ra hoàn toàn khỏi <code>BoDoi</code>. điều này làm giảm sự phụ thuộc giữa<code>BoDoi</code>và<code>AK47</code>. Mà tăng tính tùy biến, linh hoạt cho<code>code</code>.</p>
<p>Bây giờ <code>BoDoi</code> sẽ hoạt động với <code>EquipGun</code> mà thôi. Và <code>EquipGun</code> ở đâu ra? Chúng ta tạo ra và đưa nó vào <code>(Inject)</code> anh <code>BoDoi</code>.</p>
<p>Khái niệm <code>Dependency Injection</code> từ đây mà ra~</p>
<blockquote>
<p>Dependency Injection là việc các Object nên phụ thuộc vào các Abstract Class và thể hiện chi tiết của nó sẽ được Inject vào đối tượng lúc runtime.</p>
</blockquote>
<p>Bây giờ muốn <code>BoDoi</code> dùng súng gì khác, bạn chỉ cần tạo một Class kế thừa <code>EquipGun</code> và <em>Inject</em> (dịch là <em>Tiêm vào</em> cũng được) nó vào <code>BoDoi</code> là xong!</p>
<p>Các cách để <em>Inject dependency</em> vào một đối tượng có thể kể đến như sau:</p>
<ul>
<li>Constructor Injection: Cái này chính là ví dụ của mình, tiêm dependency ngay vào<code>Contructor</code> cho tiện.</li>
<li>Setter Injection:  Xài <code>BoDoi.setEquipGun(new P2000())</code> (Round đầu chỉ cần P2000 thôi)</li>
<li>Interface Injection : Mỗi <code>Class</code> muốn inject cái gì, thì phải <em>implement</em> một<code>Interface</code> có chứa một hàm <code>inject(xx)</code> (Gần như thay thế cho setter ý bạn). Rồi bạn muốn inject gì đó thì gọi cái hàm <code>inject(xx)</code> ra. Cách này hơi dài và khó cho người mới.</li>
</ul>
<h3 id="inversion-of-control"><a class="header" href="#inversion-of-control">Inversion of Control</a></h3>
<p><code>Dependency Injection</code> giúp chúng ta dễ dàng mở rộng <code>code</code> và giảm sự phụ thuộc giữa các dependency với nhau. Tuy nhiên, lúc này, khi code bạn sẽ phải kiêm thêm nhiệm vụ <code>Inject dependency (tiêm sự phụ thuộc)</code>. Thử tưởng tượng một <code>Class</code> có hàng chục dependency thì bạn sẽ phải tự tay inject từng ý cái. Việc này lại dẫn tới khó khăn trong việc code, quản lý code và dependency</p>
<pre><code>public static void main(String[] args) {
    EquipGun AK47 = new AK47();
    AoChongDan gucci = new AoChongDan();
    MuBaoHiem muCoi = new MuBaoHiem();
    BoDoi truongAnhNgoc = new BoDoi(AK47, gucci, muCoi);
}
</code></pre>
<p>Bây giờ giả sử, chúng ta định nghĩa trước toàn bộ các <code>dependency</code> có trong Project, mô tả nó và tống nó vào 1 cái <code>kho</code> và giao cho một thằng tên là <code>framework</code> quản lý. Bất kỳ các <code>Class</code> nào khi khởi tạo, nó cần dependency gì, thì cái <code>framework</code> này sẽ tự tìm trong <code>kho</code> rồi <em>inject</em> vào đối tượng thay chúng ta. sẽ tiện hơn phải không?</p>
<p>Và, đó cũng chính là nguyên lý chính của<code>Inversion of Control (IOC)</code>-<code>Đảo chiều sự điều khiển</code></p>
<p>Nguyên văn Wiki:</p>
<blockquote>
<p>Inversion of Control is a programming principle. flow of control within the application is not controlled by the application itself, but rather by the underlying framework.</p>
</blockquote>
<p>Khi đó, code chúng ta sẽ chỉ cần như này, để lấy ra 1 đối tượng:</p>
<pre><code>@Override
public void run(String... args) throws Exception {
    BoDoi BoDoi = context.getBean(BoDoi.class);
}
</code></pre>
<p>Đối với <code>Java</code> thì có một số Framework hỗ trợ chúng ta<code>Inversion of Control (IOC)</code>. Thường thì dùng luôn Spring framework. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="component-và-autowired"><a class="header" href="#component-và-autowired">@Component và @Autowired</a></h1>
<p><a href="https://viblo.asia/p/spring-boot-1-huong-dan-atcomponent-va-atautowired-E375zXvJZGW">Đường dẫn bài viết</a></p>
<p>Thường thì giờ đã có <a href="https://start.spring.io/">Spring Initializr</a> rồi nên thêm dự án mới rất dễ!</p>
<h3 id="việc-chạy-ứng-dụng-spring-boot"><a class="header" href="#việc-chạy-ứng-dụng-spring-boot">Việc chạy ứng dụng Spring Boot</a></h3>
<p>Chương trình chạy ở hàm <code>main()</code> và cần thêm annotation <code>@SpringBootApplication</code> trên class chính và gọi <code>SpringApplication.run(App.class, args);</code> để chạy project (Cho Spring Boot biết <code>main()</code> ở chỗ nào). <code>SpringApplication.run(App.class, args)</code> chính là câu lệnh để tạo ra <em>container</em>. Sau đó nó tìm toàn bộ các <em>dependency</em> trong project của bạn và đưa vào đó.</p>
<pre><code class="language-java">import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.ApplicationContext;

@SpringBootApplication
public class App {
    public static void main(String[] args) {
        // ApplicationContext chứa toàn bộ dependency trong project.
        SpringApplication.run(App.class, args);
    }
}
</code></pre>
<p>Spring đặt tên cho:</p>
<ul>
<li><em>container</em> là <code>ApplicationContext</code></li>
<li><em>dependency</em> là <code>Bean</code> (Để biết cái nào là <em>dependency</em> thì dùng <code>@Component</code>)</li>
</ul>
<h3 id="component"><a class="header" href="#component">@Component</a></h3>
<p>@Component là một Annotation (chú thích) đánh dấu trên các Class để giúp Spring biết nó là một Bean. </p>
<p>Trong quá trình dò các <em>classes</em>, khi gặp một class được đánh dấu <code>@Component</code> thì nó sẽ tạo ra một instance và đưa vào <code>ApplicationContext</code> để quản lý.</p>
<pre><code class="language-java">// ApplicationContext chính là container, chứa toàn bộ các Bean
ApplicationContext context = SpringApplication.run(App.class, args);
// Khi chạy xong, lúc này context sẽ chứa các Bean có đánh
// dấu @Component.
// Lấy Bean ra bằng cách
Outfit outfit = context.getBean(Outfit.class);
// In ra để xem thử nó là gì
System.out.println(&quot;Instance: &quot; + outfit);
// xài hàm wear()
outfit.wear();
// Output
// [1] Instance: me.loda.spring.helloworld.Bikini@1e1f6d9d
// [2] Mặc bikini
</code></pre>
<p>Danh sách các bước đơn giản là:</p>
<ol>
<li>Chạy <code>SpringApplication.run(App.class, args);</code></li>
<li>Dò tìm các Classes cùng cấp.</li>
<li>Thấy Class được đánh dấu bằng <code>@Component</code> thì tạo <code>new Customer()</code> chẳng hạn và đưa vào Context (Hay <code>ApplicationContext</code>)</li>
</ol>
<h3 id="autowired"><a class="header" href="#autowired">@Autowired</a></h3>
<pre><code>@Component
public class TuiXach {

    @Autowired
    Money tien;

    public TuiXach (Money tien) {
        this.tien = tien;
    }
}
</code></pre>
<p>Tôi đánh dấu thuộc tính <code>Money</code> (Tiền) của <code>TuiXach</code> (Túi xách) bởi Annotation <code>@Autowired</code>. Điều này nói với Spring Boot hãy tự <em>inject</em> (tiêm) một instance của <code>Money</code> vào thuộc tính này khi khởi tạo <code>TuiXach</code> (Thuộc tính được đánh dấu là <code>@Autowired</code> trong Class được đánh dấu là <code>Component</code>).</p>
<h3 id="singleton"><a class="header" href="#singleton">Singleton</a></h3>
<p>Điều đặc biệt là các <code>Bean</code> được quản lý bên trong <code>ApplicationContext</code> đều là singleton.</p>
<p>Tất cả những <code>Bean</code> được quản lý trong <code>ApplicationContext</code> đều chỉ được tạo ra một lần duy nhất và khi có <code>Class</code> yêu cầu <code>@Autowired</code> thì nó sẽ lấy đối tượng có sẵn trong <code>ApplicationContext</code> để <em>inject</em> vào.</p>
<p>Trong trường hợp bạn muốn mỗi lần sử dụng là một instance hoàn toàn mới. Thì hãy đánh dấu <code>@Component</code> đó bằng <code>@Scope(&quot;prototype&quot;)</code></p>
<h3 id="inject-là-cái-quái-gì-vậy"><a class="header" href="#inject-là-cái-quái-gì-vậy">Inject là cái quái gì vậy?</a></h3>
<p>Đây không phải là phần hướng dẫn của loda, nhưng mình vẫn chưa hiểu <em>inject</em> (về cơ bản nghĩa là tiêm) là gì? Thử lấy ví dụ về truyền dịch.</p>
<p><em>Truyền nước biển còn gọi là truyền dịch là phương pháp đưa nhỏ giọt muối và các chất điện giải vào cơ thể bằng đường tĩnh mạch khi có chỉ định của bác sĩ.</em></p>
<p>Khi đó thành các <em>giọt muối và các chất điện giải</em> sẽ được <em>inject</em> và trở thành <em>thuộc tính</em> trong bạn. Mỗi một Class trong Java cũng như bạn, là một <em>đối tượng</em> (dm giải thích ngu quá mà tính lấy ví dụ Peter Park được nhện chích và thành Spider Man thì có phải hay không???)</p>
<p><em>Dependency Injection</em> cho phép &quot;inject&quot; (tiêm) những dependencies vào một đối tượng. Thay vì đối tượng phải tự tạo ra những Dependencies của chính nó. Điều này sẽ giúp giảm khả năng phụ thuộc giữa những thành phần. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="autowired---primary---qualifier"><a class="header" href="#autowired---primary---qualifier">@Autowired - @Primary - @Qualifier</a></h1>
<p>Trong bài viết này chúng ta sẽ cùng tìm hiểu cách <code>@Autowỉed</code> vận hành và cách sử dụng 2 Annotation <code>@Primary</code>, <code>@Qualifier</code>.</p>
<h3 id="cách-inject-bean-của-spring"><a class="header" href="#cách-inject-bean-của-spring">Cách inject Bean của Spring</a></h3>
<p><code>@Autowired</code> đánh dấu cho Spring biết rằng sẽ tự động inject bean tương ứng vào vị trí được đánh dấu.</p>
<pre><code>@Component
public class Girl {
    // Đánh dấu để Spring inject một đối tượng Outfit vào đây
    @Autowired
    Outfit outfit;

    // public Girl(Outfit outfit) {
    //     this.outfit = outfit;
    // }

    // GET
    // SET
}
</code></pre>
<p>Sau khi tìm thấy một class đánh dấu <code>@Component</code>. thì quá trình inject <code>Bean</code> xảy ra theo cách như sau:</p>
<ol>
<li>Nếu <code>Class</code> không có hàm Constructor hay Setter. Thì sẽ sử dụng Java Reflection để đưa đối tượng vào thuộc tính có đánh dấu <code>@Autowired</code>.</li>
<li>Nếu có hàm Constructor thì sẽ inject Bean vào bởi tham số của hàm</li>
<li>Nếu có hàm Setter thì sẽ inject Bean vào bởi tham số của hàm</li>
</ol>
<p>Như ví dụ ở trên tôi đã sử dụng cách Java Reflection để inject <code>Bean</code> vào class <code>Girl</code>. </p>
<p>Bạn cũng có thể gắn <code>@Autowired</code> lên trên method, thay vì thuộc tính, chức năng cũng vẫn tương tự, nó sẽ tìm Bean phù hợp với method đó và truyền vào.</p>
<pre><code class="language-java">@Component
public class Girl {

    // Đánh dấu để Spring inject một đối tượng Outfit vào đây
    @Autowired
    Outfit outfit;

    // Spring sẽ inject outfit thông qua Constructor trước
    public Girl() { }

    // Nếu không tìm thấy Constructor thoả mãn, nó sẽ thông qua setter
    public void setOutfit(Outfit outfit) {
        this.outfit = outfit;
    }

    @Autowired
    // Nếu không tìm thấy Constructor thoả mãn, nó sẽ thông qua setter, 
    // nếu v thì đừng gắn Autowired ở properties ở trên nha
    public void setOutfit(Outfit outfit) {
        this.outfit = outfit;
    }

    // GET
    // SET
}
</code></pre>
<p>Nếu không sử dụng <code>@Autowired</code> thì bạn phải có một Constructor thay thế, hoặc một Setter tương ứng. Khá nhiều các đồng chí gợi ý không dùng <code>@Autowired</code> và thay thế bằng:</p>
<pre><code class="language-java">@Component
public class Calculator {
   private Multiplier multiplier;
   // Cái lày là constructor
   public Calculator(Multiplier multiplier) {
      this.multiplier = multiplier;
   }
}
</code></pre>
<h3 id="vấn-đề-của-autowired"><a class="header" href="#vấn-đề-của-autowired">Vấn đề của @Autowired</a></h3>
<p>Trong thực tế, sẽ có trường hợp chúng ta sử dụng <code>@Autowired</code> khi <strong>Spring Boot</strong> có chứa 2 Bean cùng loại trong Context. Lúc này thì <strong>Spring</strong> sẽ bối rối và không biết sử dụng Bean nào để inject vào đối tượng.</p>
<h3 id="primary"><a class="header" href="#primary"><strong>@Primary</strong></a></h3>
<p>Cách giải quyết thứ nhất là sử dụng Annotation <code>@Primary</code>. <code>@Primary</code> là annotation đánh dấu trên một Bean, giúp nó <strong>luôn được ưu tiên lựa</strong> chọn trong trường hợp có nhiều Bean cùng loại trong Context.</p>
<p>Trong ví dụ ở trên, nếu chúng ta để <code>Suit</code> là primary. Thì chương trình sẽ chạy bình thường. Và hiển nhiên <code>Outfit</code> bên trong <code>Girl</code> sẽ là <code>Suit</code>.</p>
<p>Chạy thử chương trình:</p>
<pre><code class="language-java">// ===========================================================================
@Component
@Primary
public class Suit implements Outfit {
    @Override
    public void wear() {
        System.out.println(&quot;Đang mặc âu phục&quot;);
    }
}
// ===========================================================================
@SpringBootApplication
public class App {
    public static void main(String[] args) {
        // ApplicationContext chính là container, chứa toàn bộ các Bean
        ApplicationContext context = SpringApplication.run(App.class, args);
        // Khi chạy xong, lúc này context sẽ chứa các Bean có đánh
        // dấu @Component.
        Girl girl = context.getBean(Girl.class);
        System.out.println(&quot;Girl Instance: &quot; + girl);
        System.out.println(&quot;Girl Outfit: &quot; + girl.outfit);
        girl.outfit.wear();
    }
}
// ===========================================================================
// Output:
// Girl Instance: me.loda.spring.helloprimaryqualifier.Girl@eb9a089
// Girl Outfit: me.loda.spring.helloprimaryqualifier.Naked@1688653c
// Đang mặc âu phục
</code></pre>
<h3 id="qualifier"><a class="header" href="#qualifier"><strong>@Qualifier</strong></a></h3>
<p>Cách thứ hai, là sử dụng Annotation <code>@Qualifier</code>. <code>@Qualifier</code> xác định tên của một Bean mà bạn muốn chỉ định inject.</p>
<p>Ví dụ:</p>
<pre><code class="language-java">@Component(&quot;suit&quot;)
public class Suit implements Outfit {
    @Override
    public void wear() {
        System.out.println(&quot;Mặc âu phục&quot;);
    }
}

// ==============================================
@Component
public class Girl {

    Outfit outfit;

    // Đánh dấu để Spring inject một đối tượng Outfit vào đây
    public Girl(@Qualifier(&quot;suit&quot;) Outfit outfit) {
        // Spring sẽ inject outfit thông qua Constructor đầu tiên
        // Ngoài ra, nó sẽ tìm Bean có @Qualifier(&quot;naked&quot;) trong context để ịnject
        this.outfit = outfit;
    }
    // GET
    // SET
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="spring-bean-life-cycle--postconstruct-và-predestroy"><a class="header" href="#spring-bean-life-cycle--postconstruct-và-predestroy">Spring Bean Life Cycle + @PostConstruct và @PreDestroy</a></h1>
<p>Tìm hiểu về vòng đời của Bean</p>
<h3 id="postconstruct"><a class="header" href="#postconstruct">@PostConstruct</a></h3>
<p><code>@PostConstruct</code> được đánh dấu trên một method duy nhất bên trong <code>Bean</code>. </p>
<p><code>IoC Container</code> hoặc <code>ApplicationContext</code> sẽ gọi hàm này sau khi một <code>Bean</code> được tạo ra và quản lý.</p>
<pre><code>@Component
public class Girl {
    
    @PostConstruct
    public void postConstruct(){
        System.out.println(&quot;\t&gt;&gt; Đối tượng Girl sau khi khởi tạo xong sẽ chạy hàm này&quot;);
    }
}
</code></pre>
<h3 id="predestroy"><a class="header" href="#predestroy">@PreDestroy</a></h3>
<p><code>@PreDestroy</code> được đánh dấu trên một method duy nhất bên trong <code>Bean</code>. </p>
<p><code>IoC Container</code> hoặc <code>ApplicationContext</code> sẽ gọi hàm này trước khi một <code>Bean</code> bị xóa hoặc không được quản lý nữa.</p>
<pre><code>@Component
public class Girl {

    @PreDestroy
    public void preDestroy(){
        System.out.println(&quot;\t&gt;&gt; Đối tượng Girl trước khi bị destroy thì chạy hàm này&quot;);
    }
}
</code></pre>
<h3 id="bean-life-cycle"><a class="header" href="#bean-life-cycle">Bean Life Cycle</a></h3>
<p>Spring Boot từ thời điểm chạy lần đầu tới khi <em>shutdown</em> thì các <code>Bean</code> nó quản lý sẽ có một vòng đời được biểu diễn như ảnh dưới đây.</p>
<p><img src="https://images.viblo.asia/2380e7ca-0b97-4be3-9054-27430b29e150.jpg" alt="" /></p>
<p>Nhìn có vẻ loằng ngoằng, trong series căn bản này, bạn có lẽ sẽ chỉ cần hiểu như sau:</p>
<ol>
<li>Khi <code>IoC Container</code> (<code>ApplicationContext</code>) tìm thấy một Bean cần quản lý, nó sẽ khởi tạo bằng <code>Constructor</code>.</li>
<li>inject dependencies vào <code>Bean</code> bằng Setter, và thực hiện các quá trình cài đặt khác vào <code>Bean</code> như <code>setBeanName</code>, <code>setBeanClassLoader</code>, v.v..</li>
<li>Hàm đánh dấu <code>@PostConstruct</code> được gọi</li>
<li>Tiền xử lý sau khi <code>@PostConstruct</code> được gọi.</li>
<li><code>Bean</code> sẵn sàng để hoạt động</li>
<li>Nếu <code>IoC Container</code> không quản lý bean nữa hoặc bị shutdown nó sẽ gọi hàm <code>@PreDestroy</code> trong <code>Bean</code></li>
<li>Xóa <code>Bean</code>.</li>
</ol>
<h3 id="ví-dụ"><a class="header" href="#ví-dụ">Ví dụ</a></h3>
<p>Chúng ta tạo ra class <code>Girl</code> bao gồm:</p>
<pre><code class="language-java">import org.springframework.stereotype.Component;
import javax.annotation.PostConstruct;
import javax.annotation.PreDestroy;

@Component
public class Girl {

    @PostConstruct
    public void postConstruct(){
        System.out.println(&quot;\t&gt;&gt; Đối tượng Girl sau khi khởi tạo xong sẽ chạy hàm này&quot;);
    }

    @PreDestroy
    public void preDestroy(){
        System.out.println(&quot;\t&gt;&gt; Đối tượng Girl trước khi bị destroy thì chạy hàm này&quot;);
    }
}
</code></pre>
<p>In ra màn hình quá Spring Boot chạy lần đầu cho tới khi shutdown:</p>
<pre><code class="language-java">import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ConfigurableApplicationContext;

@SpringBootApplication
public class App {
    public static void main(String[] args) {
        // ApplicationContext chính là container, chứa toàn bộ các Bean
        System.out.println(&quot;&gt; Trước khi IoC Container được khởi tạo&quot;);
        ApplicationContext context = SpringApplication.run(App.class, args);
        System.out.println(&quot;&gt; Sau khi IoC Container được khởi tạo&quot;);
        // Khi chạy xong, lúc này context sẽ chứa các Bean có đánh
        // dấu @Component.
        Girl girl = context.getBean(Girl.class);
        System.out.println(&quot;&gt; Trước khi IoC Container destroy Girl&quot;);
        ((ConfigurableApplicationContext) context).getBeanFactory().destroyBean(girl);
        System.out.println(&quot;&gt; Sau khi IoC Container destroy Girl&quot;);

    }
}
</code></pre>
<p>Output:</p>
<pre><code>&gt; Trước khi IoC Container được khởi tạo
&gt; Trước khi IoC Container được khởi tạo
	&gt;&gt; Đối tượng Girl sau khi khởi tạo xong sẽ chạy hàm này
&gt; Sau khi IoC Container được khởi tạo
&gt; Trước khi IoC Container destroy Girl
	&gt;&gt; Đối tượng Girl trước khi bị destroy thì chạy hàm này
&gt; Sau khi IoC Container destroy Girl
</code></pre>
<p>Bạn sẽ thấy dòng <em>&quot;Trước khi IoC Container được khởi tạo&quot;</em> được chạy 2 lần. Điều này xảy ra bởi vì hàm App.main(args) được chạy 2 lần!</p>
<p>Lần đầu là do chúng ta chạy. Lần thứ hai là do Spring Boot chạy sau khi nó được gọi <code>SpringApplication.run(App.class, args)</code>. Đây là lúc mà IoC Container (<code>ApplicationContext</code>) được tạo ra và đi tìm <code>Bean</code>.</p>
<h3 id="Ý-nghĩa"><a class="header" href="#Ý-nghĩa">Ý nghĩa.</a></h3>
<p><code>@PostConstruct</code> và <code>@PreDestroy</code> là 2 Annotation cực kỳ ý nghĩa, nếu bạn nắm được vòng đời của một <code>Bean</code>, bạn có thể tận dụng nó để làm các nhiệm vụ riêng như setting, thêm giá trị mặc định trong thuộc tính sau khi tạo, xóa dữ liệu trước khi xóa, v.v.. Rất nhiều chức năng khác tùy theo nhu cầu.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="component-vs-service-vs-repository"><a class="header" href="#component-vs-service-vs-repository">@Component vs @Service vs @Repository</a></h1>
<h3 id="kiến-trúc-trong-spring-boot"><a class="header" href="#kiến-trúc-trong-spring-boot">Kiến trúc trong Spring Boot</a></h3>
<p>Kiến trúc MVC trong Spring Boot được xây dựng dựa trên tư tưởng &quot;độc lập&quot; kết hợp với các nguyên lý thiết kế hướng đối tượng (một đại diện tiêu biểu là Dependency Inversion). </p>
<p>Độc lập ở đây ám chỉ việc các layer phục vụ các mục đích nhất định, khi muốn thực hiện một công việc ngoài phạm vi thì sẽ đưa công việc xuống các layer thấp hơn.</p>
<p>Kiến trúc Controller - Service - Repository chia project thành 3 lớp:</p>
<ul>
<li>Consumer Layer hay Controller: là tầng giao tiếp với bên ngoài và handler các request từ bên ngoài tới hệ thống.</li>
<li>Service Layer: Thực hiện các nghiệp vụ và xử lý logic</li>
<li>Repository Layer: Chịu trách nhiệm giao tiếp với các DB, thiết bị lưu trữ, xử lý query và trả về các kiểu dữ liệu mà tầng Service yêu cầu.</li>
</ul>
<h3 id="controller-vs-service-vs-repository"><a class="header" href="#controller-vs-service-vs-repository">@Controller vs @Service vs @Repository</a></h3>
<p>Để phục vụ cho kiến trúc ở trên, Spring Boot tạo ra 3 Annotation là <code>@Controller</code>, <code>@Service</code>, <code>@Repository</code> để chúng ta có thể đánh dấu các tầng với nhau.</p>
<ul>
<li><code>@Service</code> Đánh dấu một Class là tầng Service, phục vụ các logic nghiệp vụ.</li>
<li><code>@Repository</code> Đánh dấu một Class Là tầng Repository, phục vụ truy xuất dữ liệu.</li>
</ul>
<h3 id="implement"><a class="header" href="#implement">Implement</a></h3>
<p>Chạy chương trình:</p>
<pre><code class="language-java">import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.ApplicationContext;

@SpringBootApplication
public class App {

    public static void main(String[] args) {
        ApplicationContext context = SpringApplication.run(App.class, args);

        // Lấy ra bean GirlService
        GirlService girlService = context.getBean(GirlService.class);
        // Lấu ra random một cô gái từ tầng service
        Girl girl = girlService.getRandomGirl();
        // In ra màn hình
        System.out.println(girl);

    }
}
</code></pre>
<h3 id="giải-thích"><a class="header" href="#giải-thích">Giải thích</a></h3>
<p>Về bản chất <code>@Service</code> và <code>@Repository</code> cũng chính là <code>@Component</code>. Nhưng đặt tên khác nhau để giúp chúng ta phân biệt các tầng với nhau.</p>
<p>Cùng nhìn vào source code của 2 Annotation này:</p>
<p><em>Service.java</em></p>
<pre><code class="language-java">@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Component // Cũng là một @Component
public @interface Service {
    @AliasFor(
        annotation = Component.class
    )
    String value() default &quot;&quot;;
}
</code></pre>
<p><em>Repository.java</em></p>
<pre><code class="language-java">@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Component
public @interface Repository {
    @AliasFor(
        annotation = Component.class
    )
    String value() default &quot;&quot;;
}
</code></pre>
<p>Trong các bài đầu tiên chúng ta đã biết <code>@Component</code> đánh dấu cho Spring Boot biết Class đó là <code>Bean</code>. Và hiển nhiên <code>@Service</code> và <code>@Repository</code> cũng vậy. Vì thế ở ví dụ trên chúng ta có thể lấy <code>GirlService</code> từ <code>ApplicationContext</code>. Về bản chất thì bạn có thể sử dụng thay thế 3 Annotation <code>@Component</code>, <code>@Service</code> và <code>@Repository</code> cho nhau mà không ảnh hưởng gì tới code của bạn cả. Nó vẫn sẽ hoạt động.</p>
<p>Tuy nhiên từ góc độ thiết kế thì chúng ta cần phân rõ 3 Annotation này cho các Class đảm nhiệm đúng nhiệm vụ của nó.</p>
<ul>
<li><code>@Service</code> gắn cho các <code>Bean</code> đảm nhiệm xử lý logic</li>
<li><code>@Repository</code> gắn cho các <code>Bean</code> đảm nhiệm giao tiếp với DB</li>
<li><code>@Component</code> gắn cho các <code>Bean</code> khác.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="component-scan-là-gì"><a class="header" href="#component-scan-là-gì">Component Scan là gì?</a></h1>
<p>Chúng ta sẽ tìm hiểu thêm về cách Spring Boot tìm kiếm <code>Bean</code> trong project của bạn như thế nào.</p>
<h3 id="component-scan"><a class="header" href="#component-scan">Component Scan</a></h3>
<p>Trong bài 1 tôi có đề cập một lần về việc Spring Boot khi chạy sẽ dò tìm toàn bộ các <em>Class cùng cấp</em> hoặc ở trong các <em>package thấp hơn</em> và tạo ra Bean từ các Class tìm thấy.</p>
<p>Trong trường hợp bạn muốn tuỳ chỉnh cấu hình cho Spring Boot chỉ tìm kiếm các bean trong một package nhất định thì có các cách sau đây:</p>
<ol>
<li>Sử dụng <code>@ComponentScan</code></li>
<li>Sử dụng <code>scanBasePackages</code> tromg <code>@SpringBootApplication</code>.</li>
</ol>
<p>Bạn có thể cấu hình cho Spring Boot Tìm kiếm các Bean ở nhiều package khác nhau bằng cách</p>
<h3 id="cách-1componentscan"><a class="header" href="#cách-1componentscan">Cách 1:<code>@ComponentScan</code></a></h3>
<pre><code class="language-java">@ComponentScan(&quot;me.loda.spring.componentscan.others&quot;)
// Tìm nhiều package khác nhau
// @ComponentScan({&quot;me.loda.spring.componentscan.others2&quot;,&quot;me.loda.spring.componentscan.others&quot;})

@SpringBootApplication
public class App {
    ...
}
</code></pre>
<h3 id="cách-2scanbasepackages"><a class="header" href="#cách-2scanbasepackages">Cách 2:<code>scanBasePackages</code></a></h3>
<pre><code class="language-java">@SpringBootApplication(scanBasePackages = &quot;me.loda.spring.componentscan.others&quot;)
// Tìm nhiều package khác nhau
// @SpringBootApplication(scanBasePackages = {&quot;me.loda.spring.componentscan.others&quot;, &quot;me.loda.spring.componentscan.others2&quot;})
public class App {
  ...
}
</code></pre>
<p>Cả 2 cách đều cho kết quả in ra màn hình như sau:</p>
<pre><code>Bean Girl không tồn tại
Bean: OtherGirl.java
</code></pre>
<p>Lúc này, Spring Boot chỉ tìm kiếm các bean trong package <code>others</code> mà thôi. Nên khi lấy ra <code>Girl</code> thì nó không tồn tại trong <code>Context</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="configuration-và-bean"><a class="header" href="#configuration-và-bean">@Configuration và @Bean</a></h1>
<h3 id="configuration-và-bean-1"><a class="header" href="#configuration-và-bean-1">@Configuration và @Bean</a></h3>
<p><code>@Configuration</code> là một Annotation đánh dấu trên một <code>Class</code> cho phép Spring Boot biết được đây là nơi định nghĩa ra các <em>Bean</em>.</p>
<p><code>@Bean</code> là một Annotation được đánh dấu trên các <code>method</code> cho phép Spring Boot biết được đây là <em>Bean</em> và sẽ thực hiện đưa <em>Bean</em> này vào <code>Context</code>.</p>
<p><code>@Bean</code> sẽ nằm trong các class có đánh dấu <code>@Configuration</code>.</p>
<p>Ví dụ:</p>
<p><em>SimpleBean.java</em></p>
<pre><code class="language-java">// Một class cơ bản, không sử dụng `@Component`

public class SimpleBean {
    private String username;

    public SimpleBean(String username) {
        setUsername(username);
    }

    @Override
    public String toString() {
        return &quot;This is a simple bean, name: &quot; + username;
    }
}
</code></pre>
<p><em>AppConfig.java</em></p>
<pre><code class="language-java">import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class AppConfig {
    @Bean
    SimpleBean simpleBeanConfigure(){
        // Khởi tạo một instance của SimpleBean và trả ra ngoài
        return new SimpleBean(&quot;loda&quot;);
    }
}
</code></pre>
<p><em>App.java</em></p>
<pre><code class="language-java">import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.ApplicationContext;

@SpringBootApplication
public class App {
    public static void main(String[] args) {
        ApplicationContext context = SpringApplication.run(App.class, args);
        // Lấy ra bean SimpleBean trong Context
        SimpleBean simpleBean = context.getBean(SimpleBean.class);
        // In ra màn hình
        System.out.println(&quot;Simple Bean Example: &quot; + simpleBean.toString());
        // OUTPUT: Simple Bean Example: This is a simple bean, name: loda
    }
}
</code></pre>
<p>Bạn sẽ thấy là <code>SimpleBean</code> là một object được quản lý trong <code>Context</code> của Spring Boot, mặc dù trong bài này, chúng ta không hề sử dụng tới các khái niệm <code>@Component</code>.</p>
<h3 id="hoạt-động-nền"><a class="header" href="#hoạt-động-nền">Hoạt động nền</a></h3>
<p>Đằng sau chương trình, Spring Boot lần đầu khởi chạy, ngoài việc đi tìm các <code>@Component</code> thì nó còn làm một nhiệm vụ nữa là tìm các class <code>@Configuration</code>.</p>
<ol>
<li>Đi tìm class có đánh dấu <code>@Configuration</code></li>
<li>Tạo ra đối tượng từ class có đánh dấu <code>@Configuration</code></li>
<li>tìm các method có đánh dấu <code>@Bean</code> trong đối tượng vừa tạo</li>
<li>Thực hiện gọi các method có đánh dấu <code>@Bean</code> để lấy ra các <em>Bean</em> và đưa vào `Context.</li>
</ol>
<p>Ngoài ra, về bản chất, <code>@Configuration</code> cũng là <code>@Component</code>. Nó chỉ khác ở ý nghĩa sử dụng. (Giống với việc class được đánh dấu <code>@Service</code> chỉ nên phục vụ logic vậy).</p>
<pre><code class="language-java">@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Component // Nó được đánh dấu là Component
public @interface Configuration {
    @AliasFor(
        annotation = Component.class
    )
    String value() default &quot;&quot;;
}
</code></pre>
<h3 id="có-ý-nghĩa-gì"><a class="header" href="#có-ý-nghĩa-gì">Có ý nghĩa gì?</a></h3>
<p>Nhiều bạn sẽ tự hỏi rằng <code>@Configuration</code> và <code>@Bean</code> sẽ có ý nghĩa gì khi chúng ta đã có <code>@Component</code>? Sao không đánh dấu <code>SimpleBean</code> là <code>@Component</code> cho nhanh?</p>
<p>Các bạn thắc mắc rất đúng, và việc sử dụng <code>@Component</code> cũng hoàn toàn ổn.</p>
<p>Thông thường thì các class được đánh dấu <code>@Component</code> đều có thể tạo tự động và inject tự động được.</p>
<p>Tuy nhiên trong thực tế, nếu một <code>Bean</code> có quá nhiều logic để khởi tạo và cấu hình, thì chúng ta sẽ sử dụng <code>@Configuration</code> và <code>@Bean</code> để tự tay tạo ra <code>Bean</code>. Việc tự tay tạo ra <code>Bean</code> như này có thể hiểu phần nào là chúng ta đang <em>config</em> cho chương trình.</p>
<h3 id="ví-dụ-1"><a class="header" href="#ví-dụ-1">Ví dụ</a></h3>
<p><a href="https://viblo.asia/p/spring-boot-6-atconfiguration-va-atbean-bJzKmyprK9N#_vi-du-5">Đọc trong trang bài viết</a></p>
<h3 id="bean-có-tham-số"><a class="header" href="#bean-có-tham-số">@Bean có tham số</a></h3>
<p>Nếu method được đánh dấu bởi <code>@Bean</code> có tham số truyền vào, thì Spring Boot sẽ tự inject các Bean đã có trong <code>Context</code> vào làm tham số.</p>
<p>Ví dụ:</p>
<p><em>AppConfig.java</em></p>
<pre><code class="language-java">@Configuration
public class AppConfig {

    @Bean
    SimpleBean simpleBeanConfigure(){
        // Khởi tạo một instance của SimpleBean và trả ra ngoài
        return new SimpleBean(&quot;loda&quot;);
    }

    @Bean(&quot;mysqlConnector&quot;)
    DatabaseConnector mysqlConfigure(SimpleBean simpleBean) { // SimpleBean được tự động inject vào.
        DatabaseConnector mySqlConnector = new MySqlConnector();
        mySqlConnector.setUrl(&quot;jdbc:mysql://host1:33060/&quot; + simpleBean.getUsername());
        // Set username, password, format, v.v...
        return mySqlConnector;
    }
}
</code></pre>
<h3 id="thực-tế"><a class="header" href="#thực-tế">Thực tế</a></h3>
<p>Trong thực tế, việc sử dụng <code>@Configuration</code> là hết sức cần thiết, và nó đóng vai trò là nơi cấu hình cho toàn bộ ứng dụng của bạn. Một Ứng dụng sẽ có nhiều class chứa <code>@Configuration</code> và mỗi class sẽ đảm nhận cấu hình một bộ phận gì đó trong ứng dụng.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="application-config-và-value"><a class="header" href="#application-config-và-value">Application Config và @Value</a></h1>
<p>Trong thực tế không phải lúc nào chúng ta cũng nên để mọi thứ trong code của mình. Có những thông số tốt hơn hết nên được truyền từ bên ngoài vào ứng dụng, để giúp ứng dụng của bạn dễ dàng thay đổi giữa các môi trường khác nhau. Để phục vụ điều này, chúng ta sẽ tìm hiểu về khái niệm config ứng dụng Spring Boot với <code>application.properties</code></p>
<h3 id="applicationproperties"><a class="header" href="#applicationproperties">application.properties</a></h3>
<p>Trong Spring Boot, các thông tin cấu hình mặc định được lấy từ file <code>resources/applications.properties</code>. Ví dụ, bạn muốn Spring Boot chạy trên port 8081 thay vì 8080 thì <code>server.port = 8081</code></p>
<p>Hoặc bạn muốn log của chương trình chi tiết hơn. Hãy chuyển nó sang dậng Debug bằng cách config như sau: <code>logging.level.root=DEBUG</code></p>
<h3 id="value"><a class="header" href="#value">@Value</a></h3>
<p>Trong trường hợp, bạn muốn tự config những giá trị của riêng mình, thì Spring Boot hỗ trợ bạn với annotation <code>@Value</code></p>
<p>Ví dụ, tôi muốn cấu hình cho thông tin database của tôi từ bên ngoài ứng dụng</p>
<p><em>application.properties</em></p>
<pre><code>loda.mysql.url=jdbc:mysql://host1:33060/loda
</code></pre>
<p><code>@Value</code> được sử dụng trên thuộc tính của class, Có nhiệm vụ lấy thông tin từ file properties và gán vào biến.</p>
<pre><code>public class AppConfig {
    // Lấy giá trị config từ file application.properties
    @Value(&quot;${loda.mysql.url}&quot;)
    String mysqlUrl;
}
</code></pre>
<p>Thông tin truyền vào annottaion <code>@Value</code> chính là tên của cấu hình đặt trong dấu <code>${name}</code></p>
<h3 id="ví-dụ-và-đọc-thêm"><a class="header" href="#ví-dụ-và-đọc-thêm">Ví dụ và đọc thêm</a></h3>
<p><a href="https://viblo.asia/p/spring-boot-7-spring-boot-application-config-va-atvalue-RQqKLwr657z#_vi-du-4">Phần ví dụ đầy đủ cho bài viết này</a></p>
<p>Sau bài này bạn có thể xem thêm nội dung sau:</p>
<ol>
<li><a href="https://www.baeldung.com/configuration-properties-in-spring-boot">Hướng dẫn sử dụng Spring Properties với <code>@ConfigurationProperties</code></a></li>
<li>Hướng dẫn sử dụng Spring Profiles</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="controller--thymeleaf"><a class="header" href="#controller--thymeleaf">@Controller + Thymeleaf</a></h1>
<h3 id="controller"><a class="header" href="#controller"><strong>@Controller</strong></a></h3>
<p>Trong bài viết số 4, khi nói về <code>@Service</code> và <code>@Repository</code> tôi đã đề cập tới kiến trúc trong <strong>Spring Boot</strong>.</p>
<p>Để xây dựng một trang web với <strong>Spring Boot</strong>, bạn sẽ cần tuân theo quy trình như hình dưới đây:</p>
<p><img src="https://images.viblo.asia/95ff7fc2-b915-419a-bb14-38bfdf5bf250.png" alt="" /></p>
<p><code>@Controller</code> là nơi tiếp nhận các thông tin request từ phía người dùng. Nó có nhiệm vụ đón nhận các yêu cầu (kèm theo thông tin request) và chuyển các yêu cầu này xuống cho tầng <code>@Serivce</code> xử lý logic.</p>
<h3 id="html"><a class="header" href="#html"><strong>HTML</strong></a></h3>
<p>Để tạo ra một trang Web, bạn sẽ cần tạo ra các trang html để trả về cho người dùng. Mặc định trong <strong>Spring Boot</strong>, các file html này sẽ được lưu trữ trong thư mục <code>resources/templates</code>. <strong>Spring Boot + Thymeleaf</strong> sẽ tìm kiếm các file này theo tên. Ví dụ &quot;index&quot; sẽ tương ứng với &quot;index.html&quot;.</p>
<h3 id="giải-thích-1"><a class="header" href="#giải-thích-1">Giải thích 1</a></h3>
<p>Bản thân <code>@Controller</code> Cũng là một <code>@Component</code> nên nó sẽ được <strong>Spring Boot</strong> quản lý.</p>
<pre><code class="language-java">@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Component
public @interface Controller {
    @AliasFor(
        annotation = Component.class
    )
    String value() default &quot;&quot;;
}
</code></pre>
<p><strong>Spring Boot</strong> sẽ lắng nghe các request từ phía người dùng. và tùy theo đường dẫn <code>path</code> là gì, nó sẽ mapping tới hàm xử lý tương ứng trong <code>@Controller</code>.</p>
<p>Như ví dụ trên, tôi sử dụng <code>GET</code> vào địa chỉ <code>localhost:8080/</code> ( đường dẫn là <code>/</code>). <strong>Spring Boot</strong> sẽ gọi tới hàm có gắn <code>@GetMapping(&quot;/&quot;)</code> và yêu cầu hàm này xử lý request này.</p>
<h3 id="giải-thích-2"><a class="header" href="#giải-thích-2">Giải thích 2</a></h3>
<p>Tới đây bạn hãy tham chiếu đường dẫn request với hàm xử lý nó:</p>
<pre><code class="language-java">// http://localhost:8080/hello?name=Loda
    @GetMapping(&quot;/hello&quot;)
    public String hello(
            // Request param &quot;name&quot; sẽ được gán giá trị vào biến String
            @RequestParam(name = &quot;name&quot;, required = false, defaultValue = &quot;&quot;) String name,
            // Model là một object của Spring Boot, được gắn vào trong mọi request.
            Model model
    ) {
        // Gắn vào model giá trị name nhận được
        model.addAttribute(&quot;name&quot;, name);

        return &quot;hello&quot;; // trả về file hello.html cùng với thông tin trong object Model
    }
</code></pre>
<p>Khi request lên, chúng ta nhận được giá trị của <code>name</code> và tiếp tục gán nó vào <code>Model</code>.</p>
<p><img src="https://images.viblo.asia/c1490e7d-3093-430e-b22e-32ab1395c199.png" alt="" /></p>
<p><code>Model</code> ở đây là một object được <strong>Spring Boot</strong> đính kém trong mỗi response. <code>Model</code> chứa các thông tin mà bạn muốn trả về và <strong>Template Engine</strong> sẽ trích xuất thông tin này ra thành html và đưa cho người dùng. Trong file <code>hello.html</code> tôi lấy giá trị của <code>name</code> trong <code>Model</code> ra bằng cách sử dụng cú pháp của <code>Thymeleaf</code></p>
<pre><code>&lt;h1 th:text=&quot;'Hello, ' + ${name}&quot;&gt;&lt;/h1&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="giải-thích-cách-thymeleaf-vận-hành--expression"><a class="header" href="#giải-thích-cách-thymeleaf-vận-hành--expression">Giải thích cách Thymeleaf vận hành + Expression</a></h1>
<h3 id="thymeleaf"><a class="header" href="#thymeleaf">Thymeleaf</a></h3>
<p>Thymeleaf là một Java Template Engine. Có nhiệm vụ xử lý và generate ra các file HTML, XML, v.v.. Các file HMTL do Thymeleaf tạo ra là nhờ kết hợp dữ liệu và template + quy tắc để sinh ra một file HTML chứa đầy đủ thông tin. Việc của bạn là cung cấp dữ liệu và quy định template như nào, còn việc dùng các thông tin đó để render ra HTML sẽ do Thymeleaf giải quyết.</p>
<h3 id="cú-pháp"><a class="header" href="#cú-pháp">Cú pháp</a></h3>
<p>Cú pháp của Thymeleaf sẽ là một attributes (Thuộc tính) của thẻ HTML và bắt đầu bằng chữ <code>th:</code>.</p>
<p>Ví dụ: Để truyền dữ liệu từ biến <code>name</code> trong Java vào một thẻ <code>H1</code> của HTML.</p>
<pre><code class="language-html">&lt;h1 th:text=&quot;${name}&quot;&gt;&lt;/h1&gt;
</code></pre>
<p>Chúng ta viết thẻ h1 như bình thường, nhưng không chứa bất cứ text nào trong thẻ. Mà sử dụng cú pháp <code>th:text=&quot;${name}&quot;</code> để Thymeleaf lấy thông tin từ biến <code>name</code> và đưa vào thẻ <code>H1</code>.</p>
<p>Kết quả khi render ra, thuộc tính <code>th:text</code> biến mất và giá trị biến <code>name</code> được đưa vào trong thẻ <code>H1</code>. Đó là cách Thymeleaf hoạt động:</p>
<pre><code class="language-java">// Giả sử String name = &quot;loda&quot;
&lt;h1&gt;Loda&lt;/h1&gt;
</code></pre>
<h3 id="model--view-trong-spring-boot"><a class="header" href="#model--view-trong-spring-boot">Model &amp; View Trong Spring Boot</a></h3>
<p><code>Model</code> là đối tượng lưu giữ thông tin và được sử dụng bởi Template Engine để generate ra webpage. Có thể hiểu nó là <code>Context</code> của Thymeleaf. <code>Model</code> lưu giữ thông tin dưới dạng key-value.</p>
<p>Trong template thymeleaf, để lấy các thông tin trong <code>Model</code>. bạn sẽ sử dụng <code>Thymeleaf Standard Expression</code>.</p>
<ol>
<li><code>${...}</code>: Giá trị của một biến.</li>
<li><code>*{...}</code>: Giá trị của một biến được chỉ định.</li>
</ol>
<p>Ngoài ra, để lấy thông tin đặc biệt hơn:</p>
<ol>
<li><code>#{...}</code>: Lấy message</li>
<li><code>@{...}</code>: Lấy đường dẫn URL dựa theo context của server</li>
</ol>
<p>Nói tới đây có lẽ hơi khó hiểu, chúng ta sẽ dùng ví dụ để hiểu rõ từng loại Expression.</p>
<h3 id="---variables-expressions"><a class="header" href="#---variables-expressions"><code>${...}</code> - Variables Expressions</a></h3>
<p>Trên Controller bạn đưa vào một số giá trị:</p>
<pre><code>model.addAttribute(&quot;today&quot;, &quot;Monday&quot;);
</code></pre>
<p>Để lấy giá trị của biến <code>today</code>, tôi sử dụng <code>${...}</code></p>
<pre><code>&lt;p&gt;Today is: &lt;span th:text=&quot;${today}&quot;&gt;&lt;/span&gt;.&lt;/p&gt;
</code></pre>
<h3 id="---variables-expressions-on-selections"><a class="header" href="#---variables-expressions-on-selections"><code>*{...}</code> - Variables Expressions on selections</a></h3>
<p>Dấu <code>*</code> còn gọi là <code>asterisk syntax</code>. Chức năng của nó giống với <code>${...}</code> là lấy giá trị của một biến. Điểm khác biệt là nó sẽ lấy ra giá trị của một biến cho trước bởi <code>th:object</code></p>
<pre><code class="language-html">&lt;div th:object=&quot;${session.user}&quot;&gt;&lt;!-- th:object tồn tại trong phạm vi của thẻ div này --&gt;
    &lt;!-- Lấy ra tên của đối tượng session.user --&gt;
    &lt;p&gt;Name: &lt;spanth:text=&quot;*{firstName}&quot;&gt;&lt;/span&gt;.&lt;/p&gt;&lt;!-- Lấy ra lastName của đối tượng session.user --&gt;
    &lt;p&gt;Surname: &lt;spanth:text=&quot;*{lastName}&quot;&gt;&lt;/span&gt;.&lt;/p&gt;
&lt;/div&gt;
</code></pre>
<p>Vậy đoạn code ở trên tương đương với:</p>
<pre><code>&lt;div&gt;&lt;p&gt;Name: &lt;spanth:text=&quot;${session.user.firstName}&quot;&gt;&lt;/span&gt;.&lt;/p&gt;&lt;p&gt;Surname: &lt;spanth:text=&quot;${session.user.lastName}&quot;&gt;&lt;/span&gt;.&lt;/p&gt;&lt;/div&gt;
</code></pre>
<p>Còn <code>${...}</code> sẽ lấy ra giá trị cục bộ trong <code>Context</code> hay <code>Model</code>.</p>
<h3 id="---message-expression"><a class="header" href="#---message-expression"><code>#{...}</code> - Message Expression</a></h3>
<p>Ví dụ, trong file config <code>.properties</code> của tôi có một message chào người dùng bằng nhiều ngôn ngữ.</p>
<pre><code>home.welcome=¡Bienvenido a nuestra tienda de comestibles!
</code></pre>
<p>Thì cách lấy nó ra nhanh nhất là:</p>
<pre><code>&lt;p th:utext=&quot;#{home.welcome}&quot;&gt;Xin chào các bạn!&lt;/p&gt;
</code></pre>
<p>Đoạn text tiếng việt bên trong thẻ <code>p</code> sẽ bị thay thế bởi thymeleaf khi render <code>#{home.welcome}</code>.</p>
<h3 id="---url-expression"><a class="header" href="#---url-expression"><code>@{...}</code> - URL Expression</a></h3>
<p><code>@{...}</code> xử lý và trả ra giá trị URL theo context của máy chủ cho chúng ta.</p>
<p>Ví dụ:</p>
<pre><code>// &lt;a th:href=&quot;@{/order/list}&quot;&gt;
// If our app is installed at http://localhost:8080/myapp, this URL will output:
// &lt;a href=&quot;/myapp/order/list&quot;&gt;
&lt;a href=&quot;details.html&quot; th:href=&quot;@{/order/details(orderId=${o.id})}&quot;&gt;view&lt;/a&gt;
&lt;ahref=&quot;details.html&quot;th:href=&quot;@{/order/{orderId}/details(orderId=${o.id})}&quot;&gt;view&lt;/a&gt;
</code></pre>
<p>Nếu bắt dầu bằng dấu <code>/</code> thì nó sẽ là Relative URL và sẽ tương ứng theo context của máy chủ của bạn.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="requestmapping--postmapping--modelattribute--requestparam"><a class="header" href="#requestmapping--postmapping--modelattribute--requestparam">@RequestMapping + @PostMapping + @ModelAttribute + @RequestParam</a></h1>
<h3 id="postmapping"><a class="header" href="#postmapping"><strong>@PostMapping</strong></a></h3>
<p><code>@PostMapping</code> có nhiệm vụ đánh dấu hàm xử lý POST request trong Controller.</p>
<p>Ví dụ:</p>
<p>Tôi có 2 hàm xử lý, một cho <code>GET</code> method và một cho <code>POST</code>.</p>
<p>Cả hai đều chung đường dẫn nhưng bạn nên biết rằng cùng một <code>path</code> nhưng khác <code>method</code> thì sẽ xử lý khác nhau.</p>
<pre><code>@Controller
public class WebController {
    @GetMapping(&quot;/addTodo&quot;)
    public String addTodo(Model model) {
        return &quot;addTodo&quot;;
    }

    @PostMapping(&quot;/addTodo&quot;)
    public String addTodo(Model model) {
        return &quot;success&quot;;
    }
}
</code></pre>
<h3 id="requestmapping"><a class="header" href="#requestmapping"><strong>@RequestMapping</strong></a></h3>
<p>Trong trường hợp bạn muốn tất cả các method đều dùng chung một cách xử lý thì có thể sử dụng Annotation <code>@RequestMapping</code>. @RequestMapping là một annotation có ý nghĩa và mục đích sử dụng rộng hơn các loại @GetMapping, @PostMapping,v.v.. Nếu không chỉ định method cho <code>@RequestMapping</code> thì nó sẽ nhận toàn bộ các method.</p>
<pre><code class="language-java">@Controller
@RequestMapping(&quot;api/v1&quot;)
public class WebController {

    // Đường dẫn lúc này là: /api/v1/addTodo và method GET
    @RequestMapping(value = &quot;/addTodo&quot;, method = RequestMethod.GET)
    public String addTodo(Model model) {
        return &quot;addTodo&quot;;
    }

    // Đường dẫn lúc này là: /api/v1/addTodo và method POST
    @RequestMapping(value = &quot;/addTodo&quot;, method = RequestMethod.POST)
    public String addTodo(@ModelAttribute Todo todo) {
        return &quot;success&quot;;
    }
}
</code></pre>
<h3 id="getmapping"><a class="header" href="#getmapping">GetMapping</a></h3>
<p>Khi tôi request lên server như này <code>http://localhost:8080/listTodo?limit=2</code>.</p>
<pre><code class="language-java">@GetMapping(&quot;/listTodo&quot;)
public String index(Model model, @RequestParam(value = &quot;limit&quot;, required = false) Integer limit) {
    // Trả về đối tượng todoList.
    // Nếu người dùng gửi lên param limit thì trả về sublist của todoList
    model.addAttribute(&quot;todoList&quot;, limit != null ? todoList.subList(0, limit) : todoList);

    // Trả về template &quot;listTodo.html&quot;
    return &quot;listTodo&quot;;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="spring-boot-jpa--mysql"><a class="header" href="#spring-boot-jpa--mysql">Spring Boot JPA + MySQL</a></h1>
<h3 id="spring-boot-jpa"><a class="header" href="#spring-boot-jpa"><strong>Spring Boot JPA</strong></a></h3>
<p><strong>Spring Boot JPA</strong> là một phần trong hệ sinh thái Spring Data, nó tạo ra một layer ở giữa tầng service và database, giúp chúng ta thao tác với database một cách dễ dàng hơn, tự động config và giảm thiểu code thừa thãi.</p>
<p><strong>Spring Boot JPA</strong> đã wrapper Hibernate và tạo ra một interface mạnh mẽ. Nếu như bạn gặp khó khăn khi làm việc với Hibernate thì đừng lo, bạn hãy để <strong>Spring JPA</strong> làm hộ.</p>
<h3 id="tạo-table-và-dữ-liệu"><a class="header" href="#tạo-table-và-dữ-liệu"><strong>Tạo Table và dữ liệu</strong></a></h3>
<p>Trước khi bắt đầu, chúng ta cần tạo ra dữ liệu trong Database. Ở đây tôi chọn <code>MySQL</code>. Dưới đây là SQL Script để tạo DATABASE <code>micro_db</code>. Chứa một TABLE duy nhất là <code>User</code>.</p>
<h3 id="tạo-model-user"><a class="header" href="#tạo-model-user"><strong>Tạo Model User</strong></a></h3>
<p>Khi đã có dữ liệu trong Database. Chúng ta sẽ tạo một Class trong Java để mapping thông tin. Cần biết thêm về Hibernate. Đây là <em>User.java</em>:</p>
<pre><code class="language-java">@Entity
@Table(name = &quot;user&quot;)
@Data
public class User implements Serializable {
    private static final long serialVersionUID = -297553281792804396L;
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    // Mapping thông tin biến với tên cột trong Database
    @Column(name = &quot;hp&quot;)
    private int hp;
    // Nếu không đánh dấu @Column thì sẽ mapping tự động theo tên biến
    private int atk;
}
</code></pre>
<h3 id="vấn-đề-của-hibernate-truyền-thống"><a class="header" href="#vấn-đề-của-hibernate-truyền-thống"><strong>Vấn đề của Hibernate truyền thống</strong></a></h3>
<p>Thông thường, khi bạn đã định nghĩa <code>Entity</code> tương ứng với <code>Table</code> trong DB thông qua Hibernate. Thì nhiệm vụ tiếp theo sẽ là tạo ra các class thao tác với DB.</p>
<p>Ví dụ muốn query lấy tất cả <code>User</code> bằng Hibernate truyền thống sẽ như sau. Nó sẽ rất dài nên khi nắm được vấn đề này, Spring Data đã wrapper lên Hibernate một lớp nữa gọi là Spring JPA.</p>
<h3 id="jparepository"><a class="header" href="#jparepository"><strong>JpaRepository</strong></a></h3>
<p>Để sử dụng <strong>Spring JPA</strong>, bạn cần sử dụng interface <code>JpaRepository</code>.</p>
<p>Yêu cầu của interface này đó là bạn phải cung cấp 2 thông tin:</p>
<ol>
<li>Entity (Đối tượng tương ứng với Table trong DB)</li>
<li>Kiểu dữ liệu của khóa chính (PrimaryKey)</li>
</ol>
<p>Ví dụ: Tôi muốn lấy thông tin của bảng <code>User</code> thì làm như sau:</p>
<pre><code>import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

@Repository
public interface UserRepository extends JpaRepository&lt;User, Long&gt; {

}
</code></pre>
<p>Vậy thôi, <code>@Repository</code> đánh dấu <code>UserRepository</code> là một Bean và chịu trách nhiệm giao tiếp với DB. <strong>Spring Boot</strong> sẽ tự tìm thấy và khởi tạo ra đối tượng <code>UserRepository</code> trong Context. Việc tạo ra <code>UserRepository</code> hoàn toàn tự động và tự config, vì chúng ta đã kế thừa <code>JpaRepository</code>. Bây giờ, việc lấy ra toàn bộ <code>User</code> sẽ như sau:</p>
<pre><code class="language-java">@Autowired
UserRepository userRepository;

userRepository.findAll().forEach(System.out::println);
</code></pre>
<p>Nếu bạn tìm kiếm thì sẽ thấy <code>UserRepository</code> có hàng chục method mà chúng ta không cần viết lại nữa. Vì nó kế thừa <code>JpaRepository</code> rồi.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="spring-jpa-method--query"><a class="header" href="#spring-jpa-method--query">Spring JPA Method + @Query</a></h1>
<h3 id="query-creation"><a class="header" href="#query-creation"><strong>Query Creation</strong></a></h3>
<p>Trong <strong>Spring JPA</strong>, có một cơ chế giúp chúng ta tạo ra các câu Query mà không cần viết thêm code. Cơ chế này xây dựng Query từ tên của method. Ví dụ: Chúng ta có đối tượng <code>User</code>.</p>
<p><em>User.java</em></p>
<pre><code class="language-java">@Entity
@Table(name = &quot;user&quot;)
@Data
public class User implements Serializable {
    private static final long serialVersionUID = -297553281792804396L;

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    // Mapping thông tin biến với tên cột trong Database
    @Column(name = &quot;hp&quot;)
    private int hp;
    @Column(name = &quot;stamina&quot;)
    private int stamina;

    // Nếu không đánh dấu @Column thì sẽ mapping tự động theo tên biến
    private int atk;
    private int def;
    private int agi;
}
</code></pre>
<p>Khi chúng ta đặt tên method là: <code>findByAtk(int atk)</code>. Thì <strong>Spring JPA</strong> sẽ tự định nghĩa câu Query cho method này, bằng cách xử lý tên method. Vậy là chúng ta đã có thể truy vấn dữ liệu mà chỉ mất thêm 1 dòng code.</p>
<h3 id="quy-tắc-đặt-tên-method-trong-spring-jpa"><a class="header" href="#quy-tắc-đặt-tên-method-trong-spring-jpa"><strong>Quy tắc đặt tên method trong Spring JPA</strong></a></h3>
<p>Trong <strong>Spring JPA</strong>, cơ chế xây dựng truy vấn thông qua tên của method được quy định bởi các tiền tố sau:</p>
<p><code>find…By</code>, <code>read…By</code>, <code>query…By</code>, <code>count…By</code>, và <code>get…By</code>.</p>
<p>phần còn lại sẽ được parse theo tên của thuộc tính (viết hoa chữ cái đầu). Nếu chúng ta có nhiều điều kiện, thì các thuộc tính có thể kết hợp với nhau bằng chữ <code>And</code> hoặc <code>Or</code>. Bạn có thể đọc thêm <a href="https://docs.spring.io/spring-data/jpa/reference/jpa/query-methods.html#jpa.query-methods.query-creation">trong Docs của Spring: Query Creation</a></p>
<p>Ví dụ:</p>
<pre><code class="language-java">interface PersonRepository extends JpaRepository&lt;User, Long&gt; {
    // Dễ
    // version rút gọn
    Person findByLastname(String lastname);
    // verson đầy đủ
    Person findPersonByLastname(String lastname);
    Person findAllByLastname(String lastname);
    // Trung bình
    List&lt;Person&gt; findByEmailAddressAndLastname(EmailAddress emailAddress, String lastname);
    // findDistinct là tìm kiếm và loại bỏ đi các đối tượng trùng nhau
    List&lt;Person&gt; findDistinctPeopleByLastnameOrFirstname(String lastname, String firstname);
    List&lt;Person&gt; findPeopleDistinctByLastnameOrFirstname(String lastname, String firstname);
    // IgnoreCase là tìm kiếm không phân biệt hoa thường, ví dụ ở đây tìm kiếm lastname
    // lastname sẽ không phân biệt hoa thường
    List&lt;Person&gt; findByLastnameIgnoreCase(String lastname);
    // AllIgnoreCase là không phân biệt hoa thường cho tất cả thuộc tính
    List&lt;Person&gt; findByLastnameAndFirstnameAllIgnoreCase(String lastname, String firstname);
    // OrderBy là cách sắp xếp thứ tự trả về
    // Sắp xếp theo Firstname ASC
    List&lt;Person&gt; findByLastnameOrderByFirstnameAsc(String lastname);
    // Sắp xếp theo Firstname Desc
    List&lt;Person&gt; findByLastnameOrderByFirstnameDesc(String lastname);
}
</code></pre>
<p>Các thuộc tính trong tên method phải thuộc về Class đó, nếu không sẽ gây ra lỗi. Tuy nhiên, trong một số trường hợp bạn có thể query bằng thuộc tính con. Ví dụ: Đói tượng <code>Person</code> có thuộc tính là <code>Address</code> và trong <code>Address</code> lại có <code>ZipCode</code></p>
<pre><code class="language-java">// person.address.zipCode
List&lt;Person&gt; findByAddressZipCode(ZipCode zipCode);
</code></pre>
<h3 id="query"><a class="header" href="#query"><strong>@Query</strong></a></h3>
<p>Với cách sử dụng <code>@Query</code>, bạn sẽ có thể sử dụng câu truy vấn <a href="https://en.wikipedia.org/wiki/Jakarta_Persistence_Query_Language">JPQL</a> (Hibernate) hoặc SQL thuần (raw SQL). Ví dụ:</p>
<pre><code class="language-java">public interface UserRepository extends JpaRepository&lt;User, Long&gt; {
    // Khi được gắn @Query, thì tên của method không còn tác dụng nữa
    // Đây là JPQL
    @Query(&quot;select u from User u where u.emailAddress = ?1&quot;)
    User myCustomQuery(String emailAddress);
    // Đây là Native SQL
    @Query(value = &quot;select * from User u where u.email_address = ?1&quot;, nativeQuery = true)
    User myCustomQuery2(String emailAddress);
}
</code></pre>
<p>Cách truyền tham số là gọi theo thứ tự các tham số của method bên dưới <code>?1</code>, <code>?2</code>. Nếu bạn không thích sử dụng <code>?{number}</code> thì có thể đặt tên cho tham số.</p>
<pre><code class="language-java">public interface UserRepository extends JpaRepository&lt;User, Long&gt; {
    // JPQL
    @Query(&quot;SELECT u FROM User u WHERE u.status = :status and u.name = :name&quot;)
    User findUserByNamedParams(@Param(&quot;status&quot;) Integer status, @Param(&quot;name&quot;) String name);
    // Native SQL
    @Query(value = &quot;SELECT * FROM Users u WHERE u.status = :status and u.name = :name&quot;, nativeQuery = true)
    User findUserByNamedParamsNative(@Param(&quot;status&quot;) Integer status, @Param(&quot;name&quot;) String name);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chi-tiết-spring-boot--thymeleaf--mysql--i18n"><a class="header" href="#chi-tiết-spring-boot--thymeleaf--mysql--i18n">Chi tiết Spring Boot + Thymeleaf + MySQL + i18n</a></h1>
<h3 id="tạo-database"><a class="header" href="#tạo-database">Tạo Database</a></h3>
<p><em>script.sql</em></p>
<pre><code class="language-sql">CREATE SCHEMA IF NOT EXISTS `todo_db` DEFAULT CHARACTER SET utf8mb4 ;

CREATE TABLE IF NOT EXISTS `todo_db`.`todo` (
  `id` INT(11) NOT NULL AUTO_INCREMENT,
  `title` VARCHAR(255) NULL DEFAULT NULL,
  `detail` VARCHAR(255) NULL DEFAULT NULL,
  PRIMARY KEY (`id`))
ENGINE = InnoDB
DEFAULT CHARACTER SET = utf8mb4;
</code></pre>
<p>Thêm 1 record vào DB</p>
<pre><code class="language-sql">INSERT INTO `todo_db`.`todo` (`title`, `detail`) VALUES ('Làm bài tập', 'Hoàn thiện bài viết Spring Boot #13');
</code></pre>
<h3 id="cấu-hình-ứng-dụng"><a class="header" href="#cấu-hình-ứng-dụng">Cấu hình ứng dụng</a></h3>
<p>Cấu hình là phần cực kì quan trọng rồi, chúng ta phải cung cấp cho Spring Boot các thông tin về Database và Thymeleaf. Ngoài ra, tùy chỉnh một số thông tin để giúp chúng ta lập trình đơn giản hơn.
(Có thể đọc qua và tham khảo một số thông số có thể được sử dụng). Đây là <em>application.properties</em></p>
<pre><code class="language-yaml">#Chạy ứng dụng trên port 8085
server.port=8085
# Bỏ tính năng cache của thymeleaf để lập trình cho nhanh
spring.thymeleaf.cache=false
# Các message tĩnh sẽ được lưu tại thư mục i18n
spring.messages.basename=i18n/messages
# Bỏ properties này đi khi deploy
# Nó có tác dụng cố định ngôn ngữ hiện tại chỉ là Tiếng Việt
spring.mvc.locale-resolver=fixed
# Mặc định ngôn ngữ là tiếng việt
spring.mvc.locale=vi_VN
# Đổi thành tiếng anh bằng cách bỏ comment ở dứoi
#spring.mvc.locale=en_US
spring.datasource.url=jdbc:mysql://localhost:3306/todo_db?useSSL=false
spring.datasource.username=root
spring.datasource.password=root
## Hibernate Properties
# The SQL dialect makes Hibernate generate better SQL for the chosen database
spring.jpa.properties.hibernate.dialect = org.hibernate.dialect.MySQL5InnoDBDialect
# Hibernate ddl auto (create, create-drop, validate, update)
spring.jpa.hibernate.ddl-auto = update
</code></pre>
<h3 id="tạo-model"><a class="header" href="#tạo-model">Tạo Model</a></h3>
<p>Tạo model <code>Todo</code> liên kết tới bảng <code>todo</code> trong Database.</p>
<pre><code class="language-java">import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;

import lombok.Data;

@Entity
@Data
public class Todo {

}
</code></pre>
<p>Ngoài ra, chúng ta tạo thêm một đối tượng là <code>TodoValidator</code>, có trách nhiệm kiểm tra xem một object <code>Todo</code> là hợp lệ hay không.</p>
<pre><code class="language-java">import org.thymeleaf.util.StringUtils;

/*
Đối tượng này dùng để kiểm tra xem một Object Todo có hợp lệ không
 */
public class TodoValidator {

    /
     * Kiểm tra một object Todo có hợp lệ không
     * @param todo
     * @return
     */
    public boolean isValid(Todo todo) {
        return Optional.ofNullable(todo)
                       .filter(t -&gt; !StringUtils.isEmpty(t.getTitle())) // Kiểm tra title khác rỗng
                       .filter(t -&gt; !StringUtils.isEmpty(t.getDetail())) // Kiểm tra detail khác rỗng
                       .isPresent(); // Trả về true nếu hợp lệ, ngược lại false
    }
}
</code></pre>
<p>Vậy là xong phần chuẩn bị <code>Model</code>.</p>
<h3 id="todoconfig"><a class="header" href="#todoconfig">TodoConfig</a></h3>
<p>Trong ứng dụng của mình, tôi muốn tự tạo ra Bean <code>TodoValidator</code>. Đây là lúc sử dụng <code>@Configuration</code> và <code>@Bean</code> đã học tại bài Spring Boot #6</p>
<p><em>config/TodoConfig.java</em></p>
<pre><code class="language-java">@Configuration
public class TodoConfig {
    /
     * Tạo ra Bean TodoValidator để sử dụng sau này
     * @return
     */
    @Bean
    public TodoValidator validator() {
        return new TodoValidator();
    }
}
</code></pre>
<h3 id="tầng-repository"><a class="header" href="#tầng-repository">Tầng Repository</a></h3>
<p>Tầng Repository, chịu trách nhiệm giao tiếp với Database. Chúng ta sử dụng Spring JPA. <em>repository/TodoRepository.java</em></p>
<pre><code class="language-java">@Repository
public interface TodoRepository extends JpaRepository&lt;Todo, Long&gt; {
}
</code></pre>
<h3 id="tầng-service"><a class="header" href="#tầng-service">Tầng Service</a></h3>
<p>Tầng Service, chị trách nhiệm thực hiện các xử lý logic, business, hỗ trợ cho tầng Controller. <em>service/TodoService.java</em></p>
<pre><code class="language-java">@Service
public class TodoService {
    @Autowired
    private TodoRepository todoRepository;

    @Autowired
    private TodoValidator validator;

    /
     * Lấy ra danh sách List&lt;Todo&gt;
     *
     * @param limit - Giới hạn số lượng lấy ra
     *
     * @return Trả về danh sách List&lt;Todo&gt; dựa theo limit, nếu limit == null thì trả findAll()
     */
    public List&lt;Todo&gt; findAll(Integer limit) {
        return Optional.ofNullable(limit)
                       .map(value -&gt; todoRepository.findAll(PageRequest.of(0, value)).getContent())
                       .orElseGet(() -&gt; todoRepository.findAll());
    }

    /
     * Thêm một Todo mới vào danh sách công việc cần làm
     *
     * @return Trả về đối tượng Todo sau khi lưu vào DB, trả về null nếu không thành công
     */
    public Todo add(Todo todo) {
        if (validator.isValid(todo)) {
            return todoRepository.save(todo);
        }
        return null;
    }
}
</code></pre>
<h3 id="tầng-controller"><a class="header" href="#tầng-controller">Tầng Controller</a></h3>
<p>Tầng Controller, nơi đón nhận các request từ phía người dùng, và chuyển tiếp xử lý xuống tầng Service.</p>
<p><em>controller/TodoController.java</em></p>
<pre><code class="language-java">@Controller
public class TodoController {

    @Autowired
    private TodoService todoService;

    /*
    @RequestParam dùng để đánh dấu một biến là request param trong request gửi lên server.
    Nó sẽ gán dữ liệu của param-name tương ứng vào biến
     */
    @GetMapping(&quot;/listTodo&quot;)
    public String index(Model model, @RequestParam(value = &quot;limit&quot;, required = false) Integer limit) {
        // Trả về đối tượng todoList.
        model.addAttribute(&quot;todoList&quot;, todoService.findAll(limit));
        // Trả về template &quot;listTodo.html&quot;
        return &quot;listTodo&quot;;
    }

    @GetMapping(&quot;/addTodo&quot;)
    public String addTodo(Model model) {
        model.addAttribute(&quot;todo&quot;, new Todo());
        return &quot;addTodo&quot;;
    }

    /*
    @ModelAttribute đánh dấu đối tượng Todo được gửi lên bởi Form Request
     */
    @PostMapping(&quot;/addTodo&quot;)
    public String addTodo(@ModelAttribute Todo todo) {
        return Optional.ofNullable(todoService.add(todo))
                       .map(t -&gt; &quot;success&quot;) // Trả về success nếu save thành công
                       .orElse(&quot;failed&quot;); // Trả về failed nếu không thành công

    }
}
</code></pre>
<h3 id="templates"><a class="header" href="#templates">Templates</a></h3>
<p>Tầng Controller đã trả về templates, nhiệm vụ tiếp theo là sử dụng Template Engine để xử lý các templates này và trả về webpage cho người dùng.</p>
<h3 id="i18n"><a class="header" href="#i18n">i18n</a></h3>
<p>Trong các template, tôi có sử dụng các message tĩnh, những message này hỗ trợ đa ngôn ngữ. Chúng ta định nghĩa các message này tại thư mục <code>i18n</code>.</p>
<p><em>i18n/messages_vi.properties</em></p>
<pre><code>loda.message.hello=Welcome to TodoApp
loda.message.success=Thêm Todo thành công!
loda.message.failed=Thêm Todo không thành công!

loda.value.addTodo=Thêm công việc
loda.value.viewListTodo=Xem danh sách công việc
loda.value.listTodo=Danh sách công việc
</code></pre>
<p><em>i18n/messages_en.properties</em></p>
<pre><code>loda.message.hello=Welcome to TodoApp
loda.message.success=Add To-do Successfully!
loda.message.failed=Add To-do Failed!

loda.value.addTodo=Add To-do
loda.value.viewListTodo=View To-do list
loda.value.listTodo=To-do list
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="restful-api--restcontroller--pathvariable--requestbody"><a class="header" href="#restful-api--restcontroller--pathvariable--requestbody">Restful API + @RestController + @PathVariable + @RequestBody</a></h1>
<h3 id="restful-api"><a class="header" href="#restful-api">Restful API</a></h3>
<p>Bạn có thể đọc <a href="https://github.com/dwyl/learn-api-design">dwyl/learn-api-design</a></p>
<h3 id="restcontroller"><a class="header" href="#restcontroller">@RestController</a></h3>
<p>Khác với <code>@Controller</code> là sẽ trả về một template.</p>
<p><code>@RestController</code> trả về dữ liệu dưới dạng JSON.</p>
<pre><code>@RestController
@RequestMapping(&quot;/api/v1&quot;)
public class RestApiController{

    @GetMapping(&quot;/todo&quot;)
    public List&lt;Todo&gt; getTodoList() {
        return todoList;
    }
}
</code></pre>
<p>Các đối tượng trả về dưới dạng Object sẽ được Spring Boot chuyển thành JSON. Các đối tượng trả về rất đa dạng, bạn có thể trả về <code>List</code>, <code>Map</code>, v.v.. Spring Boot sẽ convert hết chúng thành JSON, mặc định sẽ dùng Jackson converter để làm điều đó. Nếu bạn muốn API tùy biến được kiểu dữ liệu trả về, bạn có thể trả về đối tượng <code>ResponseEntity</code> của Spring cung cấp. Đây là đối tượng cha của mọi response và sẽ wrapper các object trả về. Cái này bạn xem tiếp phần dưới sẽ rõ.</p>
<h3 id="requestbody"><a class="header" href="#requestbody">@RequestBody</a></h3>
<p>Vì bây giờ chúng ta xây dựng API, nên các thông tin từ phía Client gửi lên Server sẽ nằm trong <code>Body</code>, và cũng dưới dạng <code>JSON</code> luôn.</p>
<pre><code class="language-java">@RestController
@RequestMapping(&quot;/api/v1&quot;)
public class RestApiController {

    List&lt;Todo&gt; todoList = new CopyOnWriteArrayList&lt;&gt;();

    @PostMapping(&quot;/todo&quot;)
    public ResponseEntity addTodo(@RequestBody Todo todo) {
        todoList.add(todo);
        // Trả về response với STATUS CODE = 200 (OK)
        // Body sẽ chứa thông tin về đối tượng todo vừa được tạo.
        return ResponseEntity.ok().body(todo);
    }
}
</code></pre>
<p>Tất nhiên là Spring Boot sẽ làm giúp chúng ta các phần nặng nhọc, nó chuyển chuỗi JSON trong request thành một Object Java. bạn chỉ cần cho nó biết cần chuyển JSON thành Object nào bằng Annotation <code>@RequestBody</code></p>
<h3 id="pathvariable"><a class="header" href="#pathvariable">@PathVariable</a></h3>
<p><code>RESTful API</code> là một tiêu chuẩn dùng trong việc thết kế các thiết kế API cho các ứng dụng web để quản lý các resource.</p>
<p>Và với cách thống nhất này, thì sẽ có một phần thông tin quan trọng sẽ nằm ngay trong chính URL của api.</p>
<p>Ví dụ:</p>
<ol>
<li>URL tạo To-do: https://loda.me/todo. Tương ứng với HTTP method là POST</li>
<li>URL lấy thông tin To-do số 12: https://loda.me/todo/12. Tương ứng với HTTP method là GET</li>
<li>URL sửa thông tin To-do số 12: https://loda.me/todo/12. Tương ứng với HTTP method là PUT</li>
<li>URL xoá To-do số 12: https://loda.me/todo/12. Tương ứng với HTTP method là DELETE</li>
</ol>
<p>Ngoài thông tin trong <code>Body</code> của request, thì cái chúng ta cần chính là cái con số 12 nằm trong URL. Phải lấy được con số đó thì mới biết được đối tượng To-do cần thao tác là gì.</p>
<p><code>@PathVariable</code> tham chiến.</p>
<pre><code class="language-java">@RestController
@RequestMapping(&quot;/api/v1&quot;)
public class RestApiController {

    /*
    phần path URL bạn muốn lấy thông tin sẽ để trong ngoặc kép {}
     */
    @GetMapping(&quot;/todo/{todoId}&quot;)
    public Todo getTodo(@PathVariable(name = &quot;todoId&quot;) Integer todoId){
        // @PathVariable lấy ra thông tin trong URL
        // dựa vào tên của thuộc tính đã định nghĩa trong ngoặc kép /todo/{todoId}
        return todoList.get(todoId);
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="exception-handling-exceptionhandler--restcontrolleradvicecontrolleradvice--responsestatus"><a class="header" href="#exception-handling-exceptionhandler--restcontrolleradvicecontrolleradvice--responsestatus">Exception Handling @ExceptionHandler + @RestControllerAdvice/@ControllerAdvice + @ResponseStatus</a></h1>
<h3 id="restcontrolleradvice--controlleradvice--exceptionhandler"><a class="header" href="#restcontrolleradvice--controlleradvice--exceptionhandler">@RestControllerAdvice &amp; @ControllerAdvice + @ExceptionHandler</a></h3>
<p><code>@RestControllerAdvice</code> là một Annotation gắn trên Class. Có tác dụng xen vào quá trình xử lý của các <code>@RestController</code>. Tương tự với <code>@ControllerAdvice</code>. <code>@RestControllerAdvice</code> thường được kết hợp với <code>@ExceptionHandler</code> để cắt ngang quá trình xử lý của Controller, và xử lý các ngoại lệ xảy ra.</p>
<pre><code class="language-java">@RestControllerAdvice
public class ApiExceptionHandler {
    @ExceptionHandler(IndexOutOfBoundsException.class)
    @ResponseStatus(value = HttpStatus.BAD_REQUEST)
    public ErrorMessage TodoException(Exception ex,  WebRequest request) {
        return new ErrorMessage(10100, &quot;Đối tượng không tồn tại&quot;);
    }
}
</code></pre>
<p>Hiểu đơn giản là Controller đang hoạt động bình thường, chẳng may có một Exception được ném ra, thì thay vì báo lỗi hệ thống, thì nó sẽ được thằng <code>@RestControllerAdvice</code> và <code>@ExceptionHandler</code> đón lấy và xử lý. Sau đó trả về cho người dùng thông tin hữu ích hơn.</p>
<h3 id="responsestatus"><a class="header" href="#responsestatus">@ResponseStatus</a></h3>
<p><code>@ResponseStatus</code> là một cách định nghĩa HttpStatus trả về cho người dùng. Nếu bạn không muốn sử dụng <code>ResponseEntity</code> thì có thể dùng <code>@ResponseStatus</code> đánh dấu trên <code>Object</code> trả về.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hướng-dẫn-sử-dụng-configurationproperties"><a class="header" href="#hướng-dẫn-sử-dụng-configurationproperties">Hướng dẫn sử dụng @ConfigurationProperties</a></h1>
<h3 id="cấu-hình-đơn-giản"><a class="header" href="#cấu-hình-đơn-giản"><strong>Cấu hình đơn giản</strong></a></h3>
<p>Giả sử, ứng dụng của tôi sẽ yêu cầu có một số giá trị toàn cục, mà thay vì cấu hình ở trong code, tôi muốn lưu nó ở bên ngoài, để tiện thay đổi mỗi khi cần.</p>
<p>Thì tôi sẽ làm như sau, tạo ra một class chứa các thông tin:</p>
<pre><code class="language-java">@Data // Lombok (Tạo Getter, Setter các thứ)
@Component // Là 1 Spring Bean
// Đánh dấu để lấy config từ trong file loda.yml
// @PropertySource(&quot;classpath:loda.yml&quot;)
@ConfigurationProperties(prefix = &quot;loda&quot;) // Chỉ lấy các config có tiền tố là &quot;loda&quot;
public class LodaAppProperties {
    private String email;
    private String googleAnalyticsId;

    // standard getters and setters
}
</code></pre>
<p>Sử dụng <code>@PropertySource</code> để định nghĩa tên của file config. Nếu không có annotation này, Spring sẽ sử dụng file mặc định (<em>classpath:application.yml</em> trong thư mục <em>resources</em>)</p>
<p>Cuối cùng là <code>@ConfigurationProperties</code>, Annotation này đánh dấu class bên dưới nó là properties, các thuộc tính sẽ được tự động nạp vào khi Spring khởi tạo. Lưu ý: các thuộc tính này được xác định bởi <code>prefix=loda</code>. Cái này bạn xem file <em>application.yml</em> ở dưới sẽ hiểu.</p>
<p>Spring sẽ tự tìm các hàm setter để set giá trị cho các thuộc tính này, nên quan trọng là bạn phải tạo ra các setter method. (Ở đây tôi nhường việc đó cho lombok).</p>
<p>Ngoài ra, để chạy được tính năng này, bạn cần kích hoạt nó bằng cách gắn <code>@EnableConfigurationProperties</code> lên một Configuration nào đó. Ở đây tôi gắn lên hàm main luôn.</p>
<pre><code class="language-java">@SpringBootApplication
@EnableConfigurationProperties
public class App {
    public static void main(String[] args) {
        SpringApplication.run(App.class, args);
    }
}
</code></pre>
<p>Bây giờ, Spring sẽ tự động bind toàn bộ giá trị từ trong file application.yml vào bean LodaAppProperties cho chúng ta. Tạo ra file <em>application.yml</em> tại thư mục resources. Thêm các thông tin chúng ta cần. Chúng ta phải đặt các thuộc tính này sau prefix <em>loda</em>:</p>
<pre><code>loda:
  email: loda.namnh@gmail.com
  googleAnalyticsId: U-xxxxx
</code></pre>
<h3 id="chạy-thử"><a class="header" href="#chạy-thử"><strong>Chạy thử</strong></a></h3>
<pre><code class="language-java">@SpringBootApplication
@EnableConfigurationProperties
public class App implements CommandLineRunner {
    public static void main(String[] args) {
        SpringApplication.run(App.class, args);
    }

    @Autowired LodaAppProperties lodaAppProperties;

    @Override
    public void run(String... args) throws Exception {
        System.out.println(&quot;Global variable:&quot;);
        System.out.println(&quot;\t Email: &quot;+lodaAppProperties.getEmail());
        System.out.println(&quot;\t GA ID: &quot;+lodaAppProperties.getGoogleAnalyticsId());
    }
}
</code></pre>
<p>Kết quả:</p>
<pre><code>Global variable:
	 Email: loda.namnh@gmail.com
	 GA ID: U-xxxxx
</code></pre>
<p>Bây giờ, ở bất kỳ đâu trong chương trình, khi cần lấy các thông tin config, tôi chỉ cần:</p>
<pre><code class="language-java">@Autowired LodaAppProperties lodaAppProperties;
</code></pre>
<h3 id="nested-properties"><a class="header" href="#nested-properties"><strong>Nested Properties</strong></a></h3>
<p>Chúng ta có thể config các thuộc tính bên trong Class kể cả khi nó là <code>Lists</code>, <code>Maps</code> hay một class khác.</p>
<p>Bổ sung thêm thuộc tính:</p>
<pre><code class="language-java">...
@ConfigurationProperties(prefix = &quot;loda&quot;) // Chỉ lấy các config có tiền tố là &quot;loda&quot;
public class LodaAppProperties {
    ...
    private List&lt;String&gt; authors;
    private Map&lt;String, String&gt; exampleMap;
}
</code></pre>
<p>Sửa file <em>application.yml</em>:</p>
<pre><code>loda:
  email: loda.namnh@gmail.com
  googleAnalyticsId: U-xxxxx
  authors:
    - loda
    - atom
  exampleMap:
    key1: hello
    key2: world
</code></pre>
<p>Chạy lại chương trình:</p>
<pre><code class="language-java">@Override
public void run(String... args) throws Exception {
    System.out.println(&quot;Global variable:&quot;);
    System.out.println(&quot;\t Email: &quot; + lodaAppProperties.getEmail());
    System.out.println(&quot;\t GA ID: &quot; + lodaAppProperties.getGoogleAnalyticsId());
    System.out.println(&quot;\t Authors: &quot; + lodaAppProperties.getAuthors());
    System.out.println(&quot;\t Example Map: &quot; + lodaAppProperties.getExampleMap());
}
</code></pre>
<p>Kết quả:</p>
<pre><code>Global variable:
	 Email: loda.namnh@gmail.com
	 GA ID: U-xxxxx
	 Authors: [loda, atom]
	 Example Map: {key1=hello, key2=world}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chạy-nhiều-môi-trường-với-spring-profile"><a class="header" href="#chạy-nhiều-môi-trường-với-spring-profile">Chạy nhiều môi trường với Spring Profile</a></h1>
<h3 id="1-tạo-file-config"><a class="header" href="#1-tạo-file-config">1. Tạo file config</a></h3>
<p><code>Spring Profiles</code> có sẵn trong Framework rồi nên bạn không cần thêm bất kì thư viện nào khác. Để sử dụng, các bạn tạo file config tại thư mục <code>resources</code> trong project. Mặc định Spring sẽ nhận các file có tên như sau:</p>
<pre><code class="language-yaml">application.properties
application.yml
application-{profile-name}.yml // .properties
</code></pre>
<p>ví dụ mình có 2 môi trường là <code>local</code> và <code>aws</code>, thì mình sẽ tạo ra các file như thế này:</p>
<pre><code class="language-yaml">application.yml
application-local.yml
application-aws.yml
application-common.yml
</code></pre>
<ul>
<li><code>application</code> là file config chính khai báo các enviroment.</li>
<li><code>application-local</code> chỉ sử dụng khi chạy chương trình ở local</li>
<li><code>application-aws</code> chỉ sử dụng khi chạy ở AWS</li>
<li><code>application-common</code> là những config dùng chung, môi trường nào cũng cần.</li>
</ul>
<p>Bây giờ, mình sẽ khai báo trong từng file như sau (Xóa bớt nội dung từng tệp rùi cho ngắn gọn):</p>
<p><em>application.yml</em></p>
<pre><code class="language-yml">#application.yml
---
spring.profiles: local
spring.profiles.include: common, local
---
spring.profiles: aws
spring.profiles.include: common, aws
---
</code></pre>
<p><em>application-aws.yml</em></p>
<pre><code class="language-yml">spring:
  datasource:
    username: xxx
    password: xxx
</code></pre>
<p><em>application-local.yml</em></p>
<pre><code class="language-yml">spring:
  datasource:
    username: root
    password:
    url: jdbc:mysql://localhost:3306/news?useSSL=false&amp;characterEncoding=UTF-8
</code></pre>
<p><em>application-common.yml</em></p>
<pre><code class="language-yml">spring:
  jpa:
    properties:
</code></pre>
<p>Tadaa, xong, mình giải thích chút. bạn để ý trong file <code>application.yml</code> mình có khai báo 2 môi trường là <code>local</code> và <code>aws</code>. Tại mỗi môi trường sẽ <code>include</code> (bao gồm) các file config như kia. Khi mình kích hoạt <code>aws</code> chẳng hạn, <em>Spring</em> sẽ load tất cả config có trong <code>application-common.yml</code> và <code>application-aws.yml</code>.</p>
<h3 id="2-kích-hoạt-config"><a class="header" href="#2-kích-hoạt-config">2. Kích hoạt config</a></h3>
<p>Để sử dụng một <code>Profiles</code> bạn có các cách sau:</p>
<h4 id="sử-dụng-springprofilesactive-trong-file-applicationproperties-hoặc-applicationyml"><a class="header" href="#sử-dụng-springprofilesactive-trong-file-applicationproperties-hoặc-applicationyml">Sử dụng <code>spring.profiles.active</code> trong file <code>application.properties</code> hoặc <code>application.yml</code></a></h4>
<pre><code>spring.profiles.active=aws
</code></pre>
<h4 id="3-sử-dụng-jvm-system-parameter-nên-dùng"><a class="header" href="#3-sử-dụng-jvm-system-parameter-nên-dùng">3: Sử dụng JVM System Parameter (nên dùng)</a></h4>
<pre><code>-Dspring.profiles.active=aws
</code></pre>
<h4 id="4-environment-variable-unix-nên-dùng"><a class="header" href="#4-environment-variable-unix-nên-dùng">4: Environment Variable (Unix) (nên dùng)</a></h4>
<pre><code>export SPRING_PROFILES_ACTIVE=aws
</code></pre>
<h3 id="3-cách-sử-dụng-profile"><a class="header" href="#3-cách-sử-dụng-profile">3. Cách sử dụng @Profile</a></h3>
<p>Khi đã có <code>Profile</code> rồi, ngoài các biến toàn cục được thay đổi theo môi trường, bạn cũng có thể toàn quyền quyết định xem trong code rằng <code>Bean</code> hay <code>Class</code> nào sẽ được quyền chạy ở môi trường nào. Bằng cách sử dụng annotation <code>@Profile</code></p>
<pre><code class="language-java">// Bean này Spring chỉ khởi tạo và quản lý khi môi trường là `local`
@Component
@Profile(&quot;local&quot;)
public class LocalDatasourceConfig {}
// Ngoài ra bạn có thể sử dụng toàn tử logic ở đây, ví dụ:
@Component
@Profile(&quot;!local&quot;)
public class LocalDatasourceConfig {}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hướng-dẫn-chi-tiết-test-spring-boot"><a class="header" href="#hướng-dẫn-chi-tiết-test-spring-boot">Hướng dẫn chi tiết Test Spring Boot</a></h1>
<p>Hôm nay chúng ta sẽ tìm hiểu cách để viết TestCase trong <strong>Spring Boot</strong>. Yêu cầu tối thiếu để đi tiếp phần này đó là bạn phải có nền tảng với <code>JUnit</code> và <code>Mockito</code>.</p>
<h3 id="vấn-đề-test--spring"><a class="header" href="#vấn-đề-test--spring"><strong>Vấn đề Test + Spring</strong></a></h3>
<p><strong>Spring Boot</strong> sẽ phải tạo Context và tìm kiếm các Bean và nhét vào đó. Sau tất cả các bước config và khởi tạo thì chúng ta sử dụng <code>@Autowired</code> để lấy đối tượng ra sử dụng. Vấn đề đầu tiên bạn nghĩ tới khi viết Test sẽ là làm sao <code>@Autowired</code> bean vào class Test được và làm sao cho <code>JUnit</code> hiểu <code>@Autowired</code> là gì. Hướng giải quyết là tích hợp <code>Spring</code> vào với <code>JUnit</code>.</p>
<h3 id="runwithspringrunnerclass"><a class="header" href="#runwithspringrunnerclass"><strong>@RunWith(SpringRunner.class)</strong></a></h3>
<p><strong>Spring Boot</strong> đã thiết kế ra lớp <code>SpringRunner</code>, sẽ giúp chúng ta tích hợp <strong>Spring + JUnit</strong>.</p>
<p>Để test trong Spring, trong mọi class Test chúng ta sẽ thêm <code>@RunWith(SpringRunner.class)</code> lên đầu Class Test đó.</p>
<pre><code>@RunWith(SpringRunner.class)
public class TodoServiceTest {
    ...
}
</code></pre>
<p>Khi bạn chạy <code>TodoServiceTest</code> nó sẽ tạo ra một <code>Context</code> riêng để chứa <code>bean</code> trong đó, vậy là chúng ta có thể <code>@Autowired</code> thoải mái trong nội hàm Class này.</p>
<p>Vấn đề tiếp theo là làm sao đưa <code>Bean</code> vào trong <code>Context</code>.</p>
<p>Có 2 cách</p>
<ol>
<li><code>@SpringBootTest</code></li>
<li><code>@TestConfiguration</code></li>
</ol>
<h3 id="springboottest"><a class="header" href="#springboottest"><strong>@SpringBootTest</strong></a></h3>
<p><code>@SpringBootTest</code> sẽ đi tìm kiếm class có gắn <code>@SpringBootApplication</code> và từ đó đi tìm toàn bộ <code>Bean</code> và nạp vào <code>Context</code>.</p>
<p>Cái này chỉ nên sử dụng trong trường hợp muốn Integration Tests, vì nó sẽ tạo toàn bộ <code>Bean</code>, không khác gì bạn chạy cả cái <code>SpringApplication.run(App.class, args);</code>, rất tốn thời gian mà rất nhiều <code>Bean</code> thừa thãi, không cần dùng đến cũng khởi tạo.</p>
<pre><code>@RunWith(SpringRunner.class)
@SpringBootTest
public class TodoServiceTest {

    /**
     * Cách này sử dụng @SpringBootTest
     * Nó sẽ load toàn bộ Bean trong app của bạn lên,
     * Giống với việc chạy App.java vậy
     */

    @Autowired
    private TodoService todoService;
}
</code></pre>
<h3 id="testconfiguration"><a class="header" href="#testconfiguration"><strong>@TestConfiguration</strong></a></h3>
<p><code>@TestConfiguration</code> giống với <code>@Configuration</code>, chúng ta tự định nghĩa ra <code>Bean</code>.</p>
<p>Các Bean được tạo bởi <code>@TestConfiguration</code> chỉ tồn tại trong môi trường Test. Rất phụ hợp với việc viết UnitTest.</p>
<p>Class Test nào, cần Bean gì, thì tự tạo ra trong <code>@TestConfiguration</code></p>
<pre><code>@RunWith(SpringRunner.class)
public class TodoServiceTest2 {

    /**
     * Cách này sử dụng @TestConfiguration
     * Nó chỉ tạo ra Bean trong Context test này mà thôi
     * Tiết kiệm thời gian hơn khi sử dụng @SpringBootTest (vì phải load hết Bean lên mà không dùng đến)
     */
    @TestConfiguration
    public static class TodoServiceTest2Configuration{

        /*
        Tạo ra trong Context một Bean TodoService
         */
        @Bean
        TodoService todoService(){
            return new TodoService();
        }
    }

    @Autowired
    private TodoService todoService;
</code></pre>
<h3 id="mockbean"><a class="header" href="#mockbean"><strong>@MockBean</strong></a></h3>
<p><strong>Spring</strong> hỗ trợ mock với annotation <code>@MockBean</code>, chúng ta có thể mock lấy ra một <code>Bean</code> &quot;giả&quot; mà không thèm để ý tới thằng <code>Bean</code> &quot;thật&quot;. (Kể cả thằng &quot;thật&quot; có ở trong Context đi nữa, cũng không quan tâm).</p>
<pre><code>@RunWith(SpringRunner.class)
public class TodoServiceTest2 {

    /**
     * Đối tượng TodoRepository sẽ được mock, chứ không phải bean trong context
     */
    @MockBean
    TodoRepository todoRepository;
</code></pre>
<h3 id="demo-1"><a class="header" href="#demo-1"><strong>Demo 1</strong></a></h3>
<p>Chúng ta sẽ học cách sử dụng các Annotation ở trên.</p>
<h3 id="cài-đặt"><a class="header" href="#cài-đặt"><strong>Cài đặt</strong></a></h3>
<p><em>pom.xml</em></p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;packaging&gt;pom&lt;/packaging&gt;
    &lt;parent&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
        &lt;version&gt;2.0.5.RELEASE&lt;/version&gt;
        &lt;relativePath /&gt; &lt;!-- lookup parent from repository --&gt;
    &lt;/parent&gt;
    &lt;groupId&gt;me.loda.spring&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-learning&lt;/artifactId&gt;
    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
    &lt;name&gt;spring-boot-learning&lt;/name&gt;
    &lt;description&gt;Everything about Spring Boot&lt;/description&gt;

    &lt;properties&gt;
        &lt;java.version&gt;1.8&lt;/java.version&gt;
    &lt;/properties&gt;

    &lt;dependencies&gt;

        &lt;!--spring mvc, rest--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;!--for test--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

    &lt;build&gt;
        &lt;plugins&gt;
        &lt;plugin&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
        &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;

&lt;/project&gt;
</code></pre>
<p>Cấu trúc thư mục:</p>
<p>!image</p>
<h3 id="tạo-model-service-repository"><a class="header" href="#tạo-model-service-repository"><strong>Tạo Model, Service, Repository</strong></a></h3>
<p>Chúng ta sử dụng Lombok cho tiện nhé.</p>
<p><em>Todo.java</em></p>
<pre><code>@Data
@AllArgsConstructor
public class Todo {
    private int id;
    private String title;
    private String detail;
}
</code></pre>
<p>Vì phục vụ mục đích demo, chúng ta sẽ không cần sử dụng tới <strong>Spring JPA</strong> mà sẽ tự viết.</p>
<p><em>TodoRepository.java</em></p>
<pre><code>public interface TodoRepository {
    List&lt;Todo&gt; findAll();

    Todo findById(int id);
}
</code></pre>
<p><em>TodoService.java</em></p>
<pre><code>@Service
public class TodoService {
    @Autowired
    private TodoRepository todoRepository;

    public int countTodo(){
        return todoRepository.findAll().size();
    }

    public Todo getTodo(int id){
        return todoRepository.findById(id);
    }

    public List&lt;Todo&gt; getAll(){
        return todoRepository.findAll();
    }
}
</code></pre>
<p><em>App.java</em></p>
<pre><code>@SpringBootApplication
public class App {
    public static void main(String[] args) {
        SpringApplication.run(App.class, args);
    }
}
</code></pre>
<p>Rất đơn giản.</p>
<h3 id="test-bằng-springboottest"><a class="header" href="#test-bằng-springboottest"><strong>Test bằng @SpringBootTest</strong></a></h3>
<p>Chúng ta <code>mock TodoRepository</code> và giả lập cho nó trả ra một <code>List&lt;Todo&gt;</code> gồm 10 phần tử.</p>
<pre><code>@RunWith(SpringRunner.class)
@SpringBootTest
public class TodoServiceTest {

    /**
     * Cách này sử dụng @SpringBootTest
     * Nó sẽ load toàn bộ Bean trong app của bạn lên,
     * Giống với việc chạy App.java vậy
     */

    /**
     * Đối tượng TodoRepository sẽ được mock, chứ không phải bean trong context
     */
    @MockBean
    TodoRepository todoRepository;

    @Autowired
    private TodoService todoService;

    @Before
    public void setUp() {
        Mockito.when(todoRepository.findAll())
               .thenReturn(IntStream.range(0, 10)
                                    .mapToObj(i -&gt; new Todo(i, &quot;title-&quot; + i, &quot;detail-&quot; + i))
                                    .collect(Collectors.toList()));

    }

    @Test
    public void testCount() {
        Assert.assertEquals(10, todoService.countTodo());
    }

}
</code></pre>
<p>Bạn sẽ thấy Test chạy thành công, nhưng sẽ mất thời gian vì khởi tạo <code>Context</code> quá lâu do <code>@SpringBootTest</code> phải load hết tất cả bean lên.</p>
<h3 id="test-bằng-testconfiguration"><a class="header" href="#test-bằng-testconfiguration"><strong>Test bằng @TestConfiguration</strong></a></h3>
<pre><code>```java
package me.loda.spring.testinginspringboot;
/*******************************************************
 * For Vietnamese readers:
 *    Các bạn thân mến, mình rất vui nếu project này giúp
 * ích được cho các bạn trong việc học tập và công việc. Nếu
 * bạn sử dụng lại toàn bộ hoặc một phần source code xin để
 * lại dường dẫn tới github hoặc tên tác giá.
 *    Xin cảm ơn!
 *******************************************************/

import java.util.stream.Collectors;
import java.util.stream.IntStream;

import org.junit.Assert;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.Mockito;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.TestConfiguration;
import org.springframework.boot.test.mock.mockito.MockBean;
import org.springframework.context.annotation.Bean;
import org.springframework.test.context.junit4.SpringRunner;

@RunWith(SpringRunner.class)
public class TodoServiceTest2 {

    /**
     * Cách này sử dụng @TestConfiguration
     * Nó chỉ tạo ra Bean trong Context test này mà thôi
     * Tiết kiệm thời gian hơn khi sử dụng @SpringBootTest (vì phải load hết Bean lên mà không dùng đến)
     */
    @TestConfiguration
    public static class TodoServiceTest2Configuration{

        /*
        Tạo ra trong Context một Bean TodoService
         */
        @Bean
        TodoService todoService(){
            return new TodoService();
        }
    }

    @MockBean
    TodoRepository todoRepository;

    @Autowired
    private TodoService todoService;

    @Before
    public void setUp() {
        Mockito.when(todoRepository.findAll())
               .thenReturn(IntStream.range(0, 10)
                                    .mapToObj(i -&gt; new Todo(i, &quot;title-&quot; + i, &quot;detail-&quot; + i))
                                    .collect(Collectors.toList()));

    }

    @Test
    public void testCount() {
        Assert.assertEquals(10, todoService.countTodo());
    }

}
</code></pre>
<h3 id="vấn-đề-test--spring-boot-2"><a class="header" href="#vấn-đề-test--spring-boot-2"><strong>Vấn đề Test + Spring Boot 2</strong></a></h3>
<p>Ở trên chúng ta đã xử lý xong vấn đề dependency injection của <strong>JUnit</strong> + <strong>Spring Boot</strong> rồi.</p>
<p>Vấn đề tiếp theo là cái <strong>Controller</strong>. Đúng vậy, chúng ta tạo ra hàng chục Rest API đón request người dùng, vậy làm sao để test nó.</p>
<p>Nếu <strong>Controller</strong> không được test thì là một lỗ hổng cực lớn, vì nó là đầu ra chính của chương trình, nó sai -&gt; chương trình không có giá trị.</p>
<p>Tuy nhiên, chúng ta không muốn khởi động cả Tomcat Server + Database để test 1 API. Nó rất tốn tài nguyên và thời gian.</p>
<h3 id="webmvctest"><a class="header" href="#webmvctest"><strong>@WebMvcTest</strong></a></h3>
<p><strong>Spring Boot</strong> hỗ trợ test <strong>Controller</strong> mà không cần khởi động Tomcat Server bằng annotation <code>@WebMvcTest</code>.</p>
<p>Tất nhiên là nếu không khởi động Server, thì phải có một phương thức khác giả lập, vâng, lại là <strong>Mock</strong>.</p>
<p>Bây giờ, khi muốn test một Controller nào đó, chúng ta làm như sau:</p>
<pre><code>@RunWith(SpringRunner.class)
// Bạn cần cung cấp lớp Controller cho @WebMvcTest
@WebMvcTest(TodoRestController.class)
public class TodoRestControllerTest {
    /**
     * Đối tượng MockMvc do Spring cung cấp
     * Có tác dụng giả lập request, thay thế việc khởi động Server
     */
    @Autowired
    private MockMvc mvc;
}
</code></pre>
<h3 id="demo-2"><a class="header" href="#demo-2"><strong>Demo 2</strong></a></h3>
<p>Chúng ta vẫn sử dụng tiếp Project đã tạo ở <strong># Demo 1</strong></p>
<h3 id="tạo-controller"><a class="header" href="#tạo-controller"><strong>Tạo Controller</strong></a></h3>
<p><em>TodoRestController.java</em></p>
<pre><code>@RestController
@RequestMapping(&quot;/api/v1&quot;)
public class TodoRestController {
    @Autowired
    TodoService todoService;

    @GetMapping(&quot;/todo&quot;)
    public List&lt;Todo&gt; findAll(){
        return todoService.getAll();
    }
}
</code></pre>
<h3 id="tạo-test-controller"><a class="header" href="#tạo-test-controller"><strong>Tạo Test Controller</strong></a></h3>
<pre><code>import static org.hamcrest.CoreMatchers.is;
import static org.hamcrest.Matchers.hasSize;
import static org.mockito.BDDMockito.given;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;
import org.springframework.boot.test.mock.mockito.MockBean;
import org.springframework.http.MediaType;
import org.springframework.test.context.junit4.SpringRunner;
import org.springframework.test.web.servlet.MockMvc;

@RunWith(SpringRunner.class)
// Bạn cần cung cấp lớp Controller cho @WebMvcTest
@WebMvcTest(TodoRestController.class)
public class TodoRestControllerTest {
    /**
     * Đối tượng MockMvc do Spring cung cấp
     * Có tác dụng giả lập request, thay thế việc khởi động Server
     */
    @Autowired
    private MockMvc mvc;

    @MockBean
    private TodoService todoService;

    @Test
    public void testFindAll() throws Exception {
        // Tạo ra một List&lt;Todo&gt; 10 phần tử
        List&lt;Todo&gt; allTodos = IntStream.range(0, 10)
                                       .mapToObj(i -&gt; new Todo(i, &quot;title-&quot; + i, &quot;detail-&quot; + i))
                                       .collect(Collectors.toList());

        // giả lập todoService trả về List mong muốn
        given(todoService.getAll()).willReturn(allTodos);

        mvc.perform(get(&quot;/api/v1/todo&quot;).contentType(MediaType.APPLICATION_JSON)) // Thực hiện GET REQUEST
           .andExpect(status().isOk()) // Mong muốn Server trả về status 200
           .andExpect(jsonPath(&quot;$&quot;, hasSize(10))) // Hi vọng server trả về List độ dài 10
           .andExpect(jsonPath(&quot;$[0].id&quot;, is(0))) // Hi vọng phần tử trả về đầu tiên có id = 0
           .andExpect(jsonPath(&quot;$[0].title&quot;, is(&quot;title-0&quot;))) // Hi vọng phần tử trả về đầu tiên có title = &quot;title-0&quot;
           .andExpect(jsonPath(&quot;$[0].detail&quot;, is(&quot;detail-0&quot;)));
    }
}
</code></pre>
<p>Chạy thử và trải nghiệm bạn nhé :3</p>
<h3 id="kết"><a class="header" href="#kết"><strong>Kết</strong></a></h3>
<p>Test là một phần quan trọng trong hệ thống, hi vọng các đọc kĩ và thực hành để nắm chắc.</p>
<p>💁 Nếu có, toàn bộ project / code mẫu được lưu trữ tại <strong>GitHub</strong></p>
<p>🌟 Đây là một bài viết trong Series <strong>Làm chủ Spring Boot – Zero to Hero</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hướng-dẫn-chi-tiết-test-spring-boot-phần-2"><a class="header" href="#hướng-dẫn-chi-tiết-test-spring-boot-phần-2">Hướng dẫn chi tiết Test Spring Boot (Phần 2)</a></h1>
<p>Trong bài này, tôi sẽ tập trung vào việc giới thiệu với các các bạn cách chuẩn bị dữ liệu test.</p>
<p>Bài viết có sử dụng:</p>
<ol>
<li>Hibernate là gì?</li>
<li>Spring JPA</li>
<li>Lombok</li>
<li>Spring Boot</li>
</ol>
<h3 id="cài-đặt-1"><a class="header" href="#cài-đặt-1"><strong>Cài đặt</strong></a></h3>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;projectxmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;&lt;parent&gt;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;&lt;version&gt;2.0.5.RELEASE&lt;/version&gt;&lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;
	&lt;/parent&gt;&lt;groupId&gt;me.loda.spring&lt;/groupId&gt;&lt;artifactId&gt;example-independent-maven-spring-project&lt;/artifactId&gt;&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;&lt;name&gt;example-independent-maven-spring-project&lt;/name&gt;&lt;description&gt;Demo project for Spring Boot&lt;/description&gt;&lt;properties&gt;&lt;java.version&gt;1.8&lt;/java.version&gt;&lt;/properties&gt;&lt;dependencies&gt;&lt;dependency&gt;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;&lt;scope&gt;runtime&lt;/scope&gt;&lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt;&lt;dependency&gt;&lt;groupId&gt;org.projectlombok&lt;/groupId&gt;&lt;artifactId&gt;lombok&lt;/artifactId&gt;&lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt;&lt;dependency&gt;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;&lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;!--spring jpa--&gt;
		&lt;dependency&gt;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--in memory database--&gt;
		&lt;dependency&gt;&lt;groupId&gt;com.h2database&lt;/groupId&gt;&lt;artifactId&gt;h2&lt;/artifactId&gt;&lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;&lt;/dependencies&gt;&lt;build&gt;&lt;plugins&gt;&lt;plugin&gt;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;&lt;/plugin&gt;&lt;/plugins&gt;&lt;/build&gt;&lt;/project&gt;
</code></pre>
<h3 id="prepare"><a class="header" href="#prepare"><strong>Prepare</strong></a></h3>
<p>Trước hết, giả sử chúng ta có một hệ thống quản lý công việc</p>
<p><em>Todo.java</em></p>
<pre><code>@Data
@AllArgsConstructor
@NoArgsConstructor
@Entity
public class Todo {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private int id;
    private String title;
    private String detail;
}
</code></pre>
<p><em>TodoRepository.java</em></p>
<pre><code>public interface TodoRepository extends JpaRepository&lt;Todo, Long&gt; {
    List&lt;Todo&gt; findAll();

    Todo findById(int id);
}
</code></pre>
<p><em>TodoController.java</em></p>
<pre><code>@RestController
@RequestMapping(&quot;/api/v1&quot;)
@RequiredArgsConstructor
public class TodoRestController {
    private final TodoService todoService;

    @GetMapping(&quot;/todo&quot;)
    public List&lt;Todo&gt; findAll() {
        return todoService.getAll();
    }
}
</code></pre>
<h3 id="datajpatest"><a class="header" href="#datajpatest"><strong>@DataJpaTest</strong></a></h3>
<p>Về cơ bản, chúng ta không thể mock hay làm giả dữ liệu của Database mãi được, nó sẽ là một lỗ hổng lớn trong hệ thống. Ngoài ra, bạn cũng sẽ không thể test được quá trình thao tác với Database của dự án.</p>
<p>Vậy nên sau cùng, chúng ta cũng sẽ phải test các thao tác vận hành với Database,</p>
<p>Nhưng chớ lo, để tập trung vào việc test các thao tác với Database, Spring Boot đã hỗ trợ chúng ta bằng <code>@DataJpaTest</code></p>
<p>Kết hợp giữa <code>@DataJpaTest</code> và <code>h2-database</code> (Memory database) là Combo hoàn hảo.</p>
<pre><code>@RunWith(SpringRunner.class)
/**
 * Khi đánh dấu một class là @DataJpaTest.
 * Spring Boot sẽ load lên tất cả các Bean có liên quan tới tầng Repository
 * Thay vì load hết tất cả Bean như là @SpringBootTest
 */
@DataJpaTest
public class DataJpaAnnotationTest {

    @Autowired
    private DataSource dataSource;
    @Autowired
    private JdbcTemplate jdbcTemplate;
    @Autowired
    private EntityManager entityManager;
    @Autowired
    private TodoRepository todoRepository;

    @Test
    public void allComponentAreNotNull() {
        Assertions.assertThat(dataSource).isNotNull();
        Assertions.assertThat(jdbcTemplate).isNotNull();
        Assertions.assertThat(entityManager).isNotNull();
        Assertions.assertThat(todoRepository).isNotNull();
    }

}
</code></pre>
<p><code>@DataJpaTest</code> có tác dụng khởi tạo các Bean cần thiết cho tầng Repository. Ngoài ra, nó không khởi tạo thêm các Bean thừa thãi nào khác. (Chuyên biệt hơn <code>@SpringBootTest</code>)</p>
<h3 id="tạo-data"><a class="header" href="#tạo-data"><strong>Tạo Data</strong></a></h3>
<p>Cách Fake dữ liệu đơn giản nhất là tự insert bằng repository</p>
<pre><code>import org.assertj.core.api.Assertions;
import org.junit.After;

    @Test
    public void testTodoRepositoryByCode() {
        todoRepository.save(new Todo(0, &quot;Todo-1&quot;, &quot;Detail-1&quot;));
        todoRepository.save(new Todo(0, &quot;Todo-2&quot;, &quot;Detail-2&quot;));

        Assertions.assertThat(todoRepository.findAll()).hasSize(2);
        Assertions.assertThat(todoRepository.findById(1).getTitle()).isEqualTo(&quot;Todo-1&quot;);
    }

    @After
    public void clean() {
        todoRepository.deleteAll();
    }
</code></pre>
<h3 id="sql"><a class="header" href="#sql"><strong>@Sql</strong></a></h3>
<p>Một cách làm hay hơn để chuẩn bị dữ liệu cho Test đó là sử dụng annotation <code>@Sql</code></p>
<p><code>@Sql</code> có tác dụng load một hoặc nhiều file scripts sql lên và thực thi.</p>
<p>ví dụ:</p>
<p><em>createToDo.sql</em></p>
<pre><code>INSERT INTO todo (title, detail) VALUES ('Todo-1', 'Do homework');
INSERT INTO todo (title, detail) VALUES ('Todo-2', 'Walking');
</code></pre>
<p>Để chạy scripts này trong class Test, bạn làm như sau:</p>
<pre><code>@RunWith(SpringRunner.class)
@DataJpaTest
public class SqlAnnotationTest {
    @Autowired
    private TodoRepository todoRepository;

    @Test
    @Sql(&quot;/createTodo.sql&quot;)
    public void testTodoRepositoryBySqlSchema() {
        Assertions.assertThat(todoRepository.findAll()).hasSize(2);
        Assertions.assertThat(todoRepository.findById(1).getTitle()).isEqualTo(&quot;Todo-1&quot;);
    }

}
</code></pre>
<p>Để chạy nhiều file sql cùng lúc, bạn sử dụng <code>@SqlGroup</code></p>
<h3 id="kết-1"><a class="header" href="#kết-1"><strong>Kết</strong></a></h3>
<p>💁 Nếu có, toàn bộ project / code mẫu được lưu trữ tại <strong>GitHub</strong></p>
<p>🌟 Đây là một bài viết trong Series <strong>Làm chủ Spring Boot – Zero to Hero</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sb20-hướng-dẫn-toàn-tập-mockito"><a class="header" href="#sb20-hướng-dẫn-toàn-tập-mockito">[SB20] Hướng dẫn toàn tập Mockito</a></h1>
<h3 id="yêu-cầu"><a class="header" href="#yêu-cầu"><strong>Yêu cầu</strong></a></h3>
<p>Trước khi tìm hiểu Mockito, bạn cần biết JUnit.</p>
<p>Trong bài viết có sử dụng Lombok</p>
<h3 id="giới-thiệu-4"><a class="header" href="#giới-thiệu-4"><strong>Giới thiệu</strong></a></h3>
<p>Về cơ bản, Unit test là phương pháp tiếp cận độc lập, tức là mỗi một chức chăng năng sẽ được đi kèm với một hoặc nhiều bài test để chắc chắn ràng cái chức năng đó hoạt động ổn. Vậy nên Unit Test thường là đơn nhỏ nhất và test case cũng dễ dàng khởi tạo</p>
<pre><code>@Test
public void testSum(){
    Assert.assertEquals(3, MathUtil.sum(1,2));
}
</code></pre>
<p>Bài toán mở rộng ra hơn, Khi chúng ta phải test sự hoạt động phối hợp giữa nhiều chức năng hay thành phần với nhau hoặc muốn test một chức năng lớn thì sẽ trở nên phức tạp và khó xây dựng hơn rất nhiều.</p>
<p>Các kịch bản sau thường diễn ra:</p>
<ul>
<li>Chức năng A gọi tới chức năng B. tuy nhiên, B chưa viết xong</li>
<li>Chức năng A gọi tới chức năng B. tuy nhiên, B khởi tạo rất phức tạp (truy xuất Database, yêu cầu nhiều params, v.v.)</li>
<li>Muốn test chức năng A, tuy nhiên A yêu cầu nỗ lực lớn của cả hệ thống (Yêu cầu có HTTP-server, authorize, v.v.)</li>
</ul>
<pre><code>// Giả sử muốn test hàm này
public int getAllData(){

    // Giả sử như thằng driver không được khởi tạo hoặc bị lỗi
    // thì function này coi như hỏng

    MySQLdriver.connect() // Kết nối xuống Database
    var data = MySQLdriver.get()// Lấy dữ liệu

    // Chúng ta muốn test logic xử lý dữ liệu ở dưới đây,
    // mà k cần kết nối databse, phải làm sao?

    // Xử lý dữ liệu
    ...
    // trả ra dữ liệu
    return data
}
</code></pre>
<p>Rất nhiều kịch bản phức tạp xảy ra, mà trên thực tế, chúng ta chỉ mong muốn confirm rằng A ổn, chứ thằng B, C, D gì đó thì hãy cứ tạm coi là nó &quot;đã ổn&quot; đi.</p>
<p>Để đơn giản hoá các kịch bản test như trên, khái niệm <code>Mock</code> ra đời.</p>
<p>Tư tưởng của <code>Mock</code> đơn giản là khi muốn test (A gọi B) thì thay vì tạo ra một đối tượng B thật sự, bạn tạo ra một thằng B' giả mạo, có đầy đủ chức năng như B thật (nhưng không phải thật)</p>
<p>Bạn sẽ giả lập cho B' biết là khi thằng A gọi tới nó, nó cần làm gì, trả lại cái gì (hardcode). Miễn làm sao cho nó trả ra đúng cái thằng A cần để chúng ta có thể test A thuận lợi nhất.</p>
<pre><code>// Đại loại như này
// Khi driver.get() được gọi, hãy trả ra một List(1,2,3)
Mockito.when(driver.get())
       .thenReturn(Arrays.asList(1, 2, 3));
</code></pre>
<p>Ở trong Java, <code>Mockito</code> chính là thư viện nổi tiếng nhất để các bạn làm việc này.</p>
<h3 id="cài-đặt-2"><a class="header" href="#cài-đặt-2"><strong>Cài đặt</strong></a></h3>
<p>Để sử dụng <code>Mockito</code> bạn cần:</p>
<pre><code>&lt;!--https://mvnrepository.com/artifact/org.mockito/mockito-core --&gt;
&lt;dependency&gt;&lt;groupId&gt;org.mockito&lt;/groupId&gt;&lt;artifactId&gt;mockito-core&lt;/artifactId&gt;&lt;version&gt;3.2.4&lt;/version&gt;&lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;
</code></pre>
<p>Chúng ta đang viết test, nên đừng quên <code>JUnit</code> nữa nhé:</p>
<pre><code>&lt;!--https://mvnrepository.com/artifact/junit/junit --&gt;
&lt;dependency&gt;&lt;groupId&gt;junit&lt;/groupId&gt;&lt;artifactId&gt;junit&lt;/artifactId&gt;&lt;version&gt;4.12&lt;/version&gt;&lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;
</code></pre>
<h3 id="cách-mock"><a class="header" href="#cách-mock"><strong>Cách Mock</strong></a></h3>
<p>Khái niệm cơ bản đầu tiên, đó là làm sao để tạo ra một đối tượng bị Mock.</p>
<h3 id="cách-1-mockitomock"><a class="header" href="#cách-1-mockitomock"><strong>Cách 1: Mockito.mock()</strong></a></h3>
<p>Sử dụng <code>Mockito.mock()</code> để tạo ra một object của <code>Class</code> bạn yêu cầu, nó thậm chí còn không quan tâm hàm khởi tạo của <code>Class</code> ý như nào và ra sao, vì nó đâu có thật :v</p>
<pre><code>@Test
public void testUserMockFunction() {
    List mockList = Mockito.mock(List.class);

    Mockito.when(mockList.size()).thenReturn(2);

    Assert.assertEquals(2, mockList.size());
}
</code></pre>
<h3 id="cách-2-sử-dụng-mock"><a class="header" href="#cách-2-sử-dụng-mock"><strong>Cách 2: Sử dụng @Mock</strong></a></h3>
<p>Bạn muốn mock cái gì, thì đánh dấu <code>@Mock</code> lên ý, đơn giản vãi :v</p>
<pre><code>@Mock
List&lt;String&gt; mockedList;
</code></pre>
<p>Tuy nhiên, gắn <code>@Mock</code> là chưa đủ, bạn cần kích hoạt <code>Mockito</code> để nó mock các object ý cho bạn.</p>
<p>Sau khi kích hoạt, thì tất cả các object được gắn <code>@Mock</code> sẽ trở thành 1 object giả mạo, và đã được khởi tạo (tức là <code>!= null</code>)</p>
<p>Các cách kích hoạt như sau:</p>
<ol>
<li>Gắn <code>@RunWith(MockitoJUnitRunner.class)</code> lên class test của bạn</li>
</ol>
<pre><code>// Cách 1
@RunWith(MockitoJUnitRunner.class)
public class MockitoAnnotationTest {
    @Mock
    List&lt;String&gt; mockedList;
}
</code></pre>
<ol>
<li>tạo ra một đối tượng <code>MockitoRule</code> bên trong class test của bạn</li>
</ol>
<pre><code>public class MockitoAnnotationTest {

    // Cách 2
    @Rule
    public MockitoRule initRule = MockitoJUnit.rule();

    @Mock
    List&lt;String&gt; mockedList;
}
</code></pre>
<ol>
<li>Sử dụng <code>Mockito.init()</code></li>
</ol>
<pre><code>public class MockitoAnnotationTest {

    @Mock
    List&lt;String&gt; mockedList;

    @Before
    public void setUp() throws Exception {
        // Cách 3
        // Nếu bạn không dùng cách 1 hoặc 2 thì phải sử dụng
        // dòng code dưới đây:
        MockitoAnnotations.initMocks(this);
    }
}
</code></pre>
<p>Vậy là xong, bạn đã tạo ra được một Object bị mock.</p>
<h3 id="cách-sử-dụng-1"><a class="header" href="#cách-sử-dụng-1"><strong>Cách sử dụng</strong></a></h3>
<p><code>Mockito</code> cung cấp rất nhiều methods khác nhau để giúp bạn giả lập đầy đủ các thứ bạn cần.</p>
<p>Hay sử dụng nhất là hàm <code>when()</code>.</p>
<pre><code>// Trả là size 100 khi gọi hàm size()
Mockito.when(mockedList.size()).thenReturn(100);
// Throw exception khi gọi hàm size()
Mockito.when(mockedList.size()).thenThrow(NullPointerException.class);
// Bạn có thể đổi ngược cách viết, còn logic vẫn vậy
// Ném ra exception khi gọi hàm .get() với tham số truyền vào bất kì
Mockito.doThrow(NullPointerException.class).when(mockedList.get(Mockito.any()));
</code></pre>
<h3 id="spy"><a class="header" href="#spy"><strong>Spy</strong></a></h3>
<p><code>Spy</code> là việc sửa một đối tượng Thật -&gt; Giả</p>
<pre><code>@RunWith(MockitoJUnitRunner.class)
public class SpyTest {
    @Spy
    List&lt;String&gt; list = new ArrayList&lt;&gt;();

    @Test
    public void testSpy() {
        list.add(&quot;one&quot;);
        list.add(&quot;two&quot;);
        // show the list items
        System.out.println(list);

        Mockito.verify(list).add(&quot;one&quot;);
        Mockito.verify(list).add(&quot;two&quot;);

        // @Spy thực sự gọi hàm .add của List nên nó có size là 2 mà không cần giả lập
        Assert.assertEquals(2, list.size());

        // Vẫn có thể làm giả thông tin gọi hàm với @Spy
        Mockito.when(list.size()).thenReturn(100);

        Assert.assertEquals(100, list.size());
    }
}
</code></pre>
<h3 id="captor"><a class="header" href="#captor"><strong>Captor</strong></a></h3>
<p><code>Captor</code> có nhiệm vụ ghi lại các tham số của đối tượng</p>
<pre><code>@RunWith(MockitoJUnitRunner.class)
public class CaptorTest {
    @Mock
    List&lt;Object&gt; list;

    @Captor
    ArgumentCaptor&lt;Object&gt; captor;

    @Test
    public void testCaptor1() {
        list.add(1);
        // Capture lần gọi add vừa rồi có giá trị là gì
        Mockito.verify(list).add(captor.capture());

        System.out.println(captor.getAllValues());

        Assert.assertEquals(1, captor.getValue());
    }
}
</code></pre>
<h3 id="inject-mock"><a class="header" href="#inject-mock"><strong>Inject Mock</strong></a></h3>
<p>Quay lại với ví dụ đầu bài viết:</p>
<p>Tôi có một lớp <code>Service</code> chứa lớp <code>DatabaseDriver</code> như sau:</p>
<pre><code>public interface DatabaseDriver {
    List&lt;Object&gt; get() throws SQLException;
}

@Data
@AllArgsConstructor
public static class SuperService {
    DatabaseDriver driver;

    public List&lt;Object&gt; getObjects() throws SQLException {
        System.out.println(&quot;LOG: Getting objects&quot;);
        List&lt;Object&gt; list = driver.get();

        System.out.println(&quot;LOG: Sorting&quot;);
        Collections.sort(list, Comparator.comparingInt(value -&gt; Integer.valueOf(value.toString())));

        System.out.println(&quot;LOG: Done&quot;);
        return list;
    }
}
</code></pre>
<p>Rõ ràng thì <code>driver</code> chính là mắt xích trong trong việc <code>SuperService</code> có hoạt động được hay không. Vì thế, muốn test được <code>SuperService</code>, chúng ta phải mock đối tượng <code>driver</code>.</p>
<p>kịch bản bây giờ sẽ là tôi mock một đối tượng của <code>DatabaseDriver</code> rồi truyền nó vào đối tượng <code>SuperService</code>.</p>
<p>Để truyền một đối tượng mock vào một đối tượng khác, chúng ta dùng <code>@InjectMocks</code>.</p>
<pre><code>@RunWith(MockitoJUnitRunner.class)
public class InjectMockTest {
    @Mock
    DatabaseDriver driver;

    /**
     * Inject driver vào superService.
     * Mọi người có thể liên tưởng nó giống với Spring Injection
     */
    @InjectMocks
    SuperService superService;

    @Test(expected = SQLException.class)
    public void testInjectMock() throws SQLException {
        // Giả lập cho driver luôn trả về list (3,2,1) khi được gọi tới
        Mockito.doReturn(Arrays.asList(3, 2, 1)).when(driver).get();

        Assert.assertEquals(driver, superService.getDriver());

        // Test xem superService trả ra ngoài có đúng không?
        Assert.assertEquals(Arrays.asList(1, 2, 3), superService.getObjects());

        // Giả lập cho driver bắn exception
        Mockito.when(driver.get()).thenThrow(SQLException.class);
        superService.getObjects();
    }
}
</code></pre>
<h3 id="kết-2"><a class="header" href="#kết-2"><strong>Kết</strong></a></h3>
<p>Tới đây, bạn đã có thể dùng <code>Mockito</code> xoành xoạch rồi.</p>
<p>Tiếp theo, có thể đọc cách sử dụng <code>Mockito</code> với <code>Spring Boot</code>tại đây</p>
<p>💁 Nếu có, toàn bộ project / code mẫu được lưu trữ tại <strong>GitHub</strong></p>
<p>🌟 Đây là một bài viết trong Series <strong>Làm chủ Spring Boot – Zero to Hero</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sb21-hướng-dẫn-tạo-bean-có-điều-kiện-với-conditional"><a class="header" href="#sb21-hướng-dẫn-tạo-bean-có-điều-kiện-với-conditional">[SB21] Hướng dẫn tạo Bean có điều kiện với @Conditional</a></h1>
<ul>
<li>Giới thiệu</li>
<li>Cách tạo bean có điều kiện</li>
<li>@ConditionalOnBean</li>
<li>@ConditionalOnProperty</li>
<li>@ConditionalOnExpression</li>
<li>@ConditionalOnMissingBean</li>
<li>@ConditionalOnResource</li>
<li>@ConditionalOnClass</li>
<li>@ConditionalOnMissingClass</li>
<li>@ConditionalOnJava</li>
<li>Một số loại khác</li>
<li>Custom Conditional</li>
<li>Kết</li>
</ul>
<h3 id="giới-thiệu-5"><a class="header" href="#giới-thiệu-5"><strong>Giới thiệu</strong></a></h3>
<p>Khi xây dựng một chương trình với <strong>Spring Boot</strong> đôi lúc chúng ta một <strong>Bean</strong> chỉ được load lên hoặc khởi tạo theo một điều kiện nào đó. Ví dụ như tạo một <strong>Bean</strong> trong môi trường Test, còn môi trường thật sẽ không cần nữa.</p>
<p><strong>Spring Boot</strong> hỗ trợ chúng ta làm điều này với Annotation <code>@Conditional</code>.</p>
<p>Bài này yêu cầu kiến thức cơ bản:</p>
<ol>
<li>「Spring Boot #0」 Series làm chủ Spring Boot, Zero to Hero</li>
</ol>
<p>Toàn bộ ví dụ trong bài viết này đều có tại Github</p>
<h3 id="cách-tạo-bean-có-điều-kiện"><a class="header" href="#cách-tạo-bean-có-điều-kiện"><strong>Cách tạo bean có điều kiện</strong></a></h3>
<p>Trong <strong>Spring Boot</strong>, có rất nhiều cách để tạo ra <code>Bean</code>, bạn biết cách nào?</p>
<p><code>@Component</code>, <code>@Configuration</code>, <code>@Bean</code>, <code>@Service</code>, v.v...</p>
<p>Với tất cả các cách tạo ra <code>Bean</code>, bạn đều có thể thêm <strong>một hoặc nhiều điều kiện</strong> để cho việc tạo ra <code>Bean</code> đó chỉ xảy ra nếu nó thỏa mãn một điều kiện cho trước.</p>
<p><strong>SpringBoot</strong> hỗ trợ rất nhiều loại điều kiện khác nhau, tất cả đều sẽ bắt đầu bằng tiền tố <code>@Conditional...</code>. Còn hậu tố thì chúng ta sẽ đề cập sau.</p>
<p>Cách thức hoạt động của tất cả <code>@Condition</code> như sau:</p>
<pre><code>@Configuration
public class ConditionalOnBeanExample {
    /*
    ABeanWithCondition chỉ được tạo ra khi @Condition thỏa mãn
    */
    @Bean
    @Conditional...
    ABeanWithCondition aBeanWithACondition() {
        return new ABeanWithCondition();
    }
}
</code></pre>
<p>Nếu bạn gắn nó trên một <code>@Configuration</code> thì toàn bộ các <code>@Bean</code> bên trong sẽ bị chịu tác động.</p>
<pre><code>@Conditional...
@Configuration
public class ConditionalOnBeanExample {
    /*
    SomeOtherBean chỉ được tạo ra khi @Condition thỏa mãn
    */
    @Bean
    SomeOtherBean someOtherBean() {
        return new SomeOtherBean();
    }
       /*
    SomeOtherBean2 chỉ được tạo ra khi @Condition thỏa mãn
    */
    @Bean
    SomeOtherBean2 someOtherBean2() {
        return new SomeOtherBean2();
    }
}
</code></pre>
<p>Tương tự cho tất cả các annotation khác như <code>@Component</code>, <code>@Service</code>, <code>@Repository</code></p>
<pre><code>@Conditional...
@Component
public class ConditionalOnBeanExample {
}
</code></pre>
<p>Bây giờ chúng ta sẽ đi tìm hiểu các loại điều kiện trong <strong>Spring Boot</strong>.</p>
<h3 id="conditionalonbean"><a class="header" href="#conditionalonbean"><strong>@ConditionalOnBean</strong></a></h3>
<p><code>@ConditionalOnBean</code> sử dụng khi chúng ta muốn tạo ra một Bean, chỉ khi có một Bean khác đang tồn tại</p>
<pre><code>@Configuration
public class ConditionalOnBeanExample {
    /*
    Đây là một Bean, bạn hãy chạy ứng dụng
    khi comment và chạy lại lần nữa nhưng bỏ dấu comment phía
    dưới để xem kết quả.
     */
    // @Bean
    RandomBean randomBean() {
        return new RandomBean();
    }

    /*
    ABeanWithCondition chỉ được tạo ra, khi RandomBean tồn tại trong Context.
     */
    @Bean
    @ConditionalOnBean(RandomBean.class)
    ABeanWithCondition aBeanWithACondition() {
        return new ABeanWithCondition();
    }
}
</code></pre>
<h3 id="conditionalonproperty"><a class="header" href="#conditionalonproperty"><strong>@ConditionalOnProperty</strong></a></h3>
<p>Dùng <code>@ConditionalOnProperty</code> khi bạn muốn quyết định sự tồn tại Bean thông qua cấu hình property.</p>
<pre><code>@Configuration
public class ConditionalOnPropertyExample {

    /*
    @ConditionalOnProperty giúp gắn điều kiện cho @Bean dựa theo
    property trong config
     */
    @Bean
    @ConditionalOnProperty(
            value=&quot;loda.bean2.enabled&quot;,
            havingValue = &quot;true&quot;, // Nếu giá trị loda.bean2.enabled  = true thì Bean mới được khởi tạo
            matchIfMissing = false) // matchIFMissing là giá trị mặc định nếu không tìm thấy property loda.bean2.enabled
    ABeanWithCondition2 aBeanWithCondition2(){
        return new ABeanWithCondition2();
    }
}
</code></pre>
<p><em>application.properties</em></p>
<pre><code>#Thay đổi thành true để tạo bean2
loda.bean2.enabled=true
</code></pre>
<h3 id="conditionalonexpression"><a class="header" href="#conditionalonexpression"><strong>@ConditionalOnExpression</strong></a></h3>
<p>Trong trường hợp bạn muốn thỏa mãn nhiều điều kiện trong property, hãy sử dụng <code>@ConditionalOnExpression</code></p>
<pre><code>@Configuration
@ConditionalOnExpression(
        &quot;${loda.expression1.enabled:true} and ${loda.expression2.enabled:true}&quot;
)
public class ConditionalOnExpressionExample {
}
</code></pre>
<h3 id="conditionalonmissingbean"><a class="header" href="#conditionalonmissingbean"><strong>@ConditionalOnMissingBean</strong></a></h3>
<p>Nếu trong <code>Context</code> chưa tồn tại bất kỳ Bean nào tương tự, thì <code>@ConditionalOnMissingBean</code> sẽ thỏa mãn điều kiện và tạo ra một Bean như thế.</p>
<pre><code>@Configuration
public class ConditionalOnMissingBeanExample {
    /**
     * Nếu trong Context chưa tồn tại một SomeMissingBean nào
     * Thì Bean ở dưới đây mới được tạo
     * @return
     */
    @ConditionalOnMissingBean
    DataSource someMissingBean(){
        return new DataSource();
    }
}
</code></pre>
<h3 id="conditionalonresource"><a class="header" href="#conditionalonresource"><strong>@ConditionalOnResource</strong></a></h3>
<p><code>@ConditionalOnResource</code> thỏa mãn khi có một resources nào đó do bạn chỉ định tồn tại</p>
<pre><code>/*
Nếu Spring Boot không tìm thấy file application.properties thì class này không được tạo
*/
@Configuration
@ConditionalOnResource(resources = &quot;/application.properties&quot;)
public class ConditionalOnResourceExample {
}
</code></pre>
<h3 id="conditionalonclass"><a class="header" href="#conditionalonclass"><strong>@ConditionalOnClass</strong></a></h3>
<p><code>@ConditionalOnClass</code> thỏa mãn khi trong classpath có tồn tại class mà bạn yêu cầu</p>
<pre><code>@Configuration
@ConditionalOnClass(name = &quot;loda.me.spring.LodaHandsome&quot;)
class ConditionalOnClassExample {
}
</code></pre>
<h3 id="conditionalonmissingclass"><a class="header" href="#conditionalonmissingclass"><strong>@ConditionalOnMissingClass</strong></a></h3>
<p><code>@ConditionalOnMissingClass</code> ngược lại với <code>@ConditionalOnClass</code>. thỏa mãn khi trong classpath <strong>không</strong> tồn tại class mà bạn yêu cầu</p>
<pre><code>@Configuration
@ConditionalOnMissingClass(name = &quot;loda.me.spring.LodaHandsome&quot;)
class ConditionalOnMissingClassExample {
}
</code></pre>
<h3 id="conditionalonjava"><a class="header" href="#conditionalonjava"><strong>@ConditionalOnJava</strong></a></h3>
<p><code>@ConditionalOnJava</code> thỏa mãn nếu môi trường chạy version Java đúng với điều kiện</p>
<pre><code>@Configuration
@ConditionalOnJava(JavaVersion.EIGHT)
class ConditionalOnJavaExample {
}
</code></pre>
<h3 id="một-số-loại-khác"><a class="header" href="#một-số-loại-khác"><strong>Một số loại khác</strong></a></h3>
<p>Vẫn còn các bạn ạ, những mình thấy nó ít khi được sử dụng, nên sẽ không đề cập, tránh loạn thông tin.</p>
<h3 id="custom-conditional"><a class="header" href="#custom-conditional"><strong>Custom Conditional</strong></a></h3>
<p>Tất nhiên là bạn hoàn toàn có thể tự tạo ra cho mình một điều kiện. Mình sẽ đề cập cách làm ở bài sau.</p>
<h3 id="kết-3"><a class="header" href="#kết-3"><strong>Kết</strong></a></h3>
<p>💁 Nếu có, toàn bộ project / code mẫu được lưu trữ tại <strong>GitHub</strong></p>
<p>🌟 Đây là một bài viết trong Series <strong>Làm chủ Spring Boot – Zero to Hero</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sb22-hướng-dẫn-tự-tạo-custom-conditional"><a class="header" href="#sb22-hướng-dẫn-tự-tạo-custom-conditional">[SB22] Hướng dẫn tự tạo custom @Conditional</a></h1>
<ul>
<li>Giới thiệu</li>
<li>Tự tạo @Conditional</li>
<li>Tự tạo Annotation @Conditional</li>
<li>Chạy thử</li>
<li>Kết hợp nhiều điều kiện với OR</li>
<li>Kết hợp nhiều điều kiện với AND</li>
<li>Kết</li>
</ul>
<h3 id="giới-thiệu-6"><a class="header" href="#giới-thiệu-6"><strong>Giới thiệu</strong></a></h3>
<p>Yêu cầu bạn phải đọc bài viết về <code>@Conditional</code> trước:</p>
<ol>
<li>[Spring Boot] Hướng dẫn tạo Bean có điều kiện với @Conditional</li>
</ol>
<p>Tôi đã giới thiệu với các bạn các sử dụng các loại <code>@Conditional</code> có sẵn trong Spring Boot. Tuy nhiên, trên thực tế, sẽ có những lúc yêu cầu các loại điều kiện nằm ngoài phạm vi của Spring Boot cung cấp.</p>
<p>Khi đó, chúng ta phải tự tạo <code>@Condinal</code> cho mình.</p>
<h3 id="tự-tạo-conditional"><a class="header" href="#tự-tạo-conditional"><strong>Tự tạo @Conditional</strong></a></h3>
<p>Để tạo ra một điều kiện cho mình, bạn cần kế thừa lớp <code>Condition</code>, và implement lại function <code>matches</code></p>
<p><code>matches</code> là nơi bạn kiểm tra điều kiện xem có thoả mãn không.</p>
<pre><code>/*
Một điều kiện, phải kế thừa lớp Condition của Spring Boot cung cấp
 */
public class WindowRequired implements Condition{

    @Override
    public boolean matches(ConditionContext conditionContext, AnnotatedTypeMetadata annotatedTypeMetadata) {
        // Nếu OS ra window trả ra true.
        return System.getProperty(&quot;os.name&quot;).toLowerCase().contains(&quot;win&quot;);
    }
}
</code></pre>
<p>Và khi đã định nghĩa được cho mình một điều kiện riêng, bạn có thể sử dụng như sau:</p>
<pre><code>@Configuration
public class AppConfiguration {
    public static class SomeBean{
    }

    /*
    SomeBean chỉ được tạo ra khi
    thỏa mãn điều kiện
     */
    @Conditional(WindowRequired.class)
    @Bean
    SomeBean someBean(){
        return new SomeBean();
    }
}
</code></pre>
<h3 id="tự-tạo-annotation-conditional"><a class="header" href="#tự-tạo-annotation-conditional"><strong>Tự tạo Annotation @Conditional</strong></a></h3>
<p>Nếu việc viết <code>@Conditional(WindowRequired.class)</code> chưa làm bạn hài lòng, bạn có thể tự tạo ra một <code>Annotation</code> giống với Spring Boot.</p>
<p>Ví dụ như <code>@ConditionalOnClass</code> trong bài viết trước</p>
<p>Thì hãy làm như sau:</p>
<pre><code>@Target({ ElementType.TYPE, ElementType.METHOD })
@Retention(RetentionPolicy.RUNTIME)
@Documented
// Đánh dấu annotation này bởi @Conditional(WindowRequired.class)
@Conditional(WindowRequired.class)
public @interface ConditionalOnWindow {
    /*
    Trong trường hợp bạn muốn viết ngắn gọn,
    hay tạo ra 1 Annotation mới và gắn @Conditional(WindowRequired.class)
    trên nó

    Như vậy khi cần sử dụng chỉ cần gọi @ConditionalOnWindow là được
     */
}
</code></pre>
<p>Khi sử dụng:</p>
<pre><code>@Configuration
public class AppConfiguration {
    public static class SomeBean{
    }

    /*
    SomeBean chỉ được tạo ra khi
    thỏa mãn điều kiện
     */
    @ConditionalOnWindow
    @Bean
    SomeBean someBean(){
        return new SomeBean();
    }
}
</code></pre>
<h3 id="chạy-thử-1"><a class="header" href="#chạy-thử-1"><strong>Chạy thử</strong></a></h3>
<pre><code>@SpringBootApplication
public class App {
    public static void main(String[] args) {
        ApplicationContext context = SpringApplication.run(App.class, args);
        try {
            SomeBean someBean = context.getBean(SomeBean.class);
            System.out.println(&quot;SomeBean tồn tại!&quot;);
        }catch (Exception e){
            System.out.println(&quot;SomeBean chỉ được tạo nếu chạy trên Window&quot;);
        }

    }
}
</code></pre>
<p>Hãy bỏ Annotation <code>@ConditionalOnWindow</code> đi và chạy thử, sau đó thêm lại, xem kết quả của 2 lần chạy.</p>
<h3 id="kết-hợp-nhiều-điều-kiện-với-or"><a class="header" href="#kết-hợp-nhiều-điều-kiện-với-or"><strong>Kết hợp nhiều điều kiện với OR</strong></a></h3>
<p>Bạn có thể kết hợp nhiều điều kiện với nhau bởi phép OR.</p>
<p>Spring Boot hỗ trợ điều này bằng cách kế thừa lớp <code>AnyNestedCondition</code></p>
<pre><code>/**
 * Class kế thừa AnyNestedCondition sẽ chấp nhận mọi
 * điều kiện @Conditional bên trong nó
 */
public class WindowOrMacRequired extends AnyNestedCondition{

    public WindowOrMacRequired(){
        super(ConfigurationPhase.REGISTER_BEAN);
    }

    /*
    Bạn phải định nghĩa các Điều kiện bên trong class
    kế thừa AnyNestedCondition
     */
    @Conditional(WindowRequired.class)
    public class RunOnWindow{}

    /*
    Lúc này, cả 2 điều kiện Window và Mac sẽ được kết hợp vs
    nhau khi kiểm tra, nếu thoả mãn 1 trong 2 là đc
     */
    @Conditional(MacRequired.class)
    public class RunOnMac{}
}
</code></pre>
<p>Sử dụng</p>
<pre><code>@Configuration
public class AppConfiguration {
    public static class SomeBean{
    }

    /*
    SomeBean chỉ được tạo ra khi
    thỏa mãn điều kiện
     */
    @Conditional(WindowOrMacRequired.class)
    @Bean
    SomeBean someBean(){
        return new SomeBean();
    }
}
</code></pre>
<h3 id="kết-hợp-nhiều-điều-kiện-với-and"><a class="header" href="#kết-hợp-nhiều-điều-kiện-với-and"><strong>Kết hợp nhiều điều kiện với AND</strong></a></h3>
<p>Bạn có thể kết hợp các điều kiện bằng phép AND bằng cách kế thừa lớp <code>AllNestedConditions</code>.</p>
<p>Cách kế thừa của nó giống với <code>AnyNestedCondition</code> nên tôi sẽ không cần đề cập thêm.</p>
<p>Ngoài ra, có một cách khác là sử dụng nhiều custom <code>@Conditional</code> cùng một lúc.</p>
<pre><code>@Bean
@ConditionalOnWindow
@Conditional(MacRequired.class)
SomeBean someBean() {
  return new SomeBean();
}
</code></pre>
<h3 id="kết-4"><a class="header" href="#kết-4"><strong>Kết</strong></a></h3>
<p>Tới đây, bạn có thể nắm vững được cách tạo điều kiện cho cấu hình ứng dụng của mình, nó sẽ rất có ích khi bạn làm việc và tách biệt được hai môi trường dev và production.</p>
<p>💁 Nếu có, toàn bộ project / code mẫu được lưu trữ tại <strong>GitHub</strong></p>
<p>🌟 Đây là một bài viết trong Series <strong>Làm chủ Spring Boot – Zero to Hero</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sb23-xử-lý-sự-kiện-với-eventlistener--async"><a class="header" href="#sb23-xử-lý-sự-kiện-với-eventlistener--async">[SB23] Xử lý sự kiện với @EventListener + @Async</a></h1>
<ul>
<li>Giới thiệu</li>
<li>Cơ bản về Event &amp; Listener</li>
<li>Áp vào thực tế</li>
<li>Event</li>
<li>Event Publisher</li>
<li>Event Listener</li>
<li>Chạy thử 1</li>
<li>@Async</li>
<li>@Async</li>
<li>Chạy thử lần 2</li>
<li>Kết</li>
</ul>
<h3 id="giới-thiệu-7"><a class="header" href="#giới-thiệu-7"><strong>Giới thiệu</strong></a></h3>
<p>Hẳn trong <strong>Java</strong> không ít thì nhiều các bạn đã từng sử dụng qua <code>Listener Pattern</code> rồi, nên tôi nghĩ sẽ không giới thiệu về nó nữa.</p>
<p>Trong bài viết này, chúng ta tập trung vào cách làm sao để thực hiện việc tạo ra <code>Event</code> và xử lý <code>Event</code> đó một cách gọn gàng với <strong>Spring Boot</strong>.</p>
<p>Bài này yêu cầu kiến thức cơ bản:</p>
<ol>
<li>「Spring Boot #0」 Series làm chủ Spring Boot, Zero to Hero</li>
</ol>
<h3 id="cơ-bản-về-event--listener"><a class="header" href="#cơ-bản-về-event--listener"><strong>Cơ bản về Event &amp; Listener</strong></a></h3>
<p>!image</p>
<p>Cơ bản là khi chương trình của bạn đang vận hành, và có một công việc gì đó, bạn không muốn xử lý trực tiếp tại Class hiện hành hoặc muốn thông báo cho các Đối tượng khác biết bạn vừa làm gì.</p>
<p>Thì bạn sẽ bắn ra một object gọi là <code>Event</code> (sự kiện), có hoặc không thông tin đi kèm, và nhiệm vụ của các thằng khác là đón lấy hay lắng nghe sự kiện đó để xử lý nghiệp vụ của riêng nó, thằng xử lý gọi là <code>Listener</code>.</p>
<p>Thằng gây ra sự kiện gọi là <code>Source</code>.</p>
<p>Còn thằng cầm sự kiện đó ném cho <code>Listener</code> gọi là <code>Pushlisher</code></p>
<h3 id="Áp-vào-thực-tế"><a class="header" href="#Áp-vào-thực-tế"><strong>Áp vào thực tế</strong></a></h3>
<p>Giả sử bạn có một cái chuông cửa, khi có người tới bấm cái chuông này. Chuông sẽ phát ra tiếng kêu.</p>
<p>Ở trong nhà có chó, nó nghe thấy tiếng kêu, nó sẽ sủa lên.</p>
<p>Thì:</p>
<ul>
<li><code>Source</code>: Người bấm chuông cửa, là người gây ra sự kiện.</li>
<li><code>Event</code>: sự kiện bấm chuông cửa</li>
<li><code>Pushlisher</code>: Cái chuông phát ra âm thanh (sự kiện) để thông báo.</li>
<li><code>Listener</code>: Con chó lắng nghe và xử lý sự kiện</li>
</ul>
<h3 id="event"><a class="header" href="#event"><strong>Event</strong></a></h3>
<p>Một <code>Event</code> (sự kiện) muốn được <strong>Spring Boot</strong> hỗ trợ thì sẽ phải kế thừa lớp <code>ApplicationEvent</code>.</p>
<pre><code>/*
DoorBellEvent phải kế thừa lớp ApplicationEvent của Spring
Như vậy nó mới được coi là một sự kiện hợp lệ.
 */
public class DoorBellEvent extends ApplicationEvent {
    /*
        Mọi Class kế thừa ApplicationEvent sẽ
        phải gọi Constructor tới lớp cha.
     */
    public DoorBellEvent(Object source, String guestName) {
        // Object source là object tham chiếu tới
        // nơi đã phát ra event này!
        super(source);
    }
}
</code></pre>
<h3 id="event-publisher"><a class="header" href="#event-publisher"><strong>Event Publisher</strong></a></h3>
<p>Trong <strong>Spring Boot</strong>, để bắn ra một sự kiện chúng ta sử dụng đối tượng <code>ApplicationEventPublisher</code>. Đây là một <code>Bean</code> có sẵn trong <code>Context</code> do Spring cung cấp, bạn chỉ cần lôi ra sử dụng thôi.</p>
<pre><code>@Component
public class MyHouse {
    @Autowired
    ApplicationEventPublisher applicationEventPublisher;

    /**
     * Hành động bấm chuông cửa
     */
    public void rangDoorbellBy(String guestName) {
        // Phát ra một sự kiện DoorBellEvent
        // source (Nguồn phát ra) chính là class này
        applicationEventPublisher.publishEvent(new DoorBellEvent(this, guestName));
    }
}
</code></pre>
<h3 id="event-listener-1"><a class="header" href="#event-listener-1"><strong>Event Listener</strong></a></h3>
<p>Để lắng nghe các sự kiện do <code>ApplicationEventPublisher</code> bắn ra, chúng ta sử dụng <code>@EventListener</code></p>
<pre><code>// Tạo ra Bean
@Component
public class MyDog {

    /*
        @EventListener sẽ lắng nghe mọi sự kiện xảy ra
        Nếu có một sự kiện DoorBellEvent được bắn ra, nó sẽ đón lấy
        và đưa vào hàm để xử lý
     */
    @EventListener
    public void doorBellEventListener(DoorBellEvent doorBellEvent) throws InterruptedException {
        // Giả sử con chó đang ngủ, 1 giây sau mới dậy
        Thread.sleep(1000);
        // Sự kiện DoorBellEvent được lắng nghe và xử lý tại đây
        System.out.println(Thread.currentThread().getName() + &quot;: Chó ngủ dậy!!!&quot;);
        System.out.println(String.format(&quot;%s: Go go!! Có người tên là %s gõ cửa!!!&quot;, Thread.currentThread().getName(), doorBellEvent.getGuestName()));
    }
}
</code></pre>
<p><code>@EventListener</code> gắn trên một method, với tham số đầu vào chính là sự kiện mà bạn muốn lắng nghe.</p>
<p>Lưu ý: Class chịu trách nhiệm xử lý, có chứa method <code>@EventListener</code> cũng phải là Bean nhé.</p>
<h3 id="chạy-thử-1"><a class="header" href="#chạy-thử-1"><strong>Chạy thử 1</strong></a></h3>
<pre><code>@SpringBootApplication
public class App {
    @Autowired
    MyHouse myHouse;

    public static void main(String[] args) {
        SpringApplication.run(App.class, args);
    }

    @Bean
    CommandLineRunner run() {
        return args -&gt; {
            System.out.println(Thread.currentThread().getName() + &quot;: Loda đi tới cửa nhà !!!&quot;);
            System.out.println(Thread.currentThread().getName() + &quot;: =&gt; Loda bấm chuông và khai báo họ tên!&quot;);
            // gõ cửa
            myHouse.rangDoorbellBy(&quot;Loda&quot;);
            System.out.println(Thread.currentThread().getName() +&quot;: Loda quay lưng bỏ đi&quot;);
        };
    }

}
</code></pre>
<p>OUTPUT:</p>
<pre><code>restartedMain: Loda đi tới cửa nhà !!!
restartedMain: =&gt; Loda bấm chuông và khai báo họ tên!
restartedMain: Chó ngủ dậy!!!
restartedMain: Go go!! Có người tên là Loda gõ cửa!!!
restartedMain: Loda quay lưng bỏ đi
</code></pre>
<p>Bạn sẽ thấy quá trình xử lý ở đây xảy ra một cách <strong>tuần tự</strong> và đồng bộ (Synchronous).</p>
<p>Vậy là chúng ta có thể hiểu:</p>
<blockquote>
<p>nếu không cấu hình gì thêm, ApplicationEvent và @EventListener là Synchronous.</p>
</blockquote>
<p>Chương trình sẽ phải chờ sự kiện xử lý xong thì mới được chạy tiếp.</p>
<h3 id="async"><a class="header" href="#async"><strong>@Async</strong></a></h3>
<p>Đa phần, xử lý Synchronous không phải điều mà chúng ta mong đợi, chúng ta muốn việc xử lý sự kiện có thể hoạt động riêng và không ảnh hưởng tới luồng làm việc chính.</p>
<p>Nói cách khác, chúng ta muốn sự kiện được xử lý ở một Thread khác, đây gọi là <strong>bất đồng bộ (Asynchronous)</strong></p>
<p>Để làm được điều này, chúng ta cần kích hoạt chức năng xử lý bất đồng bộ của <strong>Spring Boot</strong>, bằng cách bổ sung annotation <code>@EnableAsync</code>.</p>
<pre><code>@Configuration
@EnableAsync
public class ListenerConfiguration {
    /**
     * Tạo ra Executor cho Async
     * @return
     */
    @Bean
    TaskExecutor taskExecutor() {
        return new SimpleAsyncTaskExecutor();
    }
}
</code></pre>
<p><strong>Spring Boot</strong> khi thấy Annotation này, sẽ kích hoạt cho phép xử lý sự kiện dưới dạng Async</p>
<p>các <code>Event</code> sẽ được gửi vào một <code>Executor</code> (đơn giản nhất là <code>SimpleAsyncTaskExecutor</code>) và chờ được xử lý.</p>
<p>Nếu chưa biết <code>Executor</code> là gì, bạn có thể đọc 2 bài viết sau:</p>
<ol>
<li>Khái niệm ThreadPool và Executor trong Java</li>
<li>ThreadPoolExecutor và nguyên tắc quản lý pool size</li>
</ol>
<h3 id="async-1"><a class="header" href="#async-1"><strong>@Async</strong></a></h3>
<p>Sau khi kích hoạt tính năng <code>Async</code>, bất kỳ sự kiện nào bạn muốn nó xử lý Async thì hãy đánh dấu nó bởi <code>@Async</code>.</p>
<pre><code>@Component
public class MyDog {

    /*
        @EventListener sẽ lắng nghe mọi sự kiện xảy ra
        Nếu có một sự kiện DoorBellEvent được bắn ra, nó sẽ đón lấy
        và đưa vào hàm để xử lý
     */
    /*
        @Async là cách lắng nghe sự kiện ở một Thread khác, không ảnh hưởng tới
        luồng chính
     */
    @Async
    @EventListener
    public void doorBellEventListener(DoorBellEvent doorBellEvent) throws InterruptedException {
        // Giả sử con chó đang ngủ, 1 giây sau mới dậy
        Thread.sleep(1000);
        // Sự kiện DoorBellEvent được lắng nghe và xử lý tại đây
        System.out.println(&quot;Chó ngủ dậy!!!&quot;);
        System.out.println(String.format(&quot;Go go!! Có người tên là %s gõ cửa!!!&quot;, doorBellEvent.getGuestName()));
    }
}
</code></pre>
<h3 id="chạy-thử-lần-2"><a class="header" href="#chạy-thử-lần-2"><strong>Chạy thử lần 2</strong></a></h3>
<p>OUTPUT:</p>
<pre><code>restartedMain: Loda đi tới cửa nhà !!!
restartedMain: =&gt; Loda bấm chuông và khai báo họ tên!
restartedMain: Loda quay lưng bỏ đi
SimpleAsyncTaskExecutor-1: Chó ngủ dậy!!!
SimpleAsyncTaskExecutor-1: Go go!! Có người tên là Loda gõ cửa!!!
</code></pre>
<p>Lần này quá trình xử lý đã diễn ra đúng như chúng ta mong đợi, người bấm cứ bấm, mà chó kêu cứ kêu, mỗi người một việc, chả ai ảnh hưởng tới ai, chỉ cần biết có sự kiện xảy ra thì phản ứng là được.</p>
<h3 id="kết-5"><a class="header" href="#kết-5"><strong>Kết</strong></a></h3>
<p>💁 Nếu có, toàn bộ project / code mẫu được lưu trữ tại <strong>GitHub</strong></p>
<p>🌟 Đây là một bài viết trong Series <strong>Làm chủ Spring Boot – Zero to Hero</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sb24-restful-api-document-tạo-với-spring-boot--swagger"><a class="header" href="#sb24-restful-api-document-tạo-với-spring-boot--swagger">[SB24] RESTful API Document Tạo với Spring Boot + Swagger</a></h1>
<ul>
<li>Giới thiệu</li>
<li>cài đặt</li>
<li>Tổng quan Swagger</li>
<li>Prepare</li>
<li>Config Swagger</li>
<li>Góc custom</li>
</ul>
<h3 id="giới-thiệu-8"><a class="header" href="#giới-thiệu-8"><strong>Giới thiệu</strong></a></h3>
<p><strong>Spring Boot</strong> hỗ trợ chúng ta tạo ra RESTful API một cách nhanh chóng và tiện lợi, giúp sản phẩm được vận hành nhanh nhất có thể.</p>
<p>Tuy nhiên, Việc deploy nhanh chóng một services không đồng nghĩa với việc nó có thể sử dụng được. Thông thường, tất cả các API sau khi được đưa lên sẽ phải đi kèm với document mô tả, để bất kì ai sử dụng đến thì có thể tra cứu.</p>
<p>Thật không may là việc làm document chưa bao giờ là dễ dàng cả :(( từ lí do này, <code>Swagger</code> ra đời để giúp chúng ta mô tả tài liệu dự án một cách nhanh chóng bằng annotation.</p>
<p>Trong bài có đề cập các kiến thức:</p>
<ol>
<li>Spring Boot</li>
<li>jpa</li>
<li>lombok</li>
</ol>
<h3 id="cài-đặt-3"><a class="header" href="#cài-đặt-3"><strong>cài đặt</strong></a></h3>
<p>Trong bài này, tôi sẽ hướng dẫn các bạn sử dụng <code>Swagger2</code> và tuân theo các quy tắc cảu <strong>Swagger Specification 2.0</strong> nhé.</p>
<p>Tại thời điểm viết bài này, hiện phiên bản mới nhất là 3, tuy nhiên, nó sẽ là <strong>OpenAPI 3.0</strong>.</p>
<p><em>pom.xml</em></p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;projectxmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;&lt;parent&gt;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;&lt;version&gt;2.0.5.RELEASE&lt;/version&gt;&lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;
	&lt;/parent&gt;&lt;groupId&gt;me.loda.spring&lt;/groupId&gt;&lt;artifactId&gt;example-independent-maven-spring-project&lt;/artifactId&gt;&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;&lt;name&gt;example-independent-maven-spring-project&lt;/name&gt;&lt;description&gt;Demo project for Spring Boot&lt;/description&gt;&lt;properties&gt;&lt;java.version&gt;1.8&lt;/java.version&gt;&lt;/properties&gt;&lt;dependencies&gt;&lt;dependency&gt;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;&lt;scope&gt;runtime&lt;/scope&gt;&lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt;&lt;dependency&gt;&lt;groupId&gt;org.projectlombok&lt;/groupId&gt;&lt;artifactId&gt;lombok&lt;/artifactId&gt;&lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt;&lt;dependency&gt;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;&lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;

		&lt;dependency&gt;&lt;groupId&gt;io.springfox&lt;/groupId&gt;&lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt;&lt;version&gt;2.9.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;&lt;groupId&gt;io.springfox&lt;/groupId&gt;&lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;&lt;version&gt;2.9.2&lt;/version&gt;&lt;/dependency&gt;&lt;!--spring jpa--&gt;
		&lt;dependency&gt;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--in memory database--&gt;
		&lt;dependency&gt;&lt;groupId&gt;com.h2database&lt;/groupId&gt;&lt;artifactId&gt;h2&lt;/artifactId&gt;&lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;&lt;/dependencies&gt;&lt;build&gt;&lt;plugins&gt;&lt;plugin&gt;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;&lt;/plugin&gt;&lt;/plugins&gt;&lt;/build&gt;&lt;/project&gt;
</code></pre>
<p><code>springfox</code> là một thư viện java implementation của Swagger Specification.</p>
<p><code>springfox-swagger2</code> chứa core của swagger, giúp chúng ta khai báo document cho api.</p>
<p><code>springfox-swagger-ui</code> giúp chúng ta biểu diễn tài liệu dưới dạng web view, dễ nhìn và test.</p>
<h3 id="tổng-quan-swagger"><a class="header" href="#tổng-quan-swagger"><strong>Tổng quan Swagger</strong></a></h3>
<p>Để sử dụng cơ bản thì <code>Swagger</code> cung cấp một số các Annotations hữu ích sau:</p>
<p>Chúng ta đi vào thực hành thử nhé.</p>
<p>Đại loại sau khi làm xong, chúng ta sẽ có 1 web view document như thế này:</p>
<p>!image</p>
<h3 id="prepare-1"><a class="header" href="#prepare-1"><strong>Prepare</strong></a></h3>
<p>Tạo ra class Model</p>
<p><em>User.java</em></p>
<pre><code>@Data
@Entity
@Table
@NoArgsConstructor
@AllArgsConstructor
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String firstName;
    private String lastName;
    private String email;
}
</code></pre>
<p><em>UserRepository.java</em></p>
<pre><code>@Repository
public interface UserRepository extends JpaRepository&lt;User, Long&gt; {

}
</code></pre>
<p>Khi đã có được Model và Repository, chúng ta sẽ tạo Controller để thao tác liên quan tới <code>User</code> nhé.</p>
<pre><code>@RestController
@RequestMapping(&quot;/api/v1&quot;)
@RequiredArgsConstructor
public class UserController {
    private final UserRepository userRepository;

    @GetMapping(&quot;/users&quot;)
    public List&lt;User&gt; getAllUsers() {
        return userRepository.findAll();
    }

    @GetMapping(&quot;/users/{id}&quot;)
    public User getUser(@PathVariable(&quot;id&quot;) Long id) {
        return userRepository.findById(id).orElse(new User());
    }

    @PostMapping(&quot;/users&quot;)
    public User createUser(@Valid @RequestBody User user) {
        return userRepository.save(user);
    }

    @PutMapping(&quot;/users/{id}&quot;)
    public User updateUser(@PathVariable(&quot;id&quot;) Long id, @Valid @RequestBody User user) {
        user.setId(id);
        return userRepository.save(user);
    }

    @DeleteMapping(&quot;/users/{id}&quot;)
    public void deleteUser(@PathVariable(&quot;id&quot;) Long id) {
        userRepository.deleteById(id);
    }
}
</code></pre>
<p>Âu khê, tạm thời như thế đã 😂</p>
<p>Bây giờ vào phần chính, config <code>Swagger</code> cho dự án của chúng ta.</p>
<h3 id="config-swagger"><a class="header" href="#config-swagger"><strong>Config Swagger</strong></a></h3>
<p>Thật may mắn, trước khi đi vào các custom phức tạp thì Swagger hỗ trợ chúng ta tự động sinh ra tài liệu một cách mặc định mà chưa cần phải khai báo bất kì annotation nào đã giới thiệu ở trên.</p>
<p>Chỉ cần tạo ra đối tượng <code>Docket</code> của <code>Swagger</code> và nó sẽ quét hết các địa chỉ API mà bạn chỉ định, rồi tự động sinh ra tài liệu cơ bản cho chúng ta.</p>
<pre><code>@Configuration
@EnableSwagger2
public class Swagger2Config {
    @Bean
    public Docket api() {
        return new Docket(DocumentationType.SWAGGER_2).select()
                                                      .apis(RequestHandlerSelectors.basePackage(&quot;me.loda.spring.swagger.controller&quot;))
                                                      .paths(PathSelectors.regex(&quot;/.*&quot;))
                                                      .build()
                                                      .apiInfo(apiEndPointsInfo());
    }

    private ApiInfo apiEndPointsInfo() {
        return new ApiInfoBuilder().title(&quot;Spring Boot REST API&quot;)
                                   .description(&quot;Employee Management REST API&quot;)
                                   .contact(new Contact(&quot;loda&quot;, &quot;https://loda.me/&quot;, &quot;loda.namnh@gmail.com&quot;))
                                   .license(&quot;Apache 2.0&quot;)
                                   .licenseUrl(&quot;http://www.apache.org/licenses/LICENSE-2.0.html&quot;)
                                   .version(&quot;1.0.0&quot;)
                                   .build();
    }
}
</code></pre>
<p>Các thứ cần lưu ý bao gồm:</p>
<ol>
<li>Để <code>Swagger</code> hoạt động, bạn nhớ kích hoạt nó bằng <code>@EnableSwagger2</code>.</li>
<li>Bạn có thể chọn nơi chứa các API bằng <code>RequestHandlerSelectors</code>. Nếu muốn quét hết cả project, có thể xài <code>RequestHandlerSelectors.any()</code></li>
<li>Bạn có thể chỉ định bộ lọc cho các api bằng <code>PathSelectors</code>. Nếu muốn quét tất cả, chọn <code>PathSelectors.any()</code>.</li>
</ol>
<pre><code>@SpringBootApplication
public class App {
    public static void main(String[] args) {
        SpringApplication.run(App.class, args);
    }
}
</code></pre>
<p>Bây giờ, chạy thử và vào địa chỉ <code>http://localhost:8080/swagger-ui.html</code> để xem thành quả nhé.</p>
<h3 id="góc-custom"><a class="header" href="#góc-custom"><strong>Góc custom</strong></a></h3>
<p>Bạn có thể chỉ định rõ hơn các mô tả của tài liệu bằng cách sử dụng các Annotation mà <code>Swagger</code> cung cấp.</p>
<p><em>User.java</em></p>
<pre><code>@Data
@Entity
@Table
@NoArgsConstructor
@AllArgsConstructor
@ApiModel(value = &quot;User model&quot;)
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @ApiModelProperty(notes = &quot;The database generated User ID&quot;)
    private Long id;

    private String firstName;
    private String lastName;
    private String email;
}
</code></pre>
<p><em>UserController.java</em></p>
<pre><code>@RestController
@RequestMapping(&quot;/api/v1&quot;)
@RequiredArgsConstructor
@Api(value = &quot;User APIs&quot;)
public class UserController {
    private final UserRepository userRepository;

    @ApiOperation(value = &quot;Xem danh sách User&quot;, response = List.class)
    @ApiResponses(value = {
            @ApiResponse(code = 200, message = &quot;Thành công&quot;),
            @ApiResponse(code = 401, message = &quot;Chưa xác thực&quot;),
            @ApiResponse(code = 403, message = &quot;Truy cập bị cấm&quot;),
            @ApiResponse(code = 404, message = &quot;Không tìm thấy&quot;)
    })
    @GetMapping(&quot;/users&quot;)
    public List&lt;User&gt; getAllUsers() {
        return userRepository.findAll();
    }

    @GetMapping(&quot;/users/{id}&quot;)
    public User getUser(@PathVariable(&quot;id&quot;) Long id) {
        return userRepository.findById(id).orElse(new User());
    }

    @PostMapping(&quot;/users&quot;)
    public User createUser(
            @ApiParam(value = &quot;Đối tượng User cần tạo mới&quot;, required = true) @Valid @RequestBody User user
    ) {
        return userRepository.save(user);
    }

    @PutMapping(&quot;/users/{id}&quot;)
    public User updateUser(@PathVariable(&quot;id&quot;) Long id, @Valid @RequestBody User user) {
        user.setId(id);
        return userRepository.save(user);
    }

    @DeleteMapping(&quot;/users/{id}&quot;)
    public void deleteUser(@PathVariable(&quot;id&quot;) Long id) {
        userRepository.deleteById(id);
    }
}
</code></pre>
<p>Tới đây bạn có thể sử dụng Swagger thoải mái rồi, tôi sẽ làm một bài khác về <strong>OpenAPI 3.0</strong>.</p>
<p>💁 Nếu có, toàn bộ project / code mẫu được lưu trữ tại <strong>GitHub</strong></p>
<p>🌟 Đây là một bài viết trong Series <strong>Làm chủ Spring Boot – Zero to Hero</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sb25-restful-api-document-với-spring-boot--openapi-30"><a class="header" href="#sb25-restful-api-document-với-spring-boot--openapi-30">[SB25] RESTful API Document với Spring Boot + OpenApi 3.0</a></h1>
<ul>
<li>Giới thiệu</li>
<li>cài đặt</li>
<li>Tổng quan OpenApi 3.0</li>
<li>Prepare</li>
<li>Config OpenApi 3.0</li>
<li>Kết</li>
</ul>
<h3 id="giới-thiệu-9"><a class="header" href="#giới-thiệu-9"><strong>Giới thiệu</strong></a></h3>
<p>Trong bài viết trước:</p>
<ol>
<li>RESTful API Document Tạo với Spring Boot + Swagger</li>
</ol>
<p>Tôi đã giới thiệu lí do vì sao cần Document, và cách tạo ra nó nhanh chóng với <code>Swagger 2</code>.</p>
<p>Trong bài này, tôi sẽ giới thiệu thêm phiên bản tiếp theo, một tiêu chuẩn mới nhất về RESTful document đó là OpenApi 3.0.</p>
<p>Tại sao k đặt tên là <code>Swagger 3</code>? câu chuyện đằng sau nó là việc SmartBear mua lại Swagger, và đổi tên Swagger Specification thành OpenApi Specification, bắt đầu tạo ra các tiêu chuẩn mới cho xây dựng Document, tuy nhiên vẫn xây dựng trên Swagger core.</p>
<p><code>OpenApi 3.0</code> là bản mới nhất được ra mắt tại thời điểm viết bài này.</p>
<p>Trong bài có đề cập các kiến thức:</p>
<ol>
<li>Spring Boot</li>
<li>jpa</li>
<li>lombok</li>
</ol>
<h3 id="cài-đặt-4"><a class="header" href="#cài-đặt-4"><strong>cài đặt</strong></a></h3>
<p><em>pom.xml</em></p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;projectxmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;&lt;parent&gt;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;&lt;version&gt;2.0.5.RELEASE&lt;/version&gt;&lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;
	&lt;/parent&gt;&lt;groupId&gt;me.loda.spring&lt;/groupId&gt;&lt;artifactId&gt;example-independent-maven-spring-project&lt;/artifactId&gt;&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;&lt;name&gt;example-independent-maven-spring-project&lt;/name&gt;&lt;description&gt;Demo project for Spring Boot&lt;/description&gt;&lt;properties&gt;&lt;java.version&gt;1.8&lt;/java.version&gt;&lt;/properties&gt;&lt;dependencies&gt;&lt;dependency&gt;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;&lt;scope&gt;runtime&lt;/scope&gt;&lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt;&lt;dependency&gt;&lt;groupId&gt;org.projectlombok&lt;/groupId&gt;&lt;artifactId&gt;lombok&lt;/artifactId&gt;&lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt;&lt;dependency&gt;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;&lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;!--https://mvnrepository.com/artifact/org.springdoc/springdoc-openapi-core --&gt;
        &lt;dependency&gt;&lt;groupId&gt;org.springdoc&lt;/groupId&gt;&lt;artifactId&gt;springdoc-openapi-core&lt;/artifactId&gt;&lt;version&gt;1.1.49&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;&lt;groupId&gt;org.springdoc&lt;/groupId&gt;&lt;artifactId&gt;springdoc-openapi-ui&lt;/artifactId&gt;&lt;version&gt;1.1.49&lt;/version&gt;&lt;/dependency&gt;&lt;!--spring jpa--&gt;
		&lt;dependency&gt;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--in memory database--&gt;
		&lt;dependency&gt;&lt;groupId&gt;com.h2database&lt;/groupId&gt;&lt;artifactId&gt;h2&lt;/artifactId&gt;&lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;&lt;/dependencies&gt;&lt;build&gt;&lt;plugins&gt;&lt;plugin&gt;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;&lt;/plugin&gt;&lt;/plugins&gt;&lt;/build&gt;&lt;/project&gt;
</code></pre>
<p><code>springdoc</code> là một thư viện java implementation của OpenApi Specification 3.0.</p>
<p><code>springdoc-openapi-core</code> chứa core của swagger, giúp chúng ta khai báo document cho api.</p>
<p><code>springdoc-openapi-ui</code> giúp chúng ta biểu diễn tài liệu dưới dạng web view, dễ nhìn và test.</p>
<h3 id="tổng-quan-openapi-30"><a class="header" href="#tổng-quan-openapi-30"><strong>Tổng quan OpenApi 3.0</strong></a></h3>
<p><code>OpenApi 3.0</code> kế thừa và đổi mới khá nhiều các thành phần của <code>Swagger2</code>, khiến nó tường minh và dễ đọc hơn.</p>
<p>SWAGGER2OPENAPI 3.0DESCRIPTION@Api</p>
<p>@Tag</p>
<p>Đánh dấu 1 class là nơi chứa các API</p>
<p>@ApiModel</p>
<p>không còn</p>
<p>Đánh dấu 1 class là Swagger Model</p>
<p>@ApiModelProperty</p>
<p>@Schema</p>
<p>Bổ sung các thông tin cho</p>
<p>@ApiOperation</p>
<p>@Operation</p>
<p>Mô tả cho một API và response của nó</p>
<p>@ApiParam</p>
<p>@Parameter</p>
<p>Mô tả các parameter</p>
<p>@ApiResponse</p>
<p>@ApiResponse</p>
<p>Mô tả status code của response</p>
<p>@ApiResponses</p>
<p>@ApiResponses</p>
<p>Mô tả danh sách các status code của response</p>
<p>Chúng ta đi vào thực hành thử nhé.</p>
<p>Đại loại sau khi làm xong, chúng ta sẽ có 1 web view document như thế này:</p>
<p>!image</p>
<p>Ngoài đẹp hơn, mô tả chi tiết và dễ sử dụng hơn, thì có 1 phần rất hay, đó là chúng ta có thể chọn Server Url khi test API</p>
<p>!image</p>
<h3 id="prepare-2"><a class="header" href="#prepare-2"><strong>Prepare</strong></a></h3>
<p>Tạo ra class Model</p>
<p><em>User.java</em></p>
<pre><code>@Data
@Entity
@Table
@NoArgsConstructor
@AllArgsConstructor
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Schema(description = &quot;User UUID in  the database&quot;)
    @JsonProperty(&quot;id&quot;)
    private Long id;

    private @NotBlank @Size(min = 0, max = 20) String firstName;
    private String lastName;

    private @NotBlank @Size(min = 0, max = 50) String email;
}
</code></pre>
<p><em>UserRepository.java</em></p>
<pre><code>@Repository
public interface UserRepository extends JpaRepository&lt;User, Long&gt; {

}
</code></pre>
<p>Khi đã có được Model và Repository, chúng ta sẽ tạo Controller để thao tác liên quan tới <code>User</code> nhé.</p>
<p>Điểm khác biệt lớn nhất của <code>OpenApi3</code> so với <code>Swagger2</code> là hệ thống Annotation rất là dày đặc, đa phần các giá trị được biểu diễn và ăn khớp với nhau bằng Annotation và Class.</p>
<pre><code>@RestController
@RequestMapping(&quot;/api/v1&quot;)
@RequiredArgsConstructor
@Tag(name = &quot;user&quot;)
public class UserController {
    private final UserRepository userRepository;

    @Operation(description = &quot;Xem danh sách User&quot;, responses = {
            @ApiResponse(content = @Content(array = @ArraySchema(schema = @Schema(implementation = User.class))), responseCode = &quot;200&quot;) })
    @ApiResponses(value = {
            @ApiResponse(responseCode  = &quot;200&quot;, description = &quot;Thành công&quot;),
            @ApiResponse(responseCode  = &quot;401&quot;, description = &quot;Chưa xác thực&quot;),
            @ApiResponse(responseCode  = &quot;403&quot;, description = &quot;Truy cập bị cấm&quot;),
            @ApiResponse(responseCode  = &quot;404&quot;, description = &quot;Không tìm thấy&quot;)
    })
    @GetMapping(&quot;/users&quot;)
    public List&lt;User&gt; getAllUsers() {
        return userRepository.findAll();
    }

    @GetMapping(&quot;/users/{id}&quot;)
    public User getUser(@PathVariable(&quot;id&quot;) Long id) {
        return userRepository.findById(id).orElse(new User());
    }

    @PostMapping(&quot;/users&quot;)
    public User createUser(
            @Valid
            @Parameter(description = &quot;User model to create.&quot;, required = true, schema = @Schema(implementation = User.class))
            @RequestBody User user) {
        return userRepository.save(user);
    }

    @PutMapping(&quot;/users/{id}&quot;)
    public User updateUser(@PathVariable(&quot;id&quot;) Long id, @Valid @RequestBody User user) {
        user.setId(id);
        return userRepository.save(user);
    }

    @DeleteMapping(&quot;/users/{id}&quot;)
    public void deleteUser(@PathVariable(&quot;id&quot;) Long id) {
        userRepository.deleteById(id);
    }
}
</code></pre>
<p>Âu khê, Chỉ cần như vậy là chạy được rồi.</p>
<p>Nếu đầy đủ hơn, thì bạn nên config <code>OpenApi</code> cho dự án của chúng ta để bổ sung các thông tin tổng quan.</p>
<h3 id="config-openapi-30"><a class="header" href="#config-openapi-30"><strong>Config OpenApi 3.0</strong></a></h3>
<p>Chỉ cần tạo ra đối tượng <code>OpenAPI</code> và cung cấp các thông tin cần thiết.</p>
<pre><code>@Configuration
public class OpenApiConfig {
    @Bean
    public OpenAPI customOpenAPI() {
        return new OpenAPI()
                // Thiết lập các server dùng để test api
                .servers(Lists.newArrayList(
                        new Server().url(&quot;http://localhost:8080&quot;),
                        new Server().url(&quot;https://user.loda.me&quot;)
                ))
                // info
                .info(new Info().title(&quot;Loda Application API&quot;)
                                .description(&quot;Sample OpenAPI 3.0&quot;)
                                .contact(new Contact()
                                                 .email(&quot;loda.namnh@gmail.com&quot;)
                                                 .name(&quot;loda&quot;)
                                                 .url(&quot;https://loda.me/&quot;))
                                .license(new License()
                                                 .name(&quot;Apache 2.0&quot;)
                                                 .url(&quot;http://www.apache.org/licenses/LICENSE-2.0.html&quot;))
                                .version(&quot;1.0.0&quot;));
    }
}
</code></pre>
<p><code>OpenApi3.0</code> thì bạn không cần <code>@Enable</code> mà chỉ cần add <code>springdoc-openapi-core</code> vào dependencies thôi là nó tự động gen ra tài liệu rồi.</p>
<pre><code>@SpringBootApplication
public class App {
    public static void main(String[] args) {
        SpringApplication.run(App.class, args);
    }
}
</code></pre>
<p>Bây giờ, chạy thử và vào địa chỉ <code>http://localhost:8080/swagger-ui.html</code> để xem thành quả nhé.</p>
<h3 id="kết-6"><a class="header" href="#kết-6"><strong>Kết</strong></a></h3>
<p>Tới đây bạn có thể sử dụng <strong>OpenAPI 3.0</strong> thoải mái rồi.</p>
<p>💁 Nếu có, toàn bộ project / code mẫu được lưu trữ tại <strong>GitHub</strong></p>
<p>🌟 Đây là một bài viết trong Series <strong>Làm chủ Spring Boot – Zero to Hero</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="jpahibernate-là-gì"><a class="header" href="#jpahibernate-là-gì">「Jpa」Hibernate là gì?</a></h1>
<ul>
<li>Giới thiệu</li>
<li>Định nghĩa</li>
<li>POJO</li>
<li>Mapping dữ liệu</li>
<li>Session</li>
<li>Hibernate Query Language (HQL)</li>
</ul>
<h3 id="giới-thiệu-10"><a class="header" href="#giới-thiệu-10"><strong>Giới thiệu</strong></a></h3>
<p><code>Hibernate</code> là framework được sử dụng nhiều nhất hiện nay để giúp lập trình viên Java có thể map các class (Pojo) với một cơ sở dữ liệu bất kỳ.</p>
<p>Trước khi <code>Hibernate</code> ra đời, chúng ta thường thao tác với cơ sở dữ liệu thông qua <code>JDBC</code>. Theo thời gian, <code>JDBC</code> bộc lộ nhiều điểm yếu như:</p>
<ul>
<li>Có nhiều code thừa mà chỉ phục vụ mục đích là lấy dữ liệu.</li>
<li>Mất nhiều thời gian map dữ liệu vào object Java.</li>
<li>Sẽ tốn nhiều công sức khi hệ thống thay đổi CSDL (yêu cầu <code>jdbc</code> mới, code mới)</li>
<li>Giao tiếp giữa các bảng thường khó, thiếu tính OOP trong đó.</li>
</ul>
<p>Từ đây, để giảm tải gánh nặng cho dev khi thao tác với database. <code>Hibernate</code> ra đời!</p>
<h3 id="Định-nghĩa-1"><a class="header" href="#Định-nghĩa-1"><strong>Định nghĩa</strong></a></h3>
<p><code>Hibernate</code> là một thư viện <code>ORM (Object Relational Mapping)</code> mã nguồn mở giúp lập trình viên viết ứng dụng Java có thể map các objects (pojo) với hệ quản trị cơ sở dữ liệu quan hệ, và hỗ trợ thực hiện các khái niệm lập trình hướng đối tượng với cớ dữ liệu quan hệ.</p>
<p>Hiểu ngắn gọn thì <code>Hibernate</code> sẽ là một layer đứng trung gian giữa ứng dụng và database, và chúng ta sẽ giao tiếp với <code>Hibernate</code> thay vì giao tiếp với database</p>
<p>!image</p>
<p>Để giao tiếp với <code>Hibernate</code>, chúng ta sẽ tạo ra một <code>Class</code> đại diện cho một <code>Table</code>. Và mọi dữ liệu từ <code>Table</code> trong database sẽ được <code>Hibernate</code> bind vào <code>Class</code> đó cho chúng ta.</p>
<h3 id="pojo"><a class="header" href="#pojo"><strong>POJO</strong></a></h3>
<p><code>Pojo (plain old Java object)</code> là class đại diện cho một <code>Table</code>, thuật ngữ này để định nghĩa chính xác thì mình không dám chắc, nhưng về ý nghĩa thì nó là một class java thuần túy, rất thuần túy:</p>
<ol>
<li>All properties must public setter and getter methods (mọi biến đều phải có get/set)</li>
<li>All instance variables should be private (mọi biến là thuộc tính thì nên là private)</li>
</ol>
<pre><code>public class MyFirstPojo
{
    private String name;

    public static void main(String [] args)
    {
       for (String arg : args)
       {
          MyFirstPojo pojo = new MyFirstPojo(arg);  // Here's how you create a POJO
          System.out.println(pojo);
       }
    }

    public MyFirstPojo(String name)
    {
        this.name = name;
    }

    public String getName() { return this.name; }

    public String toString() { return this.name; }
}
</code></pre>
<h3 id="mapping-dữ-liệu"><a class="header" href="#mapping-dữ-liệu"><strong>Mapping dữ liệu</strong></a></h3>
<p>Khi đã có <code>Class</code> đại diện cho <code>Table</code> rồi, chúng ta sẽ định nghĩa các trường trong class đó tương ứng với column nào trong database bằng tập hợp các <code>Annotaion</code> mà <code>Hibernate</code> cung cấp.</p>
<pre><code>@Entity // Đánh dấu đây là một Entity, chịu sự quản lý của Hibernate
@Table(name = &quot;USER&quot;) //Entity này đại diện cho table USER trong db
public class UserModel {
    @Id // Đánh dấu biến ở dưới là primary key của table này
    @GeneratedValue(strategy = GenerationType.IDENTITY) // Tự động tăng giá trị khi insert
    private Long id;

    @Column(name = &quot;email&quot;, unique = true) // trường email ở dưới đại diện cho cột email trong database
    private String email;

    @Column(name = &quot;name&quot;)
    private String name;

    public Long getId() {
        return this.id;
    }
    public void setId(Long id) {
        this.id = id;
    }
    public String getEmail() {
        return email;
    }
    public void setEmail(String email) {
        this.email = email;
    }
    public String getName() {
        return this.name;
    }
    public void setName(String name) {
        this.name = name;
    }
}
</code></pre>
<p>Bây giờ việc bạn lấy dữ liệu từ database sẽ đại loại như này:</p>
<pre><code>public List&lt;User&gt; findAll() {
    return session.createQuery(&quot;SELECT a FROM User a&quot;, User.class).getResultList();
}
</code></pre>
<p>Chúng ta tiết kiệm được rất nhiều thời gian cho việc mapping dữ liệu từ database sang class java, và đặc biệt là khi thay đổi Database thì cũng sẽ không ảnh hưởng gì tới đoạn code ở trên cả, chúng ta gần như trong suốt với tầng database, mà chỉ cần nói chuyện với <code>Hibernate</code> là đủ!</p>
<h3 id="session"><a class="header" href="#session"><strong>Session</strong></a></h3>
<p>Đối tượng chính của việc truy xuất hay insert dữ liệu bằng <code>Hibernate</code> chính là <code>Session</code> và được tạo ra từ <code>Session Factory</code>.</p>
<p><code>Session Factory</code> Là một interface giúp tạo ra session kết nối đến database bằng cách đọc các cấu hình trong một file xml và mỗi loại Database khác nhau sẽ có một cấu hình khác nhau.</p>
<p>File cấu hình <code>hibernate.cfg.xml</code> có dạng như sau:</p>
<pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;
&lt;!DOCTYPE hibernate-configuration PUBLIC
&quot;-//Hibernate/Hibernate Configuration DTD//EN&quot;
&quot;http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd&quot;&gt;

&lt;hibernate-configuration&gt;&lt;session-factory&gt;&lt;propertyname=&quot;hibernate.connection.driver_class&quot;&gt;com.mysql.jdbc.Driver&lt;/property&gt;&lt;propertyname=&quot;hibernate.connection.url&quot;&gt;jdbc:mysql://192.168.10.13:3306/loda
&lt;/property&gt;&lt;propertyname=&quot;hibernate.connection.username&quot;&gt;root&lt;/property&gt;&lt;propertyname=&quot;hibernate.connection.password&quot;&gt;root&lt;/property&gt;&lt;propertyname=&quot;hibernate.connection.pool_size&quot;&gt;10&lt;/property&gt;&lt;propertyname=&quot;dialect&quot;&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt;&lt;propertyname=&quot;hibernate.current_session_context_class&quot;&gt;thread&lt;/property&gt;&lt;/session-factory&gt;&lt;/hibernate-configuration&gt;
</code></pre>
<p>Khi đã có file config này rồi, chúng ta sử dụng nó để tạo ra <code>Session Factory</code> như sau:</p>
<pre><code>public class SessionFactoryProvider {

    private static SessionFactory buildSessionFactory() {
        ServiceRegistry serviceRegistry = new StandardServiceRegistryBuilder()//
                .configure(&quot;hibernate.cfg.xml&quot;).build();

        Metadata metadata = new MetadataSources(serviceRegistry).getMetadataBuilder().build();

        return metadata.getSessionFactoryBuilder().build();
    }
}
</code></pre>
<p>Từ đó, mỗi lần cần query hay insert dữ liệu, chúng ta sẽ tạo ra <code>Session</code> và sử dụng.</p>
<pre><code>SessionFactory factory = HibernateSessionUtils.getSessionFactory();

Session session = factory.getCurrentSession();

try {
    session.getTransaction().begin();

    List&lt;User&gt; users = session.createQuery(&quot;SELECT a FROM User a&quot;, User.class).getResultList();

    session.getTransaction().commit();
}catch (Exception e) {}
</code></pre>
<h3 id="hibernate-query-language-hql"><a class="header" href="#hibernate-query-language-hql"><strong>Hibernate Query Language (HQL)</strong></a></h3>
<p><code>Hibernate</code> sử dụng ngôn ngữ <code>Hibernate Query Language (HQL)</code> để query dữ liệu. Nó chỉ khác <code>SQL</code> bình thường ở chỗ, đối tượng tác động lúc này là <code>Entity</code> chứ không còn là <code>Table</code> nữa:</p>
<p>ví dụ:</p>
<pre><code>-- SQL
-- from table name
Select u.id, u.email from USER u;

-- HQL
-- from class name
Select u.id, u.email from User u;

-- query toàn bộ object
Select u from User u;
</code></pre>
<p>Đang viết dở Continue...</p>
<ol>
<li><a href="spring-boot/">🪂「Jpa」Hướng dẫn sử dụng @OneToOne</a></li>
<li><a href="spring-boot/">🚅「Jpa」Hướng dẫn @OneToMany và @ManyToOne</a></li>
<li><a href="spring-boot/">🛵「Jpa」Hướng dẫn @ManyToMany</a></li>
</ol>
<p>💁 Nếu có, toàn bộ project / code mẫu được lưu trữ tại <strong>GitHub</strong></p>
<p>🌟 Đây là một bài viết trong Series <strong>Làm chủ Spring Boot – Zero to Hero</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="jpa-hướng-dẫn-sử-dụng-specification-phần-1"><a class="header" href="#jpa-hướng-dẫn-sử-dụng-specification-phần-1">「Jpa」 Hướng dẫn sử dụng Specification (Phần 1)</a></h1>
<h3 id="giới-thiệu-11"><a class="header" href="#giới-thiệu-11"><strong>Giới thiệu</strong></a></h3>
<p>Trong một bài viết gần nhất về  tôi đã hướng dẫn các bạn cách xây dựng các câu query xuống Database bằng các API do Hibernate cung cấp.</p>
<p>Và trong một bài viết khác về JPA Repository thì chúng ta cũng đã biết cách custom các query bằng cách đặt tên method:</p>
<ol>
<li>「Spring Boot #11」 Hướng dẫn Spring Boot JPA + MySQL</li>
<li>「Spring Boot #12」 Spring JPA Method + @Query </li>
</ol>
<p>Tuy nhiên, trong các phương pháp trên, vẫn sẽ còn một số các điểm bất cập, ví dụ như <code>JpaRepository</code> thì bạn sẽ phải viết quá nhiều method và mỗi cái sẽ phục vụ cho một mục đích cố định (không thể tái sử dụng, reuseable).</p>
<pre><code>public interface UserRepository extends JpaRepository&lt;User, Long&gt; {

  User findByEmailAddress(String emailAddress);

  List&lt;User&gt; findByLastname(String lastname, Sort sort);

  Page&lt;User&gt; findByFirstname(String firstname, Pageable pageable);
}
</code></pre>
<p>Để có thể tối ưu việc viết query một cách linh động hơn và có thể tái sử dụng lại, Spring mang tới cho chúng ta interface <code>Specification</code>.</p>
<p>Lúc này, cách tiếp cận của việc xây dựng query sẽ đại loại như sau:</p>
<pre><code>userRepository.findAll(Specification.where(hasIdIn(Arrays.asList(1L, 2L, 3L, 4L, 5L)))
                                                .and(hasType(UserType.NORMAL))
                                                .or(hasId(10L)));
</code></pre>
<p>Với cách định nghĩa này, chúng ta có thể tái sử dụng query và tuỳ biến nó mọi lúc để phù hợp với yêu cầu.</p>
<p>Khái niệm <code>Specification</code> được xây dựng tương đương với <code>Predicate</code> trong Hibernate. Bạn hãy đọc bài dưới trước khi đi tiếp vào bài này: <strong>Hướng dẫn sử dụng Criteria API trong Hibernate (Phần 2)</strong> </p>
<p>Trong bài có sử dụng: Lombok</p>
<h3 id="cài-đặt-5"><a class="header" href="#cài-đặt-5"><strong>Cài đặt</strong></a></h3>
<p>Nhớ thêm <code>spring-boot-starter-data-jpa</code> vào dependencies của bạn.</p>
<p>Trong phần này, tôi xài <em>H2 database</em> để demo. (H2 là dạng memory database, nó sẽ lưu trong ram và khi tắt chương trình nó sẽ mất sạch)</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;projectxmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;&lt;parent&gt;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;&lt;version&gt;2.0.5.RELEASE&lt;/version&gt;&lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;
	&lt;/parent&gt;&lt;groupId&gt;me.loda.spring&lt;/groupId&gt;&lt;artifactId&gt;example-independent-maven-spring-project&lt;/artifactId&gt;&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;&lt;name&gt;example-independent-maven-spring-project&lt;/name&gt;&lt;description&gt;Demo project for Spring Boot&lt;/description&gt;&lt;properties&gt;&lt;java.version&gt;1.8&lt;/java.version&gt;&lt;/properties&gt;&lt;dependencies&gt;&lt;dependency&gt;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;&lt;scope&gt;runtime&lt;/scope&gt;&lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt;&lt;dependency&gt;&lt;groupId&gt;org.projectlombok&lt;/groupId&gt;&lt;artifactId&gt;lombok&lt;/artifactId&gt;&lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt;&lt;dependency&gt;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;&lt;scope&gt;test&lt;/scope&gt;&lt;!--			&lt;exclusions&gt;--&gt;
			&lt;!--				&lt;exclusion&gt;--&gt;
			&lt;!--					&lt;groupId&gt;org.junit.vintage&lt;/groupId&gt;--&gt;
			&lt;!--					&lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt;--&gt;
			&lt;!--				&lt;/exclusion&gt;--&gt;
			&lt;!--			&lt;/exclusions&gt;--&gt;
		&lt;/dependency&gt;&lt;!--spring jpa--&gt;
		&lt;dependency&gt;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--in memory database--&gt;
		&lt;dependency&gt;&lt;groupId&gt;com.h2database&lt;/groupId&gt;&lt;artifactId&gt;h2&lt;/artifactId&gt;&lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;&lt;!--https://mvnrepository.com/artifact/org.hibernate/hibernate-jpamodelgen --&gt;
		&lt;dependency&gt;&lt;groupId&gt;org.hibernate&lt;/groupId&gt;&lt;artifactId&gt;hibernate-jpamodelgen&lt;/artifactId&gt;&lt;version&gt;5.4.9.Final&lt;/version&gt;&lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt;&lt;/dependencies&gt;&lt;build&gt;&lt;plugins&gt;&lt;plugin&gt;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;&lt;/plugin&gt;&lt;/plugins&gt;&lt;/build&gt;&lt;/project&gt;
</code></pre>
<p>Chú ý, xem kĩ hơn <code>hibernate-jpamodelgen</code> trong bài viết </p>
<h3 id="specification"><a class="header" href="#specification"><strong>Specification</strong></a></h3>
<p><code>Specification</code> là một cách để định nghĩa các <code>Predicate</code> có thể tái sử dụng được.</p>
<p>Bản chất <code>Specification</code> là một funtional interface với 1 hàm duy nhất như sau:</p>
<pre><code>public interface Specification&lt;T&gt; {
  Predicate toPredicate(Root&lt;T&gt; root, CriteriaQuery query, CriteriaBuilder cb);
}
</code></pre>
<p>Tham số đầu vào là 3 khái niệm tôi đã giới thiệu ở bài , bao gồm:</p>
<ol>
<li><code>Root</code></li>
<li><code>CriteriaQuery</code></li>
<li><code>CriteriaBuilder</code></li>
</ol>
<p>tôi sẽ demo trước một số implementation của <code>Specification</code> và đề cập cách sử dụng nó ở phía dưới:</p>
<p><em>User.java</em></p>
<pre><code>@Entity
@Data
@Builder
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private UserType type;
    private String name;

    public enum UserType {
        NORMAL, VIP;
    }
}
</code></pre>
<p><em>UserSpecification.java</em></p>
<pre><code>public final class UserSpecification {
    /**
     * Lấy ra user có UserType chỉ định
     * @param type
     * @return
     */
    public static Specification&lt;User&gt; hasType(UserType type) {
        return (root, query, cb) -&gt; cb.equal(root.get(User_.TYPE), type);
    }

    /**
     * Lấy ra user có id chỉ định
     * @param userId
     * @return
     */
    public static Specification&lt;User&gt; hasId(long userId) {
        return (root, query, cb) -&gt; cb.equal(root.get(User_.ID), userId);
    }

    /**
     * Lấy ra user nằm trong tập ID chỉ định
     * @param userIds
     * @return
     */
    public static Specification&lt;User&gt; hasIdIn(Collection&lt;Long&gt; userIds) {
        return (root, query, cb) -&gt; root.get(User_.ID).in(userIds);
    }
}
</code></pre>
<p>Tôi định nghĩa ra các <code>static method</code> trả ra ngoài là các implement của <code>Specification</code>. Nó không hẳn là đoạn code đẹp nhất ==! nhưng nó là một cách làm hay để có thể định nghĩa một tập các điều kiện có thể sử dụng lại được cho <code>User</code>.</p>
<h3 id="jpaspecificationexecutor"><a class="header" href="#jpaspecificationexecutor"><strong>JpaSpecificationExecutor</strong></a></h3>
<p>Để có thể sử dụng được <code>Specification</code>, bạn cần kế thừa <code>JpaSpecificationExecutor</code> từ Spring JPA</p>
<pre><code>public interface UserRepository extends JpaRepository&lt;User, Long&gt;,
                                        JpaSpecificationExecutor&lt;User&gt; {
}
</code></pre>
<p>Lúc này, ngoài các method truyền thống như <code>findAll()</code>, <code>findOne()</code>, <code>findBy()</code> thì bạn sẽ thấy xuất hiện các method mới có tham số đầu vào là <code>Specification&lt;T&gt;</code>:</p>
<pre><code>Optional&lt;T&gt; findOne(@Nullable Specification&lt;T&gt; var1);

List&lt;T&gt; findAll(@Nullable Specification&lt;T&gt; var1);

Page&lt;T&gt; findAll(@Nullable Specification&lt;T&gt; var1, Pageable var2);

List&lt;T&gt; findAll(@Nullable Specification&lt;T&gt; var1, Sort var2);

long count(@Nullable Specification&lt;T&gt; var1);
</code></pre>
<h3 id="usage"><a class="header" href="#usage"><strong>Usage</strong></a></h3>
<p>Lúc này, để sử dụng, bạn gọi <code>Specification.where()</code> để xây dựng cho mình tập các điều kiện để query</p>
<pre><code>// Lấy ra user nằm trong tập ID đã cho và có type là NORMAL
// hoặc lấy ra user có ID = 10
Specification conditions = Specification.where(UserSpecification.hasIdIn(Arrays.asList(1L, 2L, 3L, 4L, 5L)))
                                        .and(UserSpecification.hasType(UserType.NORMAL))
                                        .or(UserSpecification.hasId(10L));
// Truyền Specification vào hàm findAll()
userRepository.findAll(conditions).forEach(System.out::println);
</code></pre>
<p>OUTPUT:</p>
<pre><code>User(id=1, type=NORMAL, name=name-0)
User(id=2, type=NORMAL, name=name-1)
User(id=5, type=NORMAL, name=name-4)
User(id=10, type=VIP, name=name-9)
</code></pre>
<p>Ngoài ra, bạn có thể import trực tiếp các hàm static vào để code gọn hơn:</p>
<pre><code>import static me.loda.spring.specification.User.UserType.NORMAL;
import static me.loda.spring.specification.UserSpecification.*;

...
// Lấy ra user nằm trong tập ID đã cho và có type là NORMAL
// hoặc lấy ra user có ID = 10
Specification conditions = Specification.where(hasIdIn(Arrays.asList(1L, 2L, 3L, 4L, 5L)))
                                        .and(hasType(NORMAL))
                                        .or(hasId(10L));
// Truyền Specification vào hàm findAll()
userRepository.findAll(conditions).forEach(System.out::println);
</code></pre>
<p>Gọn hơn thì không nên tạo ra 1 biến tham chiếu thừa thãi:</p>
<pre><code>userRepository.findAll(Specification.where(hasIdIn(Arrays.asList(1L, 2L, 3L, 4L, 5L)))
                                    .and(hasType(NORMAL))
                                    .or(hasId(10L)))
              .forEach(System.out::println);
</code></pre>
<h3 id="kết-7"><a class="header" href="#kết-7"><strong>Kết</strong></a></h3>
<p>Tới đây bạn đã có thể sử dụng <code>Specification</code> để thực hiện các truy vấn phức tạp và tái sử dụng được trong nhiều trường hợp. Đón đọc các bài sau về các phần nâng cao hơn.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="jpahướng-dẫn-sử-dụng-onetoone"><a class="header" href="#jpahướng-dẫn-sử-dụng-onetoone">「Jpa」Hướng dẫn sử dụng @OneToOne</a></h1>
<ul>
<li>Giới thiệu</li>
<li>Tạo project</li>
<li>Tạo Table</li>
<li>Chạy thử</li>
<li>Thêm dữ liệu</li>
</ul>
<h3 id="giới-thiệu-12"><a class="header" href="#giới-thiệu-12"><strong>Giới thiệu</strong></a></h3>
<p>Cách biểu thị quan hệ 1-1 trong cơ sở dữ liệu là rất phổ biến, ví dụ một người sẽ có một địa chỉ duy nhất (giả sử).</p>
<p>Bình thường, khi các bạn tạo table trong csdl để biểu thị mối quan hệ này, thì sẽ có một bảng chứa khóa ngoại của bảng còn lại.</p>
<p>!image</p>
<p>Thể hiện mỗi quan hệ này trong <code>code</code> bằng <code>Hibernate</code> thì chúng ta sẽ dùng <code>@OneToOne</code>.</p>
<p>Trong bài sử dụng các kiến thức:</p>
<ol>
<li>Hibernate là gì?</li>
<li>Cách sử dụng Lombok để tiết kiệm thời gian code</li>
</ol>
<h3 id="tạo-project"><a class="header" href="#tạo-project"><strong>Tạo project</strong></a></h3>
<p>Toàn bộ bài viết được up tại <code>Github</code>: github.com/loda-kun/java-all</p>
<p>Chúng ta sẽ sử dụng <code>Gradle</code> để tạo một project có khai báo <code>Spring Boot</code> và <code>Jpa</code> để hỗ trợ cho việc demo <code>@OneToOne</code>.</p>
<p>Các bạn có thể tự tạo 1 project Spring-boot với gradle đơn giản tại: https://start.spring.io</p>
<pre><code>plugins {
    id 'org.springframework.boot' version '2.1.4.RELEASE'
    id 'java'
}
apply plugin: 'io.spring.dependency-management'

group 'me.loda.java'
version '1.0-SNAPSHOT'

sourceCompatibility = 1.8

configurations {
    compileOnly {
        extendsFrom annotationProcessor
    }
}

repositories {
    mavenCentral()
}

dependencies {
    implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
    implementation 'org.springframework.boot:spring-boot-starter-web'
    compileOnly 'org.projectlombok:lombok'
    runtimeOnly 'com.h2database:h2'
    annotationProcessor 'org.projectlombok:lombok'
    testImplementation 'org.springframework.boot:spring-boot-starter-test'
}
</code></pre>
<p>Trong ứng dụng trên bạn sẽ thấy có <code>com.h2database:h2</code>. Đây là một <strong>database</strong>, tuy nhiên nó chỉ tồn tại trong bộ nhớ. Tức làm mỗi khi chạy chương trình này, nó sẽ tạo database trong <code>RAM</code>, và tắt chương trình đi nó sẽ mất.</p>
<p>Chúng ta sẽ sử dụng <code>H2</code> thay cho <code>MySql</code> để cho.. tiện!</p>
<p>Khi tạo xong project, sẽ có thư mục như sau:</p>
<p>!image</p>
<h3 id="tạo-table"><a class="header" href="#tạo-table"><strong>Tạo Table</strong></a></h3>
<p>Để tạo table, chúng ta tạo ra các <code>Class</code> tương ứng.</p>
<pre><code>import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;
import javax.persistence.JoinColumn;
import javax.persistence.OneToOne;

import lombok.Builder;
import lombok.Data;

@Entity // Hibernate entity
@Data // Lombok
@Builder // Lombok
public class Person { //Table person

    @Id // Đánh dấu trường này là primary key
    @GeneratedValue // Tự động tăng giá trị id
    private Long id;
    private String name;
}
</code></pre>
<pre><code>@Entity
@Data
@Builder
public class Address { // Table address
    @Id
    @GeneratedValue
    private Long id;

    private String city;
    private String province;

    @OneToOne // Đánh dấu có mỗi quan hệ 1-1 với Person ở phía dưới
    @JoinColumn(name = &quot;person_id&quot;) // Liên kết với nhau qua khóa ngoại person_id
    private Person person;
}
</code></pre>
<p>Nếu chúng ta chưa tạo ra các table trong cơ sở dữ liệu, thì mặc định <code>Hibernate</code> sẽ bind dữ liệu từ class xuống và tạo table cho chúng ta.</p>
<p>Bạn phải tạo file config <code>src\main\resources\application.properties</code> như sau để kết nối tới <code>H2</code> database nhé:</p>
<pre><code>spring.datasource.url=jdbc:h2:mem:testdb
spring.datasource.driverClassName=org.h2.Driver
spring.datasource.username=sa
spring.datasource.password=
// Không có password, vào thẳng luôn
spring.jpa.database-platform=org.hibernate.dialect.H2Dialect
# Cho phép vào xem db thông qua web
spring.h2.console.enabled=true
</code></pre>
<h3 id="chạy-thử-2"><a class="header" href="#chạy-thử-2"><strong>Chạy thử</strong></a></h3>
<p>Bạn tạo file <code>OneToOneExampleApplication</code> và cấu hình <code>Spring Boot</code> và khởi chạy chương trình.</p>
<pre><code>@SpringBootApplication
@RequiredArgsConstructor
public class OneToOneExampleApplication {
    public static void main(String[] args) {
        SpringApplication.run(OneToOneExampleApplication.class, args);
    }
}
</code></pre>
<p>Sau khi chạy xong, hãy truy cập vào <code>http://localhost:8080/h2-console/</code> để vào xem database có gì nhé.</p>
<p>!image</p>
<p>Bạn sẽ thấy nó tạo table giống với mô tả ở đầu bài. Với khóa ngoại <code>person_id</code> ở bảng <code>address</code>.</p>
<h3 id="thêm-dữ-liệu"><a class="header" href="#thêm-dữ-liệu"><strong>Thêm dữ liệu</strong></a></h3>
<p>Để thêm dữ liệu vào database, chúng ta sẽ dùng tới <code>Jpa</code>.</p>
<pre><code>import org.springframework.data.jpa.repository.JpaRepository;

public interface AddressRepository extends JpaRepository&lt;Address,Long&gt; {
}
public interface PersonRepository extends JpaRepository&lt;Person, Long&gt; {
}
</code></pre>
<p>Chúng ta sẽ tạo một chương trình <code>Spring Boot</code> đơn giản bằng cách sử dụng <code>CommandLineRunner</code> để chạy code ngay khi khởi động.</p>
<pre><code>import javax.transaction.Transactional;

import org.springframework.boot.CommandLineRunner;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

import com.google.common.collect.Lists;

import lombok.RequiredArgsConstructor;

@SpringBootApplication
@RequiredArgsConstructor
public class OneToOneExampleApplication implements CommandLineRunner {
    public static void main(String[] args) {
        SpringApplication.run(OneToOneExampleApplication.class, args);
    }

    // Sử dụng @RequiredArgsConstructor và final để thay cho @Autowired
    private final PersonRepository personRepository;
    private final AddressRepository addressRepository;

    @Override
    public void run(String... args) throws Exception {
        // Tạo ra đối tượng person
        Person person = Person.builder()
                              .name(&quot;loda&quot;)
                              .build();
        // Lưu vào db
        personRepository.save(person);

        // Tạo ra đối tượng Address có tham chiếu tới person
        Address address = Address.builder()
                .city(&quot;Hanoi&quot;)
                .person(person)
                .build();

        // Lưu vào db
        addressRepository.save(address);

        // Vào:http://localhost:8080/h2-console/ để xem dữ liệu đã insert
    }
}
</code></pre>
<p>Kết quả trong database lúc này:</p>
<p>!image</p>
<p>Vậy là thằng <code>Address</code> đã liên kết tới <code>Person</code> có <code>id=1</code>. Đúng như ta mong đợi.</p>
<p>Bài viết của mình không còn gì để ngắn hơn được nữa :((( thật hổ thẹn, mình có up code lên đây, bạn chạy code cái là hiểu liền à:</p>
<p>Chúc các bạn học tập tốt! ahuu</p>
<ol>
<li><a href="spring-boot/">🚅「Jpa」Hướng dẫn @OneToMany và @ManyToOne</a></li>
<li><a href="spring-boot/">🛵「Jpa」Hướng dẫn @ManyToMany</a></li>
</ol>
<p>💁 Nếu có, toàn bộ project / code mẫu được lưu trữ tại <strong>GitHub</strong></p>
<p>🌟 Đây là một bài viết trong Series <strong>Làm chủ Spring Boot – Zero to Hero</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="jpahướng-dẫn-onetomany-và-manytoone"><a class="header" href="#jpahướng-dẫn-onetomany-và-manytoone">「Jpa」Hướng dẫn @OneToMany và @ManyToOne</a></h1>
<ul>
<li>Giới thiệu</li>
<li>Tạo project</li>
<li>Tạo Table</li>
<li>Chạy thử</li>
<li>Thêm dữ liệu</li>
</ul>
<h3 id="giới-thiệu-13"><a class="header" href="#giới-thiệu-13"><strong>Giới thiệu</strong></a></h3>
<p>Cách biểu thị quan hệ 1-n trong cơ sở dữ liệu là rất phổ biến, ví dụ một địa chỉ có thể có nhiều người ở (gia đình).</p>
<p>Bình thường, khi các bạn tạo table trong csdl để biểu thị mối quan hệ này, thì bảng đại diện phía nhiều (phía n trong câu 1-n) sẽ chứa id của bảng tham chiếu (phía 1 trong câu 1-n)</p>
<p>!image</p>
<p>Thể hiện mỗi quan hệ này một cách đầy đủ trong <code>code</code> bằng <code>Hibernate</code> thì chúng ta sẽ dùng <code>@OneToMany</code> và <code>@ManyToOne</code>.</p>
<p>Trong bài sử dụng các kiến thức:</p>
<ol>
<li>Hibernate là gì?</li>
<li>Cách sử dụng Lombok để tiết kiệm thời gian code</li>
</ol>
<h3 id="tạo-project-1"><a class="header" href="#tạo-project-1"><strong>Tạo project</strong></a></h3>
<p>Toàn bộ bài viết được up tại <code>Github</code>: github.com/loda-kun/java-all</p>
<p>Chúng ta sẽ sử dụng <code>Gradle</code> để tạo một project có khai báo <code>Spring Boot</code> và <code>Jpa</code> để hỗ trợ cho việc demo <code>@ManyToOne</code>.</p>
<p>Các bạn có thể tự tạo 1 project Spring-boot với gradle đơn giản tại: https://start.spring.io</p>
<pre><code>plugins {
    id 'org.springframework.boot' version '2.1.4.RELEASE'
    id 'java'
}
apply plugin: 'io.spring.dependency-management'

group 'me.loda.java'
version '1.0-SNAPSHOT'

sourceCompatibility = 1.8

configurations {
    compileOnly {
        extendsFrom annotationProcessor
    }
}

repositories {
    mavenCentral()
}

dependencies {
    implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
    implementation 'org.springframework.boot:spring-boot-starter-web'
    compileOnly 'org.projectlombok:lombok'
    runtimeOnly 'com.h2database:h2'
    annotationProcessor 'org.projectlombok:lombok'
    testImplementation 'org.springframework.boot:spring-boot-starter-test'
}
</code></pre>
<p>Trong ứng dụng trên bạn sẽ thấy có <code>com.h2database:h2</code>. Đây là một <strong>database</strong>, tuy nhiên nó chỉ tồn tại trong bộ nhớ. Tức làm mỗi khi chạy chương trình này, nó sẽ tạo database trong <code>RAM</code>, và tắt chương trình đi nó sẽ mất.</p>
<p>Chúng ta sẽ sử dụng <code>H2</code> thay cho <code>MySql</code> để cho.. tiện!</p>
<p>Khi tạo xong project, sẽ có thư mục như sau:</p>
<p>!image</p>
<h3 id="tạo-table-1"><a class="header" href="#tạo-table-1"><strong>Tạo Table</strong></a></h3>
<p>Để tạo table, chúng ta tạo ra các <code>Class</code> tương ứng.</p>
<pre><code>import java.util.Collection;

import javax.persistence.CascadeType;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;
import javax.persistence.OneToMany;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.EqualsAndHashCode;
import lombok.NoArgsConstructor;
import lombok.ToString;

@Entity // Đánh dấu đây là table trong db
@Data // lombok giúp generate các hàm constructor, get, set v.v.
@AllArgsConstructor
@NoArgsConstructor
public class Address {

    @Id //Đánh dấu là primary key
    @GeneratedValue // Giúp tự động tăng
    private Long id;

    private String city;
    private String province;

    @OneToMany(mappedBy = &quot;address&quot;, cascade = CascadeType.ALL) // Quan hệ 1-n với đối tượng ở dưới (Person) (1 địa điểm có nhiều người ở)
    // MapopedBy trỏ tới tên biến Address ở trong Person.
    @EqualsAndHashCode.Exclude // không sử dụng trường này trong equals và hashcode
    @ToString.Exclude // Khoonhg sử dụng trong toString()
    private Collection&lt;Person&gt; persons;
}
</code></pre>
<pre><code>@Entity
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Person {

    @Id
    @GeneratedValue
    private Long id;
    private String name;

    // Many to One Có nhiều người ở 1 địa điểm.
    @ManyToOne
    @JoinColumn(name = &quot;address_id&quot;) // thông qua khóa ngoại address_id
    @EqualsAndHashCode.Exclude
    @ToString.Exclude
    private Address address;
}
</code></pre>
<p>Nếu chúng ta chưa tạo ra các table trong cơ sở dữ liệu, thì mặc định <code>Hibernate</code> sẽ bind dữ liệu từ class xuống và tạo table cho chúng ta.</p>
<p>Bạn phải tạo file config <code>src\main\resources\application.properties</code> như sau để kết nối tới <code>H2</code> database nhé:</p>
<pre><code>spring.datasource.url=jdbc:h2:mem:testdb
spring.datasource.driverClassName=org.h2.Driver
spring.datasource.username=sa
spring.datasource.password=
// Không có password, vào thẳng luôn
spring.jpa.database-platform=org.hibernate.dialect.H2Dialect
# Cho phép vào xem db thông qua web
spring.h2.console.enabled=true
</code></pre>
<h3 id="chạy-thử-3"><a class="header" href="#chạy-thử-3"><strong>Chạy thử</strong></a></h3>
<p>Bạn tạo file <code>OneToManyExampleApplication</code> và cấu hình <code>Spring Boot</code> và khởi chạy chương trình.</p>
<pre><code>@SpringBootApplication
@RequiredArgsConstructor
public class OneToManyExampleApplication {
    public static void main(String[] args) {
        SpringApplication.run(OneToManyExampleApplication.class, args);
    }
}
</code></pre>
<p>Sau khi chạy xong, hãy truy cập vào <code>http://localhost:8080/h2-console/</code> để vào xem database có gì nhé.</p>
<p>!image</p>
<p>Bạn sẽ thấy nó tạo table giống với mô tả ở đầu bài. Với khóa ngoại <code>address_id</code> ở bảng <code>person</code>.</p>
<h3 id="thêm-dữ-liệu-1"><a class="header" href="#thêm-dữ-liệu-1"><strong>Thêm dữ liệu</strong></a></h3>
<p>Để thêm dữ liệu vào database, chúng ta sẽ dùng tới <code>Spring JPA</code> .</p>
<pre><code>import org.springframework.data.jpa.repository.JpaRepository;

public interface AddressRepository extends JpaRepository&lt;Address,Long&gt; {
}
public interface PersonRepository extends JpaRepository&lt;Person, Long&gt; {
}
</code></pre>
<p>Chúng ta sẽ tạo một chương trình <code>Spring Boot</code> đơn giản bằng cách sử dụng <code>CommandLineRunner</code> để chạy code ngay khi khởi động.</p>
<pre><code>import javax.transaction.Transactional;

import org.springframework.boot.CommandLineRunner;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

import com.google.common.collect.Lists;

import lombok.RequiredArgsConstructor;

@SpringBootApplication
@RequiredArgsConstructor
public class OneToManyExampleApplication implements CommandLineRunner {
    public static void main(String[] args) {
        SpringApplication.run(OneToManyExampleApplication.class, args);
    }

    // Sử dụng @RequiredArgsConstructor và final để thay cho @Autowired
    private final PersonRepository personRepository;
    private final AddressRepository addressRepository;

    @Override
    public void run(String... args) throws Exception {
        // Tạo ra đối tượng Address có tham chiếu tới person
        Address address = new Address();
        address.setCity(&quot;Hanoi&quot;);

        // Tạo ra đối tượng person
        Person person = new Person();
        person.setName(&quot;loda&quot;);
        person.setAddress(address);

        address.setPersons(Collections.singleton(person));
        // Lưu vào db
        // Chúng ta chỉ cần lưu address, vì cascade = CascadeType.ALL nên nó sẽ lưu luôn Person.
        addressRepository.saveAndFlush(address);

        // Vào:http://localhost:8080/h2-console/ để xem dữ liệu đã insert

        personRepository.findAll().forEach(p -&gt; {
            System.out.println(p.getId());
            System.out.println(p.getName());
            System.out.println(p.getAddress());
        });

    }
}
//output:
// 2
// loda
// Address(id=1, city=Hanoi, province=null)
// Chúng ta đã có thể gọi trực tiếp address trong person sau khi query
</code></pre>
<p>Kết quả trong database lúc này:</p>
<p>!image</p>
<p>Bài viết của mình không còn gì để ngắn hơn được nữa :((( thật hổ thẹn, mình có up code lên đây, bạn chạy code cái là hiểu liền à:</p>
<p>Chúc các bạn học tập thật tốt! ahuu</p>
<ol>
<li><a href="spring-boot/">🪂「Jpa」Hướng dẫn sử dụng @OneToOne</a></li>
<li><a href="spring-boot/">🛵「Jpa」Hướng dẫn @ManyToMany</a></li>
</ol>
<p>💁 Nếu có, toàn bộ project / code mẫu được lưu trữ tại <strong>GitHub</strong></p>
<p>🌟 Đây là một bài viết trong Series <strong>Làm chủ Spring Boot – Zero to Hero</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="jpahướng-dẫn-manytomany"><a class="header" href="#jpahướng-dẫn-manytomany">「Jpa」Hướng dẫn @ManyToMany</a></h1>
<ul>
<li>Giới thiệu</li>
<li>Tạo project</li>
<li>Tạo Table</li>
<li>Chạy thử</li>
<li>Thêm dữ liệu</li>
</ul>
<h3 id="giới-thiệu-14"><a class="header" href="#giới-thiệu-14"><strong>Giới thiệu</strong></a></h3>
<p>Cách biểu thị quan hệ n-n trong cơ sở dữ liệu là rất phổ biến, ví dụ một địa chỉ có thể có nhiều người ở (gia đình). và một người có thể có nhiều hơn một địa chỉ.</p>
<p>Bình thường, khi các bạn tạo table trong csdl để biểu thị mối quan hệ này, chúng ta sẽ tạo ra một bảng mới, tham chiếu tới cả bảng này.</p>
<p>!image</p>
<p>Thể hiện mỗi quan hệ này một cách đầy đủ trong <code>code</code> bằng <code>Hibernate</code> thì chúng ta sẽ dùng <code>@ManyToMany</code></p>
<p>Trong bài sử dụng các kiến thức:</p>
<ol>
<li>Hibernate là gì?</li>
<li>Cách sử dụng Lombok để tiết kiệm thời gian code</li>
</ol>
<h3 id="tạo-project-2"><a class="header" href="#tạo-project-2"><strong>Tạo project</strong></a></h3>
<p>Toàn bộ bài viết được up tại <code>Github</code>: github.com/loda-kun/java-all</p>
<p>Chúng ta sẽ sử dụng <code>Gradle</code> để tạo một project có khai báo <code>Spring Boot</code> và <code>Jpa</code> để hỗ trợ cho việc demo <code>@ManyToMany</code>.</p>
<p>Các bạn có thể tự tạo 1 project Spring-boot với gradle đơn giản tại: https://start.spring.io</p>
<pre><code>plugins {
    id 'org.springframework.boot' version '2.1.4.RELEASE'
    id 'java'
}
apply plugin: 'io.spring.dependency-management'

group 'me.loda.java'
version '1.0-SNAPSHOT'

sourceCompatibility = 1.8

configurations {
    compileOnly {
        extendsFrom annotationProcessor
    }
}

repositories {
    mavenCentral()
}

dependencies {
    implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
    implementation 'org.springframework.boot:spring-boot-starter-web'
    compileOnly 'org.projectlombok:lombok'
    runtimeOnly 'com.h2database:h2'
    annotationProcessor 'org.projectlombok:lombok'
    testImplementation 'org.springframework.boot:spring-boot-starter-test'
}
</code></pre>
<p>Trong ứng dụng trên bạn sẽ thấy có <code>com.h2database:h2</code>. Đây là một <strong>database</strong>, tuy nhiên nó chỉ tồn tại trong bộ nhớ. Tức làm mỗi khi chạy chương trình này, nó sẽ tạo database trong <code>RAM</code>, và tắt chương trình đi nó sẽ mất.</p>
<p>Chúng ta sẽ sử dụng <code>H2</code> thay cho <code>MySql</code> để cho.. tiện!</p>
<p>Khi tạo xong project, sẽ có thư mục như sau:</p>
<p>!image</p>
<h3 id="tạo-table-2"><a class="header" href="#tạo-table-2"><strong>Tạo Table</strong></a></h3>
<p>Để tạo table, chúng ta tạo ra các <code>Class</code> tương ứng.</p>
<pre><code>import java.util.Collection;

import javax.persistence.CascadeType;
import javax.persistence.Entity;
import javax.persistence.FetchType;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;
import javax.persistence.JoinColumn;
import javax.persistence.JoinTable;
import javax.persistence.ManyToMany;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.EqualsAndHashCode;
import lombok.NoArgsConstructor;
import lombok.ToString;

@Entity // Đánh dấu đây là table trong db
@Data // lombok giúp generate các hàm constructor, get, set v.v.
@AllArgsConstructor
@NoArgsConstructor
@Builder
public class Address {

    @Id //Đánh dấu là primary key
    @GeneratedValue // Giúp tự động tăng
    private Long id;

    private String city;
    private String province;

    @ManyToMany(cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    // Quan hệ n-n với đối tượng ở dưới (Person) (1 địa điểm có nhiều người ở)
    @EqualsAndHashCode.Exclude // không sử dụng trường này trong equals và hashcode
    @ToString.Exclude // Khoonhg sử dụng trong toString()

    @JoinTable(name = &quot;address_person&quot;, //Tạo ra một join Table tên là &quot;address_person&quot;
            joinColumns = @JoinColumn(name = &quot;address_id&quot;),  // TRong đó, khóa ngoại chính là address_id trỏ tới class hiện tại (Address)
            inverseJoinColumns = @JoinColumn(name = &quot;person_id&quot;) //Khóa ngoại thứ 2 trỏ tới thuộc tính ở dưới (Person)
    )
    private Collection&lt;Person&gt; persons;
}
</code></pre>
<pre><code>@Entity
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class Person {

    @Id
    @GeneratedValue
    private Long id;
    private String name;

    // mappedBy trỏ tới tên biến persons ở trong Address.
    @ManyToMany(mappedBy = &quot;persons&quot;)
    // LAZY để tránh việc truy xuất dữ liệu không cần thiết. Lúc nào cần thì mới query
    @EqualsAndHashCode.Exclude
    @Exclude
    private Collection&lt;Address&gt; addresses;
}
</code></pre>
<p>Nếu chúng ta chưa tạo ra các table trong cơ sở dữ liệu, thì mặc định <code>Hibernate</code> sẽ bind dữ liệu từ class xuống và tạo table cho chúng ta.</p>
<p>Bạn phải tạo file config <code>src\main\resources\application.properties</code> như sau để kết nối tới <code>H2</code> database nhé:</p>
<pre><code>spring.datasource.url=jdbc:h2:mem:testdb
spring.datasource.driverClassName=org.h2.Driver
spring.datasource.username=sa
spring.datasource.password=
// Không có password, vào thẳng luôn
spring.jpa.database-platform=org.hibernate.dialect.H2Dialect
# Cho phép vào xem db thông qua web
spring.h2.console.enabled=true
</code></pre>
<h3 id="chạy-thử-4"><a class="header" href="#chạy-thử-4"><strong>Chạy thử</strong></a></h3>
<p>Bạn tạo file <code>ManyToManyExampleApplication</code> và cấu hình <code>Spring Boot</code> và khởi chạy chương trình.</p>
<pre><code>@SpringBootApplication
@RequiredArgsConstructor
public class ManyToManyExampleApplication {
    public static void main(String[] args) {
        SpringApplication.run(ManyToManyExampleApplication.class, args);
    }
}
</code></pre>
<p>Sau khi chạy xong, hãy truy cập vào <code>http://localhost:8080/h2-console/</code> để vào xem database có gì nhé.</p>
<p>!image</p>
<p>Bạn sẽ thấy nó tạo table giống với mô tả ở đầu bài. Gồm có hai bảng chính là <code>address</code> và <code>person</code>. Ngoài ra, sẽ tạo ra một bảng trung gian ở giữa liên kết hai bảng là <code>address_person</code>.</p>
<h3 id="thêm-dữ-liệu-2"><a class="header" href="#thêm-dữ-liệu-2"><strong>Thêm dữ liệu</strong></a></h3>
<p>Để thêm dữ liệu vào database, chúng ta sẽ dùng tới <code>Spring JPA</code> .</p>
<pre><code>import org.springframework.data.jpa.repository.JpaRepository;

public interface AddressRepository extends JpaRepository&lt;Address,Long&gt; {
}
public interface PersonRepository extends JpaRepository&lt;Person, Long&gt; {
}
</code></pre>
<p>Chúng ta sẽ tạo một chương trình <code>Spring Boot</code> đơn giản bằng cách sử dụng <code>CommandLineRunner</code> để chạy code ngay khi khởi động.</p>
<pre><code>import javax.transaction.Transactional;

import org.springframework.boot.CommandLineRunner;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

import com.google.common.collect.Lists;

import lombok.RequiredArgsConstructor;

@SpringBootApplication
@RequiredArgsConstructor
public class ManyToManyExampleApplication implements CommandLineRunner {
    public static void main(String[] args) {
        SpringApplication.run(ManyToManyExampleApplication.class, args);
    }

    // Sử dụng @RequiredArgsConstructor và final để thay cho @Autowired
    private final PersonRepository personRepository;
    private final AddressRepository addressRepository;

    @Override
    @Transactional
    public void run(String... args) throws Exception {
        // Tạo ra đối tượng Address
        Address hanoi = Address.builder()
                                 .city(&quot;hanoi&quot;)
                                 .build();
        Address hatay = Address.builder()
                               .city(&quot;hatay&quot;)
                               .build();

        // Tạo ra đối tượng person
        Person person1 = Person.builder()
                              .name(&quot;loda1&quot;)
                              .build();
        Person person2 = Person.builder()
                              .name(&quot;loda2&quot;)
                              .build();

        // set Persons vào address
        hanoi.setPersons(Lists.newArrayList(person1, person2));
        hatay.setPersons(Lists.newArrayList(person1));

        // Lưu vào db
        // Chúng ta chỉ cần lưu address, vì cascade = CascadeType.ALL nên nó sẽ lưu luôn Person.
        addressRepository.saveAndFlush(hanoi);
        addressRepository.saveAndFlush(hatay);

        // Vào:http://localhost:8080/h2-console/ để xem dữ liệu đã insert

        Address queryResult = addressRepository.findById(1L).get();
        System.out.println(queryResult.getCity());
        System.out.println(queryResult.getPersons());

    }

}
// Output:
// hanoi
// [Person(id=2, name=loda1), Person(id=3, name=loda2)]
</code></pre>
<p>Lưu ý ở đây chúng ta dùng <code>@Transactional</code>. Đê khiến toàn bộ code chạy trong hàm đều nằm trong <code>Session</code> quản lý của <code>Hibernate</code>.</p>
<p>Nếu không có <code>@Transactional</code> thì việc bạn gọi <code>address.getPersons()</code> sẽ bị lỗi, vì nó không thể query xuống database để lấy dữ liệu person lên được. Bạn ghi nhớ chỗ này nhé.</p>
<p>Kết quả trong database lúc này:</p>
<p><code>Address</code></p>
<p>!image</p>
<p>!image</p>
<p>!image</p>
<p>Bài viết của mình không còn gì để ngắn hơn được nữa :((( thật hổ thẹn, mình có up code lên đây, bạn chạy code cái là hiểu liền à:</p>
<p>Chúc các bạn học tập thật tốt! ahuu</p>
<ol>
<li><a href="spring-boot/">🪂「Jpa」Hướng dẫn sử dụng @OneToOne</a></li>
<li><a href="spring-boot/">🚅「Jpa」Hướng dẫn @OneToMany và @ManyToOne</a></li>
</ol>
<p>💁 Nếu có, toàn bộ project / code mẫu được lưu trữ tại <strong>GitHub</strong></p>
<p>🌟 Đây là một bài viết trong Series <strong>Làm chủ Spring Boot – Zero to Hero</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="jpahướng-dẫn-query-phân-trang-bằng-pageable-phần-1"><a class="header" href="#jpahướng-dẫn-query-phân-trang-bằng-pageable-phần-1">「Jpa」Hướng dẫn Query phân trang bằng Pageable (Phần 1)</a></h1>
<ul>
<li>Giới thiệu</li>
<li>Cài đặt</li>
<li>Tạo Model và Repository</li>
<li>Pageable</li>
<li>Sorting</li>
<li>Note</li>
<li>Ví dụ DEMO</li>
<li>Kết</li>
</ul>
<h3 id="giới-thiệu-15"><a class="header" href="#giới-thiệu-15"><strong>Giới thiệu</strong></a></h3>
<p>Điều này có lẽ ai cũng biết, đó là đa phần chúng ta không lấy toàn bộ dữ liệu từ Database lên, mà chỉ lấy một số lượng nhất định, và chia nó thành nhiều trang.</p>
<p>Mà cái blog này cũng là ví dụ điển hình:</p>
<p>!image</p>
<p>Tôi chia dữ liệu thành nhiều trang khác nhau, với mỗi trang thì sẽ lấy ra các bài viết cần thiết.</p>
<p>Tạo sao cần dùng phân trang? vì nó giúp tiết kiệm băng thông và tăng tốc xử lý, ngoài ra nó cũng giảm thiểu việc hiển thị các thông tin thừa không cần thiết.</p>
<p>Chúng ta sẽ tìm hiểu các làm việc này bằng <code>JPA Pageable</code></p>
<p>Nếu chưa biết Spring JPA thì xem tại đây:</p>
<ol>
<li>Hibernate là gì?</li>
<li>Spring JPA</li>
</ol>
<h3 id="cài-đặt-6"><a class="header" href="#cài-đặt-6"><strong>Cài đặt</strong></a></h3>
<p>Nhớ thêm <code>spring-boot-starter-data-jpa</code> vào dependencies của bạn.</p>
<p>Trong phần này, tôi xài H2 database để demo. (h2 là dạng memory database, nó sẽ lưu trong ram và khi tắt chương trình nó sẽ mất sạch)</p>
<p><em>pom.xml</em></p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;packaging&gt;pom&lt;/packaging&gt;
    &lt;parent&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
        &lt;version&gt;2.0.5.RELEASE&lt;/version&gt;
        &lt;relativePath /&gt; &lt;!-- lookup parent from repository --&gt;
    &lt;/parent&gt;
    &lt;groupId&gt;me.loda.spring&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-learning&lt;/artifactId&gt;
    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
    &lt;name&gt;spring-boot-learning&lt;/name&gt;
    &lt;description&gt;Everything about Spring Boot&lt;/description&gt;

    &lt;properties&gt;
        &lt;java.version&gt;1.8&lt;/java.version&gt;
    &lt;/properties&gt;

    &lt;dependencies&gt;

        &lt;!--spring mvc, rest--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;!--spring jpa--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;!-- h2 database --&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;com.h2database&lt;/groupId&gt;
            &lt;artifactId&gt;h2&lt;/artifactId&gt;
            &lt;scope&gt;runtime&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

    &lt;build&gt;
        &lt;plugins&gt;
        &lt;plugin&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
        &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;

&lt;/project&gt;
</code></pre>
<p>Cấu trúc thư mục:</p>
<p>!image</p>
<h3 id="tạo-model-và-repository"><a class="header" href="#tạo-model-và-repository"><strong>Tạo Model và Repository</strong></a></h3>
<p>Tạo ra class <code>User</code> và insert sẵn 100 <code>User</code> vào Database.</p>
<p><em>User.java</em></p>
<pre><code>@Entity
@Data
@Builder
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;
}
</code></pre>
<p><em>UserRepository.java</em></p>
<pre><code>public interface UserRepository extends JpaRepository&lt;User, Long&gt; {

}
</code></pre>
<p><em>DatasourceConfig.java</em></p>
<pre><code>@Configuration
@RequiredArgsConstructor
public class DatasourceConfig {
    // inject bởi RequiredArgsConstructor
    private final UserRepository userRepository;

    // Chỉ áp dụng trong demo :D
    @PostConstruct
    public void initData() {
        // Insert 100 User vào H2 Database sau khi
        // DatasourceConfig được khởi tạo
        userRepository.saveAll(IntStream.range(0, 100)
                                        .mapToObj(i -&gt; User.builder()
                                                           .name(&quot;name-&quot; + i)
                                                           .build())
                                        .collect(Collectors.toList())
        );
    }
}
</code></pre>
<h3 id="pageable"><a class="header" href="#pageable"><strong>Pageable</strong></a></h3>
<p>Ukie, giả sử bây giờ chúng ta có 100 record trong DB rồi.</p>
<p>Để có thể query lấy dữ liệu theo dạng Page, <strong>Spring Data JPA</strong> hỗ trợ chúng ta bằng đối tượng <code>Pageable</code>.</p>
<p>Hàm <code>findAll(Pageable pageable)</code> là có sẵn và trả về đối tượng <code>Page&lt;T&gt;</code></p>
<pre><code>// Lấy ra 5 user đầu tiên
// PageRequest.of(0,5) tương đương với lấy ra page đầu tiên, và mỗi page sẽ có 5 phần tử
// PageRequest là một đối tượng kế thừa Pageable
Page&lt;User&gt; page = userRepository.findAll(PageRequest.of(0, 5));
</code></pre>
<p>Để lấy ra 5 <code>User</code> tiếp theo, chúng ta có thể làm theo 2 cách:</p>
<pre><code>// tận dụng đối tượng Page trước đó
page.nextPageable()

// Sử dụng PageRequest mới
PageRequest.of(1, 5)
</code></pre>
<h3 id="sorting"><a class="header" href="#sorting"><strong>Sorting</strong></a></h3>
<p>Bạn có thể query dạng <code>Page</code> kèm theo yêu cầu sorting theo một trường nào đó.</p>
<pre><code>Page&lt;User&gt; page = userRepository.findAll(PageRequest.of(1, 5, Sort.by(&quot;name&quot;).descending()));
</code></pre>
<h3 id="note"><a class="header" href="#note"><strong>Note</strong></a></h3>
<p>Ngoài ra, bạn hoàn toàn có thể tự custom để hàm trả về <code>Page&lt;T&gt;</code>, <code>Slice&lt;T&gt;</code>, <code>List&lt;T&gt;</code>.</p>
<pre><code>public interface UserRepository extends JpaRepository&lt;User, Long&gt; {
    List&lt;User&gt; findAllByNameLike(String name, Pageable pageable);
}
</code></pre>
<h3 id="ví-dụ-demo"><a class="header" href="#ví-dụ-demo"><strong>Ví dụ DEMO</strong></a></h3>
<pre><code>@SpringBootApplication
@RequiredArgsConstructor
public class App {
    public static void main(String[] args) {
        SpringApplication.run(App.class, args);
    }

    private final UserRepository userRepository;

    @Bean
    CommandLineRunner run() {
        return args -&gt; {
            // Lấy ra 5 user đầu tiên
            // PageRequest.of(0,5) tương đương với lấy ra page đầu tiên, và mỗi page sẽ có 5 phần tử
            Page&lt;User&gt; page = userRepository.findAll(PageRequest.of(0, 5));
            // In ra 5 user đầu tiên
            System.out.println(&quot;In ra 5 user đầu tiên: &quot;);
            page.forEach(System.out::println);
            // Lấy ra 5 user tiếp theo
            page = userRepository.findAll(page.nextPageable());

            System.out.println(&quot;In ra 5 user tiếp theo: &quot;);
            page.forEach(System.out::println);

            System.out.println(&quot;In ra số lượng user ở page hiện tại: &quot; + page.getSize());
            System.out.println(&quot;In ra tổng số lượng user: &quot; + page.getTotalElements());
            System.out.println(&quot;In ra tổng số page: &quot; + page.getTotalPages());

            // Lấy ra 5 user ở page 1, sort theo tên
            page = userRepository.findAll(PageRequest.of(1, 5, Sort.by(&quot;name&quot;).descending()));
            System.out.println(&quot;In ra 5 user page 1, sắp xếp theo name descending:&quot;);
            page.forEach(System.out::println);

            // Custom method
            List&lt;User&gt; list = userRepository.findAllByNameLike(&quot;name-%&quot;, PageRequest.of(0, 5));
            System.out.println(list);
        };
    }

}
</code></pre>
<p>Output:</p>
<pre><code>In ra 5 user đầu tiên:
User(id=1, name=name-0)
User(id=2, name=name-1)
User(id=3, name=name-2)
User(id=4, name=name-3)
User(id=5, name=name-4)

In ra 5 user tiếp theo:
User(id=6, name=name-5)
User(id=7, name=name-6)
User(id=8, name=name-7)
User(id=9, name=name-8)
User(id=10, name=name-9)

In ra số lượng user ở page hiện tại: 5
In ra tổng số lượng user: 100
In ra tổng số page: 20

In ra 5 user page 1, sắp xếp theo name descending:
User(id=95, name=name-94)
User(id=94, name=name-93)
User(id=93, name=name-92)
User(id=92, name=name-91)
User(id=91, name=name-90)

Custom Method
[User(id=1, name=name-0), User(id=2, name=name-1), User(id=3, name=name-2), User(id=4, name=name-3), User(id=5, name=name-4)]
</code></pre>
<h3 id="kết-8"><a class="header" href="#kết-8"><strong>Kết</strong></a></h3>
<p><code>Pageable</code> là một cách tiếp cận rất tiện lợi, tuy nhiên bạn cần biết rằng các hàm sử dụng <code>Pageable</code> sẽ thực hiện query 2 lần xuống DB. Một lần là để lấy ra tổng số lượng bản ghi, một lần là query lấy ra page bạn cần. Cái này tôi sẽ nói kĩ hơn ở bài sau để chúng ta tối ưu hiệu năng</p>
<p>💁 Nếu có, toàn bộ project / code mẫu được lưu trữ tại <strong>GitHub</strong></p>
<p>🌟 Đây là một bài viết trong Series <strong>Làm chủ Spring Boot – Zero to Hero</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="jpahướng-dẫn-sử-dụng-criteria-api-trong-hibernate"><a class="header" href="#jpahướng-dẫn-sử-dụng-criteria-api-trong-hibernate">「Jpa」Hướng dẫn sử dụng Criteria API trong Hibernate</a></h1>
<p><code>JPA Criteria API</code> cho phép ta tạo ra các câu truy vấn bằng Java Object thay vì việc khai báo trực tiếp trong <code>String</code> (JPQL) như thế này:</p>
<p>Tương đương với câu lệnh trên nhưng xây dựng bằng <code>Criteria API</code> thì sẽ như này:</p>
<pre><code>CriteriaBuilder cb = em.getCriteriaBuilder();

CriteriaQuery&lt;Office&gt; q = cb.createQuery(Office.class);
Root&lt;Office&gt; c = q.from(Office.class);
q.select(c);
</code></pre>
<p>Nhìn có vẻ dài dòng và khó hiểu phải không &gt;&quot;&lt; Yea, thì đúng là như thế đấy ==!</p>
<p>Nếu nó dài dòng như vậy, tại sao người ta lại tạo ra và sử dụng nó thay cho câu lệnh <code>JPQL</code> bình thường? Các bạn đọc phần tiếp theo sẽ rõ nha.</p>
<h3 id="jpql-vs-criteria-api"><a class="header" href="#jpql-vs-criteria-api"><strong>JPQL vs Criteria API</strong></a></h3>
<p><code>JPQL</code> có thể làm đầy đủ chức năng chúng ta cần chỉ với 1 câu lệnh, tuy nhiên, chính vì điều đó, chúng ta thường khó tùy biến hay sử dụng lại nó, thậm chí khó kiểm soát lỗi của nó hơn. Với một câu lệnh phức tạp, chúng ta không biết được nó có lỗi hay không cho tới khi chạy chương trình hay debug (Mà chương trình đã chạy được rồi thì vẫn có lỗi tiềm ẩn :v chời đậu).</p>
<p><code>Criteria API</code> thì ngược lại, nó cho phép chúng ta xây dựng câu lệnh một cách <code>Dynamic</code>, rất linh động, và không bị <code>hardcode</code> trong một <code>String</code> và có thể <code>tái sử dụng</code> lại được. Đặc biệt, vì là Java Object, nên chúng ta sẽ biết một câu lệnh bị lỗi, không đúng quy tắc ngay khi biên dịch chương trình rồi.</p>
<p>Túm váy lại, với một lệnh đơn giản như ví dụ đầu bài, thì các bạn nên xài <code>JPQL</code>, còn với những câu lệnh phức hợp, thay đổi theo <code>context</code> của chương trình thì nên sử dụng <code>Criteria</code>.</p>
<h3 id="how-to-use"><a class="header" href="#how-to-use"><strong>How to use.</strong></a></h3>
<p>Quay trở lại với ví dụ ban đầu nhé:</p>
<pre><code>CriteriaBuilder builder = em.getCriteriaBuilder();

CriteriaQuery&lt;Office&gt; query =  builder.createQuery(Office.class);
Root&lt;Office&gt; root = query.from(Office.class);
query.select(root);
</code></pre>
<p>Chúng ta cùng tìm hiểu từng dòng lệnh:</p>
<ul>
<li>
<p><code>CriteriaBuilder</code>: Để xây dựng một câu query, các bạn sẽ cần tới <code>interface``CriteriaBuilder</code>, mục đích của nó là giúp tạo ra đối tượng chứa câu lệnh truy vấn <code>CriteriaQuery</code> và cung cấp cơ số các phép biến đổi, phép logic, điều kiện cho câu lệnh (and, or, not, avg, greater than,v.v...)</p>
</li>
<li>
<p><code>CriteriaQuery</code>: Đối tượng chính của chúng ta đây, nó được tạo ra bởi <code>builder.createQuery(Office.class)</code>. Mục đích là khai báo đối tượng bạn muốn lấy ra sau khi thực hiện query. Nó tương đương với đoạn ngoặc đơn ở dưới đây:</p>
</li>
<li>
<p><code>Root</code>: root là khai báo đối tượng bạn sẽ sử dụng trong query, tương đương với đối tượng sau mệnh đề <code>FROM</code></p>
</li>
</ul>
<p>Cuối cùng, để hoàn thiện câu lệnh <code>SELECT</code> chỉ đơn giản là lấy đối tượng <code>CriteriaQuery</code> đã khai báo là sử dụng function <code>select</code>. Đối tượng truyền vào chính là cái <code>root</code> (hay cái đối tượng của <code>FROM</code>) kia.</p>
<p>Trông vậy chứ cũng dễ dễ rồi đấy nhỉ :)))</p>
<p>Okie, có điều này không biết đã bạn nào để ý chưa 😅 chúng ta mới tạo ra câu lệnh, chứ chưa hề gọi nó xuống <code>Database</code> 😅</p>
<p>Để sử dụng câu lệnh đã tạo, các bạn làm giống với <code>JPQL</code> đó là sử dụng đối tượng <code>EntityManager</code></p>
<pre><code>TypedQuery&lt;Office&gt; query = em.createQuery(query);
List&lt;Office&gt; results = query.getResultList();
</code></pre>
<p>Oh right, thế là implement xong ví dụ đơn giản đâu tiên, không cóa gì khó khăn 🤔 (chém). Bây giờ thử advanced lên tý nhỉ:</p>
<p>Bây giờ mình muốn lấy tất cả <code>Office</code> ở thành phố <code>hanoi</code> thì sẽ làm như nào?</p>
<pre><code>SELECT o FROM Office o WHERE o.city = 'hanoi'
</code></pre>
<p>Lúc này query của chúng ta sẽ như thế này:</p>
<pre><code>query.select(root).where(builder.equal(root.get(&quot;city&quot;), &quot;hanoi&quot;));
</code></pre>
<p>Các bạn để ý đoạn này nhé. Mình sử <code>builder</code> để lấy hàm <code>equal</code> (phép toán logic, như mình đề cập ở trên, chuẩn chưa nào). Tiếp tới là cái <code>root.get(&quot;city&quot;)</code>, <code>root</code> chính là đối tượng chúng ta đã khai báo, bây giờ chúng ta sẽ lấy trường <code>city</code> của nó và kiểm tra nó với <code>hanoi</code>.</p>
<p>Có thể nói <code>Criteria API</code> đã hiện thực hóa rất thành công câu lệnh JPQL (hay HQL) thành những api java cực kì dễ dọc, dễ hiểu và dễ sử dụng. Khi đã hiểu được câu lệnh gốc, bạn có thể dễ dàng chuyển nó thành <code>Criteria</code> và ngược lại.</p>
<p>Trong bài viết tới ở chương <code>Spring</code>, mình sẽ hướng dẫn các bạn sử dụng tới <code>Specifications</code> kết hợp <code>Criteria API</code> để tạo ra một vụ nổ khi giao tiếp với db bằng <code>Java</code> (vãi cả chém 😂)</p>
<p>Chúc các bạn sử dụng thành công <code>Criteria API</code> và đừng quên like or chia sẻ bài viết cho bạn bè hihi, cảm ơn các bạn đã theo dõi!</p>
<p>💁 Nếu có, toàn bộ project / code mẫu được lưu trữ tại <strong>GitHub</strong></p>
<p>🌟 Đây là một bài viết trong Series <strong>Làm chủ Spring Boot – Zero to Hero</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="jpahướng-dẫn-sử-dụng-criteria-api-trong-hibernate-phần-2"><a class="header" href="#jpahướng-dẫn-sử-dụng-criteria-api-trong-hibernate-phần-2">「Jpa」Hướng dẫn sử dụng Criteria API trong Hibernate (Phần 2)</a></h1>
<ul>
<li>Giới thiệu</li>
<li>Cài đặt</li>
<li>JPA Meta Model</li>
<li>Predicate</li>
</ul>
<h3 id="giới-thiệu-16"><a class="header" href="#giới-thiệu-16"><strong>Giới thiệu</strong></a></h3>
<p>Trong bài viết trước, tôi đã giới thiệu với các bạn về <strong>Criteria API</strong> của <strong>Hibernate</strong>.</p>
<ol>
<li>Hibernate là gì?</li>
<li>Hướng dẫn sử dụng Criteria API trong Hibernate</li>
</ol>
<p>Trong phần này chúng ta sẽ tìm hiểu một số các phần cần thiết khác trong <strong>Criteria API</strong>, thứ giúp cho bạn xây dựng query một cách đơn giản hơn.</p>
<p>Trong bài có sử dụng:</p>
<ol>
<li>Lombok</li>
</ol>
<h3 id="cài-đặt-7"><a class="header" href="#cài-đặt-7"><strong>Cài đặt</strong></a></h3>
<p>Nhớ thêm <code>spring-boot-starter-data-jpa</code> vào dependencies của bạn.</p>
<p>Trong phần này, tôi xài <em>H2 database</em> để demo. (H2 là dạng memory database, nó sẽ lưu trong ram và khi tắt chương trình nó sẽ mất sạch)</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;projectxmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;&lt;parent&gt;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;&lt;version&gt;2.0.5.RELEASE&lt;/version&gt;&lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;
	&lt;/parent&gt;&lt;groupId&gt;me.loda.spring&lt;/groupId&gt;&lt;artifactId&gt;example-independent-maven-spring-project&lt;/artifactId&gt;&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;&lt;name&gt;example-independent-maven-spring-project&lt;/name&gt;&lt;description&gt;Demo project for Spring Boot&lt;/description&gt;&lt;properties&gt;&lt;java.version&gt;1.8&lt;/java.version&gt;&lt;/properties&gt;&lt;dependencies&gt;&lt;dependency&gt;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;&lt;scope&gt;runtime&lt;/scope&gt;&lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt;&lt;dependency&gt;&lt;groupId&gt;org.projectlombok&lt;/groupId&gt;&lt;artifactId&gt;lombok&lt;/artifactId&gt;&lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt;&lt;dependency&gt;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;&lt;scope&gt;test&lt;/scope&gt;&lt;!--			&lt;exclusions&gt;--&gt;
			&lt;!--				&lt;exclusion&gt;--&gt;
			&lt;!--					&lt;groupId&gt;org.junit.vintage&lt;/groupId&gt;--&gt;
			&lt;!--					&lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt;--&gt;
			&lt;!--				&lt;/exclusion&gt;--&gt;
			&lt;!--			&lt;/exclusions&gt;--&gt;
		&lt;/dependency&gt;&lt;!--spring jpa--&gt;
		&lt;dependency&gt;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--in memory database--&gt;
		&lt;dependency&gt;&lt;groupId&gt;com.h2database&lt;/groupId&gt;&lt;artifactId&gt;h2&lt;/artifactId&gt;&lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;&lt;!--https://mvnrepository.com/artifact/org.hibernate/hibernate-jpamodelgen --&gt;
		&lt;dependency&gt;&lt;groupId&gt;org.hibernate&lt;/groupId&gt;&lt;artifactId&gt;hibernate-jpamodelgen&lt;/artifactId&gt;&lt;version&gt;5.4.9.Final&lt;/version&gt;&lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt;&lt;/dependencies&gt;&lt;build&gt;&lt;plugins&gt;&lt;plugin&gt;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;&lt;/plugin&gt;&lt;/plugins&gt;&lt;/build&gt;&lt;/project&gt;
</code></pre>
<p>Đặc biệt, chú ý <code>hibernate-jpamodelgen</code>, tôi sẽ giải thích tác dụng của nó trước.</p>
<h3 id="jpa-meta-model"><a class="header" href="#jpa-meta-model"><strong>JPA Meta Model</strong></a></h3>
<p>trong bài trước mọi người cũng biết cách cấu trúc của một câu query trong Criteria API:</p>
<pre><code>SELECT o FROM Office o WHERE o.city = 'hanoi'
</code></pre>
<p>Lúc này query của chúng ta sẽ như thế này:</p>
<pre><code>query.select(root).where(builder.equal(root.get(&quot;city&quot;), &quot;hanoi&quot;));
</code></pre>
<p>Để ý thì có thể thấy, khi muốn lấy column <code>city</code> để kiểm tra, chúng ta đang hardcode bằng <code>String</code>.</p>
<p>Có một số bất lợi khi làm vậy, thứ nhất là bạn phải tự nhớ tên các column mỗi khi gọi, thứ hai là bạn sẽ phải tìm kiếm tất cả các chỗ sử dụng mỗi sửa đổi tên cột.</p>
<p>Cách giải quyết hay nhất là tham chiếu tên các column của <strong>Table</strong> vào một <strong>Object</strong> để chúng ta có thể gọi tới mỗi khi sử dụng. Khi có sự thay đổi, chỉ cần thay đổi trong đối tượng này là xong. Đối tượng biểu diễn này được gọi là <strong>Meta Model</strong>.</p>
<p>Và rất may là Hibernate hỗ trợ chúng ta tự động generate ra các Meta Model từ các class <code>@Entity</code></p>
<p>Ví dụ:</p>
<p>Chúng ta có Class Entity <code>User</code></p>
<p><em>User.java</em></p>
<pre><code>@Entity
@Data
@Builder
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private UserType type;
    private String name;

    public enum UserType {
        NORMAL, VIP;
    }
}
</code></pre>
<p>Thì class Meta Model của <code>User</code> sẽ tên là <code>User_</code> và có cấu trúc như sau:</p>
<pre><code>@Generated(value = &quot;org.hibernate.jpamodelgen.JPAMetaModelEntityProcessor&quot;)
@StaticMetamodel(User.class)
public abstract class User_ {

	public static volatile SingularAttribute&lt;User, String&gt; name;
	public static volatile SingularAttribute&lt;User, Long&gt; id;
	public static volatile SingularAttribute&lt;User, UserType&gt; type;

	public static final String NAME = &quot;name&quot;;
	public static final String ID = &quot;id&quot;;
	public static final String TYPE = &quot;type&quot;;

}
</code></pre>
<p>Để có thể Generate ra các class Meta Model, bạn sẽ cần thêm dependency <code>hibernate-jpamodelgen</code> vào project của mình.</p>
<pre><code>&lt;dependency&gt;&lt;groupId&gt;org.hibernate&lt;/groupId&gt;&lt;artifactId&gt;hibernate-jpamodelgen&lt;/artifactId&gt;&lt;version&gt;CURRENT-VERSION&lt;/version&gt;&lt;/dependency&gt;
</code></pre>
<p>Khi build jar nó sẽ tự động generate thêm cho bạn</p>
<p>Để có thể sử dụng trong IDE, bạn có thể Config Annotation Processor (Giống với Lombok), để IDE hiểu và tự động generate ra giúp bạn lập trình dễ hơn.</p>
<p>!image</p>
<h3 id="predicate"><a class="header" href="#predicate"><strong>Predicate</strong></a></h3>
<p>Để có thể xây dựng câu truy vấn một cách trọn vẹn, bạn cần biết <code>Predicate</code>.</p>
<p>Tạm hiểu một cách đơn giản thì <code>Predicate</code> là một mệnh đề điều kiện trong câu lệnh truy vấn.</p>
<p>Như ví dụ ở dưới đây:</p>
<pre><code>@Repository
public class CustomUserRepository {

    @PersistenceContext
    private EntityManager em;

    public User getUserById(Long id) {
        CriteriaBuilder builder = em.getCriteriaBuilder();
        CriteriaQuery&lt;User&gt; query = builder.createQuery(User.class);
        Root&lt;User&gt; root = query.from(User.class);

        Predicate condition = builder.equal(root.get(User_.ID), id);

        query.select(root).where(condition);

        return em.createQuery(query).getSingleResult();
    }
}
</code></pre>
<p><code>Predicate</code> có thể liên kết với nhau bằng các phép quan hệ <code>and</code>, <code>or</code>, <code>not</code>, v.v..</p>
<p>Ví dụ:</p>
<pre><code>    public Collection&lt;User&gt; getUserByComplexConditions(String name, UserType type) {
        CriteriaBuilder builder = em.getCriteriaBuilder();
        CriteriaQuery&lt;User&gt; query = builder.createQuery(User.class);
        Root&lt;User&gt; root = query.from(User.class);

        Predicate hasNameLike = builder.like(root.get(User_.NAME), name);
        Predicate hasType = builder.equal(root.get(User_.TYPE), type);

        Predicate condition = builder.and(hasNameLike, hasType);

        query.select(root).where(condition);
        return em.createQuery(query).getResultList();
    }
</code></pre>
<p>Tới đây bạn đã nắm được cơ bản <strong>Criteria API</strong> và đã có thể tự sử dụng nó trong đa số các câu lệnh đơn giản.</p>
<p>Trong bài tiếp theo, tôi sẽ hướng dẫn nốt các join bảng nữa thôi là bạn sẽ mas con ông ter.</p>
<p>💁 Nếu có, toàn bộ project / code mẫu được lưu trữ tại <strong>GitHub</strong></p>
<p>🌟 Đây là một bài viết trong Series <strong>Làm chủ Spring Boot – Zero to Hero</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="jpahướng-dẫn-tự-tạo-validator-để-kiểm-tra-model--entity"><a class="header" href="#jpahướng-dẫn-tự-tạo-validator-để-kiểm-tra-model--entity">「Jpa」Hướng dẫn tự tạo Validator để kiểm tra Model &amp; Entity</a></h1>
<ul>
<li>Giới thiệu</li>
<li>Cài đặt</li>
<li>Prepare</li>
<li>Tạo Annotation</li>
<li>Tạo Validator</li>
<li>Chạy thử</li>
<li>Kết</li>
</ul>
<h3 id="giới-thiệu-17"><a class="header" href="#giới-thiệu-17"><strong>Giới thiệu</strong></a></h3>
<p>Bản thân Hibernate và Java đã cung cấp cho chúng ta rất nhiều các Annotation để validate dữ liệu của model.</p>
<p>Chẳng hạn như: <code>@@NotBlank</code>, <code>@Size</code>, <code>@Email</code>, v.v..</p>
<p>Tuy nhiên, trên thực tế, chúng ta có rất nhiều các điều kiện được đặt ra, tuỳ thuộc vào business và mô hình dự án.</p>
<p>Ví dụ như trong dự án của tôi, tôi muốn tất cả <code>User</code> đều phải có một thuộc tính là <code>lodaId</code>.</p>
<p>Một <code>lodaId</code> hợp lệ là chuỗi String có tiền tố: <code>loda://xxxx</code></p>
<p>Lúc này, làm sao để tôi chắc chắn được rằng mọi <code>User</code> trước khi tạo đều phải có <code>lodaId</code> hợp lệ?</p>
<p>Rõ ràng tôi phải tự tạo ra một bộ kiểm tra cho riêng mình để kiểm soát tính hợp lệ của <code>User</code>.</p>
<p>Rất may, <code>hibernate-validator</code> sẽ giúp tôi làm điều đó.</p>
<p>Trong bài có sử dụng các kiến thức:</p>
<ol>
<li>Spring Boot</li>
<li>jpa</li>
<li>lombok</li>
</ol>
<h3 id="cài-đặt-8"><a class="header" href="#cài-đặt-8"><strong>Cài đặt</strong></a></h3>
<p><em>pom.xml</em></p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;projectxmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;&lt;parent&gt;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;&lt;version&gt;2.0.5.RELEASE&lt;/version&gt;&lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;
	&lt;/parent&gt;&lt;groupId&gt;me.loda.spring&lt;/groupId&gt;&lt;artifactId&gt;example-independent-maven-spring-project&lt;/artifactId&gt;&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;&lt;name&gt;example-independent-maven-spring-project&lt;/name&gt;&lt;description&gt;Demo project for Spring Boot&lt;/description&gt;&lt;properties&gt;&lt;java.version&gt;1.8&lt;/java.version&gt;&lt;/properties&gt;&lt;dependencies&gt;&lt;dependency&gt;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;&lt;scope&gt;runtime&lt;/scope&gt;&lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt;&lt;dependency&gt;&lt;groupId&gt;org.projectlombok&lt;/groupId&gt;&lt;artifactId&gt;lombok&lt;/artifactId&gt;&lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt;&lt;dependency&gt;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;&lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;!--https://mvnrepository.com/artifact/org.hibernate/hibernate-validator --&gt;
        &lt;dependency&gt;&lt;groupId&gt;org.hibernate&lt;/groupId&gt;&lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt;&lt;version&gt;6.1.0.Final&lt;/version&gt;&lt;/dependency&gt;&lt;/dependencies&gt;&lt;build&gt;&lt;plugins&gt;&lt;plugin&gt;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;&lt;/plugin&gt;&lt;/plugins&gt;&lt;/build&gt;&lt;/project&gt;
</code></pre>
<h3 id="prepare-3"><a class="header" href="#prepare-3"><strong>Prepare</strong></a></h3>
<p>Trước khi tạo ra một bộ Validator cho riêng mình, chúng ta tạo ra các thành phần chính.</p>
<p>Tạo ra model <code>User</code></p>
<p><em>User.java</em></p>
<pre><code>@Data
public class User {
    private String lodaId;
}
</code></pre>
<p>Tạo Controller giao tiếp với client.</p>
<p><em>UserController.java</em></p>
<pre><code>@RestController
@RequestMapping(&quot;api/v1/users&quot;)
public class UserController {

    /*
        Đánh dấu object với @Valid để validator tự động kiểm tra object đó có hợp lệ hay không
     */
    @PostMapping
    public Object createUser(@Valid @RequestBody User user) {
        return user;
    }

}
</code></pre>
<h3 id="tạo-annotation"><a class="header" href="#tạo-annotation"><strong>Tạo Annotation</strong></a></h3>
<p>Để tạo ra một validator với Hibernate-Validator, chúng ta cần khai báo một annotation mới.</p>
<p>Ở đây, tôi tạo ra một Annotation của chính mình như sau:</p>
<pre><code>/**
 * Khai báo một custom annotation
 */
@Documented
@Constraint(validatedBy = LodaIdValidator.class)
@Target({ElementType.METHOD, ElementType.FIELD})
@Retention(RetentionPolicy.RUNTIME)
public @interface LodaId {
    // trường message là bắt buộc, khai báo nội dung sẽ trả về khi field k hợp lệ
    String message() default &quot;LodaId must start with loda://&quot;;
    // Cái này là bắt buộc phải có để Hibernate Validator có thể hoạt động
    Class&lt;?&gt;[] groups() default {};
    // Cái này là bắt buộc phải có để Hibernate Validator có thể hoạt động
    Class&lt;? extends Payload&gt;[] payload() default {};
}
</code></pre>
<p>Vậy là xong, giờ chỉ cần gắn <code>@LodaId</code> lên trường nào cần kiểm tra tính hợp lệ.</p>
<pre><code>@Data
public class User {
    // Đánh dấu field lodaId sẽ cần validate bởi @LodaId
    @LodaId
    private String lodaId;
}
</code></pre>
<h3 id="tạo-validator"><a class="header" href="#tạo-validator"><strong>Tạo Validator</strong></a></h3>
<p>Sau khi đã tạo ra <code>@LodaId</code>, chúng ta cần tạo ra bộ kiểm tra cho Annotation này.</p>
<p>Rất đơn giản, bạn chỉ cần kế thừa lớp <code>ConstraintValidator</code> của Hibernate Validator</p>
<pre><code>import javax.validation.ConstraintValidator;
import javax.validation.ConstraintValidatorContext;

public class LodaIdValidator implements ConstraintValidator&lt;LodaId, String&gt; {
    private static final String LODA_PREFIX = &quot;loda://&quot;;

    /**
     * Kiểm tra tính hợp lệ của trường được đánh dấu bởi @LodaId
     * @param s
     * @param constraintValidatorContext
     * @return
     */
    @Override
    public boolean isValid(String s, ConstraintValidatorContext constraintValidatorContext) {
        if (s == null || s.isEmpty()) return false;

        return s.startsWith(LODA_PREFIX);
    }
}
</code></pre>
<h3 id="chạy-thử-5"><a class="header" href="#chạy-thử-5"><strong>Chạy thử</strong></a></h3>
<p>Request một <code>User</code> hợp lệ:</p>
<pre><code>{
	&quot;lodaId&quot;: &quot;loda://user_1&quot;
}
</code></pre>
<p>trả về thành công <code>200</code>.</p>
<p>!image</p>
<p>Request một <code>User</code> không hợp lệ:</p>
<pre><code>{
	&quot;lodaId&quot;: &quot;Laula://user_1&quot;
}
</code></pre>
<p>Trả về thất bại, Bad Request <code>400</code>.</p>
<p>!image</p>
<pre><code>{
    &quot;timestamp&quot;: &quot;2019-12-19T10:26:14.554+0000&quot;,
    &quot;status&quot;: 400,
    &quot;error&quot;: &quot;Bad Request&quot;,
    &quot;errors&quot;: [
        {
            &quot;codes&quot;: [
                &quot;LodaId.user.lodaId&quot;,
                &quot;LodaId.lodaId&quot;,
                &quot;LodaId.java.lang.String&quot;,
                &quot;LodaId&quot;
            ],
            &quot;arguments&quot;: [
                {
                    &quot;codes&quot;: [
                        &quot;user.lodaId&quot;,
                        &quot;lodaId&quot;
                    ],
                    &quot;arguments&quot;: null,
                    &quot;defaultMessage&quot;: &quot;lodaId&quot;,
                    &quot;code&quot;: &quot;lodaId&quot;
                }
            ],
            &quot;defaultMessage&quot;: &quot;LodaId must start with loda://&quot;,
            &quot;objectName&quot;: &quot;user&quot;,
            &quot;field&quot;: &quot;lodaId&quot;,
            &quot;rejectedValue&quot;: &quot;Laula://user_1&quot;,
            &quot;bindingFailure&quot;: false,
            &quot;code&quot;: &quot;LodaId&quot;
        }
    ],
    &quot;message&quot;: &quot;Validation failed for object='user'. Error count: 1&quot;,
    &quot;path&quot;: &quot;/api/v1/users&quot;
}
</code></pre>
<h3 id="kết-9"><a class="header" href="#kết-9"><strong>Kết</strong></a></h3>
<p>Rất đơn giản để có thể tự tạo ra cho mình các Validator với <code>Hibernate-Validator</code>. Nó sẽ giúp bạn tiết kiệm rất nhiều thời gian.</p>
<p>💁 Nếu có, toàn bộ project / code mẫu được lưu trữ tại <strong>GitHub</strong></p>
<p>🌟 Đây là một bài viết trong Series <strong>Làm chủ Spring Boot – Zero to Hero</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ss-hướng-dẫn-spring-security-cơ-bản-dễ-hiểu"><a class="header" href="#ss-hướng-dẫn-spring-security-cơ-bản-dễ-hiểu">[SS] Hướng dẫn Spring Security cơ bản, dễ hiểu</a></h1>
<ul>
<li>Giới thiệu</li>
<li>Cài đặt</li>
<li>Implement</li>
<li>Kích hoạt tính năng WebSecurity</li>
<li>Tạo tài khoản user</li>
<li>Phân quyền truy cập</li>
<li>Thêm controller.</li>
<li>Chạy thử</li>
<li>Kết</li>
</ul>
<h3 id="giới-thiệu-18"><a class="header" href="#giới-thiệu-18"><strong>Giới thiệu</strong></a></h3>
<p><strong>Spring Security</strong> là một trong những core feature quan trọng của Spring Framework, nó giúp chúng ta phân quyền và xác thực người dùng trước khi cho phép họ truy cập vào các tài nguyên của chúng ta.</p>
<p>Trong bài hướng dẫn này, tôi sẽ hướng dẫn các bạn cách implement <strong>Spring Security</strong> một cách cơ bản nhất, đơn giản nhất, chúng ta sẽ nâng cao dần ở các bài sau.</p>
<h3 id="cài-đặt-9"><a class="header" href="#cài-đặt-9"><strong>Cài đặt</strong></a></h3>
<p>Chúng ta cài thư viện qua maven, các dependencies bao gồm:</p>
<p><em>pom.xml</em></p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-security-example&lt;/artifactId&gt;
    &lt;version&gt;0.1.0&lt;/version&gt;

    &lt;parent&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
        &lt;version&gt;2.0.5.RELEASE&lt;/version&gt;
    &lt;/parent&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.security&lt;/groupId&gt;
            &lt;artifactId&gt;spring-security-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

    &lt;properties&gt;
        &lt;java.version&gt;1.8&lt;/java.version&gt;
    &lt;/properties&gt;

    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;

&lt;/project&gt;
</code></pre>
<p>Thư mục code gồm có:</p>
<p>!image</p>
<h3 id="implement-1"><a class="header" href="#implement-1"><strong>Implement</strong></a></h3>
<h3 id="kích-hoạt-tính-năng-websecurity"><a class="header" href="#kích-hoạt-tính-năng-websecurity"><strong>Kích hoạt tính năng WebSecurity</strong></a></h3>
<p>Trước tiên, để kích hoạt tính năng Spring Security trên ứng dụng Web của mình, các bạn cần gắn annotation <code>@EnableWebSecurity</code> trên một bean bất kỳ của mình.</p>
<p>Ở đây, tôi tạo ra một class <code>WebSecurityConfig</code> để là nơi tập trung các xử lý các thông tin liên quan tới security.</p>
<pre><code>@EnableWebSecurity
public class WebSecurityConfig {
    // ...
}
</code></pre>
<h3 id="tạo-tài-khoản-user"><a class="header" href="#tạo-tài-khoản-user"><strong>Tạo tài khoản user</strong></a></h3>
<p>Thông thường, tài khoản user của người dùng sẽ được lưu trong csdl và mã hóa. Tuy nhiên, trong ví dụ cực kì basic này, tôi sẽ lưu một tài khoản người dùng trong chính bộ nhớ chương trình.</p>
<p>Cách này chỉ để demo thôi nhé, vì nó dữ liệu sẽ bị mất khi tắt ứng dụng, chúng ta sẽ tìm hiểu cách xác thực bằng csdl ở bài sau.</p>
<pre><code>@EnableWebSecurity
public class WebSecurityConfig extends WebSecurityConfigurerAdapter {

    @Bean
    @Override
    public UserDetailsService userDetailsService() {
        // Tạo ra user trong bộ nhớ
        // lưu ý, chỉ sử dụng cách này để minh họa
        // Còn thực tế chúng ta sẽ kiểm tra user trong csdl
        InMemoryUserDetailsManager manager = new InMemoryUserDetailsManager();
        manager.createUser(
                User.withDefaultPasswordEncoder() // Sử dụng mã hóa password đơn giản
                    .username(&quot;loda&quot;)
                    .password(&quot;loda&quot;)
                    .roles(&quot;USER&quot;) // phân quyền là người dùng.
                    .build()
        );
        return manager;
    }
}
</code></pre>
<p><code>WebSecurityConfigurerAdapter</code> là một interface tiện ích của Spring Security giúp chúng ta cài đặt các thông tin dễ dàng hơn.</p>
<p><em>Method</em><code>userDetailsService()</code> có tác dụng cung cấp thông tin user cho Spring Security, chúng ta <em>Override</em> lại method này và cung cấp cho nó một <code>User</code> là <code>loda</code>.</p>
<h3 id="phân-quyền-truy-cập"><a class="header" href="#phân-quyền-truy-cập"><strong>Phân quyền truy cập</strong></a></h3>
<p>Khi đã có <code>User</code>, chúng ta sẽ cần phân quyền xem một <code>User</code> sẽ được phép truy cập vào những tài nguyên nào.</p>
<p>Lúc này, vẫn ở trong <code>WebSecurityConfigurerAdapter</code>, chúng ta override lại method <code>protected void configure(HttpSecurity http)</code> để thực hiện việc phân quyền.</p>
<pre><code>import org.springframework.context.annotation.Bean;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.provisioning.InMemoryUserDetailsManager;

@EnableWebSecurity
public class WebSecurityConfig extends WebSecurityConfigurerAdapter {

    @Bean
    @Override
    public UserDetailsService userDetailsService() {
        // Tạo ra user trong bộ nhớ
        // lưu ý, chỉ sử dụng cách này để minh họa
        // Còn thực tế chúng ta sẽ kiểm tra user trong csdl
        InMemoryUserDetailsManager manager = new InMemoryUserDetailsManager();
        manager.createUser(
                User.withDefaultPasswordEncoder() // Sử dụng mã hóa password đơn giản
                    .username(&quot;loda&quot;)
                    .password(&quot;loda&quot;)
                    .roles(&quot;USER&quot;) // phân quyền là người dùng.
                    .build()
        );
        return manager;
    }

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
                .authorizeRequests()
                    .antMatchers(&quot;/&quot;, &quot;/home&quot;).permitAll() // Cho phép tất cả mọi người truy cập vào 2 địa chỉ này
                    .anyRequest().authenticated() // Tất cả các request khác đều cần phải xác thực mới được truy cập
                    .and()
                .formLogin() // Cho phép người dùng xác thực bằng form login
                    .defaultSuccessUrl(&quot;/hello&quot;)
                    .permitAll() // Tất cả đều được truy cập vào địa chỉ này
                    .and()
                .logout() // Cho phép logout
                    .permitAll();
    }
}
</code></pre>
<p><code>HttpSecurity</code> là đối tượng chính của Spring Security, cho phép chúng ta cấu hình mọi thứ cần bảo mật, và nó được xây dựng dưới design pattern giống với <code>Builder Pattern</code>, nên mọi cài đặt có thể viết liên tục thông qua toán tử <code>.</code></p>
<p>Ở ví dụ trên, những gì chúng ta muốn cho phép, chúng ta sẽ xài method <code>.permit()</code>, còn những gì cấm hoặc yêu cầu xác thực sẽ dùng <code>.authenticated()</code></p>
<p>Khi gọi <code>.formLogin()</code> thì chúng ta cấu hình cho phép người dùng đăng nhập, thông qua địa chỉ mặc định <code>/login</code> do Spring Security tự tạo ra (Cái này có thể custom theo ý mình được, nhưng chúng ta sẽ tiếp cận ở bài sau).</p>
<p>Tương tự <code>.logout()</code> cho phép người dùng logout, Nếu không nói gì thêm, Spring Security sẽ mặc định tự tạo ra một trang logout với địa chỉ <code>/logout</code>.</p>
<h3 id="thêm-controller"><a class="header" href="#thêm-controller"><strong>Thêm controller.</strong></a></h3>
<p>Chúng ta tạo ra trang web của mình gồm có trang <code>homepage</code> và trang <code>hello</code>.</p>
<ul>
<li>Trang <code>homepage</code> thì ai cũng truy cập được.</li>
<li>Trang <code>hello</code> thì phải xác thực mới được truy cập.</li>
</ul>
<p>Các địa chỉ <code>/login</code> và <code>/logout</code> thì không cần tạo, Spring Security đã tạo sẵn rồi, chúng ta dùng lại luôn.</p>
<pre><code>import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;

@Controller
public class WebController {

    @GetMapping(value = {&quot;/&quot;, &quot;/home&quot;})
    public String homepage() {
        return &quot;home&quot;; // Trả về home.html
    }

    @GetMapping(&quot;/hello&quot;)
    public String hello() {
        return &quot;hello&quot;; // Trả về hello.html
    }

}
</code></pre>
<p>Ukie, đơn giản vậy thôi, bây giờ cần tạo ra các trang <code>home.html</code> và <code>hello.html</code>.</p>
<p>Vì ở trong file <em>pom.xml</em> chúng ta đã cài thư viện <code>thymeleaf</code>. Nên nó sẽ tự động mapping tên tương ứng trong <code>Controller</code> trả về với các file ở bên trong thư mục <code>resources/templates/</code></p>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<p><em>hello.html</em></p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;
&lt;head&gt;
  &lt;title&gt;Hello&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;Chỉ những ai đăng nhập mới truy cập được trang này!&lt;/h1&gt;

&lt;form th:action=&quot;@{/logout}&quot; method=&quot;post&quot;&gt;
  &lt;input type=&quot;submit&quot; value=&quot;Sign Out&quot;/&gt;
&lt;/form&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>Cú pháp <code>th:action=&quot;@{/logout}&quot;</code> là của thymeleaf, có tác dụng request tới địa chỉ <code>/logout</code></p>
<p><em>home.html</em></p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;
&lt;head&gt;
  &lt;title&gt;Spring Security Example&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;Welcome!&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;/login&quot;&gt;login&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Click &lt;a href=&quot;https://loda.me&quot;&gt;here&lt;/a&gt; to see a loda homepage.&lt;/p&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="chạy-thử-6"><a class="header" href="#chạy-thử-6"><strong>Chạy thử</strong></a></h3>
<p>Chạy ứng dụng bằng cách implement <code>@SpringBootApplication</code></p>
<pre><code>import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class App {
    public static void main(String[] args) {
        SpringApplication.run(App.class, args);
    }
}
</code></pre>
<p>Khi chạy xong, truy cập vào đường dẫn <code>http://localhost:8080/home</code> để vào trang chủ.</p>
<p>!image</p>
<p>Khi chưa đăng nhập, chúng ta truy cập vào đường dẫn <code>/hello</code>. Thì nó sẽ tự redirect sang trang <code>/login</code>.</p>
<p>!image</p>
<p>Khi đã đăng nhập thành công, chúng ta sẽ có thể vào trang <code>/hello</code> như bình thường.</p>
<p>!image</p>
<p>Khi click vào <code>Sign Out</code> thì sẽ đăng xuất.</p>
<p>!image</p>
<h3 id="kết-10"><a class="header" href="#kết-10"><strong>Kết</strong></a></h3>
<p>Trong bài này, tôi đã giới thiệu với các bạn về <strong>Spring Security</strong> đồng thời giới thiệu các khái niệm cơ bản về User và phân quyền. Ở các bài nâng cao sau, tôi sẽ giới thiệu thêm với các bạn về cách xác thực người dùng trong csdl và xác thực bằng <code>OAuth 2.0</code></p>
<p>Bài viết liên quan:</p>
<ol>
<li>[⛳SS] Hướng dẫn Spring Security + Jpa Hibernate</li>
</ol>
<p>💁 Nếu có, toàn bộ project / code mẫu được lưu trữ tại <strong>GitHub</strong></p>
<p>🌟 Đây là một bài viết trong Series <strong>Làm chủ Spring Boot – Zero to Hero</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ss-hướng-dẫn-spring-security--jpa-hibernate"><a class="header" href="#ss-hướng-dẫn-spring-security--jpa-hibernate">[SS] Hướng dẫn Spring Security + Jpa Hibernate</a></h1>
<ul>
<li>Giới thiệu</li>
<li>Cài đặt</li>
<li>Implement</li>
<li>Tạo User</li>
<li>Tham chiếu User với UserDetails</li>
<li>Cấu hình và phân quyền</li>
<li>Tạo Controller và webpage</li>
<li>Tạo thông tin User trong database</li>
<li># Chạy thử</li>
<li>Kết</li>
</ul>
<h3 id="giới-thiệu-19"><a class="header" href="#giới-thiệu-19"><strong>Giới thiệu</strong></a></h3>
<p>Trong bài trước, tôi đã hướng dẫn với các bạn về cách để sử dụng <strong>Spring Security</strong> cơ bản, cách kích hoạt, tạo user và phân quyền.</p>
<p>Trong bài này, chúng sẽ tìm hiểu cách để kiểm tra một <code>User</code> ở bên trong csdl.</p>
<p>Trong bài viết giả định bạn đã có các kiến thức sau:</p>
<ol>
<li>Hibernate</li>
<li>Lombok</li>
<li>Spring Security Cơ bản</li>
</ol>
<h3 id="cài-đặt-10"><a class="header" href="#cài-đặt-10"><strong>Cài đặt</strong></a></h3>
<p>Chúng ta sử dụng <strong>Maven</strong>, Cài đặt file <em>pom.xml</em> của bạn như sau.</p>
<p>Khác với project trước đó, lần này chúng ta sử dụng thêm database <code>com.h2database</code>. Đây là một <em>in memory database</em>. Đại khái là mọi thứ bạn lưu trên database chỉ tồn tại trong bộ nhớ, khi tắt ứng dụng, database sẽ mất sạch, thích hợp cho việc demo.</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-security-hibernate&lt;/artifactId&gt;
    &lt;version&gt;0.1.0&lt;/version&gt;

    &lt;parent&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
        &lt;version&gt;2.0.5.RELEASE&lt;/version&gt;
    &lt;/parent&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.h2database&lt;/groupId&gt;
            &lt;artifactId&gt;h2&lt;/artifactId&gt;
            &lt;scope&gt;runtime&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

    &lt;properties&gt;
        &lt;java.version&gt;1.8&lt;/java.version&gt;
    &lt;/properties&gt;

    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;

&lt;/project&gt;
</code></pre>
<p>Thư mục code gồm có:</p>
<p>!image</p>
<h3 id="implement-2"><a class="header" href="#implement-2"><strong>Implement</strong></a></h3>
<h3 id="tạo-user"><a class="header" href="#tạo-user"><strong>Tạo User</strong></a></h3>
<p>Tạo ra class <code>User</code> tham chiếu với database.</p>
<pre><code>import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;
import javax.persistence.Table;

import lombok.Data;

@Entity
@Table(name = &quot;user&quot;)
@Data // lombok
public class User {
    @Id
    @GeneratedValue
    private Long id;

    @Column(nullable = false, unique = true)
    private String username;
    private String password;
}
</code></pre>
<p>Tạo <code>UserRepository</code> kế thừa <code>JpaRepository</code> để truy xuất thông tin từ database.</p>
<pre><code>import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

@Repository
public interface UserRepository extends JpaRepository&lt;User, Long&gt; {
    User findByUsername(String username);
}
</code></pre>
<h3 id="tham-chiếu-user-với-userdetails"><a class="header" href="#tham-chiếu-user-với-userdetails"><strong>Tham chiếu User với UserDetails</strong></a></h3>
<p>Mặc định <strong>Spring Security</strong> sử dụng một đối tượng <code>UserDetails</code> để chứa toàn bộ thông tin về người dùng. Vì vậy, chúng ta cần tạo ra một class mới giúp chuyển các thông tin của <code>User</code> thành <code>UserDetails</code></p>
<p><em>CustomUserDetails.java</em></p>
<pre><code>import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;

import lombok.AllArgsConstructor;
import lombok.Data;

@Data
@AllArgsConstructor
public class CustomUserDetails implements UserDetails {
    User user;

    @Override
    public Collection&lt;? extends GrantedAuthority&gt; getAuthorities() {
        // Mặc định mình sẽ để tất cả là ROLE_USER. Để demo cho đơn giản.
        return Collections.singleton(new SimpleGrantedAuthority(&quot;ROLE_USER&quot;));
    }

    @Override
    public String getPassword() {
        return user.getPassword();
    }

    @Override
    public String getUsername() {
        return user.getUsername();
    }

    @Override
    public boolean isAccountNonExpired() {
        return true;
    }

    @Override
    public boolean isAccountNonLocked() {
        return true;
    }

    @Override
    public boolean isCredentialsNonExpired() {
        return true;
    }

    @Override
    public boolean isEnabled() {
        return true;
    }
}
</code></pre>
<p>Khi người dùng đăng nhập thì <strong>Spring Security</strong> sẽ cần lấy các thông tin <code>UserDetails</code> hiện có để kiểm tra. Vì vậy, bạn cần tạo ra một class kế thừa lớp <code>UserDetailsService</code> mà <strong>Spring Security</strong> cung cấp để làm nhiệm vụ này.</p>
<p><em>UserService.java</em></p>
<pre><code>import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;

@Service
public class UserService implements UserDetailsService {

    @Autowired
    private UserRepository userRepository;

    @Override
    public UserDetails loadUserByUsername(String username) {
        // Kiểm tra xem user có tồn tại trong database không?
        User user = userRepository.findByUsername(username);
        if (user == null) {
            throw new UsernameNotFoundException(username);
        }
        return new CustomUserDetails(user);
    }

}
</code></pre>
<h3 id="cấu-hình-và-phân-quyền"><a class="header" href="#cấu-hình-và-phân-quyền"><strong>Cấu hình và phân quyền</strong></a></h3>
<p>Giống với bài trước, chúng ta cần kích hoạt <strong>Spring Security</strong> và phân quyền người dùng.</p>
<pre><code>import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;

import me.loda.spring.springsecurityhibernate.user.UserService;

@EnableWebSecurity
public class WebSecurityConfig extends WebSecurityConfigurerAdapter {

    @Autowired
    UserService userService;

    @Bean
    public PasswordEncoder passwordEncoder() {
        // Password encoder, để Spring Security sử dụng mã hóa mật khẩu người dùng
        return new BCryptPasswordEncoder();
    }

    @Override
    protected void configure(AuthenticationManagerBuilder auth)
            throws Exception {
        auth.userDetailsService(userService) // Cung cáp userservice cho spring security
            .passwordEncoder(passwordEncoder()); // cung cấp password encoder
    }

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
                .authorizeRequests()
                .antMatchers(&quot;/&quot;, &quot;/home&quot;).permitAll() // Cho phép tất cả mọi người truy cập vào 2 địa chỉ này
                .anyRequest().authenticated() // Tất cả các request khác đều cần phải xác thực mới được truy cập
                .and()
                .formLogin() // Cho phép người dùng xác thực bằng form login
                .defaultSuccessUrl(&quot;/hello&quot;)
                .permitAll() // Tất cả đều được truy cập vào địa chỉ này
                .and()
                .logout() // Cho phép logout
                .permitAll();
    }
}
</code></pre>
<h3 id="tạo-controller-và-webpage"><a class="header" href="#tạo-controller-và-webpage"><strong>Tạo Controller và webpage</strong></a></h3>
<p>Chúng ta tạo ra trang web của mình gồm có trang <code>homepage</code> và trang <code>hello</code>.</p>
<ul>
<li>Trang <code>homepage</code> thì ai cũng truy cập được.</li>
<li>Trang <code>hello</code> thì phải xác thực mới được truy cập.</li>
</ul>
<p>Mặc định <code>/login</code> và <code>/logout</code><strong>Spring Security</strong> đã tạo cho chúng ta rồi.</p>
<pre><code>@Controller
public class WebController {

    @GetMapping(value = {&quot;/&quot;, &quot;/home&quot;})
    public String homepage() {
        return &quot;home&quot;;
    }

    @GetMapping(&quot;/hello&quot;)
    public String hello() {
        return &quot;hello&quot;;
    }

}
</code></pre>
<p><em>hello.html</em></p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;
&lt;head&gt;
  &lt;title&gt;Hello&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;Chỉ những ai đăng nhập mới truy cập được trang này!&lt;/h1&gt;

&lt;form th:action=&quot;@{/logout}&quot; method=&quot;post&quot;&gt;
  &lt;input type=&quot;submit&quot; value=&quot;Sign Out&quot;/&gt;
&lt;/form&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>Cú pháp <code>th:action=&quot;@{/logout}&quot;</code> là của thymeleaf, có tác dụng request tới địa chỉ <code>/logout</code></p>
<p><em>home.html</em></p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;
&lt;head&gt;
  &lt;title&gt;Spring Security Example&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;Welcome!&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;/login&quot;&gt;login&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Click &lt;a href=&quot;https://loda.me&quot;&gt;here&lt;/a&gt; to see a loda homepage.&lt;/p&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="tạo-thông-tin-user-trong-database"><a class="header" href="#tạo-thông-tin-user-trong-database"><strong>Tạo thông tin User trong database</strong></a></h3>
<p>Trước hết bạn cần cấu hình cho hibernate kết tới tới h2 database trong file <code>resources/appication.properties</code></p>
<pre><code>spring.datasource.url=jdbc:h2:mem:testdb
spring.datasource.driverClassName=org.h2.Driver
spring.datasource.username=sa
spring.datasource.password=

spring.jpa.database-platform=org.hibernate.dialect.H2Dialect
# Enabling H2 Console
spring.h2.console.enabled=true
</code></pre>
<p>Để phục vụ demo, mỗi khi chạy chương trình, chúng ta cần insert một <code>User</code> vào database.</p>
<p>Có thể làm việc này bằng cách sử dụng <code>CommandLineRunner</code>. Một interface của Spring cung cấp, có tác dụng thực hiện một nhiệm vụ khi Spring khởi chạy lần đầu.</p>
<pre><code>@SpringBootApplication
public class App implements CommandLineRunner {
    public static void main(String[] args) {
        SpringApplication.run(App.class, args);
    }

    @Autowired
    UserRepository userRepository;
    @Autowired
    PasswordEncoder passwordEncoder;

    @Override
    public void run(String... args) throws Exception {
        // Khi chương trình chạy
        // Insert vào csdl một user.
        User user = new User();
        user.setUsername(&quot;loda&quot;);
        user.setPassword(passwordEncoder.encode(&quot;loda&quot;));
        userRepository.save(user);
        System.out.println(user);
    }
}
</code></pre>
<h3 id="chạy-thử-7"><a class="header" href="#chạy-thử-7">**#**<strong>Chạy thử</strong></a></h3>
<p>Truy cập vào đường dẫn <code>http://localhost:8080/home</code> để vào trang chủ.</p>
<p>!image</p>
<p>Khi chưa đăng nhập, chúng ta truy cập vào đường dẫn <code>/hello</code>. Thì nó sẽ tự redirect sang trang <code>/login</code>.</p>
<p>!image</p>
<p>Khi đã đăng nhập thành công, chúng ta sẽ có thể vào trang <code>/hello</code> như bình thường.</p>
<p>!image</p>
<p>Khi click vào <code>Sign Out</code> thì sẽ đăng xuất.</p>
<p>!image</p>
<h3 id="kết-11"><a class="header" href="#kết-11"><strong>Kết</strong></a></h3>
<p>Trong bài này, chúng ta đã tìm hiểu cách sử dụng Spring Security kết hợp với Hibernate để có thể xác thực người dùng trong cơ sở dữ liệu. Chúng ta sẽ tìm hiểu các cách xác thực <code>OAuth 2.0</code> ở các bài sau.</p>
<p>💁 Nếu có, toàn bộ project / code mẫu được lưu trữ tại <strong>GitHub</strong></p>
<p>🌟 Đây là một bài viết trong Series <strong>Làm chủ Spring Boot – Zero to Hero</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ss-hướng-dẫn-spring-security--jwt-json-web-token--hibernate"><a class="header" href="#ss-hướng-dẫn-spring-security--jwt-json-web-token--hibernate">[SS] Hướng dẫn Spring Security + JWT (Json Web Token) + Hibernate</a></h1>
<ul>
<li>Giới thiệu</li>
<li>Cài đặt</li>
<li>Implement</li>
<li>Tạo User</li>
<li>Tham chiếu User với UserDetails</li>
<li>JWT</li>
<li>Cấu hình và phân quyền</li>
<li>Tạo Controller</li>
<li>Tạo thông tin User trong database</li>
<li>Chạy thử</li>
<li>Kết</li>
</ul>
<h3 id="giới-thiệu-20"><a class="header" href="#giới-thiệu-20"><strong>Giới thiệu</strong></a></h3>
<p>Xin chào các bạn, Trong hai bài trước tôi đã giới thiệu cách sử dụng <strong>Spring Security</strong> và kết nối với database để xác thực người dùng.</p>
<ol>
<li>Spring Security Cơ bản</li>
<li>Spring Security + Hibernate</li>
</ol>
<p>Trong bài hôm nay chúng ta sẽ tìm hiểu một phần cực kỳ quan trọng trong các hệ thống bảo mật ngày nay, đó là <strong>JWT</strong>.</p>
<p><strong>JWT (Json web Token)</strong> là một chuỗi mã hóa được gửi kèm trong Header của client request có tác dụng giúp phía server xác thực request người dùng có hợp lệ hay không. Được sử dụng phổ biến trong các hệ thống API ngày nay.</p>
<p>!image</p>
<h3 id="cài-đặt-11"><a class="header" href="#cài-đặt-11"><strong>Cài đặt</strong></a></h3>
<p>Chúng ta sử dụng Maven giống bài trước, tuy nhiên có update thêm thư viện <code>io.jsonwebtoken.jwtt</code> để giúp chúng ta mã hóa thông tin thành <code>jwt</code></p>
<p><em>pom.xml</em></p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-security-jwt&lt;/artifactId&gt;
    &lt;version&gt;0.1.0&lt;/version&gt;

    &lt;parent&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
        &lt;version&gt;2.0.5.RELEASE&lt;/version&gt;
    &lt;/parent&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.h2database&lt;/groupId&gt;
            &lt;artifactId&gt;h2&lt;/artifactId&gt;
            &lt;scope&gt;runtime&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;
            &lt;artifactId&gt;jjwt&lt;/artifactId&gt;
            &lt;version&gt;0.9.1&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

    &lt;properties&gt;
        &lt;java.version&gt;1.8&lt;/java.version&gt;
    &lt;/properties&gt;

    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;

&lt;/project&gt;
</code></pre>
<p>Cấu trúc thư mục code bao gồm:</p>
<p>!image</p>
<h3 id="implement-3"><a class="header" href="#implement-3"><strong>Implement</strong></a></h3>
<p>Ban đầu, chúng ta sẽ tạo ra class <code>User</code> và <code>UserDetails</code> để giao tiếp với <strong>Spring Security</strong>. Phần này giống hệt với bài viết Spring Security + Hibernate</p>
<p>Trong bài viết có sử dụng Lombok</p>
<h3 id="tạo-user-1"><a class="header" href="#tạo-user-1"><strong>Tạo User</strong></a></h3>
<p>Tạo ra class <code>User</code> tham chiếu với database.</p>
<pre><code>import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;
import javax.persistence.Table;

import lombok.Data;

@Entity
@Table(name = &quot;user&quot;)
@Data // lombok
public class User {
    @Id
    @GeneratedValue
    private Long id;

    @Column(nullable = false, unique = true)
    private String username;
    private String password;
}
</code></pre>
<p>Tạo <code>UserRepository</code> kế thừa <code>JpaRepository</code> để truy xuất thông tin từ database.</p>
<pre><code>import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

@Repository
public interface UserRepository extends JpaRepository&lt;User, Long&gt; {
    User findByUsername(String username);
}
</code></pre>
<h3 id="tham-chiếu-user-với-userdetails-1"><a class="header" href="#tham-chiếu-user-với-userdetails-1"><strong>Tham chiếu User với UserDetails</strong></a></h3>
<p>Mặc định <strong>Spring Security</strong> sử dụng một đối tượng <code>UserDetails</code> để chứa toàn bộ thông tin về người dùng. Vì vậy, chúng ta cần tạo ra một class mới giúp chuyển các thông tin của <code>User</code> thành <code>UserDetails</code></p>
<p><em>CustomUserDetails.java</em></p>
<pre><code>import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;

import lombok.AllArgsConstructor;
import lombok.Data;

@Data
@AllArgsConstructor
public class CustomUserDetails implements UserDetails {
    User user;

    @Override
    public Collection&lt;? extends GrantedAuthority&gt; getAuthorities() {
        // Mặc định mình sẽ để tất cả là ROLE_USER. Để demo cho đơn giản.
        return Collections.singleton(new SimpleGrantedAuthority(&quot;ROLE_USER&quot;));
    }

    @Override
    public String getPassword() {
        return user.getPassword();
    }

    @Override
    public String getUsername() {
        return user.getUsername();
    }

    @Override
    public boolean isAccountNonExpired() {
        return true;
    }

    @Override
    public boolean isAccountNonLocked() {
        return true;
    }

    @Override
    public boolean isCredentialsNonExpired() {
        return true;
    }

    @Override
    public boolean isEnabled() {
        return true;
    }
}
</code></pre>
<p>Khi người dùng đăng nhập thì <strong>Spring Security</strong> sẽ cần lấy các thông tin <code>UserDetails</code> hiện có để kiểm tra. Vì vậy, bạn cần tạo ra một class kế thừa lớp <code>UserDetailsService</code> mà <strong>Spring Security</strong> cung cấp để làm nhiệm vụ này.</p>
<p><em>UserService.java</em></p>
<pre><code>import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;

@Service
public class UserService implements UserDetailsService {

    @Autowired
    private UserRepository userRepository;

    @Override
    public UserDetails loadUserByUsername(String username) {
        // Kiểm tra xem user có tồn tại trong database không?
        User user = userRepository.findByUsername(username);
        if (user == null) {
            throw new UsernameNotFoundException(username);
        }
        return new CustomUserDetails(user);
    }

}
</code></pre>
<h3 id="jwt"><a class="header" href="#jwt"><strong>JWT</strong></a></h3>
<p>Sau khi có các thông tin về người dùng, chúng ta cần mã hóa thông tin người dùng thành chuỗi <code>JWT</code>. Tôi sẽ tạo ra một class <code>JwtTokenProvider</code> để làm nhiệm vụ này.</p>
<pre><code>import org.springframework.stereotype.Component;
import io.jsonwebtoken.*;
import lombok.extern.slf4j.Slf4j;
import me.loda.springsecurityhibernatejwt.user.CustomUserDetails;

@Component
@Slf4j
public class JwtTokenProvider {
    // Đoạn JWT_SECRET này là bí mật, chỉ có phía server biết
    private final String JWT_SECRET = &quot;lodaaaaaa&quot;;

    //Thời gian có hiệu lực của chuỗi jwt
    private final long JWT_EXPIRATION = 604800000L;

    // Tạo ra jwt từ thông tin user
    public String generateToken(CustomUserDetails userDetails) {
        Date now = new Date();
        Date expiryDate = new Date(now.getTime() + JWT_EXPIRATION);
        // Tạo chuỗi json web token từ id của user.
        return Jwts.builder()
                   .setSubject(Long.toString(userDetails.getUser().getId()))
                   .setIssuedAt(now)
                   .setExpiration(expiryDate)
                   .signWith(SignatureAlgorithm.HS512, JWT_SECRET)
                   .compact();
    }

    // Lấy thông tin user từ jwt
    public Long getUserIdFromJWT(String token) {
        Claims claims = Jwts.parser()
                            .setSigningKey(JWT_SECRET)
                            .parseClaimsJws(token)
                            .getBody();

        return Long.parseLong(claims.getSubject());
    }

    public boolean validateToken(String authToken) {
        try {
            Jwts.parser().setSigningKey(JWT_SECRET).parseClaimsJws(authToken);
            return true;
        } catch (MalformedJwtException ex) {
            log.error(&quot;Invalid JWT token&quot;);
        } catch (ExpiredJwtException ex) {
            log.error(&quot;Expired JWT token&quot;);
        } catch (UnsupportedJwtException ex) {
            log.error(&quot;Unsupported JWT token&quot;);
        } catch (IllegalArgumentException ex) {
            log.error(&quot;JWT claims string is empty.&quot;);
        }
        return false;
    }
}
</code></pre>
<h3 id="cấu-hình-và-phân-quyền-1"><a class="header" href="#cấu-hình-và-phân-quyền-1"><strong>Cấu hình và phân quyền</strong></a></h3>
<p>Bây giờ, chúng ta bắt đầu cấu hình <strong>Spring Security</strong> bao gồm việc kích hoạt bằng <code>@EnableWebSecurity</code>.</p>
<p>Bước này giống với bài viết Spring + Hibernate nên tôi sẽ không nói những phần lặp lại.</p>
<pre><code>import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.config.BeanIds;
import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
import me.loda.springsecurityhibernatejwt.jwt.JwtAuthenticationFilter;
import me.loda.springsecurityhibernatejwt.user.UserService;

@EnableWebSecurity
public class WebSecurityConfig extends WebSecurityConfigurerAdapter {

    @Autowired
    UserService userService;

    @Bean
    public JwtAuthenticationFilter jwtAuthenticationFilter() {
        return new JwtAuthenticationFilter();
    }

    @Bean(BeanIds.AUTHENTICATION_MANAGER)
    @Override
    public AuthenticationManager authenticationManagerBean() throws Exception {
        // Get AuthenticationManager bean
        return super.authenticationManagerBean();
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        // Password encoder, để Spring Security sử dụng mã hóa mật khẩu người dùng
        return new BCryptPasswordEncoder();
    }

    @Override
    protected void configure(AuthenticationManagerBuilder auth)
            throws Exception {
        auth.userDetailsService(userService) // Cung cáp userservice cho spring security
            .passwordEncoder(passwordEncoder()); // cung cấp password encoder
    }

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
                .cors() // Ngăn chặn request từ một domain khác
                    .and()
                .authorizeRequests()
                    .antMatchers(&quot;/api/login&quot;).permitAll() // Cho phép tất cả mọi người truy cập vào địa chỉ này
                    .anyRequest().authenticated(); // Tất cả các request khác đều cần phải xác thực mới được truy cập

        // Thêm một lớp Filter kiểm tra jwt
        http.addFilterBefore(jwtAuthenticationFilter(), UsernamePasswordAuthenticationFilter.class);
    }
}
</code></pre>
<p>Điểm khác biệt ở đây là sự xuất hiện của <code>JwtAuthenticationFilter</code>. Đây là một lớp <code>Filter</code> do tôi tự tạo ra.</p>
<p><code>JwtAuthenticationFilter</code> Có nhiệm vụ kiểm tra request của người dùng trước khi nó tới đích. Nó sẽ lấy <code>Header Authorization</code> ra và kiểm tra xem chuỗi JWT người dùng gửi lên có hợp lệ không.</p>
<pre><code>@Slf4j
public class JwtAuthenticationFilter extends OncePerRequestFilter {
    @Autowired
    private JwtTokenProvider tokenProvider;

    @Autowired
    private UserService customUserDetailsService;
    @Override
    protected void doFilterInternal(HttpServletRequest request,
                                    HttpServletResponse response, FilterChain filterChain)
            throws ServletException, IOException {
        try {
            // Lấy jwt từ request
            String jwt = getJwtFromRequest(request);

            if (StringUtils.hasText(jwt) &amp;&amp; tokenProvider.validateToken(jwt)) {
                // Lấy id user từ chuỗi jwt
                Long userId = tokenProvider.getUserIdFromJWT(jwt);
                // Lấy thông tin người dùng từ id
                UserDetails userDetails = customUserDetailsService.loadUserById(userId);
                if(userDetails != null) {
                    // Nếu người dùng hợp lệ, set thông tin cho Seturity Context
                    UsernamePasswordAuthenticationToken
                            authentication = new UsernamePasswordAuthenticationToken(userDetails, null, userDetails.getAuthorities());
                    authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));

                    SecurityContextHolder.getContext().setAuthentication(authentication);
                }
            }
        } catch (Exception ex) {
            log.error(&quot;failed on set user authentication&quot;, ex);
        }

        filterChain.doFilter(request, response);
    }

    private String getJwtFromRequest(HttpServletRequest request) {
        String bearerToken = request.getHeader(&quot;Authorization&quot;);
        // Kiểm tra xem header Authorization có chứa thông tin jwt không
        if (StringUtils.hasText(bearerToken) &amp;&amp; bearerToken.startsWith(&quot;Bearer &quot;)) {
            return bearerToken.substring(7);
        }
        return null;
    }
}
</code></pre>
<h3 id="tạo-controller-1"><a class="header" href="#tạo-controller-1"><strong>Tạo Controller</strong></a></h3>
<p>Vì phần này chúng ta làm việc với <code>JWT</code>, nên các request sẽ dưới dạng Rest API.</p>
<p>Tôi tạo ra 2 api:</p>
<ol>
<li><code>/api/login</code>: Cho phép request mà không cần xác thực.</li>
<li><code>/api/random</code>: Là một api bất kỳ nào đó, phải xác thực mới lấy được thông tin.</li>
</ol>
<pre><code>@RestController
@RequestMapping(&quot;/api&quot;)
public class LodaRestController {

    @Autowired
    AuthenticationManager authenticationManager;

    @Autowired
    private JwtTokenProvider tokenProvider;

    @PostMapping(&quot;/login&quot;)
    public LoginResponse authenticateUser(@Valid @RequestBody LoginRequest loginRequest) {

        // Xác thực từ username và password.
        Authentication authentication = authenticationManager.authenticate(
                new UsernamePasswordAuthenticationToken(
                        loginRequest.getUsername(),
                        loginRequest.getPassword()
                )
        );

        // Nếu không xảy ra exception tức là thông tin hợp lệ
        // Set thông tin authentication vào Security Context
        SecurityContextHolder.getContext().setAuthentication(authentication);

        // Trả về jwt cho người dùng.
        String jwt = tokenProvider.generateToken((CustomUserDetails) authentication.getPrincipal());
        return new LoginResponse(jwt);
    }

    // Api /api/random yêu cầu phải xác thực mới có thể request
    @GetMapping(&quot;/random&quot;)
    public RandomStuff randomStuff(){
        return new RandomStuff(&quot;JWT Hợp lệ mới có thể thấy được message này&quot;);
    }

}
</code></pre>
<h3 id="tạo-thông-tin-user-trong-database-1"><a class="header" href="#tạo-thông-tin-user-trong-database-1"><strong>Tạo thông tin User trong database</strong></a></h3>
<p>Trước hết bạn cần cấu hình cho hibernate kết tới tới h2 database trong file <code>resources/appication.properties</code></p>
<pre><code>spring.datasource.url=jdbc:h2:mem:testdb
spring.datasource.driverClassName=org.h2.Driver
spring.datasource.username=sa
spring.datasource.password=

spring.jpa.database-platform=org.hibernate.dialect.H2Dialect
# Enabling H2 Console
spring.h2.console.enabled=true
</code></pre>
<p>Để phục vụ demo, mỗi khi chạy chương trình, chúng ta cần insert một <code>User</code> vào database.</p>
<p>Có thể làm việc này bằng cách sử dụng <code>CommandLineRunner</code>. Một interface của Spring cung cấp, có tác dụng thực hiện một nhiệm vụ khi Spring khởi chạy lần đầu.</p>
<pre><code>@SpringBootApplication
public class App implements CommandLineRunner {
    public static void main(String[] args) {
        SpringApplication.run(App.class, args);
    }

    @Autowired
    UserRepository userRepository;
    @Autowired
    PasswordEncoder passwordEncoder;

    @Override
    public void run(String... args) throws Exception {
        // Khi chương trình chạy
        // Insert vào csdl một user.
        User user = new User();
        user.setUsername(&quot;loda&quot;);
        user.setPassword(passwordEncoder.encode(&quot;loda&quot;));
        userRepository.save(user);
        System.out.println(user);
    }
}
</code></pre>
<h3 id="chạy-thử-8"><a class="header" href="#chạy-thử-8"><strong>Chạy thử</strong></a></h3>
<p>Khi server on, chúng ta request thử tới địa chỉ <code>http://localhost:8080/api/random</code> mà không xác thực.</p>
<p>!image</p>
<p>Kết quả trả về mã lỗi <code>403</code> kèm theo message <code>Access Denied</code>.</p>
<p>Để có thể request được, chúng ta đăng nhập vào hệ thống bằng <code>api/login</code> để lấy <code>jwt</code>.</p>
<p>!image</p>
<p>Sau đó sử dụng thông tin <code>jwt</code> server trả về để thực hiện các request khác.</p>
<p>!image</p>
<h3 id="kết-12"><a class="header" href="#kết-12"><strong>Kết</strong></a></h3>
<p>Trong bài này, chúng ta đã tìm hiểu cách sử dụng <strong>Spring Security</strong> và <strong>JWT</strong> để có thể xác thực người dùng trong các hệ thống Restful API. Chúng ta sẽ tìm hiểu các cách xác thực <code>OAuth 2.0</code> ở các bài sau.</p>
<p>💁 Nếu có, toàn bộ project / code mẫu được lưu trữ tại <strong>GitHub</strong></p>
<p>🌟 Đây là một bài viết trong Series <strong>Làm chủ Spring Boot – Zero to Hero</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hướng-dẫn-spring-boot--redis"><a class="header" href="#hướng-dẫn-spring-boot--redis">Hướng dẫn Spring Boot + Redis</a></h1>
<ul>
<li>Giới thiệu</li>
<li>Cài đặt</li>
<li>Implement</li>
<li>Cấu hình Redis</li>
<li>Chạy thử</li>
<li>Redis operations</li>
<li>Kết</li>
</ul>
<h3 id="giới-thiệu-21"><a class="header" href="#giới-thiệu-21"><strong>Giới thiệu</strong></a></h3>
<p><strong>Redis</strong> là 1 hệ thống lưu trữ key-value in-memory rất mạnh mẽ và phổ biến hiện nay.</p>
<p><strong>Redis</strong> nổi bật bởi việc hỗ trợ nhiều cấu trúc dữ liệu khác nhau (hash, list, set, sorted set, string), giúp việc thao tác với dữ liệu cực kì nhanh và thuận tiện.</p>
<p>Các hệ thống ngày nay luôn tìm cách tối ưu performance và <strong>Redis</strong> gần như là một mảnh ghép không thể thiếu trong đó. Hôm nay chúng ta sẽ cùng tìm hiểu cách kết nối ứng dụng <strong>Spring Boot</strong> với <strong>Redis</strong>.</p>
<h3 id="cài-đặt-12"><a class="header" href="#cài-đặt-12"><strong>Cài đặt</strong></a></h3>
<p>Chúng ta sử dụng Maven, và yêu cầu các dependencies sau:</p>
<p><em>pom.xml</em></p>
<pre><code>&lt;dependencies&gt;

    &lt;!--spring mvc, rest--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
    &lt;/dependency&gt;

    &lt;dependency&gt;
      &lt;groupId&gt;org.springframework.data&lt;/groupId&gt;
      &lt;artifactId&gt;spring-data-redis&lt;/artifactId&gt;
    &lt;/dependency&gt;

    &lt;dependency&gt;
      &lt;groupId&gt;io.lettuce&lt;/groupId&gt;
      &lt;artifactId&gt;lettuce-core&lt;/artifactId&gt;
      &lt;version&gt;5.1.3.RELEASE&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<p>Trong đó, <code>spring-data-redis</code> là thư viện của Spring giúp chúng ta thao tác với <strong>Redis</strong> dễ dàng hơn.</p>
<p>Còn <code>lettuce-core</code> là một thư viện mã nguồn mở, giúp kết nối tới Redis một cách thread-safe bằng nhiều hình thức như synchronous, asynchronous and reactive usage.</p>
<p>Trong bài này chúng ta sẽ cấu hình cho <code>spring-data-redis</code> sử dụng <code>lettuce</code> kết nối tới <strong>Redis</strong>. Còn chi tiết về <code>letture</code> sẽ được đề cập ở một bài viết khác.</p>
<p>Cấu trúc thư mục bao gồm:</p>
<p>!image</p>
<h3 id="implement-4"><a class="header" href="#implement-4"><strong>Implement</strong></a></h3>
<h3 id="cấu-hình-redis"><a class="header" href="#cấu-hình-redis"><strong>Cấu hình Redis</strong></a></h3>
<p>Bài viết giả định bạn đã cài đặt Redis, để kết nối tới <strong>Redis</strong>, bạn cần cung cấp địa chỉ <code>host</code> và <code>port</code> cho <em>lettuce</em>.</p>
<p>Cách dễ nhất là ghi nó ở file <em>application.properties</em> trong thư mục resources:</p>
<p><em>application.properties</em></p>
<pre><code>redis.host=localhost
redis.port=6379
</code></pre>
<p>Sau đó, Tạo file <code>RedisConfig.java</code> để cấu hình mọi thứ liên quan tới Redis.</p>
<pre><code>import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.context.properties.EnableConfigurationProperties;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Primary;
import org.springframework.data.redis.connection.RedisConnectionFactory;
import org.springframework.data.redis.connection.RedisStandaloneConfiguration;
import org.springframework.data.redis.connection.lettuce.LettuceConnectionFactory;
import org.springframework.data.redis.core.RedisTemplate;

@Configuration
public class RedisConfig {
    @Value(&quot;${redis.host}&quot;)
    private String redisHost;

    @Value(&quot;${redis.port}&quot;)
    private int redisPort;

    @Bean
    public LettuceConnectionFactory redisConnectionFactory() {
        // Tạo Standalone Connection tới Redis
        return new LettuceConnectionFactory(new RedisStandaloneConfiguration(redisHost, redisPort));
    }

    @Bean
    @Primary
    public RedisTemplate&lt;Object, Object&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory) {
        // tạo ra một RedisTemplate
        // Với Key là Object
        // Value là Object
        // RedisTemplate giúp chúng ta thao tác với Redis
        RedisTemplate&lt;Object, Object&gt; template = new RedisTemplate&lt;&gt;();
        template.setConnectionFactory(redisConnectionFactory);
        return template;
    }
}
</code></pre>
<p>Chúng ta cần sử dụng <code>lettuce</code> để kết nối tới Redis, nên tôi tạo ra bean <code>LettuceConnectionFactory</code> và Spring Data sẽ tự động nhận vào cấu hình của mình.</p>
<p>Trong ví dụ này, chúng ta làm việc với Redis Standalone <code>RedisStandaloneConfiguration</code>. Còn nếu bạn muốn cấu hình với Redis Cluster thì cũng tương tự bằng class <code>RedisClusterConfiguration</code>.</p>
<blockquote>
<p>Đối tượng để thao tác với Redis chính là RedisTemplate.</p>
</blockquote>
<p>Ở đây tôi cấu hình cho <code>RedisTemplate</code> nhận key là <code>Object</code> và value cũng là <code>Object</code> luôn. Để chúng ta có thể lưu bất kỳ key-value nào xuống Redis.</p>
<h3 id="chạy-thử-9"><a class="header" href="#chạy-thử-9"><strong>Chạy thử</strong></a></h3>
<p>Chúng ta tạo ra một class <code>RedisExample</code> implements <code>CommandLineRunner</code> để chạy một ví dụ:</p>
<pre><code>import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.CommandLineRunner;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.stereotype.Component;

@Component
public class RedisExample implements CommandLineRunner {
    @Autowired
    private RedisTemplate template;

    @Override
    public void run(String... args) throws Exception {
        // Set giá trị của key &quot;loda&quot; là &quot;hello redis&quot;
        template.opsForValue().set(&quot;loda&quot;,&quot;hello world&quot;);

        // In ra màn hình Giá trị của key &quot;loda&quot; trong Redis
        System.out.println(&quot;Value of key loda: &quot;+template.opsForValue().get(&quot;loda&quot;));
    }
}
</code></pre>
<p>Chạy Spring App:</p>
<pre><code>import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class App {
    public static void main(String[] args) {
        SpringApplication.run(App.class, args);
    }
}
</code></pre>
<p>Khi chạy thử, màn hình sẽ in ra kết quả.</p>
<pre><code>Value of key loda: hello world
</code></pre>
<p>Vậy là chúng ta đã kết nối thành công tới Redis và lưu một cặp key-value vào trong đó.</p>
<h3 id="redis-operations"><a class="header" href="#redis-operations"><strong>Redis operations</strong></a></h3>
<p>Quay trở lại ví dụ ở trên:</p>
<pre><code>template.opsForValue().set(&quot;loda&quot;,&quot;hello world&quot;);
</code></pre>
<p><code>.opsForValue()</code> được gọi là <strong>Redis Operations</strong>.</p>
<p><strong>Spring Data</strong> hỗ trợ chúng ta thao tác với Redis thông qua các Operations như sau:</p>
<ol>
<li><code>opsForValue()</code>: Kiểu Key-Value thông thường. Với Value là 1 giá trị String tùy ý.</li>
<li><code>opsForHash()</code>: Tương ứng với cấu trúc Hash trong Redis. Value là một Object có cấu trúc</li>
<li><code>opsForList()</code>: Tương ứng với cấu trúc List trong Redis. Value là một list.</li>
<li><code>opsForSet()</code>: Tương ứng với cấu trúc Set trong Redis.</li>
<li><code>opsForZSet()</code>: Tương ứng với cấu trúc ZSet trong Redis.</li>
</ol>
<p>Ví dụ với <code>List</code>:</p>
<pre><code>@Component
public class RedisExample implements CommandLineRunner {
    @Autowired
    private RedisTemplate template;

    @Override
    public void run(String... args) throws Exception {
        listExample();
    }

    public void valueExample(){
        // Set giá trị của key &quot;loda&quot; là &quot;hello redis&quot;
        template.opsForValue().set(&quot;loda&quot;,&quot;hello world&quot;);

        // In ra màn hình Giá trị của key &quot;loda&quot; trong Redis
        System.out.println(&quot;Value of key loda: &quot;+template.opsForValue().get(&quot;loda&quot;));
    }

    public void listExample(){
        // Tạo ra một list gồm 2 phần tử
        List&lt;String&gt; list = new ArrayList&lt;&gt;();
        list.add(&quot;Hello&quot;);
        list.add(&quot;redis&quot;);

        // Set gia trị có key loda_list
        template.opsForList().rightPushAll(&quot;loda_list&quot;, list);
//        template.opsForList().rightPushAll(&quot;loda_list&quot;, &quot;hello&quot;, &quot;world&quot;);

        System.out.println(&quot;Size of key loda: &quot;+template.opsForList().size(&quot;loda_list&quot;));
    }
}
</code></pre>
<p>Kết quả in ra màn hình khi chạy:</p>
<h3 id="kết-13"><a class="header" href="#kết-13"><strong>Kết</strong></a></h3>
<p>Tới đây các bạn có thể dễ dàng thao tác với các kiểu cấu trúc trong Redis thông qua <code>RedisTemplate</code>.</p>
<p>💁 Nếu có, toàn bộ project / code mẫu được lưu trữ tại <strong>GitHub</strong></p>
<p>🌟 Đây là một bài viết trong Series <strong>Làm chủ Spring Boot – Zero to Hero</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="thuật-toán"><a class="header" href="#thuật-toán">Thuật toán</a></h1>
<p>Chưa có, nhưng sẽ tổng hợp thuật toán sau</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="command-line"><a class="header" href="#command-line">Command line</a></h1>
<h3 id="không-sử-dụng-crate-ngoài"><a class="header" href="#không-sử-dụng-crate-ngoài">Không sử dụng crate ngoài</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span><span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Config {
    pub query: String,
    pub filename: String,
    pub case_sensitive: bool,
}

impl Config {
    pub fn new(mut args: env::Args) -&gt; Result&lt;Config, &amp;'static str&gt; {
        args.next();

        let query = match args.next() {
            Some(arg) =&gt; arg,
            None =&gt; return Err(&quot;Didn't get a query string&quot;),
        };

        let filename = match args.next() {
            Some(arg) =&gt; arg,
            None =&gt; return Err(&quot;Didn't get a file name&quot;),
        };

        let case_sensitive = env::var(&quot;CASE_INSENSITIVE&quot;).is_err();

        Ok(Config { query, filename, case_sensitive })
    }
}

pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let contents = fs::read_to_string(config.filename)?;

    let results = if config.case_sensitive {
        search(&amp;config.query, &amp;contents)
    } else {
        search_case_insensitive(&amp;config.query, &amp;contents)
    };

    for line in results {
        println!(&quot;{}&quot;, line);
    }

    Ok(())
}

<span class="boring">}
</span></code></pre></pre>
<h2 id="parsing-arguments-sử-dụng-clap"><a class="header" href="#parsing-arguments-sử-dụng-clap">Parsing arguments sử dụng clap</a></h2>
<h3 id="sử-dụng-cơ-bản"><a class="header" href="#sử-dụng-cơ-bản">Sử dụng cơ bản</a></h3>
<p>This application describes the structure of its command-line interface using <code>clap</code>'s builder style. The <a href="https://docs.rs/clap/">documentation</a> gives two other possible ways to instantiate an application.</p>
<p>In the builder style, <code>with_name</code> is the unique identifier that <code>value_of</code> will use to retrieve the value passed. The <code>short</code> and <code>long</code> options control the flag the user will be expected to type; short flags look like <code>-f</code> and long flags look like <code>--file</code>.</p>
<pre><pre class="playground"><code class="language-rust">use clap::{Arg, App};

fn main() {
    let matches = App::new(&quot;My Test Program&quot;)
        .version(&quot;0.1.0&quot;)
        .author(&quot;Hackerman Jones &lt;hckrmnjones@hack.gov&gt;&quot;)
        .about(&quot;Teaches argument parsing&quot;)
        .arg(Arg::with_name(&quot;file&quot;)
                 .short(&quot;f&quot;)
                 .long(&quot;file&quot;)
                 .takes_value(true)
                 .help(&quot;A cool file&quot;))
        .arg(Arg::with_name(&quot;num&quot;)
                 .short(&quot;n&quot;)
                 .long(&quot;number&quot;)
                 .takes_value(true)
                 .help(&quot;Five less than your favorite number&quot;))
        .get_matches();

    let myfile = matches.value_of(&quot;file&quot;).unwrap_or(&quot;input.txt&quot;);
    println!(&quot;The file passed is: {}&quot;, myfile);

    let num_str = matches.value_of(&quot;num&quot;);
    match num_str {
        None =&gt; println!(&quot;No idea what your favorite number is.&quot;),
        Some(s) =&gt; {
            match s.parse::&lt;i32&gt;() {
                Ok(n) =&gt; println!(&quot;Your favorite number must be {}.&quot;, n + 5),
                Err(_) =&gt; println!(&quot;That's not a number! {}&quot;, s),
            }
        }
    }
}
</code></pre></pre>
<p>Usage information is generated by <code>clap</code>. The usage for the example application looks like this.</p>
<pre><code>My Test Program 0.1.0
Hackerman Jones &lt;hckrmnjones@hack.gov&gt;
Teaches argument parsing

USAGE:
    testing [OPTIONS]

FLAGS:
    -h, --help       Prints help information
    -V, --version    Prints version information

OPTIONS:
    -f, --file &lt;file&gt;     A cool file
    -n, --number &lt;num&gt;    Five less than your favorite number
</code></pre>
<p>We can test the application by running a command like the following.</p>
<p><code>$ cargo run -- -f myfile.txt -n 251</code></p>
<p>The output is:</p>
<pre><code>The file passed is: myfile.txt
Your favorite number must be 256.
</code></pre>
<h3 id="nâng-cao"><a class="header" href="#nâng-cao">Nâng cao</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use clap::Parser;
use std::path::PathBuf;

#[derive(Parser, Debug, Clone)]
#[clap(
    author,
    version,
    about,
    long_about = &quot;Note: When playing, all the keybindings of mpv can be used, and `q` is reserved for exiting the program&quot;
)]
pub struct Cli {
    /// Option: -u --url &lt;URL&gt;: Specifies an url to be played.
    #[clap(short, long, help = &quot;Specifies an url to be played.&quot;)]
    pub url: Option&lt;String&gt;,

    /// Option: -s --station &lt;station name&gt;: Specifies the name of the station to be played
    #[clap(
        short,
        long,
        conflicts_with = &quot;url&quot;,
        help = &quot;Specifies the name of the station to be played.&quot;
    )]
    pub station: Option&lt;String&gt;,

    /// Flag: --show-video: If *not* present, a flag is passed down to mpv to not show the video and just play the audio.
    #[clap(
        long = &quot;show-video&quot;,
        help = &quot;If *not* present, a flag is passed down to mpv to not show the video and just play the audio.&quot;
    )]
    pub show_video: bool,

    /// Option: -c --config: Specify a config file other than the default.
    #[clap(
        long,
        short,
        help = &quot;Specify a different config file from the default one.&quot;
    )]
    pub config: Option&lt;PathBuf&gt;,

    /// Option: --country-code &lt;CODE&gt;: Specify a country code to filter the search results
    #[clap(
        long = &quot;country-code&quot;,
        help = &quot;Specify a country code to filter the search.&quot;
    )]
    pub country_code: Option&lt;String&gt;,

    /// Flag: --list-countries: List all the available countries and country codes to put in the config.
    #[clap(
        long = &quot;list-countries&quot;,
        help = &quot;List all the available countries and country codes to put in the config.&quot;
    )]
    pub list_countries: bool,

    /// Flag: --no-station-cache: Don't cache the station list loaded from the internet.
    #[clap(
        long = &quot;no-station-cache&quot;,
        help = &quot;Don't cache the station list loaded from the internet.&quot;
    )]
    pub no_station_cache: bool,

    /// Show extra info
    #[clap(flatten)]
    pub verbose: clap_verbosity_flag::Verbosity,

    /// Show debug info
    #[structopt(short, long)]
    pub debug: bool,
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="một-só-cái-khác-chưa-sắp-xếp"><a class="header" href="#một-só-cái-khác-chưa-sắp-xếp">Một só cái khác chưa sắp xếp</a></h2>
<h3 id="Đọc-input-từ-người-dùng"><a class="header" href="#Đọc-input-từ-người-dùng">Đọc input từ người dùng</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs::File;
use std::io::{self, Read};

pub fn read_from_stdin() -&gt; String {
    let mut input = String::new();
    loop {
        match io::stdin().read_line(&amp;mut input) {
            Ok(len) =&gt; if len == 0 {
                break;
            }
            Err(error) =&gt; {
                eprintln!(&quot;error: {}&quot;, error);
                break;
            }
        }
    }
    input
}
<span class="boring">}
</span></code></pre></pre>
<p>Đây mới là cái Reader</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::io;

pub trait ReadInput {
    fn read_input(&amp;mut self) -&gt; io::Result&lt;String&gt;;
}

pub struct Reader&lt;R&gt; {
    reader: R,
}

impl&lt;R&gt; Reader&lt;R&gt; {
    pub fn new(reader: R) -&gt; Self {
        Self { reader }
    }
}

impl&lt;R: io::BufRead&gt; ReadInput for Reader&lt;R&gt; {
    fn read_input(&amp;mut self) -&gt; io::Result&lt;String&gt; {
        let mut input = String::new();
        self.reader.read_line(&amp;mut input)?;
        Ok(input.trim().to_string())
    }
}

#[allow(non_snake_case)]
#[cfg(test)]
mod tests {
    use crate::reader::{ReadInput, Reader};

    #[test]
    fn test_reader__read_input__success() {
        let input = b&quot;  my input with whitespace chars  &quot;;
        let mut reader = Reader::new(&amp;input[..]);

        let actual = reader.read_input().unwrap();
        let expected = &quot;my input with whitespace chars&quot;.to_string();

        assert_eq!(actual, expected);
    }
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="tất-tần-tật-về-print-trong-giao-diện-dòng-lệnh"><a class="header" href="#tất-tần-tật-về-print-trong-giao-diện-dòng-lệnh">Tất tần tật về Print trong giao diện dòng lệnh</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::io;
use std::io::Write;

pub trait Print {
    fn print(&amp;mut self, value: &amp;str) -&gt; io::Result&lt;()&gt;;
    fn println(&amp;mut self, value: &amp;str) -&gt; io::Result&lt;()&gt;;
}

pub trait PrintColor {
    fn fts_banner(&amp;mut self) -&gt; io::Result&lt;()&gt;;
    fn input_header(&amp;mut self, value: &amp;str) -&gt; io::Result&lt;()&gt;;
    fn error(&amp;mut self, value: &amp;str) -&gt; io::Result&lt;()&gt;;
}

pub struct Printer&lt;W&gt; {
    writer: W,
}

#[derive(Clone, Copy)]
pub struct PrintOptions {
    color: termcolor::Color,
    is_bold: bool,
}

impl&lt;W: Write + termcolor::WriteColor&gt; Printer&lt;W&gt; {
    pub fn new(writer: W) -&gt; Self {
        Self { writer }
    }
}

impl&lt;W: Write&gt; Print for Printer&lt;W&gt; {
    fn print(&amp;mut self, value: &amp;str) -&gt; io::Result&lt;()&gt; {
        write!(self.writer, &quot;{}&quot;, value)
    }

    fn println(&amp;mut self, value: &amp;str) -&gt; io::Result&lt;()&gt; {
        writeln!(self.writer, &quot;{}&quot;, value)
    }
}

impl&lt;W: Write + termcolor::WriteColor&gt; PrintColor for Printer&lt;W&gt; {
    fn fts_banner(&amp;mut self) -&gt; io::Result&lt;()&gt; {
        let opts = PrintOptions {
            color: termcolor::Color::Yellow,
            is_bold: false,
        };
        let banner = format!(
            &quot;{}\n{}{}{}{}{}\n{}&quot;,
            &quot;#&quot;.repeat(60),
            &quot;#&quot;.repeat(4),
            &quot; &quot;.repeat(18),
            &quot;First Time Setup&quot;,
            &quot; &quot;.repeat(18),
            &quot;#&quot;.repeat(4),
            &quot;#&quot;.repeat(60)
        );
        let description = r#&quot;
This tool requires you to have a repository with a README.md
in the root folder. The markdown file is where your ideas
will be stored.

Once first time setup has completed, simply run Eureka again
to begin writing down ideas.
        &quot;#;
        self.println_styled(&amp;format!(&quot;{}\n{}&quot;, banner.as_str(), description), opts)
    }

    fn input_header(&amp;mut self, value: &amp;str) -&gt; io::Result&lt;()&gt; {
        let opts = PrintOptions {
            color: termcolor::Color::Green,
            is_bold: true,
        };
        self.println_styled(value, opts)?;
        self.print(&quot;&gt; &quot;)?;
        self.writer.flush()
    }

    fn error(&amp;mut self, value: &amp;str) -&gt; io::Result&lt;()&gt; {
        let opts = PrintOptions {
            color: termcolor::Color::Red,
            is_bold: false,
        };
        self.println_styled(value, opts)?;
        self.writer.flush()
    }
}

impl&lt;W: Write + termcolor::WriteColor&gt; Printer&lt;W&gt; {
    fn println_styled(&amp;mut self, value: &amp;str, opts: PrintOptions) -&gt; io::Result&lt;()&gt; {
        let mut color_spec = termcolor::ColorSpec::new();
        color_spec.set_fg(Some(opts.color)).set_bold(opts.is_bold);
        self.writer.set_color(&amp;color_spec)?;
        writeln!(self.writer, &quot;{}&quot;, value)?;
        self.writer.reset()
    }
}

#[allow(non_snake_case)]
#[cfg(test)]
mod tests {
    use crate::printer::{Print, PrintColor, PrintOptions, Printer};

    #[test]
    fn test_printer__print__success() {
        let mut output = Vec::new();
        let mut printer = Printer {
            writer: &amp;mut output,
        };

        let print_result = printer.print(&quot;this value&quot;);
        assert!(print_result.is_ok());

        let actual = String::from_utf8(output).expect(&quot;Not UTF-8&quot;);
        let expected = &quot;this value&quot;;

        assert_eq!(actual, expected);
    }

    #[test]
    fn test_printer__println__success() {
        let mut output = Vec::new();
        let mut printer = Printer {
            writer: &amp;mut output,
        };

        let print_result = printer.println(&quot;this value&quot;);
        assert!(print_result.is_ok());

        let actual = String::from_utf8(output).expect(&quot;Not UTF-8&quot;);
        let expected = &quot;this value\n&quot;;

        assert_eq!(actual, expected);
    }

    #[test]
    fn test_printer__fts_banner__success() {
        let mut output = termcolor::Ansi::new(vec![]);
        let mut printer = Printer::new(&amp;mut output);

        printer.fts_banner().unwrap();

        let actual = String::from_utf8(output.into_inner()).unwrap();
        let expected = &quot;############################################################
###                  First Time Setup                  ####
###########################################################

This tool requires you to have a repository with a README.md
in the root folder. The markdown file is where your ideas
will be stored.

Once first time setup has completed, simply run Eureka again
to begin writing down ideas.&quot;;

        assert!(actual.starts_with(&quot;\u{1b}[0m\u{1b}[33m&quot;));
        assert!(actual.contains(expected));
        assert!(actual.ends_with(&quot;\n\u{1b}[0m&quot;));
    }

    #[test]
    fn test_printer__input_header__success() {
        let mut output = termcolor::Ansi::new(vec![]);
        let mut printer = Printer::new(&amp;mut output);

        printer.input_header(&quot;some-value&quot;).unwrap();

        let actual = String::from_utf8(output.into_inner()).unwrap();
        let expected = &quot;\u{1b}[0m\u{1b}[1m\u{1b}[32msome-value\n\u{1b}[0m&gt; &quot;;

        assert_eq!(actual, expected);
    }

    #[test]
    fn test_printer__error__success() {
        let mut output = termcolor::Ansi::new(vec![]);
        let mut printer = Printer::new(&amp;mut output);

        printer.error(&quot;some-value&quot;).unwrap();

        let actual = String::from_utf8(output.into_inner()).unwrap();
        let expected = &quot;\u{1b}[0m\u{1b}[31msome-value\n\u{1b}[0m&quot;;

        assert_eq!(actual, expected);
    }

    #[test]
    fn test_printer__println_styled__success() {
        let mut output_1 = termcolor::Ansi::new(vec![]);
        let mut printer = Printer::new(&amp;mut output_1);

        let opts_green_bold = PrintOptions {
            color: termcolor::Color::Green,
            is_bold: true,
        };

        printer
            .println_styled(&quot;some-green-bold-text&quot;, opts_green_bold)
            .unwrap();

        let actual_green_bold = String::from_utf8(output_1.into_inner()).unwrap();
        let expected_green_bold = &quot;\u{1b}[0m\u{1b}[1m\u{1b}[32msome-green-bold-text\n\u{1b}[0m&quot;;

        assert_eq!(actual_green_bold, expected_green_bold);

        let mut output_2 = termcolor::Ansi::new(vec![]);
        printer = Printer::new(&amp;mut output_2);

        let opts_yellow = PrintOptions {
            color: termcolor::Color::Yellow,
            is_bold: false,
        };

        printer
            .println_styled(&quot;some-yellow-text&quot;, opts_yellow)
            .unwrap();

        let actual_yellow = String::from_utf8(output_2.into_inner()).unwrap();
        let expected_yellow = &quot;\u{1b}[0m\u{1b}[33msome-yellow-text\n\u{1b}[0m&quot;;

        assert_eq!(actual_yellow, expected_yellow);
    }
}

<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chơi-đùa-với-system"><a class="header" href="#chơi-đùa-với-system">Chơi đùa với System</a></h1>
<h3 id="mở-url--path-với-ứng-dụng"><a class="header" href="#mở-url--path-với-ứng-dụng">Mở URL &amp; Path với ứng dụng</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>open::that(&quot;https://rust-lang.org&quot;);
open::with(&quot;https://rust-lang.org&quot;, &quot;firefox&quot;);

// Hoặc các đồng bào có thể dùng Path của ứng dụng để mở cũng oke, chưa thử
<span class="boring">}
</span></code></pre></pre>
<h3 id="kiểm-tra-đuôi-tệp"><a class="header" href="#kiểm-tra-đuôi-tệp">Kiểm tra đuôi tệp</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn check_img_format(filename: &amp;PathBuf) -&gt; bool {
    static IMAGE_FORMAT: &amp;[&amp;'static str; 9] = &amp;[&quot;jpg&quot;, &quot;jpeg&quot;, &quot;jpe&quot;, &quot;jfif&quot;, &quot;jfi&quot;, &quot;jif&quot;, &quot;png&quot;, &quot;bmp&quot;, &quot;gif&quot;];
    filename.extension().and_then(OsStr::to_str).is_some_and(|ext| IMAGE_FORMAT.contains(&amp;ext))
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="tạo-tệp"><a class="header" href="#tạo-tệp">Tạo tệp</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn gen_file(name: &amp;str, book_format: &amp;str) -&gt; Result&lt;File, std::io::Error&gt; {
    OpenOptions::new()
        .write(true)
        .create(true)
        .append(true)
        .open(format!(&quot;{}.{}&quot;, name, book_format))
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="Đọc-nội-dung-từ-tệp"><a class="header" href="#Đọc-nội-dung-từ-tệp">Đọc nội dung từ tệp</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn read_from_file(file: &amp;str) -&gt; String {
    let mut input = String::new();
    let mut f = File::open(file).expect(&quot;File not found!&quot;);
    f.read_to_string(&amp;mut input).expect(&quot;Something went wrong reading the file!&quot;);
    input
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="viết-nội-dung-vào-tệp"><a class="header" href="#viết-nội-dung-vào-tệp">Viết nội dung vào tệp</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn write_to_file() -&gt; Result&lt;(), anyhow::Error&gt; {
    let filename = gen_file(&quot;tep&quot;, &quot;txt&quot;);
    let mut f = BufWriter::new(f);
    f.write_all(gen_str(chapter.name, &amp;chapter.content).as_bytes())
        .expect(&quot;Can't write to the file&quot;);
    f.flush().unwrap();
    Ok(())
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="truy-cập-vào-các-ứng-dụng-khác"><a class="header" href="#truy-cập-vào-các-ứng-dụng-khác">Truy cập vào các ứng dụng khác</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::io::ErrorKind;
use std::path::PathBuf;
use std::process::Command;
use std::{env, fs, io};

pub trait ProgramOpener {
    fn open_editor(&amp;self, file_path: &amp;str) -&gt; io::Result&lt;()&gt;;
    fn open_pager(&amp;self, file_path: &amp;str) -&gt; io::Result&lt;()&gt;;
}

#[derive(Default)]
pub struct ProgramAccess;

impl ProgramOpener for ProgramAccess {
    fn open_editor(&amp;self, file_path: &amp;str) -&gt; io::Result&lt;()&gt; {
        self.open_with_fallback(file_path, &quot;EDITOR&quot;, &quot;vi&quot;)
    }

    fn open_pager(&amp;self, file_path: &amp;str) -&gt; io::Result&lt;()&gt; {
        self.open_with_fallback(file_path, &quot;PAGER&quot;, &quot;less&quot;)
    }
}

impl ProgramAccess {
    fn open_with_fallback(&amp;self, file_path: &amp;str, env_var: &amp;str, fallback: &amp;str) -&gt; io::Result&lt;()&gt; {
        let program = env::var(env_var)
            .map(PathBuf::from)
            .or_else(|_| self.get_if_available(fallback))?;

        // Make sure file exists
        fs::metadata(file_path)?;
        Command::new(program).arg(file_path).status().map(|_| ())
    }

    fn get_if_available(&amp;self, program: &amp;str) -&gt; io::Result&lt;PathBuf&gt; {
        which::which(program).map_err(|err| std::io::Error::new(ErrorKind::NotFound, err))
    }
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="internet"><a class="header" href="#internet">Internet</a></h1>
<p>Mấy cái xung quanh việc tương tác với Internet sử dụng Rust.</p>
<h3 id="encode-url"><a class="header" href="#encode-url">Encode URL</a></h3>
<p>Dùng cái này: <code>open = &quot;5.0.1&quot;</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let encoded_query =
        percent_encoding::utf8_percent_encode(&amp;args.query, NON_ALPHANUMERIC).to_string();

    for site in config.sites {
        let url = site.url.replace(&quot;%s&quot;, &amp;encoded_query);
        println!(&quot;{}:\t{}&quot;, site.name, url);
        // Phần này là dùng &quot;open&quot; rồi, hơi ngoài lề chút
        open::that(url).context(&quot;could not open the URL&quot;)?;
    }
<span class="boring">}
</span></code></pre></pre>
<h3 id="request"><a class="header" href="#request">Request</a></h3>
<p>Sử dụng ureq.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn fetch(url: &amp;str, refer_site: &amp;str) -&gt; Result&lt;Response, ureq::Error&gt; {
    let user_agent = &quot;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/126.0.0.0 Safari/537.36&quot;;
    
    let ureq_agent: Agent = ureq::AgentBuilder::new()
    .timeout_read(Duration::from_secs(30))
    .build();

    let body = ureq_agent.get(url)
        .set(&quot;User-Agent&quot;, user_agent)
        .set(&quot;Referer&quot;, refer_site)
        .call();
    body
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="lấy-thông-tin-từ-api"><a class="header" href="#lấy-thông-tin-từ-api">Lấy thông tin từ API</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Serialize, Deserialize, Default)]
struct Fact {
    id: String,
    text: String,
    source: String,
    source_url: String,
    language: String,
    permalink: String,
}

const FACT_BASE_URL: &amp;str = &quot;https://uselessfacts.jsph.pl&quot;;
const FACT_RANDOM: &amp;str = &quot;/api/v2/facts/random?language=en&quot;;
const FACT_DAILY: &amp;str = &quot;/api/v2/facts/today?language=en&quot;;

fn get_fact(url: &amp;str) -&gt; Result&lt;Fact, Box&lt;dyn std::error::Error&gt;&gt; {
    let resp = reqwest::blocking::get(url)?.json::&lt;Fact&gt;()?;
    Ok(resp)
}

fn get_random_fact() -&gt; Result&lt;Fact, Box&lt;dyn std::error::Error&gt;&gt; {
    let url = format!(&quot;{}{}&quot;, FACT_BASE_URL, FACT_RANDOM);
    get_fact(&amp;url)
}

fn get_daily_fact() -&gt; Result&lt;Fact, Box&lt;dyn std::error::Error&gt;&gt; {
    let url = format!(&quot;{}{}&quot;, FACT_BASE_URL, FACT_DAILY);
    get_fact(&amp;url)
}

fn get_help() -&gt; Result&lt;Fact, Box&lt;dyn std::error::Error&gt;&gt; {
    let mut fact = Fact::default();
    fact.text = String::from(&quot;Usage: fact [t]oday | [r]andom&quot;);
    Ok(fact)
}

fn print_fact(fact: Fact) {
    println!(&quot;Fact: {}&quot;, fact.text);
    println!(&quot;Source: {}&quot;, fact.source_url);
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="mở-trình-duyệt"><a class="header" href="#mở-trình-duyệt">Mở trình duyệt</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn show_news(new: &amp;NewsLink) -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let link = &amp;new.link;
    let response = ureq::get(link).call()?;
    let url = response.get_url();

    // if is a video of youtube
    if url.contains(&quot;youtube&quot;) {
        if webbrowser::open(new.link.as_str()).is_ok() {}
        return Ok(());
    }

    let view_select = Select::new(
        &quot;What view do you like to do?&quot;,
        vec![&quot;Web&quot;, &quot;Terminal&quot;, &quot;Ia Draft&quot;],
    )
    .with_help_message(&quot;Enter the view of the new&quot;)
    .prompt()
    .unwrap_or(&quot;Cancel&quot;);

    if view_select == &quot;Cancel&quot; {
        manage_exit(&quot;No view provided&quot;)
    }

    let view = View::from_str(view_select).expect(&quot;failed to parse view&quot;);
    match view {
        View::Terminal =&gt; {
            let html = response.into_string()?;
            let markdown = get_markdown_content(&amp;html);

            if markdown.is_empty() {
                println!(&quot;Content of new cannot be loaded in terminal&quot;);
                println!(&quot;Opening browser instead&quot;);
                if webbrowser::open(new.link.as_str()).is_ok() {}
            } else {
                generate_view(markdown.as_str()).expect(&quot;failed to generate a markdown view&quot;);
            }
        }
        View::Web =&gt; {
            webbrowser::open(new.link.as_str())?;
        }
        View::Ia =&gt; {
            let html = response.into_string()?;
            let markdown = get_markdown_content(&amp;html);
            get_resume(&amp;markdown)?;
        }
    }
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="epub"><a class="header" href="#epub">EPUB</a></h1>
<h3 id="tạo-epub"><a class="header" href="#tạo-epub">Tạo EPUB</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>pub fn gen_epub(
    book: NovelContent,
    book_language: &amp;str,
    is_vertical: &amp;bool,
) -&gt; epub_builder::Result&lt;()&gt; {
    let output = utils::gen_file(&amp;book.title, &quot;epub&quot;).unwrap();

    let epub_mode = css_gen(is_vertical);
    let mut binding = epub_builder::EpubBuilder::new(epub_builder::ZipLibrary::new()?)?;
    let gen_epub = binding
        .metadata(&quot;author&quot;, book.author.trim())?
        .metadata(&quot;title&quot;, &amp;book.title)?
        .epub_direction(epub_mode.epub_direction)
        .metadata(&quot;lang&quot;, book_language)?
        .metadata(&quot;generator&quot;, &quot;Buukuru&quot;)?
        .add_metadata_opf(epub_builder::MetadataOpf {
            name: String::from(&quot;primary-writing-mode&quot;),
            content: epub_mode.p_writing_mode,
        })
        .epub_version(epub_builder::EpubVersion::V30)
        .stylesheet(epub_mode.epub_css.as_bytes())?;

    let generated_content = gen_content(gen_epub, book);
    generated_content
        .inline_toc()
        .generate(output)
        .expect(&quot;Error generating .epub file&quot;);
    Ok(())
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="tạo-xhtml"><a class="header" href="#tạo-xhtml">Tạo XHTML</a></h3>
<h3 id="xhtml-generator"><a class="header" href="#xhtml-generator">XHTML Generator</a></h3>
<p>Phần 1:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn to_xhtml(content: &amp;Vec&lt;String&gt;, chap_title: &amp;str) -&gt; String {
    // Start
    let start = format!(
        r##&quot;&lt;?xml version='1.0' encoding='utf-8'?&gt;
&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; lang=&quot;ja&quot; xml:lang=&quot;ja&quot;&gt;
    &lt;head&gt;
        &lt;title&gt;{}&lt;/title&gt;
        &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;/&gt;
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;stylesheet.css&quot;/&gt;
    &lt;/head&gt;
    &lt;body&gt;&quot;##,
        chap_title
    );
    let chapter_title = format!(&quot;\n\t&lt;h2&gt;{}&lt;/h2&gt;\n&quot;, chap_title);
    let mut file: String = start.to_string() + chapter_title.as_str();

    for line in content {
        match line.as_str() {
            &quot;&quot; =&gt; {}
            _ =&gt; {
                file += format!(&quot;\t\t&lt;p&gt;{}&lt;/p&gt;\n&quot;, &amp;line.trim()).as_str();
            }
        }
    }
    file += &quot;\n\t&lt;/body&gt;\n&lt;/html&gt;&quot;;
    // End
    file
}
<span class="boring">}
</span></code></pre></pre>
<p>Phần 2:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn compress_xhtml(html_input: &amp;str) -&gt; String {
    format!(r##&quot;&lt;?xml version='1.0' encoding='utf-8'?&gt;
&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; lang=&quot;ja&quot; xml:lang=&quot;ja&quot;&gt;
    &lt;head&gt;
        &lt;title&gt;Untitled&lt;/title&gt;
        &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;/&gt;
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;stylesheet.css&quot;/&gt;
    &lt;/head&gt;
    &lt;body&gt;{}{}&quot;##, html_input, &quot;\n\t&lt;/body&gt;\n&lt;/html&gt;&quot;)
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="css-for-english-and-japanese"><a class="header" href="#css-for-english-and-japanese">CSS for English and Japanese</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn css_gen(is_vertical: &amp;bool) -&gt; EpubMode {
    let vertical_css = r##&quot;@page {
  margin-bottom: 5pt;
  margin-top: 5pt;
}

html {
  -webkit-writing-mode: vertical-rl;
  -moz-writing-mode: vertical-rl;
  -ms-writing-mode: vertical-rl;
  writing-mode: vertical-rl;
}

p {
  display: block;
  height: auto;
  text-indent: inherit;
  width: auto;
  margin: 0;
  padding: 0;
}&quot;##;
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sử-dụng-git-với-rust"><a class="header" href="#sử-dụng-git-với-rust">Sử dụng Git với Rust</a></h1>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::path::Path;

pub trait GitManagement {
    fn init(&amp;mut self, repo_path: &amp;str) -&gt; Result&lt;(), git2::Error&gt;;
    fn checkout_branch(&amp;self, branch_name: &amp;str) -&gt; Result&lt;(), git2::Error&gt;;
    fn add(&amp;self) -&gt; Result&lt;(), git2::Error&gt;;
    fn commit(&amp;self, subject: &amp;str) -&gt; Result&lt;git2::Oid, git2::Error&gt;;
    fn push(&amp;self, branch_name: &amp;str) -&gt; Result&lt;(), git2::Error&gt;;
}

#[derive(Default)]
pub struct Git {
    repo: Option&lt;git2::Repository&gt;,
}

impl GitManagement for Git {
    fn init(&amp;mut self, repo_path: &amp;str) -&gt; Result&lt;(), git2::Error&gt; {
        git2::Repository::open(Path::new(&amp;repo_path)).map(|repo| self.repo = Some(repo))
    }

    fn checkout_branch(&amp;self, branch_name: &amp;str) -&gt; Result&lt;(), git2::Error&gt; {
        let repo = self.repo.as_ref().unwrap();

        let commit = repo
            .head()
            .map(|head| head.target())
            .and_then(|oid| repo.find_commit(oid.unwrap()))?;

        // Create new branch if it doesn't exist
        match repo.branch(branch_name, &amp;commit, false) {
            // This command can fail due to an existing reference. This error should be ignored.
            Err(err)
                if !(err.class() == git2::ErrorClass::Reference
                    &amp;&amp; err.code() == git2::ErrorCode::Exists) =&gt;
            {
                return Err(err);
            }
            _ =&gt; {}
        }

        let refname = format!(&quot;refs/heads/{}&quot;, branch_name);
        let obj = repo.revparse_single(refname.as_str())?;

        repo.checkout_tree(&amp;obj, None)?;
        repo.set_head(refname.as_str())
    }

    fn add(&amp;self) -&gt; Result&lt;(), git2::Error&gt; {
        let mut index = self.repo.as_ref().unwrap().index()?;

        index.add_path(Path::new(&quot;README.md&quot;))?;
        index.write()
    }

    fn commit(&amp;self, subject: &amp;str) -&gt; Result&lt;git2::Oid, git2::Error&gt; {
        let repo = self.repo.as_ref().unwrap();
        let mut index = repo.index()?;

        let signature = repo.signature()?; // Use default user.name and user.email

        let oid = index.write_tree()?;
        let parent_commit = find_last_commit(self.repo.as_ref().unwrap())?;
        let tree = repo.find_tree(oid)?;

        repo.commit(
            Some(&quot;HEAD&quot;),      // point HEAD to our new commit
            &amp;signature,        // author
            &amp;signature,        // committer
            subject,           // commit message
            &amp;tree,             // tree
            &amp;[&amp;parent_commit], // parent commit
        )
    }

    fn push(&amp;self, branch_name: &amp;str) -&gt; Result&lt;(), git2::Error&gt; {
        with_credentials(self.repo.as_ref().unwrap(), |cred_callback| {
            let mut remote = self.repo.as_ref().unwrap().find_remote(&quot;origin&quot;)?;

            let mut callbacks = git2::RemoteCallbacks::new();
            let mut options = git2::PushOptions::new();

            callbacks.credentials(cred_callback);
            options.remote_callbacks(callbacks);

            remote.push(
                &amp;[format!(
                    &quot;refs/heads/{}:refs/heads/{}&quot;,
                    branch_name, branch_name
                )],
                Some(&amp;mut options),
            )?;

            Ok(())
        })
    }
}

fn find_last_commit(repo: &amp;git2::Repository) -&gt; Result&lt;git2::Commit, git2::Error&gt; {
    let obj = repo.head()?.resolve()?.peel(git2::ObjectType::Commit)?;
    obj.into_commit()
        .map_err(|_| git2::Error::from_str(&quot;Couldn't find commit&quot;))
}

/// Helper to run git operations that require authentication.
///
/// This is inspired by [the way Cargo handles this][cargo-impl].
///
/// [cargo-impl]: https://github.com/rust-lang/cargo/blob/94bf4781d0bbd266abe966c6fe1512bb1725d368/src/cargo/sources/git/utils.rs#L437
fn with_credentials&lt;F&gt;(repo: &amp;git2::Repository, mut f: F) -&gt; Result&lt;(), git2::Error&gt;
where
    F: FnMut(&amp;mut git2::Credentials) -&gt; Result&lt;(), git2::Error&gt;,
{
    let config = repo.config()?;

    let mut tried_sshkey = false;
    let mut tried_cred_helper = false;
    let mut tried_default = false;

    f(&amp;mut |url, username, allowed| {
        if allowed.contains(git2::CredentialType::USERNAME) {
            return Err(git2::Error::from_str(&quot;No username specified in remote URL&quot;));
        }

        if allowed.contains(git2::CredentialType::SSH_KEY) &amp;&amp; !tried_sshkey {
            tried_sshkey = true;
            let username = username.unwrap();
            return git2::Cred::ssh_key_from_agent(username);
        }

        if allowed.contains(git2::CredentialType::USER_PASS_PLAINTEXT) &amp;&amp; !tried_cred_helper {
            tried_cred_helper = true;
            return git2::Cred::credential_helper(&amp;config, url, username);
        }

        if allowed.contains(git2::CredentialType::DEFAULT) &amp;&amp; !tried_default {
            tried_default = true;
            return git2::Cred::default();
        }

        Err(git2::Error::from_str(&quot;No authentication method succeeded&quot;))
    })
}

#[allow(non_snake_case)]
#[cfg(test)]
mod tests {
    use crate::git::{find_last_commit, Git, GitManagement};
    use git2::{BranchType, Repository, RepositoryInitOptions, Status};
    use tempfile::{NamedTempFile, TempDir};

    #[test]
    fn test_git__init__valid_repo() {
        let mut git = Git::default();
        // Valid repo
        let (dir, _repo, _file) = repo_init();

        let actual = git.init(dir.path().to_str().unwrap());

        assert!(actual.is_ok());
    }

    #[test]
    fn test_git__init__invalid_repo() {
        let mut git = Git::default();
        // Invalid repo
        let dir = TempDir::new().unwrap();

        let actual = git.init(dir.path().to_str().unwrap());

        assert!(actual.is_err());
    }

    #[test]
    fn test_git__checkout_branch__missing_branch() {
        let mut git = Git::default();
        let (dir, repo, _file) = repo_init();
        git.init(dir.path().to_str().unwrap()).unwrap();

        // This will create a new branch
        git.checkout_branch(&quot;new-branch-name&quot;).unwrap();

        let actual = repo.find_branch(&quot;new-branch-name&quot;, BranchType::Local);

        assert!(actual.is_ok());
    }

    #[test]
    fn test_git__checkout_branch__success() {
        let mut git = Git::default();
        let (dir, repo, _file) = repo_init();
        git.init(dir.path().to_str().unwrap()).unwrap();

        let before = repo.head();
        assert_eq!(before.unwrap().name().unwrap(), &quot;refs/heads/main&quot;);

        git.checkout_branch(&quot;new-branch-name&quot;).unwrap();

        let after = repo.head();

        assert!(after.is_ok());
        assert_eq!(after.unwrap().name().unwrap(), &quot;refs/heads/new-branch-name&quot;);
    }

    #[test]
    fn test_git__add__success() {
        let mut git = Git::default();
        let (dir, repo, _file) = repo_init();
        git.init(dir.path().to_str().unwrap()).unwrap();

        let statuses_before = repo.statuses(None).unwrap();
        let before = statuses_before.get(0).unwrap();
        assert_eq!(before.status(), Status::WT_NEW);

        git.add().unwrap();

        let statuses_after = repo.statuses(None).unwrap();
        let after = statuses_after.get(0).unwrap();
        assert_eq!(after.status(), Status::INDEX_NEW);
    }

    #[test]
    fn test_git__commit__success() {
        let mut git = Git::default();
        let (dir, _repo, _file) = repo_init();
        git.init(dir.path().to_str().unwrap()).unwrap();

        // Initial commit
        let before = find_last_commit(git.repo.as_ref().unwrap());
        assert_eq!(before.unwrap().summary().unwrap(), &quot;initial-msg&quot;);

        git.add().unwrap();
        git.commit(&quot;some-subject&quot;).unwrap();

        let after = find_last_commit(git.repo.as_ref().unwrap());
        assert_eq!(after.unwrap().summary().unwrap(), &quot;some-subject&quot;);
    }

    fn repo_init() -&gt; (TempDir, Repository, NamedTempFile) {
        let td = TempDir::new().unwrap();
        let mut opts = RepositoryInitOptions::new();
        opts.initial_head(&quot;main&quot;);
        let repo = Repository::init_opts(td.path(), &amp;opts).unwrap();

        // Create README.md file
        let file = tempfile::Builder::new()
            .prefix(&quot;README&quot;)
            .suffix(&quot;.md&quot;)
            .rand_bytes(0)
            .tempfile_in(td.path())
            .unwrap();
        {
            // Set basic config
            let mut config = repo.config().unwrap();
            config.set_str(&quot;user.name&quot;, &quot;some-name&quot;).unwrap();
            config.set_str(&quot;user.email&quot;, &quot;some-email&quot;).unwrap();

            // Make initial commit
            let mut index = repo.index().unwrap();
            let id = index.write_tree().unwrap();
            let tree = repo.find_tree(id).unwrap();
            let sig = repo.signature().unwrap();
            repo.commit(Some(&quot;HEAD&quot;), &amp;sig, &amp;sig, &quot;initial-msg&quot;, &amp;tree, &amp;[])
                .unwrap();
        }
        // Return file to not drop it and make it disappear
        (td, repo, file)
    }
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="html-1"><a class="header" href="#html-1">HTML</a></h1>
<h3 id="lấy-các-nội-dung-từ-các-selector"><a class="header" href="#lấy-các-nội-dung-từ-các-selector">Lấy các nội dung từ các Selector</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn fetcher(
    base_url: String,
    id: &amp;str,
    list_selector: &amp;str,
    item_selector: &amp;str,
    element: &amp;str
) -&gt; Vec&lt;String&gt; {
    let given_url = base_url + id;
    let body = http::get_body_from_url(&amp;given_url).unwrap();
    let document = Html::parse_document(&amp;body);
    // Logging
    println!(&quot;Đang tải chương truyện với URL là: {}&quot;, &amp;given_url);
    // Selector
    let list = Selector::parse(list_selector).unwrap();
    let item = Selector::parse(item_selector).unwrap();
    let body = Selector::parse(&quot;body&quot;).unwrap();

    let content_matcher = match document.select(&amp;list).next() {
        Some(doc) =&gt; {
            doc.select(&amp;item)
        },
        None =&gt; {
            document.select(&amp;body).next().unwrap().select(&amp;item)
        },
    };

    content_matcher.into_iter()
    .filter_map(|f| f.value().attr(element).map(|elem| elem.to_string())).collect()
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="cái-gì-đó-không-rõ"><a class="header" href="#cái-gì-đó-không-rõ">Cái gì đó không rõ</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Displays formatted html that fits a CSS selector.
pub fn display_article(
    contents_selector: scraper::Selector,
    title_selector: scraper::Selector,
    request: scraper::Html,
) {
    let mut paragraphs = request
        .select(&amp;contents_selector)
        .map(|x| from_read(x.inner_html().as_bytes(), 190))
        .collect::&lt;Vec&lt;String&gt;&gt;()
        .join(&quot;\n&quot;);

    paragraphs = filters::remove_references(paragraphs);
    paragraphs = filters::remove_square_brackets(paragraphs);
    paragraphs = filters::remove_links(paragraphs);

    let title = request
        .select(&amp;title_selector)
        .map(|x| from_read(x.inner_html().as_bytes(), 50))
        .collect::&lt;Vec&lt;String&gt;&gt;()
        .join(&quot;&quot;);

    let article = ArticleDisplay {
        title: title,
        contents: paragraphs,
    };

    ui::ArticleDisplay::new(article).unwrap();
}

<span class="boring">}
</span></code></pre></pre>
<h3 id="code-that-cleans-the-article-from-html-leftovers"><a class="header" href="#code-that-cleans-the-article-from-html-leftovers">Code that cleans the article from HTML leftovers.</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use regex::Regex;

pub fn remove_square_brackets(text: String) -&gt; String {
    let square_bracket_regex =
        Regex::new(r&quot;[(?P&lt;link&gt;[a-zA-Z0-9\(\)\-\,[:space:]&amp;=]+)]&quot;).unwrap();
    square_bracket_regex.replace_all(&amp;text, &quot;$link&quot;).to_string()
}

pub fn remove_references(text: String) -&gt; String {
    let reference_regex = Regex::new(r&quot;[+([0-9]+)]+&quot;).unwrap();
    reference_regex.replace_all(&amp;text, &quot;&quot;).to_string()
}

pub fn remove_links(text: String) -&gt; String {
    let link_regex = Regex::new(r&quot;: [/?/[a-zA-Z0-9-%:/(/)_.//&amp;=]+/]+\n&quot;).unwrap();
    let note_regex =
        Regex::new(r&quot;: #cite_note-[0-9-]+\n|: #cite_note-[a-zA-Z_-]+-[0-9-]+\n&quot;).unwrap();

    let mut new_text = link_regex.replace_all(&amp;text, &quot;&quot;).to_string();
    new_text = note_regex.replace_all(&amp;new_text, &quot;&quot;).to_string();

    new_text
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="chọn-các-elements-trong-html-bằng-selectrs"><a class="header" href="#chọn-các-elements-trong-html-bằng-selectrs">Chọn các elements trong HTML bằng select.rs</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn html_to_dict_term(file_path: &amp;str) -&gt; Vec&lt;DictTerm&gt; {
    let html_content = fs::read_to_string(file_path).expect(&quot;Should have been able to read the file&quot;);
    let document = Document::from(html_content.as_str());

    document.find(Name(&quot;idx:entry&quot;)).map(|element| {
        let dict_term = element.find(Name(&quot;idx:orth&quot;)).next().unwrap().attr(&quot;value&quot;).unwrap();
        DictTerm {
            term: dict_term.to_owned(),
            definition: element.text().replace(&quot;\&quot;&quot;, &quot;-&quot;)
        } 
    }).collect::&lt;Vec&lt;_&gt;&gt;()
    
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><pre class="playground"><code class="language-rust">fn main() {
    let matches = Command::new(&quot;tinpub-rs&quot;)
        .arg(
            Arg::new(&quot;source&quot;)
                .short('i')
                .long(&quot;source&quot;)
                .help(&quot;Which source do you wanna fetch news from&quot;)
                .required(true),
        )
        .get_matches();
        
    let feed = FeedConfig {
        name: String::from(&quot;untitled&quot;),
        url: config_path.clone()
    };

    
}

fn handle_feed(feed: &amp;FeedConfig, client: &amp;Client) -&gt; Vec&lt;FetchedItem&gt; {
    println!(&quot;Fetching {}&quot;, feed.name);

    let rss_result = fetch_rss(&amp;feed.url, client);
    let mut src_items: Vec&lt;FetchedItem&gt; = Vec::new();

    let rss_channel = match rss_result {
        Ok(channel) =&gt; channel,
        Err(_) =&gt; {
            println!(&quot;Failed to load RSS feed&quot;);
            return src_items;
        },
    };

    for item in rss_channel.into_items() {
        let title_result = item.title();
        
        let title = match title_result {
            Some(title) =&gt; title,
            None =&gt; {
                println!(&quot;No title found&quot;);
                return src_items;
            },
        };

        let item_url = item.link().unwrap();
        let item_desc = item.clone().description.unwrap();

        let item_content: String = match item.clone().content {
            Some(content) =&gt; content,
            None =&gt; String::from(&quot;&quot;),
        };

        let fetched_item = FetchedItem {
            name: String::from(title),
            url: String::from(item_url),
            desc: item_desc.to_string(),
            content: item_content.to_string()
        };

        println!(&quot;Fetching post: {}[{:?}]&quot;, title, item_url);

        src_items.push(fetched_item)

        // if download_filter.is_match(title) {}
    }
    src_items
}

fn fetch_rss(url: &amp;str, client: &amp;Client) -&gt; Result&lt;Channel, Box&lt;dyn std::error::Error&gt;&gt; {
    println!(&quot;Fetching URL {}&quot;, url);
    let response = client.get(url).send()?;
    let status = response.status();
    println!(&quot;Response status: {}&quot;, status);
    if status.is_success() {
        let text = response.text()?;

        let rss_result = Channel::read_from(text.as_bytes());
        if let Ok(channel) = rss_result {
            Ok(channel)
        } else {
            let error = rss_result.err().unwrap();
            println!(&quot;Error parsing RSS feed: {:?}&quot;, error);
            Err(Box::new(error))
        }
    } else {
        println!(&quot;Error fetching RSS feed&quot;);
        Err(Box::new(response.error_for_status().err().unwrap()))
    }
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="essentials"><a class="header" href="#essentials">Essentials</a></h3>
<p>This section covers varios aspects of Rust programming language from basic to some complex topics.</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="core-concepts"><a class="header" href="#core-concepts">Core Concepts</a></h3>
<p>Rust has several core concepts that are fundamental to understanding and effectively using the language. These concepts are designed to ensure memory safety, concurrency, and performance without sacrificing ease of use.</p>
<h3 id="1-ownership"><a class="header" href="#1-ownership">1. <a href="rust/essentials/core-concepts/./ownership.html">Ownership</a></a></h3>
<p>Ownership is a set of rules that governs how a Rust program manages memory. It ensures memory safety without needing a garbage collector.</p>
<h3 id="2-borrowing-and-references"><a class="header" href="#2-borrowing-and-references">2. <a href="rust/essentials/core-concepts/./borrow.html">Borrowing</a> and <a href="rust/essentials/core-concepts/./reference.html">References</a></a></h3>
<p>Borrowing allows you to reference a value without taking ownership of it.</p>
<h3 id="3-lifetimes"><a class="header" href="#3-lifetimes">3. <a href="rust/essentials/core-concepts/./lifetime.html">Lifetimes</a></a></h3>
<p>Lifetimes are a way of ensuring that references are valid as long as they are used. They prevent dangling references and ensure memory safety. Lifetimes are often inferred by the compiler, but they can also be explicitly specified.</p>
<h3 id="4-flow-controls-and-pattern-matching"><a class="header" href="#4-flow-controls-and-pattern-matching">4. <a href="rust/essentials/core-concepts/./flow-control.html">Flow Controls</a> and <a href="rust/essentials/core-concepts/./pattern-matching.html">Pattern Matching</a></a></h3>
<p>Pattern matching is a powerful feature that allows you to match complex data structures and execute code based on their shape. It is commonly used with <code>match</code> statements and <code>if let</code> expressions.</p>
<h3 id="5-traits"><a class="header" href="#5-traits">5. <a href="rust/essentials/core-concepts/../types/trait.html">Traits</a></a></h3>
<p>Traits help defining shared behavior. They are similar to interfaces in other languages. Traits allow you to define methods that can be implemented by different types.</p>
<h3 id="6-enums-and-pattern-matching"><a class="header" href="#6-enums-and-pattern-matching">6. <a href="rust/essentials/core-concepts/../types/enum.html">Enums</a> and <a href="rust/essentials/core-concepts/./pattern-matching.html">Pattern Matching</a></a></h3>
<p>Enums in Rust are more powerful than in many other languages because each variant can have associated data. Enums are often used with pattern matching to handle different cases.</p>
<h3 id="7-concurrency"><a class="header" href="#7-concurrency">7. <a href="rust/essentials/core-concepts/./concurency.html">Concurrency</a></a></h3>
<p>Rust provides powerful concurrency primitives, such as threads and channels, while ensuring memory safety. The ownership and borrowing system helps prevent data races at compile time.</p>
<h3 id="8-error-handling"><a class="header" href="#8-error-handling">8. <a href="rust/essentials/core-concepts/./error-handling.html">Error Handling</a></a></h3>
<p>Error handling system uses the <code>Result</code> and <code>Option</code> enums. This encourages handling errors explicitly rather than relying on exceptions.</p>
<h3 id="9-macros"><a class="header" href="#9-macros">9. <a href="rust/essentials/core-concepts/./macro.html">Macros</a></a></h3>
<p>Macros provide a way to write code that writes other code (metaprogramming). They are used for code generation and to reduce boilerplate.</p>
<h3 id="10-modules-and-crates"><a class="header" href="#10-modules-and-crates">10. <a href="rust/essentials/core-concepts/./module.html">Modules</a> and <a href="rust/essentials/core-concepts/./crate.html">Crates</a></a></h3>
<p>Modules and crates are Rust's way of organizing code. Modules allow you to group related code together, while crates are the unit of compilation and distribution.</p>
<h3 id="11-functions-and-closures"><a class="header" href="#11-functions-and-closures">11. <a href="rust/essentials/core-concepts/./function.html">Functions</a> and <a href="rust/essentials/core-concepts/./closure.html">Closures</a></a></h3>
<p>Functions are a fundamental building block for organizing and reusing code. Functions allow you to encapsulate logic, perform specific tasks, and return values.</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="functions"><a class="header" href="#functions">Functions</a></h3>
<p>Functions are a fundamental building block in Rust. They allow you to encapsulate code into reusable blocks. Functions are defined using the <code>fn</code> keyword, followed by the function name, parameters, and the body of the function.</p>
<h3 id="defining-a-function"><a class="header" href="#defining-a-function">Defining a Function</a></h3>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<p><code>main</code> is a special function that serves as the entry point of a Rust program.</p>
<h3 id="function-parameters"><a class="header" href="#function-parameters">Function Parameters</a></h3>
<p>Functions can take parameters, which are specified in the parentheses after the function name.</p>
<pre><pre class="playground"><code class="language-rust">fn greet(name: &amp;str) {
    println!(&quot;Hello, {}!&quot;, name);
}

fn main() {
    greet(&quot;Alice&quot;);
    greet(&quot;Bob&quot;);
}
</code></pre></pre>
<ul>
<li>The <code>greet</code> function takes a single parameter <code>name</code> of type <code>&amp;str</code>.</li>
</ul>
<h3 id="return-values"><a class="header" href="#return-values">Return Values</a></h3>
<p>Functions can also return values. The return type is specified after an arrow (<code>-&gt;</code>).</p>
<pre><pre class="playground"><code class="language-rust">fn add(a: i32, b: i32) -&gt; i32 {
    a + b
}

fn main() {
    let sum = add(5, 3);
    println!(&quot;Sum: {}&quot;, sum);
}
</code></pre></pre>
<ul>
<li>The <code>add</code> function takes two parameters of type <code>i32</code> and returns their sum, which is also of type <code>i32</code>.</li>
</ul>
<h3 id="early-returns"><a class="header" href="#early-returns">Early Returns</a></h3>
<p>You can return a value early from a function using the <code>return</code> keyword:</p>
<pre><pre class="playground"><code class="language-rust">fn is_even(num: i32) -&gt; bool {
    if num % 2 == 0 {
        return true;
    }
    false
}

fn main() {
    let number = 4;
    if is_even(number) {
        println!(&quot;{} is even&quot;, number);
    } else {
        println!(&quot;{} is odd&quot;, number);
    }
}
</code></pre></pre>
<ul>
<li>The <code>is_even</code> function returns <code>true</code> if the number is even and <code>false</code> otherwise.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h3 id="flow-control"><a class="header" href="#flow-control">Flow Control</a></h3>
<p>Rust provides several options for flow control, including <code>if</code> statements, <code>while</code> loops, and more. Here are some simple examples for each:</p>
<h3 id="if-statements"><a class="header" href="#if-statements"><code>if</code> Statements</a></h3>
<p>The <code>if</code> statement allows you to execute code based on a condition.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let number = 5;

if number &lt; 10 {
    println!(&quot;The number is less than 10&quot;);
} else {
    println!(&quot;The number is 10 or greater&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="while-loops"><a class="header" href="#while-loops"><code>while</code> Loops</a></h3>
<p>The <code>while</code> loop allows you to execute code repeatedly as long as a condition is true.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut count = 0;

while count &lt; 5 {
    println!(&quot;Count is: {}&quot;, count);
    count += 1;
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="for-loops"><a class="header" href="#for-loops"><code>for</code> Loops</a></h3>
<p>The <code>for</code> loop allows you to iterate over a range or collection.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for number in 1..5 {
    println!(&quot;The number is: {}&quot;, number);
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="match-statements"><a class="header" href="#match-statements"><code>match</code> Statements</a></h3>
<p>The <code>match</code> statement allows you to compare a value against a series of patterns and execute code based on which pattern matches.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let number = 3;

match number {
    1 =&gt; println!(&quot;One&quot;),
    2 =&gt; println!(&quot;Two&quot;),
    3 =&gt; println!(&quot;Three&quot;),
    _ =&gt; println!(&quot;Something else&quot;),
}
<span class="boring">}
</span></code></pre></pre>
<p>These are some of the basic flow control options available in Rust. Each of these constructs helps you manage the flow of your program effectively.</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="pattern-matching"><a class="header" href="#pattern-matching">Pattern Matching</a></h3>
<p>Pattern matching is a powerful feature that allows you to match complex data structures and perform different actions based on their shape. </p>
<h3 id="matching-literals"><a class="header" href="#matching-literals">Matching Literals</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 1;

match x {
    1 =&gt; println!(&quot;One!&quot;),
    2 =&gt; println!(&quot;Two!&quot;),
    _ =&gt; println!(&quot;Something else!&quot;),
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="matching-multiple-patterns"><a class="header" href="#matching-multiple-patterns">Matching Multiple Patterns</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 1;

match x {
    1 | 2 =&gt; println!(&quot;One or Two!&quot;),
    3 =&gt; println!(&quot;Three!&quot;),
    _ =&gt; println!(&quot;Something else!&quot;),
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="destructuring-structs"><a class="header" href="#destructuring-structs">Destructuring Structs</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Point {
    x: i32,
    y: i32,
}

let p = Point { x: 0, y: 7 };

match p {
    Point { x: 0, y } =&gt; println!(&quot;On the y axis at {}&quot;, y),
    Point { x, y: 0 } =&gt; println!(&quot;On the x axis at {}&quot;, x),
    Point { x, y } =&gt; println!(&quot;On neither axis: ({}, {})&quot;, x, y),
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="destructuring-enums"><a class="header" href="#destructuring-enums">Destructuring Enums</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

let msg = Message::ChangeColor(0, 160, 255);

match msg {
    Message::Quit =&gt; println!(&quot;The Quit variant has no data to destructure.&quot;),
    Message::Move { x, y } =&gt; println!(&quot;Move in the x direction {} and in the y direction {}&quot;, x, y),
    Message::Write(text) =&gt; println!(&quot;Text message: {}&quot;, text),
    Message::ChangeColor(r, g, b) =&gt; println!(&quot;Change the color to red {}, green {}, and blue {}&quot;, r, g, b),
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="ignoring-values-in-a-pattern"><a class="header" href="#ignoring-values-in-a-pattern">Ignoring Values in a Pattern</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let numbers = (2, 4, 8, 16, 32);

match numbers {
    (first, _, third, _, fifth) =&gt; {
        println!(&quot;Some numbers: {}, {}, {}&quot;, first, third, fifth)
    },
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="matching-ranges-of-values"><a class="header" href="#matching-ranges-of-values">Matching Ranges of Values</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;

match x {
    1..=5 =&gt; println!(&quot;One through Five&quot;),
    _ =&gt; println!(&quot;Something else&quot;),
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="using-if-guards"><a class="header" href="#using-if-guards">Using <code>if</code> Guards</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = Some(4);

match x {
    Some(n) if n &lt; 5 =&gt; println!(&quot;Less than five: {}&quot;, n),
    Some(n) =&gt; println!(&quot;{}&quot;, n),
    None =&gt; (),
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="closures-in-rust"><a class="header" href="#closures-in-rust">Closures in Rust</a></h3>
<p>Closures are anonymous functions that can capture their environment. They are similar to lambdas in other programming languages. Closures in Rust are defined using the <code>|</code> syntax.</p>
<h3 id="basic-syntax"><a class="header" href="#basic-syntax">Basic Syntax</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let add = |a, b| a + b;
println!(&quot;Sum: {}&quot;, add(2, 3)); // Output: Sum: 5
<span class="boring">}
</span></code></pre></pre>
<h3 id="capturing-environment"><a class="header" href="#capturing-environment">Capturing Environment</a></h3>
<p>Closures can capture variables from their enclosing scope.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 10;
let print_x = || println!(&quot;x: {}&quot;, x);
print_x(); // Output: x: 10
<span class="boring">}
</span></code></pre></pre>
<h3 id="mutable-captures"><a class="header" href="#mutable-captures">Mutable Captures</a></h3>
<p>Closures can also capture variables mutably.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut x = 10;
{
    let mut add_to_x = || x += 5;
    add_to_x();
}
println!(&quot;x: {}&quot;, x); // Output: x: 15
<span class="boring">}
</span></code></pre></pre>
<h3 id="moving-captures"><a class="header" href="#moving-captures">Moving Captures</a></h3>
<p>Closures can take ownership of captured variables using the <code>move</code> keyword.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = vec![1, 2, 3];
let print_x = move || println!(&quot;x: {:?}&quot;, x);
print_x(); // Output: x: [1, 2, 3]
// x is no longer accessible here
<span class="boring">}
</span></code></pre></pre>
<p>Closures are a powerful feature in Rust, enabling concise and expressive code.</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="ownership"><a class="header" href="#ownership">Ownership</a></h3>
<p>Ownership is a set of rules that governs how the program manages memory. The ownership system is designed to prevent memory leaks and ensure memory safety. Here are the key rules of ownership:</p>
<ol>
<li>Each value has a variable that’s called its owner.</li>
<li>There can only be one owner at a time.</li>
<li>When the owner goes out of scope, the value will be dropped.</li>
</ol>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let s1 = String::from(&quot;hello&quot;);
    let s2 = s1; // s1 is moved to s2

    // println!(&quot;{}&quot;, s1); // This line would cause a compile-time error because s1 is no longer valid
    println!(&quot;{}&quot;, s2); // s2 is now the owner of the string
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="borrowing"><a class="header" href="#borrowing">Borrowing</a></h3>
<p>Borrowing allows you to reference a value without taking ownership of it. There are two types of borrowing in Rust:</p>
<p><strong>Immutable Borrowing (&amp;T)</strong>: </p>
<p>You can have multiple immutable references to a value.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let s1 = String::from(&quot;hello&quot;);
    let len = calculate_length(&amp;s1); // Borrow s1 immutably

    println!(&quot;The length of '{}' is {}.&quot;, s1, len); // s1 is still valid here
}

fn calculate_length(s: &amp;String) -&gt; usize {
    s.len() // Use the borrowed value
}
</code></pre></pre>
<p>s1 is borrowed immutably by the calculate_length function. The function can read the value but cannot modify it. After the function call, s1 is still valid.</p>
<p><strong>Mutable Borrowing (&amp;mut T)</strong>: </p>
<p>You can have only one mutable reference to a value at a time. </p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut s = String::from(&quot;hello&quot;);
    change(&amp;mut s); // Borrow s mutably

    println!(&quot;{}&quot;, s); // s is still valid here and has been modified
}

fn change(some_string: &amp;mut String) {
    some_string.push_str(&quot;, world&quot;); // Modify the borrowed value
}
</code></pre></pre>
<p>s is borrowed mutably by the change function. The function can modify the value. After the function call, s is still valid and has been modified.</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="macros-in-rust"><a class="header" href="#macros-in-rust">Macros in Rust</a></h3>
<p>Macros in Rust are a way of writing code that writes other code, which is known as metaprogramming. They are used to reduce code repetition and to provide more expressive syntax.</p>
<h3 id="types-of-macros"><a class="header" href="#types-of-macros">Types of Macros</a></h3>
<ol>
<li><strong>Declarative Macros (macro_rules!)</strong></li>
<li><strong>Procedural Macros</strong></li>
</ol>
<h3 id="declarative-macros"><a class="header" href="#declarative-macros">Declarative Macros</a></h3>
<p>Declarative macros are defined using the <code>macro_rules!</code> keyword. They allow you to match against patterns and generate code based on those patterns.</p>
<pre><pre class="playground"><code class="language-rust">macro_rules! say_hello {
    () =&gt; {
        println!(&quot;Hello, world!&quot;);
    };
}

fn main() {
    say_hello!();
}
</code></pre></pre>
<h3 id="procedural-macros"><a class="header" href="#procedural-macros">Procedural Macros</a></h3>
<p>Procedural macros are more flexible and powerful. They are defined using functions and can be used to create attribute-like macros and function-like macros.</p>
<h4 id="function-like-macros"><a class="header" href="#function-like-macros">Function-like Macros</a></h4>
<p>Function-like macros look like function calls but operate on the code passed to them as arguments. They are defined using the <code>#[proc_macro]</code> attribute and can be used to generate code based on the input provided.</p>
<p>To create a procedural macro, you need to create a new crate with the <code>proc-macro</code> attribute:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// In your Cargo.toml
[lib]
proc-macro = true
<span class="boring">}
</span></code></pre></pre>
<p>Then, define the macro in your crate:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern crate proc_macro;
use proc_macro::TokenStream;

#[proc_macro]
pub fn my_function_like_macro(input: TokenStream) -&gt; TokenStream {
    // Your macro implementation here
    input
}
<span class="boring">}
</span></code></pre></pre>
<p>And use it in your main crate:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use my_function_like_macro::my_function_like_macro;

my_function_like_macro! {
    // Your code here
}
<span class="boring">}
</span></code></pre></pre>
<p><code>my_function_like_macro</code> is a function-like macro that can be invoked with the <code>!</code> syntax. The macro processes the input token stream and generates the corresponding code.</p>
<h4 id="attribute-like-macros"><a class="header" href="#attribute-like-macros">Attribute-like Macros</a></h4>
<p>Attribute-like macros are used to create custom attributes that can be applied to items such as functions, structs, or modules. They are defined similarly to procedural macros.</p>
<p>First, create a new crate with the <code>proc-macro</code> attribute:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// In your Cargo.toml
[lib]
proc-macro = true
<span class="boring">}
</span></code></pre></pre>
<p>Then, define the attribute-like macro in your crate:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern crate proc_macro;
use proc_macro::TokenStream;

#[proc_macro_attribute]
pub fn my_attribute(_attr: TokenStream, item: TokenStream) -&gt; TokenStream {
    // Your macro implementation here
    item
}
<span class="boring">}
</span></code></pre></pre>
<p>And use it in your main crate:</p>
<pre><pre class="playground"><code class="language-rust">use my_attribute::my_attribute;

#[my_attribute]
fn my_function() {
    println!(&quot;This function has a custom attribute!&quot;);
}

fn main() {
    my_function();
}
</code></pre></pre>
<p><code>my_attribute</code> is an attribute-like macro that can be applied to a function. When <code>my_function</code> is called, it will print a message to the console.</p>
<h3 id="usage-1"><a class="header" href="#usage-1">Usage</a></h3>
<p>Macros are invoked using the <code>!</code> syntax. For example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>println!(&quot;Hello, {}!&quot;, &quot;world&quot;);
<span class="boring">}
</span></code></pre></pre>
<p><code>println!</code> is a macro that prints formatted text to the console.</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="concurrency-1"><a class="header" href="#concurrency-1">Concurrency</a></h3>
<p>Concurrency is the mechanism of handling tasks in parallel. This helps use the available system resources such as CPUs more efficiently. As code runs in different contexts in threads, passing messages and handling shared variables becomes an important part of the implementation. Rust's standard library provides solutions to these concurrency needs out of the box.</p>
<h4 id="threads"><a class="header" href="#threads">Threads</a></h4>
<p>Rust's standard library provides a way to spawn threads using the <code>std::thread</code> module. The <code>thread::spawn</code> function is used to create a new thread. The || syntax is used to define a <a href="rust/essentials/core-concepts/./closure.html">closure</a>, which is an anonymous function that can capture variables from its surrounding scope.</p>
<pre><pre class="playground"><code class="language-rust">use std::thread;

macro_rules! sleep {
    ($millis:expr) =&gt; {
        std::thread::sleep(std::time::Duration::from_millis($millis));
    };
}

fn main() {
    let handle = thread::spawn(|| {
        for i in 1..10 {
            println!(&quot;hi number {} from the spawned thread!&quot;, i);
            sleep!(50);
        }
    });

    for i in 1..5 {
        println!(&quot;hi number {} from the main thread!&quot;, i);
        sleep!(50);
    }

    handle.join().unwrap();
}
</code></pre></pre>
<ul>
<li><code>||</code>: This defines a closure with no parameters. If the closure had parameters, they would be listed between the vertical bars.</li>
<li><code>{ ... }</code>: This is the body of the closure, which contains the code that will be executed in the new thread.</li>
</ul>
<h4 id="message-passing"><a class="header" href="#message-passing">Message Passing</a></h4>
<pre><pre class="playground"><code class="language-rust">use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from(&quot;hi&quot;);
        tx.send(val).unwrap();
    });

    let received = rx.recv().unwrap();
    println!(&quot;Got: {}&quot;, received);
}
</code></pre></pre>
<ul>
<li>channels from <code>std::sync::mpsc</code> module can be used for message passing between threads</li>
</ul>
<h4 id="shared-state"><a class="header" href="#shared-state">Shared State</a></h4>
<pre><pre class="playground"><code class="language-rust">use std::sync::{Arc, Mutex};
use std::thread;


fn main() {
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Arc::clone(&amp;counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();
            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!(&quot;Result: {}&quot;, *counter.lock().unwrap());
}
</code></pre></pre>
<ul>
<li>
<p>An atomic reference-counted pointer <code>Arc</code> is created to manage the shared ownership of a <code>Mutex</code> that guards an integer counter initialized to 0. <br/></p>
</li>
<li>
<p>A vector <code>handles</code> is created to store the handles of the spawned threads.<br/></p>
</li>
<li>
<p>A loop is used to spawn 10 threads. Each thread:<br/></p>
<ul>
<li>Clones the <code>Arc</code> pointer to get a new reference to the shared <code>Mutex</code>.<br/></li>
<li>Locks the <code>Mutex</code> to get mutable access to the counter.</li>
<li>Increments the counter by 1.<br/></li>
</ul>
</li>
<li>
<p>Another loop is used to join all the spawned threads, ensuring that the main thread waits for all the threads to finish execution.<br/></p>
</li>
<li>
<p>Finally, the value of the counter is printed, which should be 10 if all threads have successfully incremented the counter.<br/></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h3 id="error-handling"><a class="header" href="#error-handling">Error Handling</a></h3>
<p>Error handling is a critical part of writing robust and reliable software. Rust provides powerful tools for handling errors, primarily through the <code>Result</code> and <code>Option</code> types.</p>
<h3 id="the-result-type"><a class="header" href="#the-result-type">The <code>Result</code> Type</a></h3>
<p>The <code>Result</code> type is used for functions that can return an error. It is an enum with two variants: <code>Ok(T)</code> for successful results and <code>Err(E)</code> for errors.</p>
<pre><pre class="playground"><code class="language-rust">fn divide(a: f64, b: f64) -&gt; Result&lt;f64, String&gt; {
    if b == 0.0 {
        Err(String::from(&quot;Division by zero&quot;))
    } else {
        Ok(a / b)
    }
}

fn main() {
    match divide(4.0, 2.0) {
        Ok(result) =&gt; println!(&quot;Result: {}&quot;, result),
        Err(e) =&gt; println!(&quot;Error: {}&quot;, e),
    }

    match divide(5.0, 0.0) {
        Ok(result) =&gt; println!(&quot;Result: {}&quot;, result),
        Err(e) =&gt; println!(&quot;Error: {}&quot;, e),
    }
}
</code></pre></pre>
<h3 id="the-option-type"><a class="header" href="#the-option-type">The <code>Option</code> Type</a></h3>
<p>The <code>Option</code> type is used for values that may or may not be present. It is an enum with two variants: <code>Some(T)</code> for a value and <code>None</code> for no value.</p>
<pre><pre class="playground"><code class="language-rust">fn find_word(s: &amp;str, word: &amp;str) -&gt; Option&lt;usize&gt; {
    s.find(word)
}

fn main() {
    match find_word(&quot;hello world&quot;, &quot;world&quot;) {
        Some(index) =&gt; println!(&quot;Found at index: {}&quot;, index),
        None =&gt; println!(&quot;Not found&quot;),
    }
}
</code></pre></pre>
<h3 id="the--operator"><a class="header" href="#the--operator">The <code>?</code> Operator</a></h3>
<p>The <code>?</code> operator is a shorthand for propagating errors. It can be used in functions that return a <code>Result</code> or <code>Option</code>.</p>
<pre><pre class="playground"><code class="language-rust">use std::fs::File;
use std::io::Read;

fn read_file(path: &amp;str) -&gt; Result&lt;String, std::io::Error&gt; {
    let mut file = std::fs::File::open(path)?;
    let mut contents = String::new();
    file.read_to_string(&amp;mut contents)?;
    Ok(contents)
}

fn main() {
    match read_file(&quot;example.txt&quot;) {
        Ok(contents) =&gt; println!(&quot;File contents: {}&quot;, contents),
        Err(e) =&gt; println!(&quot;Error reading file: {}&quot;, e),
    }
}
</code></pre></pre>
<h3 id="custom-error-types"><a class="header" href="#custom-error-types">Custom Error Types</a></h3>
<p>You can define your own error types to provide more context about errors.</p>
<pre><pre class="playground"><code class="language-rust">use std::fmt;

#[derive(Debug)]
enum MyError {
    IoError(std::io::Error),
    ParseError(std::num::ParseIntError),
}

impl fmt::Display for MyError {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        match *self {
            MyError::IoError(ref err) =&gt; write!(f, &quot;IO error: {}&quot;, err),
            MyError::ParseError(ref err) =&gt; write!(f, &quot;Parse error: {}&quot;, err),
        }
    }
}

impl From&lt;std::io::Error&gt; for MyError {
    fn from(err: std::io::Error) -&gt; MyError {
        MyError::IoError(err)
    }
}

impl From&lt;std::num::ParseIntError&gt; for MyError {
    fn from(err: std::num::ParseIntError) -&gt; MyError {
        MyError::ParseError(err)
    }
}

fn read_and_parse_file(path: &amp;str) -&gt; Result&lt;i32, MyError&gt; {
    let contents = std::fs::read_to_string(path)?;
    let number: i32 = contents.trim().parse()?;
    Ok(number)
}

fn main() {
    match read_and_parse_file(&quot;number.txt&quot;) {
        Ok(number) =&gt; println!(&quot;Parsed number: {}&quot;, number),
        Err(e) =&gt; println!(&quot;Error: {}&quot;, e),
    }
}
</code></pre></pre>
<p>We define a custom error type <code>MyError</code> that can represent both I/O errors and parsing errors. We then implement the <code>fmt::Display</code> trait for <code>MyError</code> to provide a user-friendly error message. Additionally, we implement the <code>From</code> trait to convert from <code>std::io::Error</code> and <code>std::num::ParseIntError</code> to <code>MyError</code>. This allows us to use the <code>?</code> operator to propagate these errors in the <code>read_and_parse_file</code> function.</p>
<p>These patterns cover the basics of error handling in Rust. By using <code>Result</code>, <code>Option</code>, the <code>?</code> operator, and custom error types, you can write code that gracefully handles errors and provides useful feedback.</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="lifetime-in-rust"><a class="header" href="#lifetime-in-rust">Lifetime in Rust</a></h3>
<p>In Rust, lifetimes are a way of ensuring that references are valid for as long as they are needed and no longer. Lifetimes prevent dangling references, which can lead to undefined behavior.</p>
<pre><pre class="playground"><code class="language-rust">fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}

fn main() {
    let string1 = String::from(&quot;long string is long&quot;);
    let string2 = &quot;xyz&quot;;

    let result = longest(string1.as_str(), string2);
    println!(&quot;The longest string is {}&quot;, result);
}
</code></pre></pre>
<p>The function <code>longest</code> takes two string slices with the same lifetime <code>'a</code> and returns a string slice with the same lifetime <code>'a</code>. This ensures that the returned reference is valid as long as both input references are valid.</p>
<h3 id="key-points"><a class="header" href="#key-points">Key Points</a></h3>
<ul>
<li>Lifetimes are denoted with an apostrophe followed by a name, like <code>'a</code>.</li>
<li>They help the Rust compiler ensure that references do not outlive the data they point to.</li>
<li>Lifetimes are inferred by the compiler in many cases, but sometimes they need to be explicitly annotated.</li>
</ul>
<p>For more detailed information, refer to the <a href="https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html">Rust Book</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="modules-in-rust"><a class="header" href="#modules-in-rust">Modules in Rust</a></h3>
<p>Modules are a way to organize code into separate namespaces. They help in managing scope and privacy, making the code more modular and easier to maintain.</p>
<h3 id="defining-a-module"><a class="header" href="#defining-a-module">Defining a Module</a></h3>
<p>You can define a module using the <code>mod</code> keyword. Here's a basic example:</p>
<pre><pre class="playground"><code class="language-rust">mod my_module {
    pub fn say_hello() {
        println!(&quot;Hello from my_module!&quot;);
    }
}

fn main() {
    my_module::say_hello();
}
</code></pre></pre>
<ul>
<li><code>mod my_module</code> defines a module named <code>my_module</code>.</li>
<li><code>pub fn say_hello()</code> defines a public function within the module.</li>
<li><code>my_module::say_hello()</code> calls the function from the main function.</li>
</ul>
<h3 id="nested-modules"><a class="header" href="#nested-modules">Nested Modules</a></h3>
<p>Modules can be nested within other modules:</p>
<pre><pre class="playground"><code class="language-rust">mod outer_module {
    pub mod inner_module {
        pub fn say_hello() {
            println!(&quot;Hello from inner_module!&quot;);
        }
    }
}

fn main() {
    outer_module::inner_module::say_hello();
}
</code></pre></pre>
<ul>
<li><code>pub mod inner_module</code> defines a nested module within <code>outer_module</code>.</li>
<li><code>outer_module::inner_module::say_hello()</code> calls the function from the main function.</li>
</ul>
<h3 id="module-files"><a class="header" href="#module-files">Module Files</a></h3>
<p>Modules can also be defined in separate files. For example, you can create a file structure like this:</p>
<pre><code>src/
├── main.rs
└── my_module.rs
</code></pre>
<p>In <code>main.rs</code>:</p>
<pre><code class="language-rust noplaypen">mod my_module;

fn main() {
    my_module::say_hello();
}
</code></pre>
<p>In <code>my_module.rs</code>:</p>
<pre><code class="language-rust noplaypen">pub fn say_hello() {
    println!(&quot;Hello from my_module!&quot;);
}
</code></pre>
<p>This structure helps in keeping the codebase organized and manageable.</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="crates-in-rust"><a class="header" href="#crates-in-rust">Crates in Rust</a></h3>
<p>In Rust, a crate is the smallest unit of code distribution. Crates can produce an executable or a library. There are two types of crates:</p>
<ol>
<li><strong>Binary Crates</strong>: These are programs that can be compiled to an executable.</li>
<li><strong>Library Crates</strong>: These are collections of code that can be shared and reused by other programs.</li>
</ol>
<h3 id="creating-a-binary-crate"><a class="header" href="#creating-a-binary-crate">Creating a Binary Crate</a></h3>
<p>To create a binary crate, you can use the <code>cargo new</code> command:</p>
<pre><code class="language-sh">cargo new my_binary_crate
</code></pre>
<p>This will create a new directory named <code>my_binary_crate</code> with the following structure:</p>
<pre><code>my_binary_crate/
├── Cargo.toml
└── src
    └── main.rs
</code></pre>
<p>The <code>main.rs</code> file is the entry point of the binary crate.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<h3 id="creating-a-library-crate"><a class="header" href="#creating-a-library-crate">Creating a Library Crate</a></h3>
<p>To create a library crate, you can use the <code>cargo new</code> command with the <code>--lib</code> flag:</p>
<pre><code class="language-sh">cargo new my_library_crate --lib
</code></pre>
<p>This will create a new directory named <code>my_library_crate</code> with the following structure:</p>
<pre><code>my_library_crate/
├── Cargo.toml
└── src
    └── lib.rs
</code></pre>
<p>The <code>lib.rs</code> file is the entry point of the library crate.</p>
<pre><code class="language-rust noplaypen">pub fn hello() {
    println!(&quot;Hello, library!&quot;);
}
</code></pre>
<h3 id="using-crates"><a class="header" href="#using-crates">Using Crates</a></h3>
<p>To use an external crate in your project, you need to add it to your <code>Cargo.toml</code> file. For example, to use the <code>rand</code> crate, you would add the following line to your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
rand = &quot;0.8&quot;
</code></pre>
<p>Then, you can use the crate in your code:</p>
<pre><code class="language-rust noplaypen">use rand::Rng;

fn main() {
    let mut rng = rand::thread_rng();
    let n: u32 = rng.gen();
    println!(&quot;Random number: {}&quot;, n);
}
</code></pre>
<p>Crates are a fundamental concept in Rust that allow you to organize and share your code. By understanding how to create and use crates, you can take full advantage of Rust's powerful module system.</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="types"><a class="header" href="#types">Types</a></h3>
<p>Types in Rust are a way to define the kind of data that can be stored and manipulated within a program. Rust is a statically typed language, which means that the type of every variable must be known at compile time. This helps catch many errors early in the development process and ensures memory safety.</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="scalar-types"><a class="header" href="#scalar-types">Scalar Types</a></h3>
<p>Scalar types represent a single value. Rust has four primary scalar types:</p>
<p><strong>Integers</strong>: Whole numbers, both signed and unsigned.<br/>
<strong>Floating-Point Numbers</strong>: Numbers with decimal points.<br/>
<strong>Booleans</strong>: True or false values.<br/>
<strong>Characters</strong>: Single Unicode characters.<br/></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x: i32 = 42; // Integer
    let y: f64 = 3.14; // Floating-point number
    let is_active: bool = true; // Boolean
    let letter: char = 'A'; // Character

    println!(&quot;x: {}, y: {}, is_active: {}, letter: {}&quot;, x, y, is_active, letter);
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="compound-types"><a class="header" href="#compound-types">Compound Types</a></h3>
<p>Compound types can group multiple values into one type. Rust has two primary compound types:</p>
<p>Tuples: Group multiple values of different types.<br/>
Arrays: Group multiple values of the same type.<br/></p>
<p>Example:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // Tuple
    let tuple: (i32, f64, char) = (42, 3.14, 'A');
    let (x, y, z) = tuple;
    println!(&quot;Tuple: ({}, {}, {})&quot;, x, y, z);

    // Array
    let array: [i32; 3] = [1, 2, 3];
    println!(&quot;Array: {:?}&quot;, array);
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="what-is-trait"><a class="header" href="#what-is-trait">What is <strong>trait</strong>?</a></h3>
<p>In Rust, a trait is a way to define shared behavior in an abstract way. It is similar to interfaces in other programming languages. A trait defines a set of methods that a type must implement. Traits are used to define shared behavior and to enable polymorphism.</p>
<h3 id="purpose-of-traits"><a class="header" href="#purpose-of-traits">Purpose of Traits</a></h3>
<p><strong>Define Shared Behavior</strong>: Traits allow you to define methods that can be shared across different types.<br/>
<strong>Enable Polymorphism</strong>: Traits enable polymorphism, allowing you to write code that can operate on different types in a generic way.<br/>
<strong>Abstract Over Types</strong>: Traits allow you to abstract over types, enabling you to write more flexible and reusable code.<br/></p>
<p>In the sample code below the Greet trait is defined with a single method greet. The Greet trait is implemented for two structs, Person and Dog. </p>
<pre><pre class="playground"><code class="language-rust">// Define a trait named `Greet`
pub trait Greet {
    fn greet(&amp;self);
}

// Define a struct named `Person`
pub struct Person {
    name: String,
}

// Implement the `Greet` trait for the `Person` struct
impl Greet for Person {
    fn greet(&amp;self) {
        println!(&quot;Hello, my name is {}!&quot;, self.name);
    }
}

// Define a struct named `Dog`
pub struct Dog {
    name: String,
}

// Implement the `Greet` trait for the `Dog` struct
impl Greet for Dog {
    fn greet(&amp;self) {
        println!(&quot;Woof! My name is {}!&quot;, self.name);
    }
}


fn main() {
    // Create instances of `Person` and `Dog`
    let person = Person {
        name: String::from(&quot;Alice&quot;),
    };
    let dog = Dog {
        name: String::from(&quot;Buddy&quot;),
    };
    dog.greet();
    person.greet();
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="what-is-a-struct"><a class="header" href="#what-is-a-struct">What is a struct?</a></h3>
<p>Structs in Rust are custom data types that allow you to group related data together. They are similar to classes in object-oriented languages but without the associated methods for encapsulation. Structs are used to create complex data types that can be used to model real-world entities.</p>
<h3 id="types-of-structs"><a class="header" href="#types-of-structs">Types of Structs</a></h3>
<p><strong>Classic Structs</strong>: </p>
<p>These are the most common type of structs, where each field has a name and a type. Classic structs have named fields. E.g.:</p>
<pre><pre class="playground"><code class="language-rust">struct Person {
    name: String,
    age: u8,
}

fn main() {
    let person = Person {
        name: String::from(&quot;Alice&quot;),
        age: 30,
    };

    println!(&quot;Name: {}, Age: {}&quot;, person.name, person.age);
}
</code></pre></pre>
<p><strong>Tuple Structs</strong>: </p>
<p>These are similar to tuples but have a name and can be used to create new types. Tuple structs have unnamed fields. E.g.:</p>
<pre><pre class="playground"><code class="language-rust">struct Color(u8, u8, u8);

fn main() {
    let black = Color(0, 0, 0);

    println!(&quot;Black color: ({}, {}, {})&quot;, black.0, black.1, black.2);
}
</code></pre></pre>
<p><strong>Unit-like Structs</strong>: </p>
<p>These are structs without any fields and are useful for generics or traits. Unit-like structs have no fields. E.g.:</p>
<pre><pre class="playground"><code class="language-rust">struct Unit;

fn main() {
    let unit = Unit;

    println!(&quot;Unit struct created!&quot;);
}
</code></pre></pre>
<p>You can define methods and associated functions for structs using the <a href="rust/essentials/types/./imp.html">impl</a> keyword.</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="what-is-an-enum"><a class="header" href="#what-is-an-enum">What is an enum?</a></h3>
<p>Enums in Rust are a way to define a type by enumerating its possible values. They are similar to enums in other programming languages but are more powerful because each variant of an enum can have associated data. Enums are used to represent a value that could be one of several different types.</p>
<h3 id="defining-enums"><a class="header" href="#defining-enums">Defining Enums</a></h3>
<p>Enums are defined using the enum keyword, followed by the name of the enum and its variants.</p>
<pre><pre class="playground"><code class="language-rust">enum Direction {
    North,
    South,
    East,
    West,
}

fn main() {
    let direction = Direction::North;

    match direction {
        Direction::North =&gt; println!(&quot;Heading North!&quot;),
        Direction::South =&gt; println!(&quot;Heading South!&quot;),
        Direction::East =&gt; println!(&quot;Heading East!&quot;),
        Direction::West =&gt; println!(&quot;Heading West!&quot;),
    }
}
</code></pre></pre>
<p>Enums can have variants with associated data, which makes them very powerful.</p>
<pre><pre class="playground"><code class="language-rust">enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

fn main() {
    let msg1 = Message::Quit;
    let msg2 = Message::Move { x: 10, y: 20 };
    let msg3 = Message::Write(String::from(&quot;Hello&quot;));
    let msg4 = Message::ChangeColor(255, 0, 0);

    match msg1 {
        Message::Quit =&gt; println!(&quot;Quit message&quot;),
        Message::Move { x, y } =&gt; println!(&quot;Move to ({}, {})&quot;, x, y),
        Message::Write(text) =&gt; println!(&quot;Write message: {}&quot;, text),
        Message::ChangeColor(r, g, b) =&gt; println!(&quot;Change color to ({}, {}, {})&quot;, r, g, b),
    }
}
</code></pre></pre>
<p>You can also define methods on enums using the impl keyword.</p>
<pre><pre class="playground"><code class="language-rust">enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

impl Message {
    fn call(&amp;self) {
        match self {
            Message::Quit =&gt; println!(&quot;Quit message&quot;),
            Message::Move { x, y } =&gt; println!(&quot;Move to ({}, {})&quot;, x, y),
            Message::Write(text) =&gt; println!(&quot;Write message: {}&quot;, text),
            Message::ChangeColor(r, g, b) =&gt; println!(&quot;Change color to ({}, {}, {})&quot;, r, g, b),
        }
    }
}

fn main() {
    let msg = Message::Write(String::from(&quot;Hello&quot;));
    msg.call();
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="what-is-the-differences-between-structs-vs-enums"><a class="header" href="#what-is-the-differences-between-structs-vs-enums">What is the differences between Structs vs Enums?</a></h3>
<p>Enums and structs are both ways to define custom data types in Rust, but they serve different purposes and have different characteristics. Here’s a detailed comparison of enums and structs:</p>
<p><a href="rust/essentials/types/./struct.html"><strong>Structs</strong></a></p>
<p>Structs are used to group related data together. They are similar to classes in object-oriented languages but without methods for encapsulation. Structs are typically used to represent entities with a fixed set of attributes.</p>
<h3 id="characteristics-of-structs"><a class="header" href="#characteristics-of-structs">Characteristics of Structs</a></h3>
<p><strong>Fixed Set of Fields</strong>: Structs have a fixed set of fields, each with a name and a type.<br/>
<strong>Homogeneous Data</strong>: All instances of a struct have the same fields.<br/>
<strong>Data Grouping</strong>: Structs are used to group related data together.<br/></p>
<p><a href="rust/essentials/types/./enum.html"><strong>Enums</strong></a></p>
<p>Enums are used to define a type that can be one of several different variants. Each variant can have associated data. Enums are typically used to represent a value that could be one of several different types.</p>
<h3 id="characteristics-of-enums"><a class="header" href="#characteristics-of-enums">Characteristics of Enums</a></h3>
<p><strong>Multiple Variants</strong>: Enums can have multiple variants, each representing a different possible value.<br/>
<strong>Heterogeneous Data</strong>: Each variant of an enum can have different types and amounts of associated data.<br/>
<strong>Pattern Matching</strong>: Enums are often used with pattern matching to handle different cases.<br/></p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="what-is-generics"><a class="header" href="#what-is-generics">What is generics?</a></h3>
<p>Generics in Rust allow you to write flexible and reusable code by enabling you to define functions, <a href="rust/essentials/types/./struct.html">structs</a>, <a href="rust/essentials/types/./enum.html">enums</a>, and <a href="rust/essentials/types/./trait.html">traits</a> that can operate on many different types without sacrificing performance. Generics are a powerful feature that helps you write more abstract and type-safe code.</p>
<h3 id="key-concepts-of-generics"><a class="header" href="#key-concepts-of-generics">Key Concepts of Generics</a></h3>
<p>Generic Functions can operate on different types specified at the time of function call.</p>
<p>In the example, the <strong>first</strong> function is defined with a generic type parameter T. This means that T can be any type. The function takes two parameters, x and _y, both of type T. The function returns the first parameter x of type T. In the main function, the first function is called with different types of arguments (integers and strings), demonstrating its flexibility.</p>
<pre><pre class="playground"><code class="language-rust">fn first&lt;T&gt;(x: T, _y: T) -&gt; T {
    x
}

fn main() {
    let a = 10;
    let b = 20;
    let result = first(a, b);
    println!(&quot;The first value is: {}&quot;, result);

    let c = &quot;hello&quot;;
    let d = &quot;world&quot;;
    let result = first(c, d);
    println!(&quot;The first value is: {}&quot;, result);
}
</code></pre></pre>
<p>Structs that can hold data of different types specified at the time of instantiation.</p>
<p>Here the Point struct has been implemented to work with both integer and floating type.</p>
<pre><pre class="playground"><code class="language-rust">struct Point&lt;T&gt; {
    x: T,
    y: T,
}

fn main() {
    let integer_point = Point { x: 5, y: 10 };
    let float_point = Point { x: 1.0, y: 4.0 };

    println!(&quot;Integer Point: ({}, {})&quot;, integer_point.x, integer_point.y);
    println!(&quot;Float Point: ({}, {})&quot;, float_point.x, float_point.y);
}
</code></pre></pre>
<p>Enums that can hold variants of different types specified at the time of instantiation.</p>
<pre><pre class="playground"><code class="language-rust">enum Option&lt;T&gt; {
    Some(T),
    None,
}

fn main() {
    let some_number = Option::Some(5);
    let some_string = Option::Some(&quot;a string&quot;);

    println!(&quot;Some number: {:?}&quot;, some_number);
    println!(&quot;Some string: {:?}&quot;, some_string);
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="what-is-type-alias-in-rust"><a class="header" href="#what-is-type-alias-in-rust">What is type alias in Rust?</a></h1>
<p>In Rust, a type alias allows you to create a new name for an existing type. This can make your code more readable and easier to manage, especially when dealing with complex types. Type aliases are created using the <code>type</code> keyword.</p>
<h3 id="benefits-of-type-aliases"><a class="header" href="#benefits-of-type-aliases">Benefits of Type Aliases</a></h3>
<p>Improved Readability: By giving a meaningful name to a type, you can make your code more understandable. <br/>
Simplified Code: Type aliases can simplify complex type signatures, making the code easier to write and read.<br/>
Consistency: Using type aliases can help maintain consistency across your codebase.<br/></p>
<pre><pre class="playground"><code class="language-rust">// type NewName = ExistingType;

type Kilometers = i32;

fn main() {
    let distance: Kilometers = 100;
    println!(&quot;Distance: {} km&quot;, distance);
}
</code></pre></pre>
<p><code>Kilometers</code> is a type alias for <code>i32</code>. This makes it clear that the distance variable represents a distance in kilometers.</p>
<pre><pre class="playground"><code class="language-rust">struct Point&lt;T&gt; {
    x: T,
    y: T,
}

type IntPoint = Point&lt;i32&gt;;
type FloatPoint = Point&lt;f64&gt;;

fn main() {
    let int_point: IntPoint = Point { x: 5, y: 10 };
    let float_point: FloatPoint = Point { x: 1.0, y: 4.0 };

    println!(&quot;IntPoint: ({}, {})&quot;, int_point.x, int_point.y);
    println!(&quot;FloatPoint: ({}, {})&quot;, float_point.x, float_point.y);
}
</code></pre></pre>
<p><code>IntPoint</code> and <code>FloatPoint</code> are type aliases for <code>Point&lt;i32&gt;</code> and <code>Point&lt;f64&gt;</code>, respectively. This makes it clear what type of points are being used.</p>
<p>Type aliases are particularly useful for complex types, such as function pointers or nested types. </p>
<pre><pre class="playground"><code class="language-rust">type Thunk = Box&lt;dyn Fn() + Send + 'static&gt;;

fn takes_long_type(f: Thunk) {
    // Do something with the function
}

fn returns_long_type() -&gt; Thunk {
    Box::new(|| println!(&quot;Hello, world!&quot;))
}

fn main() {
    let f: Thunk = returns_long_type();
    takes_long_type(f);
}
</code></pre></pre>
<p><code>type Thunk = Box&lt;dyn Fn() + Send + 'static&gt;;</code> creates a type alias named Thunk.<br/>
<strong>Box</strong>: Box is a smart pointer that allocates data on the heap.<br/>
<strong>dyn Fn()</strong>: dyn Fn() is a trait object representing a closure that takes no arguments and returns nothing.<br/>
<strong>Send</strong>: The Send trait indicates that the closure can be transferred across thread boundaries.<br/>
<strong>'static</strong>: The 'static lifetime means that the closure can live for the entire duration of the program.<br/></p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="what-is-pointers-and-how-they-are-used-in-rust"><a class="header" href="#what-is-pointers-and-how-they-are-used-in-rust">What is pointers and how they are used in Rust?</a></h3>
<p>In Rust, pointers are types that represent memory addresses. Rust provides several types of pointers, each with different characteristics and use cases. Pointers are used to reference data stored in memory, and Rust's ownership and borrowing rules ensure that pointers are used safely.</p>
<h3 id="types-of-pointers-in-rust"><a class="header" href="#types-of-pointers-in-rust">Types of Pointers in Rust</a></h3>
<p><strong>References</strong>: Immutable and mutable references.<br/>
<strong>Smart Pointers</strong>: Box, Rc, Arc, and others.<br/>
<strong>Raw Pointers</strong>: Unsafe pointers.<br/></p>
<h3 id="references"><a class="header" href="#references">References</a></h3>
<p>References are the most common type of pointer in Rust. They allow you to borrow data without taking ownership. There are two types of references:</p>
<p>Immutable References (<code>&amp;T</code>): Allow you to read data but not modify it.<br/>
Mutable References (<code>&amp;mut T</code>): Allow you to modify data.<br/></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 5;
    let y = &amp;x; // Immutable reference
    println!(&quot;y: {}&quot;, y);

    let mut z = 10;
    let w = &amp;mut z; // Mutable reference
    *w += 5;
    println!(&quot;z: {}&quot;, z);
}
</code></pre></pre>
<h3 id="smart-pointers"><a class="header" href="#smart-pointers">Smart Pointers</a></h3>
<p>Smart pointers are data structures that not only act like a pointer but also have additional capabilities, such as automatic memory management. Common smart pointers in Rust include:</p>
<p><strong>Box</strong>: A heap-allocated pointer.<br/></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let b = Box::new(5);
    println!(&quot;b: {}&quot;, b);
}
</code></pre></pre>
<p><strong>Rc</strong>: A reference-counted pointer for single-threaded scenarios.<br/></p>
<pre><pre class="playground"><code class="language-rust">use std::rc::Rc;

fn main() {
    let a = Rc::new(5);
    let b = Rc::clone(&amp;a);
    println!(&quot;a: {}, b: {}&quot;, a, b);
}
</code></pre></pre>
<p><strong>Arc</strong>: An atomic reference-counted pointer for multi-threaded scenarios.<br/></p>
<pre><pre class="playground"><code class="language-rust">use std::sync::Arc;
use std::thread;

fn main() {
    let a = Arc::new(5);
    let b = Arc::clone(&amp;a);

    let handle = thread::spawn(move || {
        println!(&quot;b: {}&quot;, b);
    });

    println!(&quot;a: {}&quot;, a);
    handle.join().unwrap();
}
</code></pre></pre>
<h3 id="raw-pointers"><a class="header" href="#raw-pointers">Raw Pointers</a></h3>
<p>Raw pointers are unsafe pointers that can be used to perform low-level memory manipulation. They are not subject to Rust's borrowing rules and must be used within an <code>unsafe</code> block.</p>
<p>Immutable Raw Pointer (<code>*const T</code>): Points to data that cannot be modified.<br/>
Mutable Raw Pointer (<code>*mut T</code>): Points to data that can be modified.<br/></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 5;
    let y = &amp;x as *const i32; // Immutable raw pointer

    let mut z = 10;
    let w = &amp;mut z as *mut i32; // Mutable raw pointer

    unsafe {
        println!(&quot;y: {}&quot;, *y);
        *w += 5;
        println!(&quot;z: {}&quot;, *w);
    }
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="vectors-in-rust"><a class="header" href="#vectors-in-rust">Vectors in Rust</a></h3>
<p>Vectors in Rust are a dynamic array type provided by the standard library. They are implemented as the <code>Vec&lt;T&gt;</code> type, where <code>T</code> represents the type of elements stored in the vector. Vectors can grow or shrink in size and provide efficient indexing and iteration.</p>
<h3 id="creating-a-vector"><a class="header" href="#creating-a-vector">Creating a Vector</a></h3>
<p>You can create a new vector using the <code>Vec::new</code> method or the <code>vec!</code> macro:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut v: Vec&lt;i32&gt; = Vec::new();
let v = vec![1, 2, 3, 4, 5];
<span class="boring">}
</span></code></pre></pre>
<h3 id="adding-elements"><a class="header" href="#adding-elements">Adding Elements</a></h3>
<p>You can add elements to a vector using the <code>push</code> method:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut v = Vec::new();
v.push(1);
v.push(2);
v.push(3);
<span class="boring">}
</span></code></pre></pre>
<h3 id="accessing-elements"><a class="header" href="#accessing-elements">Accessing Elements</a></h3>
<p>You can access elements in a vector using indexing or the <code>get</code> method:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v = vec![1, 2, 3, 4, 5];
println!(&quot;The third element is {}&quot;, v[2]);

match v.get(2) {
    Some(third) =&gt; println!(&quot;The third element is {}&quot;, third),
    None =&gt; println!(&quot;There is no third element.&quot;),
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="iterating-over-a-vector"><a class="header" href="#iterating-over-a-vector">Iterating Over a Vector</a></h3>
<p>You can iterate over the elements of a vector using a <code>for</code> loop:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v = vec![1, 2, 3, 4, 5];
for i in &amp;v {
    println!(&quot;{}&quot;, i);
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="removing-elements"><a class="header" href="#removing-elements">Removing Elements</a></h3>
<p>You can remove elements from a vector using the <code>pop</code> method or the <code>remove</code> method:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut v = vec![1, 2, 3, 4, 5];
v.pop(); // Removes the last element
v.remove(1); // Removes the element at index 1
<span class="boring">}
</span></code></pre></pre>
<p>Vectors are a versatile and powerful collection type in Rust, suitable for many use cases where dynamic arrays are needed.</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="what-are-operators"><a class="header" href="#what-are-operators">What are operators?</a></h3>
<p>Operators are special symbols or keywords that are used to perform operations on variables and values. Rust supports a variety of operators, including <a href="rust/essentials/operators/./arithmetic-operations.html">arithmetic</a>, <a href="rust/essentials/operators/./comparison-operations.html">comparison</a>, <a href="rust/essentials/operators/./logical-operations.html">logical</a>, <a href="rust/essentials/operators/./bitwise-operations.html">bitwise</a>, and <a href="rust/essentials/operators/./assignement-operations.html">assignment</a> operators. </p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="arithmetic-operations"><a class="header" href="#arithmetic-operations">Arithmetic operations</a></h3>
<p>Arithmetic operators are used to perform basic mathematical operations.</p>
<p><code>+</code> : Addition<br/>
<code>-</code> : Subtraction<br/>
<code>*</code> : Multiplication<br/>
<code>/</code> : Division<br/>
<code>%</code> : Remainder (modulus)<br/></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let a = 10;
    let b = 3;

    println!(&quot;a + b = {}&quot;, a + b); // Addition
    println!(&quot;a - b = {}&quot;, a - b); // Subtraction
    println!(&quot;a * b = {}&quot;, a * b); // Multiplication
    println!(&quot;a / b = {}&quot;, a / b); // Division
    println!(&quot;a % b = {}&quot;, a % b); // Remainder
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="comparison-operators"><a class="header" href="#comparison-operators">Comparison Operators</a></h3>
<p>Comparison operators are used to compare two values and return a boolean result.</p>
<p><code>==</code> : Equal to<br/>
<code>!=</code> : Not equal to<br/>
<code>&gt;</code> : Greater than<br/>
<code>&lt;</code> : Less than<br/>
<code>&gt;=</code> : Greater than or equal to<br/>
<code>&lt;=</code> : Less than or equal to<br/></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let a = 10;
    let b = 3;

    println!(&quot;a == b: {}&quot;, a == b); // Equal to
    println!(&quot;a != b: {}&quot;, a != b); // Not equal to
    println!(&quot;a &gt; b: {}&quot;, a &gt; b); // Greater than
    println!(&quot;a &lt; b: {}&quot;, a &lt; b); // Less than
    println!(&quot;a &gt;= b: {}&quot;, a &gt;= b); // Greater than or equal to
    println!(&quot;a &lt;= b: {}&quot;, a &lt;= b); // Less than or equal to
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="logical-operators"><a class="header" href="#logical-operators">Logical Operators</a></h3>
<p>Logical operators are used to combine multiple boolean expressions.</p>
<p><code>&amp;&amp;</code> : Logical AND<br/>
<code>||</code> : Logical OR<br/>
<code>!</code> : Logical NOT<br/></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let a = true;
    let b = false;

    println!(&quot;a &amp;&amp; b: {}&quot;, a &amp;&amp; b); // Logical AND
    println!(&quot;a || b: {}&quot;, a || b); // Logical OR
    println!(&quot;!a: {}&quot;, !a); // Logical NOT
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="bitwise-operators"><a class="header" href="#bitwise-operators">Bitwise Operators</a></h3>
<p>Bitwise operators are used to perform operations on individual bits of integer types.</p>
<p><code>&amp;</code> : Bitwise AND<br/>
<code>|</code> : Bitwise OR<br/>
<code>^</code> : Bitwise XOR<br/>
<code>&lt;&lt;</code> : Left shift<br/>
<code>&gt;&gt;</code> : Right shift<br/></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let a = 0b1100;
    let b = 0b1010;

    println!(&quot;a &amp; b: {:04b}&quot;, a &amp; b); // Bitwise AND
    println!(&quot;a | b: {:04b}&quot;, a | b); // Bitwise OR
    println!(&quot;a ^ b: {:04b}&quot;, a ^ b); // Bitwise XOR
    println!(&quot;a &lt;&lt; 1: {:04b}&quot;, a &lt;&lt; 1); // Left shift
    println!(&quot;a &gt;&gt; 1: {:04b}&quot;, a &gt;&gt; 1); // Right shift
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="assignment-operators"><a class="header" href="#assignment-operators">Assignment Operators</a></h3>
<p>Assignment operators are used to assign values to variables. Rust also supports compound assignment operators that combine an arithmetic operation with assignment.</p>
<p><code>=</code> : Assignment<br/>
<code>+=</code> : Addition assignment<br/>
<code>-=</code> : Subtraction assignment<br/>
<code>*=</code> : Multiplication assignment<br/>
<code>/=</code> : Division assignment<br/>
<code>%=</code> : Remainder assignment<br/></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut a = 10;

    a += 5; // Addition assignment
    println!(&quot;a += 5: {}&quot;, a);

    a -= 3; // Subtraction assignment
    println!(&quot;a -= 3: {}&quot;, a);

    a *= 2; // Multiplication assignment
    println!(&quot;a *= 2: {}&quot;, a);

    a /= 4; // Division assignment
    println!(&quot;a /= 4: {}&quot;, a);

    a %= 3; // Remainder assignment
    println!(&quot;a %= 3: {}&quot;, a);
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="packing-and-related-topics"><a class="header" href="#packing-and-related-topics">Packing and related topics</a></h3>
<p>This section contains random information about Cargo and various other bits and pieces on building a Rust project.</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="what-is-the-purpose-of-no_std"><a class="header" href="#what-is-the-purpose-of-no_std">What is the purpose of ![no_std]?</a></h3>
<p>The #![no_std] attribute in Rust is used to indicate that a crate does not use the Rust standard library (std). Instead, it relies on the core library (core), which is a subset of the standard library and is available in environments where the full standard library is not available, such as embedded systems or operating system kernels.</p>
<p>Usecases can be grouped into a few items;</p>
<ul>
<li>Many embedded systems do not have the resources to support the full standard library.<br/></li>
<li>When writing an operating system, you often need to avoid dependencies on the standard library.<br/></li>
<li>Any environment where the standard library is not available or not desired.<br/></li>
<li>Targeting WebAssembly where the standard library is not fully supported.</li>
</ul>
<pre><pre class="playground"><code class="language-rust">#![no_std]

extern crate core;

use core::fmt;

struct MyStruct;

impl fmt::Display for MyStruct {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;Hello, no_std!&quot;)
    }
}

fn main() {
    let my_struct = MyStruct;
    println!(&quot;{}&quot;, my_struct); // This will not work because println! is part of std
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="how-to-call-a-function-from-a-standard-library"><a class="header" href="#how-to-call-a-function-from-a-standard-library">How to call a function from a standard library:</a></h3>
<pre><pre class="playground"><code class="language-rust">use std::time::{SystemTime, UNIX_EPOCH};

fn main() {
    // Get the current system time
    match SystemTime::now().duration_since(UNIX_EPOCH) {
        Ok(n) =&gt; println!(&quot;Current time since UNIX EPOCH: {} seconds&quot;, n.as_secs()),
        Err(_) =&gt; println!(&quot;SystemTime before UNIX EPOCH!&quot;),
    }
}
</code></pre></pre>
<h3 id="how-to-call-a-function-from-a-library-on-cratesio"><a class="header" href="#how-to-call-a-function-from-a-library-on-cratesio">How to call a function from a library on Crates.io:</a></h3>
<p>For external libraries, you can specify the external module in the Cargo.toml file.</p>
<pre><code class="language-rust noplaypen">use regex::Regex;

fn main() {
    // Create a regex pattern
    let re = Regex::new(r&quot;^\d{4}-\d{2}-\d{2}$&quot;).unwrap();

    // Test if the pattern matches a string
    let date = &quot;2023-10-05&quot;;
    if re.is_match(date) {
        println!(&quot;The date {} is in the correct format.&quot;, date);
    } else {
        println!(&quot;The date {} is not in the correct format.&quot;, date);
    }
}
</code></pre>
<p>Cargo.toml file content</p>
<pre><code class="language-toml">[dependencies]
regex = &quot;1.5&quot;
</code></pre>
<h3 id="legacy-solution-for-rust-2015-edition-or-earlier"><a class="header" href="#legacy-solution-for-rust-2015-edition-or-earlier">Legacy solution for Rust 2015 edition or earlier</a></h3>
<p>On the Rust file you may call <code>extern crate PACKAGE_NAME</code> to use an external library. This is a handy solution when you want to use <a href="https://play.rust-lang.org/">Rust Playground</a> like in this example. Otherwise, you would get an error when you execute the file.</p>
<pre><pre class="playground"><code class="language-rust">extern crate rand;
use rand::Rng;

fn main() {
    // Create a random number generator
    let mut rng = rand::thread_rng();

    // Generate a random number between 1 and 10
    let random_number: u32 = rng.gen_range(1..=10);

    println!(&quot;Random number: {}&quot;, random_number);
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="package-name-and-a-quirk-with-dash-hyphens"><a class="header" href="#package-name-and-a-quirk-with-dash-hyphens">Package name and a quirk with dash (hyphens)</a></h3>
<p>Rust supports underscores (_) for package names but not hyphens (-). However, you may see packages on Crates.io with hyphens.</p>
<p><a href="https://github.com/rust-lang/rfcs/blob/master/text/0940-hyphens-considered-harmful.md">The related RFC</a> recommends explicitly renaming those crates with underscores. E.g.</p>
<pre><code>extern crate &quot;rustc-serialize&quot; as rustc_serialize;
</code></pre>
<p>There is <a href="https://www.reddit.com/r/rust/comments/194clzq/underscores_vs_dashes_in_crate_names/">quite a bit of debate</a> about whether hyphens should be used in library names.</p>
<p>Refraining from using hyphens seems to be the most future-proof option, but I agree with the aesthetics aspect of using dash instead of underscore.</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="keywords-helps-to-tag-your-crate-to-improve-seo"><a class="header" href="#keywords-helps-to-tag-your-crate-to-improve-seo">Keywords helps to tag your Crate to improve SEO</a></h3>
<p>To add tags for your crate you may use <code>keywords</code> command in the [package] section in your Cargo.toml file. E.g.</p>
<pre><code class="language-toml">[package]

keywords = [&quot;bcrypt&quot;, &quot;password&quot;, &quot;web&quot;, &quot;hash&quot;]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="how-to-use-unstable-features-in-your-rust-project"><a class="header" href="#how-to-use-unstable-features-in-your-rust-project">How to use unstable features in your Rust project</a></h3>
<p>In Rust, the #! syntax is used for attributes that apply to the entire crate or module. These are known as &quot;inner attributes.&quot; They are typically placed at the top of a file and are used to configure various aspects of the Rust compiler's behavior for that file or crate.</p>
<p>#![feature(...)]: This attribute allows you to use unstable features in your Rust code from the nightly Rust compiler. It must be placed at the top of the file. </p>
<p>As an example, the #![feature(test)] attribute in Rust is used to enable the test crate, which includes benchmarking and testing utilities that are not yet stabilized.</p>
<pre><code class="language-rust noplaypen">#![feature(test)]
extern crate bcrypt;
extern crate test;

use bcrypt::{hash, DEFAULT_COST};

#[bench]
fn bench_cost_4(b: &amp;mut test::Bencher) {
    b.iter(|| hash(&quot;hunter2&quot;, 4));
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="what-is-features"><a class="header" href="#what-is-features">What is features?</a></h3>
<p>Features are a way to conditionally compile code based on specified configurations. They allow you to enable or disable certain functionalities in your crate or its dependencies. Features are defined in the Cargo.toml file and can be used to control optional dependencies, conditional compilation.</p>
<h3 id="defining-features"><a class="header" href="#defining-features">Defining Features</a></h3>
<p>You define features in your crate's Cargo.toml file under the [features] section.</p>
<pre><code class="language-toml">[features]
default = [&quot;feature1&quot;, &quot;feature2&quot;]
feature1 = []
feature2 = [&quot;dependency1/featureA&quot;]
</code></pre>
<p><strong>default</strong>: This is a special feature that is enabled by default when your crate is used as a dependency. It can include other features.<br/>
<strong>feature1 and feature2</strong>: These are custom features that can be enabled or disabled by the user.<br/></p>
<h3 id="using-features-in-code"><a class="header" href="#using-features-in-code">Using Features in Code</a></h3>
<p>You can use features in your Rust code with conditional compilation attributes like <code>#[cfg(feature = &quot;feature_name&quot;)]</code> and <code>#[cfg_attr(feature = &quot;feature_name&quot;, some_attribute)]</code>.</p>
<pre><code class="language-rust  noplaypen">#[cfg(feature = &quot;feature1&quot;)]
fn feature1_function() {
    // Code that is only compiled if &quot;feature1&quot; is enabled
}

#[cfg(feature = &quot;feature2&quot;)]
fn feature2_function() {
    // Code that is only compiled if &quot;feature2&quot; is enabled
}
</code></pre>
<p>When you depend on a crate, you can enable features in your Cargo.toml file:</p>
<pre><code class="language-toml">[dependencies]
my_crate = { version = &quot;1.0&quot;, features = [&quot;feature1&quot;, &quot;feature2&quot;] }
</code></pre>
<p>If you want to depend on a crate but do not want to enable its default features, you can use the <code>default-features = false</code> option:</p>
<pre><code class="language-toml">[dependencies]
my_crate = { version = &quot;1.0&quot;, default-features = false, features = [&quot;feature1&quot;] }
</code></pre>
<p><code>default-features = false</code> disables the <strong>default</strong> features.
<code>features = [&quot;feature1&quot;]</code> enables the <strong>feature1</strong> specifically.</p>
<p><code>features</code>: Allow conditional compilation and optional dependencies.<br/>
<code>default</code> attribute: Default features is enabled by default unless explicitly disabled.<br/></p>
<p>Custom Features can be added in Cargo.toml and enabled or disabled as needed. You can use <code>#[cfg(feature = &quot;feature_name&quot;)]</code> at the top of the function to include/exclude from teh code based on the feature availability.<br/></p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="standard-library"><a class="header" href="#standard-library">Standard Library</a></h3>
<p>This section explains some of the common standard library APIs and their usage. The intention is not to cover the entire API. </p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="understanding-refcell-in-rust"><a class="header" href="#understanding-refcell-in-rust">Understanding <code>RefCell</code> in Rust</a></h3>
<p><code>RefCell</code> is a type that provides interior mutability in Rust. It allows you to mutate data even when there are immutable references to that data. This is achieved by enforcing borrowing rules at runtime rather than compile time.</p>
<ul>
<li><code>RefCell</code> is part of the <code>std::cell</code> module.</li>
<li>It enables mutable borrowing checked at runtime.</li>
<li>Useful in scenarios where you need to mutate data but only have an immutable reference.</li>
</ul>
<pre><pre class="playground"><code class="language-rust">use std::cell::RefCell;

fn main() {
    let data = RefCell::new(5);

    // Borrowing the value immutably
    {
        let value = data.borrow();
        println!(&quot;Value: {}&quot;, *value);
    }

    // Borrowing the value mutably
    {
        let mut value = data.borrow_mut();
        *value += 1;
    }

    // Borrowing the value immutably again to see the change
    {
        let value = data.borrow();
        println!(&quot;Updated Value: {}&quot;, *value);
    }
}
</code></pre></pre>
<ol>
<li>We create a <code>RefCell</code> containing the value <code>5</code>.</li>
<li>We borrow the value immutably using <code>borrow()</code>.</li>
<li>We borrow the value mutably using <code>borrow_mut()</code> and modify it.</li>
<li>We borrow the value immutably again to verify the change.</li>
</ol>
<ul>
<li><code>RefCell</code> will panic at runtime if you violate borrowing rules (e.g., if you try to borrow mutably while an immutable borrow is active).</li>
<li>Use <code>RefCell</code> when you need interior mutability and are sure that the borrowing rules will be followed at runtime.</li>
<li><code>RefCell</code> works when the value is managed in a single thread. For multi-threaded scenarios use Mutex or RwLock.</li>
</ul>
<p>For more details, refer to the <a href="https://doc.rust-lang.org/std/cell/struct.RefCell.html">Rust documentation on <code>RefCell</code></a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="understanding-rc"><a class="header" href="#understanding-rc">Understanding <code>Rc</code></a></h3>
<p>The <code>Rc</code> (Reference Counted) type is used when you need multiple ownership of data. It enables multiple parts of your program to read from the same data without needing to copy it.</p>
<p>1- <code>Rc::new</code> is used to create a new reference-counted instance of a value.</p>
<p>2- <code>Rc::clone</code> is used to create a new reference to the same data. This increases the reference count, allowing multiple parts of your program to share ownership of the data.</p>
<p><code>Rc</code> is not thread-safe, so it should only be used in single-threaded scenarios. For multi-threaded scenarios, consider using <code>Arc</code> (Atomic Reference Counted) instead.</p>
<h4 id="rcnew"><a class="header" href="#rcnew"><code>Rc::new</code></a></h4>
<pre><pre class="playground"><code class="language-rust">use std::rc::Rc;

fn main() {
    let value = Rc::new(5);
    println!(&quot;Value: {}&quot;, value);
}
</code></pre></pre>
<ul>
<li><code>Rc::new(5)</code> creates a new <code>Rc</code> instance that holds the value <code>5</code>.</li>
</ul>
<h4 id="rcclone"><a class="header" href="#rcclone"><code>Rc::clone</code></a></h4>
<pre><pre class="playground"><code class="language-rust">use std::rc::Rc;

fn main() {
    let value = Rc::new(5);
    let value_clone = Rc::clone(&amp;value);

    println!(&quot;Value: {}&quot;, value);
    println!(&quot;Cloned Value: {}&quot;, value_clone);
}
</code></pre></pre>
<ul>
<li><code>Rc::clone(&amp;value)</code> creates a new reference to the same data. Both <code>value</code> and <code>value_clone</code> point to the same data, and the reference count is increased.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h3 id="understanding-self-in-rust"><a class="header" href="#understanding-self-in-rust">Understanding <code>Self</code> in Rust</a></h3>
<p>In Rust, <code>Self</code> is a special type alias that refers to the type of the current trait or implementation block. It is commonly used in trait definitions and implementations to refer to the type that is implementing the trait.</p>
<pre><pre class="playground"><code class="language-rust">trait MyTrait {
    fn new() -&gt; Self;
    fn describe(&amp;self) -&gt; String;
}

struct MyStruct {
    name: String,
}

impl MyTrait for MyStruct {
    fn new() -&gt; Self {
        Self {
            name: String::from(&quot;MyStruct&quot;),
        }
    }

    fn describe(&amp;self) -&gt; String {
        format!(&quot;This is {}&quot;, self.name)
    }
}

fn main() {
    let instance = MyStruct::new();
    println!(&quot;{}&quot;, instance.describe());
}
</code></pre></pre>
<ul>
<li>The <code>MyTrait</code> trait defines two methods: <code>new</code> and <code>describe</code>.</li>
<li>The <code>new</code> method returns an instance of the type that implements the trait, denoted by <code>Self</code>.</li>
<li>The <code>describe</code> method takes a reference to <code>self</code> and returns a description string.</li>
<li>The <code>MyStruct</code> struct implements the <code>MyTrait</code> trait, using <code>Self</code> to refer to its own type within the implementation.</li>
</ul>
<p>This allows for more flexible and reusable code, as <code>Self</code> can adapt to the type that is implementing the trait.</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="self-vs-self-in-rust"><a class="header" href="#self-vs-self-in-rust">Self vs self in Rust</a></h3>
<p>In Rust, <code>Self</code> and <code>self</code> have different meanings and uses:</p>
<ul>
<li><code>Self</code> refers to the type that is implementing a trait or a method. It is used in type definitions and associated functions.</li>
<li><code>self</code> refers to the instance of the type that is implementing a method. It is used in method signatures and method bodies.</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct MyStruct;

impl MyStruct {
    // Associated function, uses `Self`
    fn new() -&gt; Self {
        MyStruct
    }

    // Method, uses `self`
    fn consume(self) {
        // consume the instance
    }
}
<span class="boring">}
</span></code></pre></pre>
<ul>
<li><code>Self</code> is used in the <code>new</code> function to refer to the type <code>MyStruct</code>.</li>
<li><code>self</code> is used in the <code>consume</code> method to refer to the instance of <code>MyStruct</code>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h3 id="is-self-a-special-keywork-in-rust"><a class="header" href="#is-self-a-special-keywork-in-rust">Is <strong>self</strong> a special keywork in Rust?</a></h3>
<p><strong>self</strong> is a special keyword in Rust. It is used to refer to the instance of the struct or enum within its associated methods. It is similar to this in other object-oriented languages like Java or C++.</p>
<h3 id="usage-of-self"><a class="header" href="#usage-of-self">Usage of self</a></h3>
<p><strong>Method Definitions</strong>: When defining methods for a struct or enum, self is used to refer to the instance on which the method is called.<br/>
<strong>Method Parameters</strong>: self can be used as a parameter in method definitions to indicate that the method takes ownership, borrows immutably, or borrows mutably from the instance.<br/></p>
<h3 id="immutable-borrow-self"><a class="header" href="#immutable-borrow-self">Immutable Borrow (&amp;self)</a></h3>
<p>When a method takes &amp;self as a parameter, it means the method borrows the instance immutably.</p>
<pre><pre class="playground"><code class="language-rust">pub struct Person {
    name: String,
}

impl Person {
    // Method that borrows the instance immutably
    fn greet(&amp;self) {
        println!(&quot;Hello, my name is {}!&quot;, self.name);
    }
}

fn main() {
    let person = Person {
        name: String::from(&quot;Alice&quot;),
    };
    person.greet(); // Calls the greet method
}
</code></pre></pre>
<h3 id="mutable-borrow-mut-self"><a class="header" href="#mutable-borrow-mut-self">Mutable Borrow (&amp;mut self)</a></h3>
<p>When a method takes &amp;mut self as a parameter, it means the method borrows the instance mutably.</p>
<pre><pre class="playground"><code class="language-rust">pub struct Counter {
    count: i32,
}

impl Counter {
    // Method that borrows the instance mutably
    fn increment(&amp;mut self) {
        self.count += 1;
    }
}

fn main() {
    let mut counter = Counter { count: 0 };
    counter.increment(); // Calls the increment method
    println!(&quot;Count: {}&quot;, counter.count);
    counter.increment(); // Calls the increment method
    println!(&quot;Count: {}&quot;, counter.count);
}
</code></pre></pre>
<h3 id="ownership-self"><a class="header" href="#ownership-self">Ownership (self)</a></h3>
<p>When a method takes self as a parameter, it means the method takes ownership of the instance.</p>
<pre><pre class="playground"><code class="language-rust">pub struct Person {
    name: String,
}

impl Person {
    // Method that takes ownership of the instance
    fn into_name(self) -&gt; String {
        self.name
    }
}

fn main() {
    let person = Person {
        name: String::from(&quot;Alice&quot;),
    };
    let name = person.into_name(); // Calls the into_name method, taking ownership
    println!(&quot;Name: {}&quot;, name);
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="what-is-the-purpose-of-imp-keyword"><a class="header" href="#what-is-the-purpose-of-imp-keyword">What is the purpose of <strong>imp</strong> keyword?</a></h3>
<p>The <strong>impl</strong> keyword in Rust is used to define implementations for structs, enums, and <a href="rust/essentials/std-lib/./trait.html">traits</a>. It allows you to associate functions and methods with a type, and to implement traits for a type.</p>
<h3 id="usage-of-impl"><a class="header" href="#usage-of-impl">Usage of impl</a></h3>
<p><strong>Implementing Methods for a Struct or Enum</strong>: </p>
<p>You can define methods that are associated with a struct or enum.</p>
<p><code>pub fn new(name: String, age: u8) -&gt; Self</code> is an associated function (often used as a constructor) that creates a new instance of Person. <code>pub fn greet(&amp;self)</code> and <code>pub fn have_birthday(&amp;mut self)</code> are methods associated with the Person struct. The <code>greet</code> method borrows the instance immutably, while the <code>have_birthday</code> method borrows it mutably.</p>
<pre><pre class="playground"><code class="language-rust">pub struct Person {
    name: String,
    age: u8,
}

impl Person {
    // Associated function (constructor)
    pub fn new(name: String, age: u8) -&gt; Self {
        Person { name, age }
    }

    // Method that borrows the instance immutably
    pub fn greet(&amp;self) {
        println!(&quot;Hello, my name is {} and I am {} years old.&quot;, self.name, self.age);
    }

    // Method that borrows the instance mutably
    pub fn have_birthday(&amp;mut self) {
        self.age += 1;
    }
}

fn main() {
    let mut person = Person::new(String::from(&quot;Alice&quot;), 30);
    person.greet();
    person.have_birthday();
    person.greet();
}
</code></pre></pre>
<p><strong>Implementing Traits for a Struct or Enum</strong>: </p>
<p>You can implement traits for a struct or enum, defining the behavior required by the trait.</p>
<p>The <code>Greet</code> trait defines a method <code>greet</code>. The <code>impl Greet for Dog</code> block implements the Greet trait for the <code>Dog</code> struct, providing the behavior required by the trait.</p>
<pre><pre class="playground"><code class="language-rust">pub trait Greet {
    fn greet(&amp;self);
}

pub struct Dog {
    name: String,
}

impl Dog {
    pub fn new(name: String) -&gt; Self {
        Dog { name }
    }
}

impl Greet for Dog {
    fn greet(&amp;self) {
        println!(&quot;Woof! My name is {}!&quot;, self.name);
    }
}

fn main() {
    let dog = Dog::new(String::from(&quot;Buddy&quot;));
    dog.greet();
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="does-rust-have-a-new-keyword"><a class="header" href="#does-rust-have-a-new-keyword">Does Rust Have a <code>new</code> Keyword?</a></h3>
<p>Rust does <strong>not</strong> have a <code>new</code> keyword like some other programming languages (e.g., C++ or Java). Instead, Rust commonly uses an associated function named <code>new</code> to create instances of a type. This is a convention rather than a language feature.</p>
<pre><pre class="playground"><code class="language-rust">struct MyStruct {
    value: i32,
}

impl MyStruct {
    // Associated function `new` to create an instance of `MyStruct`
    fn new(value: i32) -&gt; MyStruct {
        MyStruct { value }
    }
}

fn main() {
    // Creating an instance of `MyStruct` using the `new` function
    let instance = MyStruct::new(10);
    println!(&quot;MyStruct value: {}&quot;, instance.value);
}
</code></pre></pre>
<ul>
<li>The <code>new</code> function is defined as an associated function of <code>MyStruct</code> and is used to create a new instance of <code>MyStruct</code>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h3 id="the-some-keyword"><a class="header" href="#the-some-keyword">The <code>Some</code> Keyword</a></h3>
<p>In Rust, the <code>Some</code> keyword is used to represent a value within the <a href="rust/essentials/std-lib/./option.html"><code>Option</code></a> type. The <code>Option</code> type is an enum that can either be <code>Some(T)</code> where <code>T</code> is a value, or <code>None</code>, indicating the absence of a value. This is useful for handling cases where a value might be optional.</p>
<h4 id="example"><a class="header" href="#example">Example</a></h4>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let some_number = Some(5);
    let some_string = Some(&quot;Hello&quot;);

    if let Some(value) = some_number {
        println!(&quot;We have a number: {}&quot;, value);
    }

    if let Some(text) = some_string {
        println!(&quot;We have a string: {}&quot;, text);
    }
}
</code></pre></pre>
<p><code>some_number</code> and <code>some_string</code> are both <a href="rust/essentials/std-lib/./option.html"><code>Option</code></a> types. The <code>if let</code> syntax is used to check if they contain a value (<code>Some</code>) and to extract that value.</p>
<h3 id="usage-2"><a class="header" href="#usage-2">Usage</a></h3>
<p>The <code>Option</code> type is widely used in Rust to handle cases where a value might be present or absent, providing a safer alternative to null values found in other languages.</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="option-enum"><a class="header" href="#option-enum">Option Enum</a></h3>
<p>The <code>Option</code> enum represents a value that can either be something (<code>Some</code>) or nothing (<code>None</code>). It is commonly used to handle cases where a value might be absent, avoiding the need for null pointers and reducing the risk of null pointer exceptions.</p>
<h3 id="definition"><a class="header" href="#definition">Definition</a></h3>
<p>The <code>Option</code> enum is defined in the standard library as follows:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Option&lt;T&gt; {
    Some(T),
    None,
}
<span class="boring">}
</span></code></pre></pre>
<p>Here, <code>T</code> is a generic type parameter, meaning <code>Option</code> can hold a value of any type.</p>
<p>Basic Usage</p>
<pre><pre class="playground"><code class="language-rust">fn find_word(word: &amp;str) -&gt; Option&lt;usize&gt; {
    let words = vec![&quot;hello&quot;, &quot;world&quot;, &quot;rust&quot;];
    words.iter().position(|&amp;w| w == word)
}

fn main() {
    match find_word(&quot;rust&quot;) {
        Some(index) =&gt; println!(&quot;Found at index: {}&quot;, index),
        None =&gt; println!(&quot;Not found&quot;),
    }
}
</code></pre></pre>
<p>The <code>find_word</code> function returns an <code>Option&lt;usize&gt;</code>. If the word is found, it returns <code>Some(index)</code>, otherwise it returns <code>None</code>.</p>
<h4 id="using-unwrap"><a class="header" href="#using-unwrap">Using <code>unwrap</code></a></h4>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let some_number = Some(10);
    let number = some_number.unwrap();
    println!(&quot;The number is: {}&quot;, number);
}
</code></pre></pre>
<ul>
<li>The <code>unwrap</code> method extracts the value inside <code>Some</code>, but it will panic if called on a <code>None</code> value. Use it only when you are sure that the <code>Option</code> is <code>Some</code>.</li>
</ul>
<h4 id="using-unwrap_or"><a class="header" href="#using-unwrap_or">Using <code>unwrap_or</code></a></h4>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let some_number = Some(10);
    let none_number: Option&lt;i32&gt; = None;

    println!(&quot;The number is: {}&quot;, some_number.unwrap_or(0));
    println!(&quot;The number is: {}&quot;, none_number.unwrap_or(0));
}
</code></pre></pre>
<ul>
<li>The <code>unwrap_or</code> method provides a default value if the <code>Option</code> is <code>None</code>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h3 id="what-is-the-purpose-of-derivedebug"><a class="header" href="#what-is-the-purpose-of-derivedebug">What is the purpose of <code>#[derive(Debug)]</code>?</a></h3>
<p>The <code>#[derive(Debug)]</code> attribute in Rust automatically generates an implementation of the <code>Debug</code> trait for a struct or enum. This trait allows you to format the value using the <code>{:?}</code> formatter, which is useful for debugging purposes.</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Person {
    name: String,
    age: u32,
}

fn main() {
    let person = Person {
        name: String::from(&quot;Alice&quot;),
        age: 30,
    };

    // Print the person struct using the Debug trait
    println!(&quot;{:?}&quot;, person);
}
</code></pre></pre>
<p>The <code>Person</code> struct derives the <code>Debug</code> trait, allowing us to print its value using <code>println!(&quot;{:?}&quot;, person);</code>. The output will be:</p>
<pre><code>Person { name: &quot;Alice&quot;, age: 30 }
</code></pre>
<p>This makes it easier to inspect the values of complex data structures during development and debugging.</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="design-patterns"><a class="header" href="#design-patterns">Design Patterns</a></h3>
<p>Patterns help to have reusable solutions to common problems that occur in software design. These patterns provide a template or blueprint for solving a particular problem in a specific context. They help developers avoid reinventing the wheel.</p>
<p>1- <a href="rust/patterns/./creational/intro.html">Creational Patterns</a>: Deal with object creation mechanisms, trying to create objects in a manner suitable to the situation.</p>
<p>2- <a href="rust/patterns/./behavioral/intro.html">Behavioral Patterns</a>: Deal with object collaboration and the delegation of responsibilities.</p>
<p>3- <a href="rust/patterns/./structural/intro.html">Structural Patterns</a>: Deal with object composition or the structure of classes and objects.</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="creational-patterns"><a class="header" href="#creational-patterns">Creational Patterns</a></h3>
<p>Creational Patterns deal with object creation mechanisms, trying to create objects in a manner suitable to the situation.</p>
<h3 id="some-common-creational-design-patterns"><a class="header" href="#some-common-creational-design-patterns">Some Common Creational Design Patterns</a></h3>
<p>1- <a href="rust/patterns/creational/./singleton.html">Singleton</a>: Ensures a class has only one instance and provides a global point of access to it.</p>
<p>2- <a href="rust/patterns/creational/./factory-method.html">Factory Method</a>: Defines an interface for creating an object, but lets subclasses alter the type of objects that will be created.</p>
<p>3- <a href="rust/patterns/creational/./abstract-factory.html">Abstract Factory</a>: Provides an interface for creating families of related or dependent objects without specifying their concrete classes.</p>
<p>4- <a href="rust/patterns/creational/./builder.html">Builder</a>: Separates the construction of a complex object from its representation so that the same construction process can create different representations.</p>
<p>5- <a href="rust/patterns/creational/./prototype.html">Prototype</a>: Specifies the kinds of objects to create using a prototypical instance, and creates new objects by copying this prototype.</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="singleton-design-pattern"><a class="header" href="#singleton-design-pattern">Singleton Design Pattern</a></h3>
<p>The Singleton pattern ensures that a class has only one instance and provides a global point of access to it. This is useful when exactly one object is needed to coordinate actions across the system.</p>
<pre><pre class="playground"><code class="language-rust">use std::sync::{Arc, Mutex};
use std::thread;

struct Singleton {
    data: i32,
}

impl Singleton {
    fn new() -&gt; Self {
        Singleton { data: 0 }
    }

    fn get_instance() -&gt; Arc&lt;Mutex&lt;Singleton&gt;&gt; {
        static mut SINGLETON: Option&lt;Arc&lt;Mutex&lt;Singleton&gt;&gt;&gt; = None;
        static ONCE: std::sync::Once = std::sync::Once::new();

        unsafe {
            ONCE.call_once(|| {
                let singleton = Singleton::new();
                SINGLETON = Some(Arc::new(Mutex::new(singleton)));
            });

            SINGLETON.clone().unwrap()
        }
    }

    fn increment(&amp;mut self) {
        self.data += 1;
    }

    fn get_data(&amp;self) -&gt; i32 {
        self.data
    }
}

fn main() {
    let singleton = Singleton::get_instance();

    // Acquire the lock in the main thread
    {
        let mut instance = singleton.lock().unwrap();
        instance.increment();
        println!(&quot;Main thread data: {}&quot;, instance.get_data());
    } // The lock is released here when `instance` goes out of scope

    let singleton_clone1 = Arc::clone(&amp;singleton);
    let singleton_clone2 = Arc::clone(&amp;singleton);

    let handle1 = thread::spawn(move || {
        let mut instance1 = singleton_clone1.lock().unwrap();
        instance1.increment();
        println!(&quot;Thread 1 data: {}&quot;, instance1.get_data());
    });

    let handle2 = thread::spawn(move || {
        let mut instance2 = singleton_clone2.lock().unwrap();
        instance2.increment();
        println!(&quot;Thread 2 data: {}&quot;, instance2.get_data());
    });

    handle1.join().unwrap();
    handle2.join().unwrap();

    // Acquire the lock again in the main thread
    {
        let instance = singleton.lock().unwrap();
        println!(&quot;Final data: {}&quot;, instance.get_data());
    }
}
</code></pre></pre>
<ol>
<li><strong>Singleton Struct</strong>: Defines the structure of the singleton with a single field <code>value</code>.</li>
<li><strong>new() Method</strong>: Creates a new instance of the singleton wrapped in <code>Arc</code> and <code>Mutex</code> for thread safety.</li>
<li><strong>get_instance() Method</strong>: Provides a global point of access to the singleton instance. It uses <code>std::sync::Once</code> to ensure that the instance is only created once.</li>
<li><strong>set_value() and get_value() Methods</strong>: Allow modification and retrieval of the singleton's value.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h3 id="factory-method-pattern"><a class="header" href="#factory-method-pattern">Factory Method Pattern</a></h3>
<p>The Factory Method is a creational design pattern that provides an interface for creating objects in a superclass but allows subclasses to alter the type of objects that will be created.</p>
<p>Tthe Factory Method pattern can be implemented using traits and structs. The trait defines the method for creating objects, and the structs implement this trait to create specific types of objects.</p>
<p>In this example we have a <code>Shape</code> trait and two structs <code>Circle</code> and <code>Square</code> that implement this trait. We will create a <code>ShapeFactory</code> trait with a method <code>create_shape</code> and two factories <code>CircleFactory</code> and <code>SquareFactory</code> that implement this trait.</p>
<pre><pre class="playground"><code class="language-rust">// Define the Shape trait
trait Shape {
    fn draw(&amp;self);
}

// Implement the Shape trait for Circle
struct Circle;

impl Shape for Circle {
    fn draw(&amp;self) {
        println!(&quot;Drawing a Circle&quot;);
    }
}

// Implement the Shape trait for Square
struct Square;

impl Shape for Square {
    fn draw(&amp;self) {
        println!(&quot;Drawing a Square&quot;);
    }
}

// Define the ShapeFactory trait
trait ShapeFactory {
    fn create_shape(&amp;self) -&gt; Box&lt;dyn Shape&gt;;
}

// Implement the ShapeFactory trait for CircleFactory
struct CircleFactory;

impl ShapeFactory for CircleFactory {
    fn create_shape(&amp;self) -&gt; Box&lt;dyn Shape&gt; {
        Box::new(Circle)
    }
}

// Implement the ShapeFactory trait for SquareFactory
struct SquareFactory;

impl ShapeFactory for SquareFactory {
    fn create_shape(&amp;self) -&gt; Box&lt;dyn Shape&gt; {
        Box::new(Square)
    }
}

fn main() {
    // Create a Circle using CircleFactory
    let circle_factory = CircleFactory;
    let circle = circle_factory.create_shape();
    circle.draw();

    // Create a Square using SquareFactory
    let square_factory = SquareFactory;
    let square = square_factory.create_shape();
    square.draw();
}
</code></pre></pre>
<h2 id="output"><a class="header" href="#output">Output</a></h2>
<pre><code>Drawing a Circle
Drawing a Square
</code></pre>
<ul>
<li>The <code>ShapeFactory</code> trait defines the <code>create_shape</code> method, and the <code>CircleFactory</code> and <code>SquareFactory</code> structs implement this method to create specific shapes. This allows for flexibility in creating different types of shapes without changing the client code.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h3 id="abstract-factory-pattern"><a class="header" href="#abstract-factory-pattern">Abstract Factory Pattern</a></h3>
<p>The abstract factory design pattern provides an interface for creating families of related or dependent objects without specifying their concrete classes. This pattern is particularly useful when the exact types and dependencies of the objects are not known until runtime.</p>
<pre><pre class="playground"><code class="language-rust">// Define traits for products
trait Chair {
    fn has_legs(&amp;self) -&gt; bool;
    fn sit_on(&amp;self);
}

trait Sofa {
    fn has_legs(&amp;self) -&gt; bool;
    fn lie_on(&amp;self);
}

// Concrete products for Modern style
struct ModernChair;
struct ModernSofa;

impl Chair for ModernChair {
    fn has_legs(&amp;self) -&gt; bool {
        true
    }

    fn sit_on(&amp;self) {
        println!(&quot;Sitting on a modern chair.&quot;);
    }
}

impl Sofa for ModernSofa {
    fn has_legs(&amp;self) -&gt; bool {
        true
    }

    fn lie_on(&amp;self) {
        println!(&quot;Lying on a modern sofa.&quot;);
    }
}

// Concrete products for Victorian style
struct VictorianChair;
struct VictorianSofa;

impl Chair for VictorianChair {
    fn has_legs(&amp;self) -&gt; bool {
        true
    }

    fn sit_on(&amp;self) {
        println!(&quot;Sitting on a Victorian chair.&quot;);
    }
}

impl Sofa for VictorianSofa {
    fn has_legs(&amp;self) -&gt; bool {
        true
    }

    fn lie_on(&amp;self) {
        println!(&quot;Lying on a Victorian sofa.&quot;);
    }
}

// Abstract factory trait
trait FurnitureFactory {
    fn create_chair(&amp;self) -&gt; Box&lt;dyn Chair&gt;;
    fn create_sofa(&amp;self) -&gt; Box&lt;dyn Sofa&gt;;
}

// Concrete factories
struct ModernFurnitureFactory;

impl FurnitureFactory for ModernFurnitureFactory {
    fn create_chair(&amp;self) -&gt; Box&lt;dyn Chair&gt; {
        Box::new(ModernChair)
    }

    fn create_sofa(&amp;self) -&gt; Box&lt;dyn Sofa&gt; {
        Box::new(ModernSofa)
    }
}

struct VictorianFurnitureFactory;

impl FurnitureFactory for VictorianFurnitureFactory {
    fn create_chair(&amp;self) -&gt; Box&lt;dyn Chair&gt; {
        Box::new(VictorianChair)
    }

    fn create_sofa(&amp;self) -&gt; Box&lt;dyn Sofa&gt; {
        Box::new(VictorianSofa)
    }
}

// Client code
fn main() {
    let factory: Box&lt;dyn FurnitureFactory&gt; = Box::new(ModernFurnitureFactory);
    let chair = factory.create_chair();
    let sofa = factory.create_sofa();

    chair.sit_on();
    sofa.lie_on();

    let factory2: Box&lt;dyn FurnitureFactory&gt; = Box::new(VictorianFurnitureFactory);
    let chair2 = factory2.create_chair();
    let sofa2 = factory2.create_sofa();

    chair2.sit_on();
    sofa2.lie_on();
}
</code></pre></pre>
<p>The <code>FurnitureFactory</code> trait defines methods for creating abstract products (<code>Chair</code> and <code>Sofa</code>). The <code>ModernFurnitureFactory</code> and <code>VictorianFurnitureFactory</code> structs implement this trait to create concrete products. The client code uses the factory to create and interact with the products without knowing their concrete types.</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="builder-pattern"><a class="header" href="#builder-pattern">Builder Pattern</a></h3>
<p>The builder pattern is a creational design pattern that allows constructing complex objects step by step. It separates the construction of a complex object from its representation, allowing the same construction process to create different representations.</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct House {
    walls: u8,
    doors: u8,
    windows: u8,
    has_garage: bool,
    has_swimming_pool: bool,
}

struct HouseBuilder {
    walls: u8,
    doors: u8,
    windows: u8,
    has_garage: bool,
    has_swimming_pool: bool,
}

impl HouseBuilder {
    fn new() -&gt; Self {
        HouseBuilder {
            walls: 0,
            doors: 0,
            windows: 0,
            has_garage: false,
            has_swimming_pool: false,
        }
    }

    fn walls(mut self, count: u8) -&gt; Self {
        self.walls = count;
        self
    }

    fn doors(mut self, count: u8) -&gt; Self {
        self.doors = count;
        self
    }

    fn windows(mut self, count: u8) -&gt; Self {
        self.windows = count;
        self
    }

    fn garage(mut self, has_garage: bool) -&gt; Self {
        self.has_garage = has_garage;
        self
    }

    fn swimming_pool(mut self, has_swimming_pool: bool) -&gt; Self {
        self.has_swimming_pool = has_swimming_pool;
        self
    }

    fn build(self) -&gt; House {
        House {
            walls: self.walls,
            doors: self.doors,
            windows: self.windows,
            has_garage: self.has_garage,
            has_swimming_pool: self.has_swimming_pool,
        }
    }
}

fn main() {
    let house = HouseBuilder::new()
        .walls(4)
        .doors(2)
        .windows(6)
        .garage(true)
        .swimming_pool(false)
        .build();

    println!(&quot;{:?}&quot;, house);
}
</code></pre></pre>
<p><code>HouseBuilder</code> is used to construct a <code>House</code> object step by step. The builder provides methods to set the properties of the house and a <code>build</code> method to create the final <code>House</code> object.</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="prototype-pattern"><a class="header" href="#prototype-pattern">Prototype Pattern</a></h3>
<p>The prototype pattern is a creational pattern that allows cloning of objects, even complex ones, without coupling to their specific classes. This pattern is particularly useful when the cost of creating a new instance of a class is expensive or complicated.</p>
<p>We can implement the pattern using the <code>Clone</code> trait.</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Clone)]
struct Prototype {
    field1: String,
    field2: i32,
}

impl Prototype {
    fn new(field1: String, field2: i32) -&gt; Self {
        Prototype { field1, field2 }
    }

    fn clone_prototype(&amp;self) -&gt; Self {
        self.clone()
    }
}

fn main() {
    let original = Prototype::new(String::from(&quot;Prototype&quot;), 42);
    let cloned = original.clone_prototype();

    println!(&quot;Original: {} - {}&quot;, original.field1, original.field2);
    println!(&quot;Cloned: {} - {}&quot;, cloned.field1, cloned.field2);
}
</code></pre></pre>
<ul>
<li>We define a <code>Prototype</code> struct with two fields.</li>
<li>We derive the <code>Clone</code> trait for the <code>Prototype</code> struct, which provides the <code>clone</code> method.</li>
<li>We implement a <code>clone_prototype</code> method that clones the current instance.</li>
<li>In the <code>main</code> function, we create an instance of <code>Prototype</code> and then clone it using the <code>clone_prototype</code> method.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h3 id="behavioral-patterns"><a class="header" href="#behavioral-patterns">Behavioral Patterns</a></h3>
<p>Behavioral Patterns deal with object collaboration and the delegation of responsibilities. </p>
<h3 id="some-common-behavioral-design-patterns"><a class="header" href="#some-common-behavioral-design-patterns">Some Common Behavioral Design Patterns</a></h3>
<p>1- <a href="rust/patterns/behavioral/./observer.html">Observer</a>: Defines a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically.</p>
<p>2- <a href="rust/patterns/behavioral/./strategy.html">Strategy</a>: Defines a family of algorithms, encapsulates each one, and makes them interchangeable.</p>
<p>3- <a href="rust/patterns/behavioral/./command.html">Command</a>: Encapsulates a request as an object, thereby allowing for parameterization of clients with queues, requests, and operations.</p>
<p>4- <a href="rust/patterns/behavioral/./chain-of-responsibility.html">Chain of Responsibility</a>: Allows an object to pass a request along a chain of potential handlers until the request is handled.</p>
<p>5- <a href="rust/patterns/behavioral/./iterator.html">Iterator</a>: Provides a way to access the elements of an aggregate object sequentially without exposing its underlying representation. </p>
<p>6- <a href="rust/patterns/behavioral/./mediator.html">Mediator</a>: Defines an object that encapsulates how a set of objects interact.</p>
<p>5- <a href="rust/patterns/behavioral/./visitor.html">Visitor</a>:  Allows adding further operations to objects without having to modify them.</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="observer-pattern"><a class="header" href="#observer-pattern">Observer Pattern</a></h3>
<p>The observer pattern is a behavioral design pattern where an object (the subject) maintains a list of its dependents (observers) and notifies them of any state changes, usually by calling one of their methods.</p>
<pre><pre class="playground"><code class="language-rust">// Observer type
pub trait Observer {
    fn update(&amp;self, message: &amp;str);
}

// Concrete observer
pub struct ConcreteObserver {
    name: String,
}

impl ConcreteObserver {
    pub fn new(name: &amp;str) -&gt; Self {
        ConcreteObserver {
            name: name.to_string(),
        }
    }
}

impl Observer for ConcreteObserver {
    fn update(&amp;self, message: &amp;str) {
        println!(&quot;{} received message: {}&quot;, self.name, message);
    }
}

// Subject
pub struct Subject {
    observers: Vec&lt;Box&lt;dyn Observer&gt;&gt;,
}

impl Subject {
    pub fn new() -&gt; Self {
        Subject {
            observers: Vec::new(),
        }
    }

    pub fn add_observer(&amp;mut self, observer: Box&lt;dyn Observer&gt;) {
        self.observers.push(observer);
    }

    pub fn notify_observers(&amp;self, message: &amp;str) {
        for observer in &amp;self.observers {
            observer.update(message);
        }
    }
}

fn main() {
    let mut subject = Subject::new();

    let observer1 = ConcreteObserver::new(&quot;Observer 1&quot;);
    let observer2 = ConcreteObserver::new(&quot;Observer 2&quot;);

    subject.add_observer(Box::new(observer1));
    subject.add_observer(Box::new(observer2));

    subject.notify_observers(&quot;Hello, observers!&quot;);
}
</code></pre></pre>
<p>Observer Trait defines the update method that observers must implement. Subject Struct manages a list of observers and notifies them of changes. Concrete Observers implement the Observer trait and define the update method.</p>
<p>This setup allows the subject to notify all registered observers whenever a change occurs, following the Observer pattern principles.</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="strategy-pattern"><a class="header" href="#strategy-pattern">Strategy Pattern</a></h3>
<p>The strategy pattern defines a family of algorithms, encapsulates each one, and makes them interchangeable. This pattern lets the algorithm vary independently from clients that use it.</p>
<pre><pre class="playground"><code class="language-rust">// Strategy type
pub trait Strategy {
    fn execute(&amp;self, data: &amp;str);
}

pub struct ConcreteStrategyA;

// Concrete Strategy A
impl Strategy for ConcreteStrategyA {
    fn execute(&amp;self, data: &amp;str) {
        println!(&quot;ConcreteStrategyA: {}&quot;, data);
    }
}

pub struct ConcreteStrategyB;

// Concrete Strategy B
impl Strategy for ConcreteStrategyB {
    fn execute(&amp;self, data: &amp;str) {
        println!(&quot;ConcreteStrategyB: {}&quot;, data);
    }
}

// Context type
pub struct Context {
    strategy: Box&lt;dyn Strategy&gt;,
}

// Concrete Context
impl Context {
    pub fn new(strategy: Box&lt;dyn Strategy&gt;) -&gt; Self {
        Context { strategy }
    }

    pub fn set_strategy(&amp;mut self, strategy: Box&lt;dyn Strategy&gt;) {
        self.strategy = strategy;
    }

    pub fn execute_strategy(&amp;self, data: &amp;str) {
        self.strategy.execute(data);
    }
}

fn main() {
    let strategy_a 
    = Box::new(ConcreteStrategyA);
    let strategy_b = Box::new(ConcreteStrategyB);

    let mut context = Context::new(strategy_a);
    context.execute_strategy(&quot;Hello, World!&quot;);

    context.set_strategy(strategy_b);
    context.execute_strategy(&quot;Hello, Rust!&quot;);
}
</code></pre></pre>
<p>Strategy Trait defines a common interface for all supported algorithms. Concrete Strategies implement the Strategy trait for different algorithms. Context maintains a reference to a Strategy object and is configured with a Concrete Strategy object.</p>
<p>This pattern is useful for scenarios where you need to switch between different algorithms or behaviors at runtime.</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="command-pattern"><a class="header" href="#command-pattern">Command Pattern</a></h3>
<p>The command pattern is a behavioral design pattern that turns a request into a stand-alone object that contains all information about the request. This transformation allows for parameterization of methods with different requests, queuing of requests, and logging of the requests. It also provides support for undoable operations. <br/></p>
<pre><pre class="playground"><code class="language-rust">use std::cell::RefCell;
use std::rc::Rc;

// Command
pub trait Command {
    fn execute(&amp;self);
}

// ConcreteCommand for turning on the light
pub struct TurnOnCommand {
    pub light: Rc&lt;RefCell&lt;Light&gt;&gt;,
}

impl Command for TurnOnCommand {
    fn execute(&amp;self) {
        self.light.borrow_mut().turn_on();
    }
}

// ConcreteCommand for turning off the light
pub struct TurnOffCommand {
    pub light: Rc&lt;RefCell&lt;Light&gt;&gt;,
}

impl Command for TurnOffCommand {
    fn execute(&amp;self) {
        self.light.borrow_mut().turn_off();
    }
}

// Invoker
pub struct RemoteControl{
    command: Option&lt;Box&lt;dyn Command&gt;&gt;,
}

impl RemoteControl {
    pub fn new() -&gt; Self {
        RemoteControl { command: None }
    }

    pub fn set_command(&amp;mut self, command: Box&lt;dyn Command &gt;) {
        self.command = Some(command);
    }

    pub fn press_button(&amp;mut self) {
        if let Some(ref mut command) = self.command {
            command.execute();
        }
    }
}

// Receiver
pub struct Light {
    is_on: bool,
}

impl Light {
    pub fn new() -&gt; Self {
        Light { is_on: false }
    }

    pub fn turn_on(&amp;mut self) {
        self.is_on = true;
        println!(&quot;The light is on&quot;);
    }

    pub fn turn_off(&amp;mut self) {
        self.is_on = false;
        println!(&quot;The light is off&quot;);
    }

    pub fn is_on(&amp;self) -&gt; bool {
        self.is_on
    }
}

// Client
fn main() {
    let light = Rc::new(RefCell::new(Light::new()));
    let turn_on_command = TurnOnCommand { light: Rc::clone(&amp;light) };
    let turn_off_command = TurnOffCommand { light: Rc::clone(&amp;light) };
    let mut remote = RemoteControl::new();


    remote.set_command(Box::new(turn_on_command));
    remote.press_button();
    println!(&quot;Light Status: {}&quot;, light.borrow().is_on()); // Borrow the Light instance


    remote.set_command(Box::new(turn_off_command));
    remote.press_button();
    println!(&quot;Light Status: {}&quot;, light.borrow().is_on()); // Borrow the Light instance

}
</code></pre></pre>
<ul>
<li><code>Command</code> is a trait that declares the <code>execute</code> method.</li>
<li><code>Light</code> is the receiver that knows how to perform the operations.</li>
<li><code>TurnOnCommand</code> and <code>TurnOffCommand</code> are concrete commands that implement the <code>Command</code> trait.</li>
<li><code>RemoteControl</code> is the invoker that triggers the commands.</li>
</ul>
<p>This pattern decouples the object that invokes the operation from the one that knows how to perform it.</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="chain-of-responsibility-pattern"><a class="header" href="#chain-of-responsibility-pattern">Chain of Responsibility Pattern</a></h3>
<p>The chain of responsibility pattern is a behavioral design pattern that allows an object to pass a request along a chain of potential handlers until the request is handled.</p>
<pre><pre class="playground"><code class="language-rust">trait Handler {
    fn set_next(&amp;mut self, next: Box&lt;dyn Handler&gt;);
    fn handle(&amp;self, request: &amp;str);
}

struct BaseHandler {
    next: Option&lt;Box&lt;dyn Handler&gt;&gt;,
}

impl BaseHandler {
    fn new() -&gt; Self {
        BaseHandler { next: None }
    }
}

impl Handler for BaseHandler {
    fn set_next(&amp;mut self, next: Box&lt;dyn Handler&gt;) {
        self.next = Some(next);
    }

    fn handle(&amp;self, request: &amp;str) {
        if let Some(ref next) = self.next {
            next.handle(request);
        }
    }
}

struct ConcreteHandlerA {
    next: Option&lt;Box&lt;dyn Handler&gt;&gt;,
}

impl Handler for ConcreteHandlerA {
    fn set_next(&amp;mut self, next: Box&lt;dyn Handler&gt;) {
        self.next = Some(next);
    }

    fn handle(&amp;self, request: &amp;str) {
        if request == &quot;A&quot; {
            println!(&quot;ConcreteHandlerA handled request: {}&quot;, request);
        } else {
            println!(&quot;ConcreteHandlerA passed the request&quot;);
            if let Some(ref next) = self.next {
                next.handle(request);
            }
        }
    }
}

struct ConcreteHandlerB {
    next: Option&lt;Box&lt;dyn Handler&gt;&gt;,
}

impl Handler for ConcreteHandlerB {
    fn set_next(&amp;mut self, next: Box&lt;dyn Handler&gt;) {
        self.next = Some(next);
    }

    fn handle(&amp;self, request: &amp;str) {
        if request == &quot;B&quot; {
            println!(&quot;ConcreteHandlerB handled request: {}&quot;, request);
        } else {
            println!(&quot;ConcreteHandlerB passed the request&quot;);
            if let Some(ref next) = self.next {
                next.handle(request);
            } 
        }
    }
}


fn main() {
    let mut handler = BaseHandler::new();
    let mut handler_b = Box::new(ConcreteHandlerB { next: None });
    let handler_a = Box::new(ConcreteHandlerA { next: None });

    handler_b.set_next(handler_a);
    handler.set_next(handler_b);

    println!(&quot;Handle request A&quot;);
    handler.handle(&quot;A&quot;);
    println!(&quot;Handle request B&quot;);
    handler.handle(&quot;B&quot;);
    println!(&quot;Handle request C&quot;);
    handler.handle(&quot;C&quot;);
}
</code></pre></pre>
<ul>
<li><code>Handler</code> is a trait that defines the interface for handling requests.</li>
<li><code>BaseHandler</code> is a base struct that implements the common behavior for setting the next handler and passing the request along the chain.</li>
<li><code>ConcreteHandlerA</code> and <code>ConcreteHandlerB</code> are concrete implementations of the <code>Handler</code> trait that handle specific requests.</li>
<li>The <code>main</code> function sets up the chain and tests the handlers with different requests.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h3 id="iterator-pattern"><a class="header" href="#iterator-pattern">Iterator Pattern</a></h3>
<p>The iterator pattern is a design pattern that provides a way to access the elements of an aggregate object sequentially without exposing its underlying representation. In Rust, the iterator pattern is implemented using the <code>Iterator</code> trait.</p>
<pre><pre class="playground"><code class="language-rust">struct Counter {
    count: u32,
}

impl Counter {
    fn new() -&gt; Counter {
        Counter { count: 0 }
    }
}

impl Iterator for Counter {
    type Item = u32;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        self.count += 1;
        if self.count &lt; 6 {
            Some(self.count)
        } else {
            None
        }
    }
}

fn main() {
    let mut counter = Counter::new();

    while let Some(value) = counter.next() {
        println!(&quot;{}&quot;, value);
    }

    let sum: u32 = Counter::new()
        .zip(Counter::new().skip(1))
        .map(|(a, b)| a * b)
        .filter(|x| x % 3 == 0)
        .sum();

    println!(&quot;The sum is: {}&quot;, sum);
}
</code></pre></pre>
<p>Rust's standard library provides many useful methods for iterators. In this example, we use the <code>zip</code>, <code>skip</code>, <code>map</code>, <code>filter</code>, and <code>sum</code> methods to perform various operations on the iterator.</p>
<p>The iterator pattern in Rust is a powerful and flexible way to work with sequences of data. By implementing the <code>Iterator</code> trait, you can create custom iterators and take advantage of the many methods provided by the standard library to manipulate and process data efficiently.</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="mediator-pattern"><a class="header" href="#mediator-pattern">Mediator Pattern</a></h3>
<p>The mediator pattern is a behavioral design pattern that defines an object that encapsulates how a set of objects interact. This pattern promotes loose coupling by keeping objects from referring to each other explicitly and allows their interaction to be varied independently. The pattern centralizes the control logic that would otherwise be distributed among several objects.</p>
<pre><pre class="playground"><code class="language-rust">use std::cell::RefCell;
use std::rc::Rc;

trait Mediator {
    fn notify(&amp;self, sender: &amp;str, event: &amp;str);
}

struct ConcreteMediator {
    component1: Rc&lt;RefCell&lt;Component1&gt;&gt;,
    component2: Rc&lt;RefCell&lt;Component2&gt;&gt;,
}

impl ConcreteMediator {
    fn new(component1: Rc&lt;RefCell&lt;Component1&gt;&gt;, component2: Rc&lt;RefCell&lt;Component2&gt;&gt;) -&gt; Self {
        ConcreteMediator { component1, component2 }
    }
}

impl Mediator for ConcreteMediator {
    fn notify(&amp;self, sender: &amp;str, event: &amp;str) {
        if event == &quot;A&quot; {
            println!(&quot;Mediator reacts on A and triggers following operations:&quot;);
            self.component2.borrow().do_c();
        } else if event == &quot;D&quot; {
            println!(&quot;Mediator reacts on D and triggers following operations:&quot;);
            self.component1.borrow().do_b();
            self.component2.borrow().do_c();
        }
    }
}

struct Component1 {
    mediator: Option&lt;Rc&lt;RefCell&lt;ConcreteMediator&gt;&gt;&gt;,
}

impl Component1 {
    fn new() -&gt; Self {
        Component1 { mediator: None }
    }

    fn set_mediator(&amp;mut self, mediator: Rc&lt;RefCell&lt;ConcreteMediator&gt;&gt;) {
        self.mediator = Some(mediator);
    }

    fn do_a(&amp;self) {
        println!(&quot;Component 1 does A.&quot;);
        if let Some(ref mediator) = self.mediator {
            mediator.borrow().notify(&quot;Component1&quot;, &quot;A&quot;);
        }
    }

    fn do_b(&amp;self) {
        println!(&quot;Component 1 does B.&quot;);
        if let Some(ref mediator) = self.mediator {
            mediator.borrow().notify(&quot;Component1&quot;, &quot;B&quot;);
        }
    }
}

struct Component2 {
    mediator: Option&lt;Rc&lt;RefCell&lt;ConcreteMediator&gt;&gt;&gt;,
}

impl Component2 {
    fn new() -&gt; Self {
        Component2 { mediator: None }
    }

    fn set_mediator(&amp;mut self, mediator: Rc&lt;RefCell&lt;ConcreteMediator&gt;&gt;) {
        self.mediator = Some(mediator);
    }

    fn do_c(&amp;self) {
        println!(&quot;Component 2 does C.&quot;);
        if let Some(ref mediator) = self.mediator {
            mediator.borrow().notify(&quot;Component2&quot;, &quot;C&quot;);
        }
    }

    fn do_d(&amp;self) {
        println!(&quot;Component 2 does D.&quot;);
        if let Some(ref mediator) = self.mediator {
            mediator.borrow().notify(&quot;Component2&quot;, &quot;D&quot;);
        }
    }
}

fn main() {
    let component1 = Rc::new(RefCell::new(Component1::new()));
    let component2 = Rc::new(RefCell::new(Component2::new()));

    let mediator = Rc::new(RefCell::new(ConcreteMediator::new(
        Rc::clone(&amp;component1),
        Rc::clone(&amp;component2),
    ))) as Rc&lt;RefCell&lt;ConcreteMediator&gt;&gt;;

    component1.borrow_mut().set_mediator(Rc::clone(&amp;mediator));
    component2.borrow_mut().set_mediator(Rc::clone(&amp;mediator));

    println!(&quot;Client triggers operation A.&quot;);
    component1.borrow().do_a();

    println!(&quot;\nClient triggers operation D.&quot;);
    component2.borrow().do_d();
}
</code></pre></pre>
<p><code>ConcreteMediator</code> coordinates the interactions between <code>Component1</code> and <code>Component2</code>. Each component notifies the mediator when an event occurs, and the mediator decides how to handle the event and which components to notify.</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="visitor-pattern"><a class="header" href="#visitor-pattern">Visitor Pattern</a></h3>
<p>The visitor pattern is a behavioral design pattern that allows you to add further operations to objects without having to modify them. It involves creating a visitor class that implements a visitor interface and then passing it to elements of the object structure.</p>
<pre><pre class="playground"><code class="language-rust">// Define the Visitor trait
trait Visitor {
    fn multiply_by_two(&amp;mut self, element: &amp;mut ElementA);
    fn add_ten(&amp;mut self, element: &amp;mut ElementB);
}

// Define the Element trait
trait Element {
    fn accept(&amp;mut self, visitor: &amp;mut dyn Visitor);
}

// Define concrete elements
struct ElementA {
    data: i32,
}

struct ElementB {
    data: i32,
}

impl Element for ElementA {
    fn accept(&amp;mut self, visitor: &amp;mut dyn Visitor) {
        visitor.multiply_by_two(self);
        println!(&quot;After the visit: {:?}&quot;, self.data);
    }
}

impl Element for ElementB {
    fn accept(&amp;mut self, visitor: &amp;mut dyn Visitor) {
        visitor.add_ten(self);
        println!(&quot;After the visit: {:?}&quot;, self.data);
    }
}

// Define a concrete visitor
struct ConcreteVisitor;

impl Visitor for ConcreteVisitor {
    fn multiply_by_two(&amp;mut self, element: &amp;mut ElementA) {
        println!(&quot;Visiting ElementA: {:?}&quot;, element.data);
        element.data *= 2;
    }

    fn add_ten(&amp;mut self, element: &amp;mut ElementB) {
        println!(&quot;Visiting ElementB: {:?}&quot;, element.data);
        element.data += 10;
    }
}

fn main() {
    let elements: Vec&lt;Box&lt;dyn Element&gt;&gt; = vec![Box::new(ElementA { data: 10 }), Box::new(ElementB { data: 5 })];
    let mut visitor = ConcreteVisitor;

    for mut element in elements {
        element.accept(&amp;mut visitor);
    }
}
</code></pre></pre>
<ul>
<li>The <code>Visitor</code> trait defines methods for visiting different types of elements.</li>
<li>The <code>Element</code> trait defines an <code>accept</code> method that takes a mutable reference to a <code>Visitor</code>.</li>
<li><code>ElementA</code> and <code>ElementB</code> are concrete implementations of the <code>Element</code> trait.</li>
<li><code>ConcreteVisitor</code> is a concrete implementation of the <code>Visitor</code> trait.</li>
<li>In the <code>main</code> function, we create a list of elements and a visitor, and then we iterate over the elements, passing the visitor to each element's <code>accept</code> method.</li>
</ul>
<p>This pattern allows you to add new operations to existing object structures without modifying those structures.</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="structural-patterns"><a class="header" href="#structural-patterns">Structural Patterns</a></h3>
<p>Structural Patterns deal with object composition, trying to realize new functionality by composing objects in various ways.</p>
<h3 id="some-common-structural-design-patterns"><a class="header" href="#some-common-structural-design-patterns">Some Common Structural Design Patterns</a></h3>
<p>1- <a href="rust/patterns/structural/./adapter.html">Adapter</a>: Allows objects with incompatible interfaces to work together by wrapping their own interface around that of an already existing class.</p>
<p>2- <a href="rust/patterns/structural/./bridge.html">Bridge</a>: Decouples an abstraction from its implementation so that the two can vary independently.</p>
<p>3- <a href="rust/patterns/structural/./composite.html">Composite</a>: Composes objects into tree structures to represent part-whole hierarchies, allowing clients to treat individual objects and compositions uniformly.</p>
<p>4- <a href="rust/patterns/structural/./decorator.html">Decorator</a>: Adds additional responsibilities to an object dynamically, providing a flexible alternative to subclassing for extending functionality.</p>
<p>5- <a href="rust/patterns/structural/./facade.html">Facade</a>: Provides a simplified interface to a complex subsystem, making it easier to use.</p>
<p>6- <a href="rust/patterns/structural/./flyweight.html">Flyweight</a>: Reduces the cost of creating and manipulating a large number of similar objects by sharing as much data as possible.</p>
<p>7- <a href="rust/patterns/structural/./proxy.html">Proxy</a>: Provides a surrogate or placeholder for another object to control access to it.</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="adapter-design-pattern"><a class="header" href="#adapter-design-pattern">Adapter Design Pattern</a></h3>
<p>The Adapter pattern allows incompatible interfaces to work together. This is useful when you want to use a class that doesn't have the exact interface you need.</p>
<pre><pre class="playground"><code class="language-rust">// The existing interface that we want to adapt
trait Target {
    fn request(&amp;self) -&gt; String;
}

// The adaptee class with a different interface
struct Adaptee;

impl Adaptee {
    fn specific_request(&amp;self) -&gt; String {
        &quot;specific request&quot;.to_string()
    }
}

// The adapter class that makes Adaptee compatible with Target
struct Adapter {
    adaptee: Adaptee,
}

impl Adapter {
    fn new(adaptee: Adaptee) -&gt; Self {
        Adapter { adaptee }
    }
}

impl Target for Adapter {
    fn request(&amp;self) -&gt; String {
        // Translate the interface of Adaptee to the Target interface
        self.adaptee.specific_request()
    }
}

fn main() {
    let adaptee = Adaptee;
    let adapter = Adapter::new(adaptee);

    // Client code can use the adapter as if it were a Target
    println!(&quot;Adapter request: {}&quot;, adapter.request());
}
</code></pre></pre>
<ol>
<li><strong>Target Trait</strong>: Defines the interface that the client expects.</li>
<li><strong>Adaptee Struct</strong>: The existing class with a different interface that needs to be adapted.</li>
<li><strong>Adapter Struct</strong>: Implements the <code>Target</code> trait and translates the interface of <code>Adaptee</code> to the <code>Target</code> interface.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h3 id="bridge-design-pattern"><a class="header" href="#bridge-design-pattern">Bridge Design Pattern</a></h3>
<p>The Bridge pattern is used to separate the abstraction from its implementation, allowing them to vary independently. It is useful when both the class and what it does vary often.</p>
<pre><pre class="playground"><code class="language-rust">// Abstraction
trait Shape {
    fn draw(&amp;self);
}

// Implementor
trait Color {
    fn fill(&amp;self);
}

// Concrete Implementor 1
struct Red;

impl Color for Red {
    fn fill(&amp;self) {
        println!(&quot;Filling with red color&quot;);
    }
}

// Concrete Implementor 2
struct Blue;

impl Color for Blue {
    fn fill(&amp;self) {
        println!(&quot;Filling with blue color&quot;);
    }
}

// Refined Abstraction
struct Circle {
    color: Box&lt;dyn Color&gt;,
}

impl Shape for Circle {
    fn draw(&amp;self) {
        print!(&quot;Drawing Circle - &quot;);
        self.color.fill();
    }
}

// Refined Abstraction
struct Square {
    color: Box&lt;dyn Color&gt;,
}

impl Shape for Square {
    fn draw(&amp;self) {
        print!(&quot;Drawing Square - &quot;);
        self.color.fill();
    }
}

fn main() {
    let red = Box::new(Red);
    let blue = Box::new(Blue);

    let red_circle = Circle { color: red };
    let blue_square = Square { color: blue };

    red_circle.draw();
    blue_square.draw();
}
</code></pre></pre>
<ol>
<li><strong>Shape Trait</strong>: Defines the abstraction with a <code>draw</code> method.</li>
<li><strong>Color Trait</strong>: Defines the implementor with a <code>fill</code> method.</li>
<li><strong>Red and Blue Structs</strong>: Concrete implementors of the <code>Color</code> trait.</li>
<li><strong>Circle and Square Structs</strong>: Refined abstractions that implement the <code>Shape</code> trait and use a <code>Color</code> to fill the shape.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h3 id="composite-design-pattern"><a class="header" href="#composite-design-pattern">Composite Design Pattern</a></h3>
<p>The Composite pattern allows you to compose objects into tree structures to represent part-whole hierarchies. It lets clients treat individual objects and compositions of objects uniformly.</p>
<pre><pre class="playground"><code class="language-rust">trait Component {
    fn operation(&amp;self) -&gt; String;
}

struct Leaf {
    name: String,
}

impl Leaf {
    fn new(name: &amp;str) -&gt; Self {
        Leaf {
            name: name.to_string(),
        }
    }
}

impl Component for Leaf {
    fn operation(&amp;self) -&gt; String {
        format!(&quot;Leaf {}&quot;, self.name)
    }
}

struct Composite {
    name: String,
    children: Vec&lt;Box&lt;dyn Component&gt;&gt;,
}

impl Composite {
    fn new(name: &amp;str) -&gt; Self {
        Composite {
            name: name.to_string(),
            children: Vec::new(),
        }
    }

    fn add(&amp;mut self, component: Box&lt;dyn Component&gt;) {
        self.children.push(component);
    }
}

impl Component for Composite {
    fn operation(&amp;self) -&gt; String {
        let mut result = format!(&quot;Composite {} contains:\n&quot;, self.name);
        for child in &amp;self.children {
            result.push_str(&amp;format!(&quot;  {}\n&quot;, child.operation()));
        }
        result
    }
}

fn main() {
    let mut root = Composite::new(&quot;root&quot;);

    let leaf1 = Box::new(Leaf::new(&quot;Leaf 1&quot;));
    let leaf2 = Box::new(Leaf::new(&quot;Leaf 2&quot;));

    let mut sub_tree = Composite::new(&quot;sub-tree&quot;);
    let leaf3 = Box::new(Leaf::new(&quot;Leaf 3&quot;));
    sub_tree.add(leaf3);

    root.add(leaf1);
    root.add(leaf2);
    root.add(Box::new(sub_tree));

    println!(&quot;{}&quot;, root.operation());
}
</code></pre></pre>
<ol>
<li><strong>Component Trait</strong>: Defines the common interface for all components, both simple and complex.</li>
<li><strong>Leaf Struct</strong>: Represents the leaf objects in the composition. Implements the <code>Component</code> trait.</li>
<li><strong>Composite Struct</strong>: Represents the composite objects that can have children. Implements the <code>Component</code> trait and provides methods to add children.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h3 id="decorator-design-pattern"><a class="header" href="#decorator-design-pattern">Decorator Design Pattern</a></h3>
<p>The Decorator pattern allows behavior to be added to an individual object, dynamically, without affecting the behavior of other objects from the same class. This is useful for adhering to the Single Responsibility Principle by allowing functionality to be divided between classes with unique areas of concern.</p>
<pre><pre class="playground"><code class="language-rust">trait Coffee {
    fn cost(&amp;self) -&gt; f64;
    fn description(&amp;self) -&gt; String;
}

struct SimpleCoffee;

impl Coffee for SimpleCoffee {
    fn cost(&amp;self) -&gt; f64 {
        5.0
    }

    fn description(&amp;self) -&gt; String {
        &quot;Simple coffee&quot;.to_string()
    }
}

struct MilkDecorator {
    coffee: Box&lt;dyn Coffee&gt;,
}

impl MilkDecorator {
    fn new(coffee: Box&lt;dyn Coffee&gt;) -&gt; Self {
        MilkDecorator { coffee }
    }
}

impl Coffee for MilkDecorator {
    fn cost(&amp;self) -&gt; f64 {
        self.coffee.cost() + 1.5
    }

    fn description(&amp;self) -&gt; String {
        format!(&quot;{}, with milk&quot;, self.coffee.description())
    }
}

struct SugarDecorator {
    coffee: Box&lt;dyn Coffee&gt;,
}

impl SugarDecorator {
    fn new(coffee: Box&lt;dyn Coffee&gt;) -&gt; Self {
        SugarDecorator { coffee }
    }
}

impl Coffee for SugarDecorator {
    fn cost(&amp;self) -&gt; f64 {
        self.coffee.cost() + 0.5
    }

    fn description(&amp;self) -&gt; String {
        format!(&quot;{}, with sugar&quot;, self.coffee.description())
    }
}

fn main() {
    let simple_coffee = Box::new(SimpleCoffee);
    println!(&quot;Cost: {}, Description: {}&quot;, simple_coffee.cost(), simple_coffee.description());

    let milk_coffee = Box::new(MilkDecorator::new(simple_coffee));
    println!(&quot;Cost: {}, Description: {}&quot;, milk_coffee.cost(), milk_coffee.description());

    let sugar_milk_coffee = Box::new(SugarDecorator::new(milk_coffee));
    println!(&quot;Cost: {}, Description: {}&quot;, sugar_milk_coffee.cost(), sugar_milk_coffee.description());
}
</code></pre></pre>
<ol>
<li><strong>Coffee Trait</strong>: Defines the interface for the coffee with methods <code>cost</code> and <code>description</code>.</li>
<li><strong>SimpleCoffee Struct</strong>: Implements the <code>Coffee</code> trait with basic cost and description.</li>
<li><strong>MilkDecorator Struct</strong>: A decorator that adds milk to the coffee, increasing the cost and updating the description.</li>
<li><strong>SugarDecorator Struct</strong>: A decorator that adds sugar to the coffee, increasing the cost and updating the description.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h3 id="facade-design-pattern"><a class="header" href="#facade-design-pattern">Facade Design Pattern</a></h3>
<p>The Facade pattern provides a simplified interface to a complex subsystem. It defines a higher-level interface that makes the subsystem easier to use.</p>
<pre><pre class="playground"><code class="language-rust">struct SubsystemA;

impl SubsystemA {
    fn operation_a1(&amp;self) -&gt; String {
        &quot;Subsystem A, Operation A1&quot;.to_string()
    }

    fn operation_a2(&amp;self) -&gt; String {
        &quot;Subsystem A, Operation A2&quot;.to_string()
    }
}

struct SubsystemB;

impl SubsystemB {
    fn operation_b1(&amp;self) -&gt; String {
        &quot;Subsystem B, Operation B1&quot;.to_string()
    }

    fn operation_b2(&amp;self) -&gt; String {
        &quot;Subsystem B, Operation B2&quot;.to_string()
    }
}

struct Facade {
    subsystem_a: SubsystemA,
    subsystem_b: SubsystemB,
}

impl Facade {
    fn new() -&gt; Self {
        Facade {
            subsystem_a: SubsystemA,
            subsystem_b: SubsystemB,
        }
    }

    fn operation(&amp;self) -&gt; String {
        let mut result = String::new();
        result.push_str(&amp;self.subsystem_a.operation_a1());
        result.push_str(&quot;\n&quot;);
        result.push_str(&amp;self.subsystem_a.operation_a2());
        result.push_str(&quot;\n&quot;);
        result.push_str(&amp;self.subsystem_b.operation_b1());
        result.push_str(&quot;\n&quot;);
        result.push_str(&amp;self.subsystem_b.operation_b2());
        result
    }
}

fn main() {
    let facade = Facade::new();
    println!(&quot;{}&quot;, facade.operation());
}
</code></pre></pre>
<ol>
<li><strong>SubsystemA and SubsystemB</strong>: Represent the complex subsystems with their own operations.</li>
<li><strong>Facade Struct</strong>: Provides a simplified interface to interact with the subsystems.</li>
<li><strong>new() Method</strong>: Initializes the subsystems.</li>
<li><strong>operation() Method</strong>: Provides a higher-level interface to perform operations involving multiple subsystems.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h3 id="flyweight-design-pattern"><a class="header" href="#flyweight-design-pattern">Flyweight Design Pattern</a></h3>
<p>The Flyweight pattern is used to minimize memory usage by sharing as much data as possible with similar objects. It is particularly useful when dealing with a large number of objects that have some shared state.</p>
<pre><pre class="playground"><code class="language-rust">use std::collections::HashMap;
use std::rc::Rc;

// The Flyweight struct that contains the shared state
struct Flyweight {
    shared_state: String,
}

impl Flyweight {
    fn new(shared_state: &amp;str) -&gt; Self {
        Flyweight {
            shared_state: shared_state.to_string(),
        }
    }

    fn operation(&amp;self, unique_state: &amp;str) {
        println!(
            &quot;Flyweight: Displaying shared ({}) and unique ({}) state.&quot;,
            self.shared_state, unique_state
        );
    }
}

// The FlyweightFactory that creates and manages Flyweight objects
struct FlyweightFactory {
    flyweights: HashMap&lt;String, Rc&lt;Flyweight&gt;&gt;,
}

impl FlyweightFactory {
    fn new() -&gt; Self {
        FlyweightFactory {
            flyweights: HashMap::new(),
        }
    }

    fn get_flyweight(&amp;mut self, shared_state: &amp;str) -&gt; Rc&lt;Flyweight&gt; {
        if !self.flyweights.contains_key(shared_state) {
            println!(&quot;FlyweightFactory: Creating new flyweight for state '{}'.&quot;, shared_state);
            let flyweight = Rc::new(Flyweight::new(shared_state));
            self.flyweights.insert(shared_state.to_string(), flyweight);
        } else {
            println!(&quot;FlyweightFactory: Reusing existing flyweight for state '{}'.&quot;, shared_state);
        }
        Rc::clone(self.flyweights.get(shared_state).unwrap())
    }
}

fn main() {
    let mut factory = FlyweightFactory::new();

    let flyweight1 = factory.get_flyweight(&quot;shared1&quot;);
    flyweight1.operation(&quot;unique1&quot;);

    let flyweight2 = factory.get_flyweight(&quot;shared2&quot;);
    flyweight2.operation(&quot;unique2&quot;);

    let flyweight3 = factory.get_flyweight(&quot;shared1&quot;);
    flyweight3.operation(&quot;unique3&quot;);
}
</code></pre></pre>
<ol>
<li><strong>Flyweight Struct</strong>: Contains the shared state that can be reused.</li>
<li><strong>FlyweightFactory Struct</strong>: Manages the creation and reuse of Flyweight objects.</li>
<li><strong>get_flyweight() Method</strong>: Returns an existing Flyweight if available, otherwise creates a new one.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h3 id="proxy-design-pattern"><a class="header" href="#proxy-design-pattern">Proxy Design Pattern</a></h3>
<p>The Proxy pattern provides a surrogate or placeholder for another object to control access to it. This can be useful for various purposes such as lazy initialization, access control, logging, etc.</p>
<pre><pre class="playground"><code class="language-rust">trait Subject {
    fn request(&amp;self) -&gt; String;
}

struct RealSubject;

impl Subject for RealSubject {
    fn request(&amp;self) -&gt; String {
        &quot;RealSubject: Handling request.&quot;.to_string()
    }
}

struct Proxy {
    real_subject: RealSubject,
}

impl Proxy {
    fn new() -&gt; Self {
        Proxy {
            real_subject: RealSubject,
        }
    }
}

impl Subject for Proxy {
    fn request(&amp;self) -&gt; String {
        println!(&quot;Proxy: Logging access to RealSubject.&quot;);
        self.real_subject.request()
    }
}

fn main() {
    let proxy = Proxy::new();
    println!(&quot;{}&quot;, proxy.request());
}
</code></pre></pre>
<ol>
<li><strong>Subject Trait</strong>: Defines the common interface for <code>RealSubject</code> and <code>Proxy</code>.</li>
<li><strong>RealSubject Struct</strong>: Implements the <code>Subject</code> trait and contains the actual business logic.</li>
<li><strong>Proxy Struct</strong>: Contains a reference to <code>RealSubject</code> and implements the <code>Subject</code> trait to control access to <code>RealSubject</code>.</li>
<li><strong>Proxy::new() Method</strong>: Creates a new instance of the <code>Proxy</code> with an instance of <code>RealSubject</code>.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h3 id="algorithms"><a class="header" href="#algorithms">Algorithms</a></h3>
<p>1- <a href="rust/algorithms/./sorting/intro.html">Sorting Algorithms</a>: Arrange data in a specific order (ascending, descending, etc.).</p>
<p>2- <a href="rust/algorithms/./searching/intro.html">Searching Algorithms</a>: Locate specific data in a dataset.</p>
<p>3- <a href="rust/algorithms/./graph/intro.html">Graph Algorithms</a>: Solve problems involving graphs (nodes and edges).</p>
<p>4- <a href="rust/algorithms/./dynamic-programming/intro.html">Dynamic Programming Algorithms</a>: Solve complex problems by breaking them 
down into overlapping subproblems.</p>
<p>5- <a href="rust/algorithms/./cryptographic">Cryptographic Algorithms</a>: Secure data and communications.</p>
<!-- 

# Machine Learning Algorithms
**Purpose:** Learn patterns and make predictions from data.

**Examples:**
- Linear Regression
- Decision Trees
- Support Vector Machines
- Neural Networks
- K-Means Clustering

# Numerical Algorithms
**Purpose:** Solve mathematical problems computationally.

**Examples:**
- Gaussian Elimination (Linear Systems)
- Newton-Raphson Method (Root Finding)
- Monte Carlo Methods (Simulations)

# String Processing Algorithms
**Purpose:** Operate on and analyze strings.

**Examples:**
- Knuth-Morris-Pratt (KMP) Algorithm
- Rabin-Karp Algorithm
- Levenshtein Distance
- Suffix Trees and Arrays

# Optimization Algorithms
**Purpose:** Find the best solution under given constraints.

**Examples:**
- Gradient Descent
- Simulated Annealing
- Genetic Algorithms
- Linear Programming

# Concurrent and Parallel Algorithms
**Purpose:** Optimize computations across multiple processors or threads.

**Examples:**
- MapReduce
- Fork-Join Algorithms
- Work Stealing Schedulers

# Randomized Algorithms
**Purpose:** Use randomness for computational processes.

**Examples:**
- QuickSort (Randomized Pivot)
- Monte Carlo Algorithms
- Las Vegas Algorithms

# Miscellaneous Algorithms
**Compression Algorithms:**
- Huffman Encoding
- LZW

**Simulation Algorithms:**
- Monte Carlo Simulation

**Data Structure-Specific Algorithms:**
- AVL Tree Rotations
- Hashing Techniques. Sorting Algorithms

--><div style="break-before: page; page-break-before: always;"></div><h3 id="sorting-algorithms"><a class="header" href="#sorting-algorithms">Sorting Algorithms</a></h3>
<p>Sorting algorithms are methods used to rearrange a list of elements in a particular order, typically in ascending or descending order. They are fundamental in computer science and are used in various applications, such as searching, data analysis, and database management.</p>
<p>1- <a href="rust/algorithms/sorting/./buble.html">Bubble Sort</a>: A simple comparison-based algorithm where each pair of adjacent elements is compared, and the elements are swapped if they are in the wrong order. This process is repeated until the list is sorted.</p>
<p>2- <a href="rust/algorithms/sorting/./quick.html">QuickSort</a>: A divide-and-conquer algorithm that selects a 'pivot' element from the array and partitions the other elements into two sub-arrays, according to whether they are less than or greater than the pivot. The sub-arrays are then sorted recursively.</p>
<p>3- <a href="rust/algorithms/sorting/./merge.html">Merge Sort</a>: Another divide-and-conquer algorithm that divides the list into two halves, recursively sorts each half, and then merges the two sorted halves back together.</p>
<p>4- <a href="rust/algorithms/sorting/./heap.html">Heap Sort</a>: A comparison-based sorting technique based on a binary heap data structure. It involves building a heap from the input data and then repeatedly extracting the maximum element from the heap and rebuilding the heap until all elements are sorted.</p>
<p>5- <a href="rust/algorithms/sorting/./counting.html">Counting Sort</a>: A non-comparison-based sorting algorithm that works by counting the number of occurrences of each distinct element in the input list. The count is then used to place the elements in the correct position in the output list.</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="bubble-sort-algorithm"><a class="header" href="#bubble-sort-algorithm">Bubble Sort Algorithm</a></h3>
<p>Bubble sort is a simple sorting algorithm that repeatedly steps through the list, compares adjacent elements, and swaps them if they are in the wrong order. The pass through the list is repeated until the list is sorted. For a visual explanation of the algorithm please visit <a href="https://en.wikipedia.org/wiki/Bubble_sort">Wikipedia</a>.</p>
<pre><pre class="playground"><code class="language-rust">fn bubble_sort(arr: &amp;mut [i32]) {
    let mut n = arr.len();
    while n &gt; 0 {
        let mut new_n = 0;
        for i in 1..n {
            if arr[i - 1] &gt; arr[i] {
                arr.swap(i - 1, i);
                new_n = i;
            }
        }
        println!(&quot;Iteration {:?} {}&quot;, arr, new_n);
        n = new_n;
    }
}

fn main() {
    let mut arr = [64, 34, 25, 12, 22, 12, 90, 33];
    println!(&quot;Unsorted array: {:?}&quot;, arr);
    bubble_sort(&amp;mut arr);
    println!(&quot;Sorted array: {:?}&quot;, arr);
}
</code></pre></pre>
<ul>
<li>The <code>bubble_sort</code> function takes a mutable slice of integers.</li>
<li>The outer <code>while</code> loop continues until the array is sorted. The variable <code>n</code> keeps track of the length of the unsorted portion of the array.</li>
<li>The inner <code>for</code> loop iterates through the array, comparing adjacent elements.</li>
<li>If the element at position <code>i-1</code> is greater than the element at position <code>i</code>, they are swapped using the <code>swap</code> method.</li>
<li>The variable <code>new_n</code> keeps track of the last swap position, which helps in reducing the number of comparisons in subsequent passes.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h3 id="quick-sort-algorithm"><a class="header" href="#quick-sort-algorithm">Quick Sort Algorithm</a></h3>
<p>Quick sort is based on partitioning of an array of data into smaller arrays. A large array is partitioned into two arrays, one of which holds values smaller than the specified value, say pivot, based on which the partition is made and another array holds values greater than the pivot value.</p>
<ol>
<li>Pick an element, called a pivot, from the array.</li>
<li>Partition the array into two sub-arrays:
<ul>
<li>Elements less than the pivot.</li>
<li>Elements greater than the pivot.</li>
</ul>
</li>
<li>Recursively apply the above steps to the sub-arrays.</li>
</ol>
<pre><pre class="playground"><code class="language-rust">fn quick_sort(arr: &amp;mut [i32]) {
     let len = arr.len();
     if len &lt; 2 {
          return;
     }
     let pivot_index = partition(arr);
     println!(&quot;Left array: {:?}&quot;, &amp;arr[0..pivot_index]);
     println!(&quot;Right array: {:?}&quot;, &amp;arr[pivot_index + 1..len]);
     quick_sort(&amp;mut arr[0..pivot_index]);
     quick_sort(&amp;mut arr[pivot_index + 1..len]);
}

fn partition(arr: &amp;mut [i32]) -&gt; usize {
     let len = arr.len();

     // Pick the mid element as pivot
     let pivot_index = len / 2;
     arr.swap(pivot_index, len - 1);
     
     let mut store_index = 0;
     for i in 0..len - 1 {
          if arr[i] &lt; arr[len - 1] {
                arr.swap(i, store_index);
                store_index += 1;
          }
     }
     arr.swap(store_index, len - 1);
     store_index
}

fn main() {
     let mut arr = [64, 34, 25, 12, 22, 12, 90, 33];
     println!(&quot;Original array: {:?}&quot;, arr);
     quick_sort(&amp;mut arr);
     println!(&quot;Sorted array: {:?}&quot;, arr);
}
</code></pre></pre>
<ul>
<li><code>quick_sort</code> function: This function takes a mutable slice of integers and sorts it using the Quick Sort algorithm. It recursively sorts the sub-arrays.</li>
<li><code>partition</code> function: This function partitions the array around a pivot element and returns the index of the pivot after partitioning. Often it is better to select the mid item as the pivot if the array is already semi-sorted.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h3 id="merge-sort-algorithm"><a class="header" href="#merge-sort-algorithm">Merge Sort Algorithm</a></h3>
<p>Merge sort is a divide-and-conquer algorithm that splits an array into halves, recursively sorts each half, and then merges the sorted halves to produce the final sorted array. For a visual explanation of the algorithm please visit <a href="https://www.programiz.com/dsa/merge-sort">Programiz</a>.</p>
<ol>
<li>Split the array into two halves.</li>
<li>Recursively sort each half.</li>
<li>Merge the two sorted halves into a single sorted array.</li>
</ol>
<pre><pre class="playground"><code class="language-rust">fn merge_sort&lt;T: Ord + Clone&gt;(arr: &amp;mut [T]) {
    let mid = arr.len() / 2;
    if mid == 0 {
        return;
    }

    merge_sort(&amp;mut arr[..mid]);
    merge_sort(&amp;mut arr[mid..]);

    let mut ret = arr.to_vec();

    merge(&amp;arr[..mid], &amp;arr[mid..], &amp;mut ret[..]);

    arr.clone_from_slice(&amp;ret);
}

// Merge two subarrays left and right into ret array
fn merge&lt;T: Ord + Clone&gt;(left: &amp;[T], right: &amp;[T], ret: &amp;mut [T]) {
    let mut left_iter = left.iter();
    let mut right_iter = right.iter();
    let mut left_peek = left_iter.next();
    let mut right_peek = right_iter.next();
    let mut i = 0;

    // Until we reach either end of either left or right array, pick the smaller 
    // among the elements and place it in the correct position at the returned array
    while let (Some(left_val), Some(right_val)) = (left_peek, right_peek) {
        if left_val &lt;= right_val {
            ret[i] = left_val.clone();
            left_peek = left_iter.next();
        } else {
            ret[i] = right_val.clone();
            right_peek = right_iter.next();
        }
        i += 1;
    }

    // At this point either left or right array may have elements 
    // not cloned to the returned array yet, those elements are 
    // cloned next.

    while let Some(left_val) = left_peek {
        ret[i] = left_val.clone();
        left_peek = left_iter.next();
        i += 1;
    }

    while let Some(right_val) = right_peek {
        ret[i] = right_val.clone();
        right_peek = right_iter.next();
        i += 1;
    }
}

fn main() {
    let mut arr = vec![38, 27, 43, 3, 9, 82, 10];
    println!(&quot;Original array: {:?}&quot;, arr);
    merge_sort(&amp;mut arr);
    println!(&quot;Sorted array: {:?}&quot;, arr);
}
</code></pre></pre>
<ul>
<li><code>merge_sort</code> function: Recursively splits the array into halves and sorts each half.</li>
<li><code>merge</code> function: Merges two sorted slices into a single sorted slice.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h3 id="heap-sort-algorithm"><a class="header" href="#heap-sort-algorithm">Heap Sort Algorithm</a></h3>
<p>Heap sort is a comparison-based sorting algorithm that uses a <a href="https://www.programiz.com/dsa/heap-data-structure">binary heap data structure</a>. It divides its input into a sorted and an unsorted region and iteratively shrinks the unsorted region by extracting the largest element and moving that to the sorted region. For a visual explanation of the algorithm please visit <a href="https://www.programiz.com/dsa/heap-sort">Programiz</a>.</p>
<ol>
<li>Build a max heap from the input data.</li>
<li>At this point, the largest item is stored at the root of the heap. Replace it with the last item of the heap followed by reducing the size of the heap by one. Finally, heapify the root of the tree.</li>
<li>Repeat step 2 while the size of the heap is greater than 1.</li>
</ol>
<pre><pre class="playground"><code class="language-rust">fn heapify(arr: &amp;mut [i32], n: usize, i: usize) {
    // Find largest among root, left child and right child
    let mut largest = i;
    let left = 2 * i + 1;
    let right = 2 * i + 2;

    if left &lt; n &amp;&amp; arr[left] &gt; arr[largest] {
        largest = left;
    }

    if right &lt; n &amp;&amp; arr[right] &gt; arr[largest] {
        largest = right;
    }

    // Swap and continue heapifying if root is not largest
    if largest != i {
        arr.swap(i, largest);
        heapify(arr, n, largest);
    }
}

fn heap_sort(arr: &amp;mut [i32]) {
    let n = arr.len();

    // Build max heap
    for i in (0..n / 2).rev() {
        heapify(arr, n, i);
    }

    // At this point arr[0] holds the larger item
    println!(&quot;Max heap array: {:?}&quot;, arr);

    // Heap sort, 
    for i in (1..n).rev() {
        arr.swap(0, i);
        // Heapify root element to get highest element at root again
        heapify(arr, i, 0);
    } 
} 

fn main() {
    let mut arr = [64, 34, 25, 12, 22, 12, 90, 33];
    println!(&quot;Original array: {:?}&quot;, arr);
    heap_sort(&amp;mut arr);
    println!(&quot;Sorted array: {:?}&quot;, arr);
}
</code></pre></pre>
<ul>
<li>The <code>heapify</code> function ensures that the subtree rooted at index <code>i</code> is a max heap. It compares the root with its children and swaps them if necessary, then recursively heapifies the affected subtree.</li>
<li>The <code>heap_sort</code> function first builds a max heap from the input array. It then repeatedly extracts the maximum element from the heap and places it at the end of the array, reducing the heap size each time.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h3 id="counting-sort-algorithm"><a class="header" href="#counting-sort-algorithm">Counting Sort Algorithm</a></h3>
<p>Counting sort is an integer sorting algorithm that operates by counting the number of objects that have distinct key values. It is not a comparison-based sorting algorithm and is efficient when the range of input values is not significantly greater than the number of objects to be sorted.  For a visual explanation of the algorithm please visit <a href="https://www.programiz.com/dsa/counting-sort">Programiz</a>.</p>
<ol>
<li>Determine the minimum and maximum values in the input array.</li>
<li>Create an array of size equal to the range of the input values, initialized to zero.</li>
<li>Iterate through the input array and count the occurrences of each value, storing the counts in the count array.</li>
<li>Modify the count array such that each element at each index stores the sum of previous counts. This step helps in placing the elements in the correct position in the output array.</li>
<li>Iterate through the input array in reverse order, placing each element in its correct position in the output array based on the count array, and then decrease the count by one.</li>
</ol>
<pre><pre class="playground"><code class="language-rust">fn counting_sort(arr: &amp;mut [usize], max_value: usize) {
    let mut count = vec![0; max_value + 1];
    let mut output = vec![0; arr.len()];

    // Count the occurrences of each value
    for &amp;num in arr.iter() {
        count[num] += 1;
    }
    println!(&quot;Count array: {:?}&quot;, count);

    // Accumulate the counts
    for i in 1..=max_value {
        count[i] += count[i - 1];
    }
    println!(&quot;Accumulated count array: {:?}&quot;, count);

    // Build the output array
    for &amp;num in arr.iter().rev() {
        println!(&quot;Current number being processed: {}&quot;, num);
        output[count[num] - 1] = num;
        println!(&quot;Output: {:?}&quot;, output);
        count[num] -= 1;
    }

    // Copy the sorted elements back to the original array
    arr.copy_from_slice(&amp;output);
}

fn main() {
    let mut arr = [4, 2, 2, 8, 3, 3, 1];
    let max_value = *arr.iter().max().unwrap();
    counting_sort(&amp;mut arr, max_value);
    println!(&quot;Sorted array: {:?}&quot;, arr);
}
</code></pre></pre>
<ul>
<li>The <code>counting_sort</code> function takes a mutable slice of integers <code>arr</code> and the maximum value <code>max_value</code> in the array.</li>
<li>It initializes a <code>count</code> array to store the count of each unique value and an <code>output</code> array to store the sorted elements.</li>
<li>It iterates through the input array to count the occurrences of each value.</li>
<li>It modifies the <code>count</code> array to accumulate the counts.</li>
<li>It iterates through the input array in reverse order to place each element in its correct position in the <code>output</code> array.</li>
<li>Finally, it copies the sorted elements from the <code>output</code> array back to the original array.</li>
</ul>
<p>This implementation assumes that the input array contains non-negative integers and that the maximum value is known or can be determined.</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="searching-algorithms"><a class="header" href="#searching-algorithms">Searching Algorithms</a></h3>
<p>Searching algorithms are designed to retrieve information stored within some data structure. They are fundamental to computer science and are used to solve a variety of problems. </p>
<p>1- <a href="rust/algorithms/searching/./linear.html">Linear Search</a>: A simple search algorithm that checks every element in the data structure until the desired element is found or the end is reached.</p>
<p>2- <a href="rust/algorithms/searching/./binary.html">Binary Search</a>: An efficient search algorithm that works on sorted data structures by repeatedly dividing the search interval in half until the target value is found or the interval is empty.</p>
<p>3- <a href="rust/algorithms/searching/./depth-first.html">Depth-First Search (DFS)</a>: An algorithm for traversing or searching tree or graph data structures, which starts at the root and explores as far as possible along each branch before backtracking.</p>
<p>4- <a href="rust/algorithms/searching/./breadth-first.html">Breadth-First Search (BFS)</a>: An algorithm for traversing or searching tree or graph data structures, which starts at the root and explores all neighbor nodes at the present depth prior to moving on to nodes at the next depth level.</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="linear-search-algorithm"><a class="header" href="#linear-search-algorithm">Linear Search Algorithm</a></h3>
<p>Linear search is a simple searching algorithm that checks each element in a list sequentially until the desired element is found or the list ends.</p>
<pre><pre class="playground"><code class="language-rust">fn linear_search(arr: &amp;[i32], target: i32) -&gt; Option&lt;usize&gt; {
    for (index, &amp;item) in arr.iter().enumerate() {
        if item == target {
            return Some(index);
        }
    }
    None
}

fn main() {
    let numbers = [1, 3, 5, 7, 9, 11];
    let target = 7;

    match linear_search(&amp;numbers, target) {
        Some(index) =&gt; println!(&quot;Found {} at index {}&quot;, target, index),
        None =&gt; println!(&quot;{} not found in the array&quot;, target),
    }
}
</code></pre></pre>
<ul>
<li>The <code>linear_search</code> function takes a slice of integers (<code>arr</code>) and a target integer (<code>target</code>) as arguments. </li>
<li>The function iterates over the array using <code>enumerate()</code> which provides both the index and the value of each element. For each element, it checks if the element is equal to the target. If a match is found, it returns the index wrapped in <code>Some</code>. If the loop completes without finding the target, the function returns <code>None</code>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h3 id="binary-search-algorithm"><a class="header" href="#binary-search-algorithm">Binary Search Algorithm</a></h3>
<p>Binary search is an efficient algorithm for finding an item from a sorted list of items. It works by repeatedly dividing in half the portion of the list that could contain the item, until you've narrowed down the possible locations to just one.</p>
<p>This implementation assumes that the input array is sorted. If the array is not sorted, the binary search algorithm will not work correctly. Check out the <a href="rust/algorithms/searching/../sorting/intro.html">sorting section</a> for implementations of some of array sorting algorithms.</p>
<pre><pre class="playground"><code class="language-rust">fn binary_search(arr: &amp;[i32], target: i32) -&gt; Option&lt;usize&gt; {
    let mut low = 0;
    let mut high = arr.len() - 1;

    while low &lt;= high {
        let mid = (low + high) / 2;
        if arr[mid] == target {
            return Some(mid);
        } else if arr[mid] &lt; target {
            low = mid + 1;
        } else {
            high = mid - 1;
        }
    }

    None
}

fn main() {
    let arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
    let target = 6;
    match binary_search(&amp;arr, target) {
        Some(index) =&gt; println!(&quot;Found {} at index {}&quot;, target, index),
        None =&gt; println!(&quot;{} not found in the array&quot;, target),
    }
}
</code></pre></pre>
<ul>
<li>The <code>binary_search</code> function takes a slice of integers and a target integer to search for.</li>
<li>It initializes two pointers, <code>low</code> and <code>high</code>, to the start and end of the array, respectively.</li>
<li>It enters a loop where it calculates the middle index and compares the middle element with the target.</li>
<li>If the middle element is equal to the target, it returns the index.</li>
<li>If the middle element is less than the target, it adjusts the <code>low</code> pointer to search the right half of the array.</li>
<li>If the middle element is greater than the target, it adjusts the <code>high</code> pointer to search the left half of the array.</li>
<li>If the target is not found, it returns <code>None</code>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h3 id="depth-first-search-dfs-algorithm-wip"><a class="header" href="#depth-first-search-dfs-algorithm-wip">Depth First Search (DFS) Algorithm (WIP)</a></h3>
<p>Depth First Search (DFS) is an algorithm for traversing or searching tree or graph data structures. The algorithm starts at the root node (selecting some arbitrary node as the root in the case of a graph) and explores as far as possible along each branch before backtracking.</p>
<pre><pre class="playground"><code class="language-rust">use std::collections::HashMap;

fn dfs(graph: &amp;HashMap&lt;i32, Vec&lt;i32&gt;&gt;, start: i32, visited: &amp;mut Vec&lt;i32&gt;) {
    if visited.contains(&amp;start) {
        return;
    }
    visited.push(start);
    if let Some(neighbors) = graph.get(&amp;start) {
        for &amp;neighbor in neighbors {
            dfs(graph, neighbor, visited);
        }
    }
}

fn main() {
    // Create a sample graph as an adjacency list
    let mut graph = HashMap::new();
    graph.insert(0, vec![1, 2]);
    graph.insert(1, vec![2]);
    graph.insert(2, vec![0, 3]);
    graph.insert(3, vec![3]);

    // Vector to keep track of visited nodes
    let mut visited = Vec::new();

    // Perform DFS starting from node 2
    dfs(&amp;graph, 2, &amp;mut visited);

    // Print the visited nodes
    println!(&quot;Visited nodes: {:?}&quot;, visited);
}
</code></pre></pre>
<ol>
<li><strong>Graph Representation</strong>: The graph is represented using a <code>HashMap</code> where each key is a node, and the value is a vector of its neighbors.</li>
<li><strong>DFS Function</strong>: The <code>dfs</code> function takes a reference to the graph, the current node, and a mutable reference to a vector of visited nodes.</li>
<li><strong>Base Case</strong>: If the current node has already been visited, the function returns.</li>
<li><strong>Visit Node</strong>: The current node is added to the visited vector.</li>
<li><strong>Recursive Call</strong>: The function recursively visits all the neighbors of the current node.</li>
<li><strong>Main Function</strong>: The <code>main</code> function initializes the graph, creates a vector to track visited nodes, and calls the <code>dfs</code> function starting from node 2. Finally, it prints the visited nodes.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h3 id="breadth-first-search-bfs-algorithm-wip"><a class="header" href="#breadth-first-search-bfs-algorithm-wip">Breadth-First Search (BFS) Algorithm (WIP)</a></h3>
<p>Breadth-First Search (BFS) is an algorithm for traversing or searching tree or graph data structures. It starts at the tree root (or an arbitrary node of a graph) and explores the neighbor nodes at the present depth prior to moving on to nodes at the next depth level.</p>
<pre><pre class="playground"><code class="language-rust">use std::collections::{HashMap, VecDeque};

fn bfs(graph: &amp;HashMap&lt;i32, Vec&lt;i32&gt;&gt;, start: i32) -&gt; Vec&lt;i32&gt; {
    let mut visited = Vec::new();
    let mut queue = VecDeque::new();
    queue.push_back(start);

    while let Some(node) = queue.pop_front() {
        if !visited.contains(&amp;node) {
            visited.push(node);
            if let Some(neighbors) = graph.get(&amp;node) {
                for &amp;neighbor in neighbors {
                    queue.push_back(neighbor);
                }
            }
        }
    }

    visited
}

fn main() {
    let mut graph = HashMap::new();
    graph.insert(1, vec![2, 3]);
    graph.insert(2, vec![4, 5]);
    graph.insert(3, vec![6, 7]);
    graph.insert(4, vec![]);
    graph.insert(5, vec![]);
    graph.insert(6, vec![]);
    graph.insert(7, vec![]);

    let start_node = 1;
    let result = bfs(&amp;graph, start_node);
    println!(&quot;BFS traversal starting from node {}: {:?}&quot;, start_node, result);
}
</code></pre></pre>
<ol>
<li><strong>Graph Representation</strong>: The graph is represented using a <code>HashMap</code> where each key is a node, and the value is a vector of its neighbors.</li>
<li><strong>BFS Function</strong>: The <code>bfs</code> function takes a reference to the graph and a starting node. It uses a <code>VecDeque</code> as a queue to manage the nodes to be explored.</li>
<li><strong>Traversal</strong>: The function iterates over the queue, marking nodes as visited and adding their neighbors to the queue if they haven't been visited yet.</li>
<li><strong>Main Function</strong>: The <code>main</code> function initializes the graph, calls the <code>bfs</code> function, and prints the result of the BFS traversal.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h3 id="graph-algorithms-wip"><a class="header" href="#graph-algorithms-wip">Graph Algorithms (WIP)</a></h3>
<p>Graph algorithms are a set of instructions designed to solve problems related to graph theory. These algorithms help in finding the shortest path, detecting cycles, finding the minimum spanning tree, and more. They are widely used in various fields such as computer networks, social networks, and geographical information systems.</p>
<p>1- <a href="rust/algorithms/graph/./shortest-path.html">Dijkstra’s Algorithm (Shortest Path)</a>: An algorithm for finding the shortest paths between nodes in a graph, which may represent, for example, road networks.</p>
<p>2- <a href="rust/algorithms/graph/./minimum-spanning-tree.html">Kruskal’s Algorithm (Minimum Spanning Tree)</a>: An algorithm for finding the minimum spanning tree for a connected weighted graph, ensuring that the total weight of the tree is minimized.</p>
<p>3- <a href="rust/algorithms/graph/./a-star.html">A* Algorithm (Pathfinding)</a>: A pathfinding and graph traversal algorithm, which is often used in many fields of computer science due to its performance and accuracy.</p>
<p>4- <a href="rust/algorithms/graph/./all-pairs-shortest-path.html">Floyd-Warshall Algorithm (All-Pairs Shortest Path)</a>: An algorithm for finding shortest paths in a weighted graph with positive or negative edge weights (but with no negative cycles), computing the shortest paths between all pairs of nodes.</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="shortest-path-graph-dijkstras-algorithm-wip"><a class="header" href="#shortest-path-graph-dijkstras-algorithm-wip">Shortest Path Graph (Dijkstra's) Algorithm (WIP)</a></h3>
<p>The shortest path algorithm is used to find the shortest path between nodes in a graph. One of the most common algorithms for this purpose is Dijkstra's algorithm. </p>
<pre><pre class="playground"><code class="language-rust">use std::collections::{BinaryHeap, HashMap};
use std::cmp::Ordering;

#[derive(Debug, Clone, Eq, PartialEq)]
struct State {
    cost: usize,
    position: usize,
}

// The priority queue depends on `Ord`.
// Explicitly implement the trait so the queue becomes a min-heap
// instead of a max-heap.
impl Ord for State {
    fn cmp(&amp;self, other: &amp;Self) -&gt; Ordering {
        // Notice that the we flip the ordering on costs.
        // In case of a tie we compare positions - this step is necessary
        // to make implementations of `PartialEq` and `Ord` consistent.
        other.cost.cmp(&amp;self.cost)
            .then_with(|| self.position.cmp(&amp;other.position))
    }
}

// `PartialOrd` needs to be implemented as well.
impl PartialOrd for State {
    fn partial_cmp(&amp;self, other: &amp;Self) -&gt; Option&lt;Ordering&gt; {
        Some(self.cmp(other))
    }
}

#[derive(Debug)]
struct Edge {
    node: usize,
    cost: usize,
}

fn dijkstra(adj_list: &amp;Vec&lt;Vec&lt;Edge&gt;&gt;, start: usize) -&gt; Vec&lt;usize&gt; {
    let mut dist: Vec&lt;_&gt; = (0..adj_list.len()).map(|_| usize::MAX).collect();
    let mut heap = BinaryHeap::new();

    // We're at `start`, with a zero cost
    dist[start] = 0;
    heap.push(State { cost: 0, position: start });

    // Examine the frontier with lower cost nodes first (min-heap)
    while let Some(State { cost, position }) = heap.pop() {
        // Important as we may have already found a better way
        if cost &gt; dist[position] {
            continue;
        }

        // For each node we can reach, see if we can find a way with
        // a lower cost going through this node
        for edge in &amp;adj_list[position] {
            let next = State { cost: cost + edge.cost, position: edge.node };

            // If so, add it to the frontier and continue
            if next.cost &lt; dist[next.position] {
                heap.push(next);
                // Relaxation, we have now found a better way
                dist[next.position] = next.cost;
            }
        }
    }

    dist
}

fn main() {
    // Create a graph represented as an adjacency list
    let graph = vec![
        vec![Edge { node: 1, cost: 2 }, Edge { node: 2, cost: 4 }],
        vec![Edge { node: 2, cost: 1 }, Edge { node: 3, cost: 7 }],
        vec![Edge { node: 3, cost: 3 }],
        vec![],
    ];

    // Calculate the shortest path from node 0
    let start_node = 0;
    let distances = dijkstra(&amp;graph, start_node);

    // Print the shortest path to each node
    for (i, d) in distances.iter().enumerate() {
        println!(&quot;The shortest path from node {} to node {} is {}&quot;, start_node, i, d);
    }
}
</code></pre></pre>
<ol>
<li><strong>Graph Representation</strong>: The graph is represented as an adjacency list where each node has a list of edges. Each edge has a target node and a cost.</li>
<li><strong>State Struct</strong>: The <code>State</code> struct keeps track of the current position and the cost to reach that position.</li>
<li><strong>Priority Queue</strong>: A binary heap is used as a priority queue to always expand the least costly node first.</li>
<li><strong>Dijkstra's Algorithm</strong>: The algorithm initializes the distance to the start node as 0 and all other distances as infinity. It then iteratively explores the graph, updating the shortest path to each node.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h3 id="minimum-spanning-tree-mst-wip"><a class="header" href="#minimum-spanning-tree-mst-wip">Minimum Spanning Tree (MST) (WIP)</a></h3>
<p>A Minimum Spanning Tree (MST) of a graph is a subset of the edges that connects all the vertices together, without any cycles and with the minimum possible total edge weight. One of the most common algorithms to find the MST is Kruskal's algorithm.</p>
<h2 id="kruskals-algorithm"><a class="header" href="#kruskals-algorithm">Kruskal's Algorithm</a></h2>
<p>Kruskal's algorithm works as follows:</p>
<ol>
<li>Sort all the edges in non-decreasing order of their weight.</li>
<li>Pick the smallest edge. Check if it forms a cycle with the spanning tree formed so far. If a cycle is not formed, include this edge. Else, discard it.</li>
<li>Repeat step 2 until there are (V-1) edges in the spanning tree.</li>
</ol>
<pre><pre class="playground"><code class="language-rust">use std::cmp::Ordering;
use std::collections::HashMap;

#[derive(Debug, Clone)]
struct Edge {
    src: usize,
    dest: usize,
    weight: i32,
}

#[derive(Debug)]
struct Graph {
    vertices: usize,
    edges: Vec&lt;Edge&gt;,
}

impl Graph {
    fn new(vertices: usize) -&gt; Self {
        Graph {
            vertices,
            edges: Vec::new(),
        }
    }

    fn add_edge(&amp;mut self, src: usize, dest: usize, weight: i32) {
        self.edges.push(Edge { src, dest, weight });
    }

    fn find(&amp;self, parent: &amp;mut Vec&lt;usize&gt;, i: usize) -&gt; usize {
        if parent[i] == i {
            i
        } else {
            self.find(parent, parent[i])
        }
    }

    fn union(&amp;self, parent: &amp;mut Vec&lt;usize&gt;, rank: &amp;mut Vec&lt;usize&gt;, x: usize, y: usize) {
        let xroot = self.find(parent, x);
        let yroot = self.find(parent, y);

        if rank[xroot] &lt; rank[yroot] {
            parent[xroot] = yroot;
        } else if rank[xroot] &gt; rank[yroot] {
            parent[yroot] = xroot;
        } else {
            parent[yroot] = xroot;
            rank[xroot] += 1;
        }
    }

    fn kruskal_mst(&amp;self) -&gt; Vec&lt;Edge&gt; {
        let mut result: Vec&lt;Edge&gt; = Vec::new();
        let mut i = 0;
        let mut e = 0;

        let mut edges = self.edges.clone();
        edges.sort_by(|a, b| a.weight.cmp(&amp;b.weight));

        let mut parent: Vec&lt;usize&gt; = Vec::with_capacity(self.vertices);
        let mut rank: Vec&lt;usize&gt; = Vec::with_capacity(self.vertices);

        for node in 0..self.vertices {
            parent.push(node);
            rank.push(0);
        }

        while e &lt; self.vertices - 1 {
            let next_edge = edges[i].clone();
            i += 1;

            let x = self.find(&amp;mut parent, next_edge.src);
            let y = self.find(&amp;mut parent, next_edge.dest);

            if x != y {
                result.push(next_edge);
                e += 1;
                self.union(&amp;mut parent, &amp;mut rank, x, y);
            }
        }

        result
    }
}

fn main() {
    let mut graph = Graph::new(4);
    graph.add_edge(0, 1, 10);
    graph.add_edge(0, 2, 6);
    graph.add_edge(0, 3, 5);
    graph.add_edge(1, 3, 15);
    graph.add_edge(2, 3, 4);

    let mst = graph.kruskal_mst();
    println!(&quot;Edges in the constructed MST:&quot;);
    for edge in mst {
        println!(&quot;{} -- {} == {}&quot;, edge.src, edge.dest, edge.weight);
    }
}
</code></pre></pre>
<p>We create a graph with 4 vertices and 5 edges. We then use Kruskal's algorithm to find the MST and print the edges of the MST.</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="a-pathfinding-algorithm-wip"><a class="header" href="#a-pathfinding-algorithm-wip">A* Pathfinding Algorithm (WIP)</a></h3>
<p>The A* (A-star) algorithm is a popular pathfinding and graph traversal algorithm. It is widely used in various applications, such as in games for NPC movement, in robotics for navigation, and in geographic information systems for route planning.</p>
<h3 id="how-a-algorithm-works"><a class="header" href="#how-a-algorithm-works">How A* Algorithm Works</a></h3>
<p>A* algorithm combines the strengths of Dijkstra's Algorithm and Greedy Best-First-Search. It uses a heuristic to guide its search and find the shortest path efficiently.</p>
<p>The algorithm maintains two lists:</p>
<ul>
<li><strong>Open List</strong>: Nodes that need to be evaluated.</li>
<li><strong>Closed List</strong>: Nodes that have already been evaluated.</li>
</ul>
<p>The algorithm follows these steps:</p>
<ol>
<li>Add the starting node to the open list.</li>
<li>Repeat the following steps until the open list is empty:
<ul>
<li>a. Remove the node with the lowest <code>f</code> value from the open list (current node).</li>
<li>b. If the current node is the goal, reconstruct the path and return it.</li>
<li>c. For each neighbor of the current node:
<ul>
<li>i. If the neighbor is in the closed list, skip it.</li>
<li>ii. If the neighbor is not in the open list, add it and compute its <code>f</code>, <code>g</code>, and <code>h</code> values.</li>
<li>iii. If the neighbor is in the open list, check if the new path is better (lower <code>g</code> value). If so, update its <code>f</code>, <code>g</code>, and <code>h</code> values.</li>
</ul>
</li>
<li>d. Add the current node to the closed list.</li>
</ul>
</li>
</ol>
<p>Where:</p>
<ul>
<li><code>g</code> is the cost from the start node to the current node.</li>
<li><code>h</code> is the heuristic estimate of the cost from the current node to the goal.</li>
<li><code>f</code> is the sum of <code>g</code> and <code>h</code>.</li>
</ul>
<p>Below is a simple implementation of the A* algorithm in Rust:</p>
<pre><pre class="playground"><code class="language-rust">use std::collections::{BinaryHeap, HashMap};
use std::cmp::Ordering;

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
struct Node {
     position: (i32, i32),
     g: i32,
     h: i32,
}

impl Node {
     fn f(&amp;self) -&gt; i32 {
          self.g + self.h
     }
}

impl Ord for Node {
     fn cmp(&amp;self, other: &amp;Self) -&gt; Ordering {
          other.f().cmp(&amp;self.f())
     }
}

impl PartialOrd for Node {
     fn partial_cmp(&amp;self, other: &amp;Self) -&gt; Option&lt;Ordering&gt; {
          Some(self.cmp(other))
     }
}

fn heuristic(a: (i32, i32), b: (i32, i32)) -&gt; i32 {
     (a.0 - b.0).abs() + (a.1 - b.1).abs()
}

fn a_star(start: (i32, i32), goal: (i32, i32), obstacles: &amp;[(i32, i32)]) -&gt; Option&lt;Vec&lt;(i32, i32)&gt;&gt; {
     let mut open_list = BinaryHeap::new();
     let mut closed_list = HashMap::new();
     let mut came_from = HashMap::new();

     open_list.push(Node {
          position: start,
          g: 0,
          h: heuristic(start, goal),
     });

     while let Some(current) = open_list.pop() {
          if current.position == goal {
                let mut path = vec![current.position];
                let mut current_position = current.position;
                while let Some(&amp;prev_position) = came_from.get(&amp;current_position) {
                     path.push(prev_position);
                     current_position = prev_position;
                }
                path.reverse();
                return Some(path);
          }

          closed_list.insert(current.position, current.g);

          for &amp;neighbor in &amp;[
                (current.position.0 - 1, current.position.1),
                (current.position.0 + 1, current.position.1),
                (current.position.0, current.position.1 - 1),
                (current.position.0, current.position.1 + 1),
          ] {
                if obstacles.contains(&amp;neighbor) || closed_list.contains_key(&amp;neighbor) {
                     continue;
                }

                let tentative_g = current.g + 1;

                if let Some(&amp;existing_g) = closed_list.get(&amp;neighbor) {
                     if tentative_g &gt;= existing_g {
                          continue;
                     }
                }

                open_list.push(Node {
                     position: neighbor,
                     g: tentative_g,
                     h: heuristic(neighbor, goal),
                });

                came_from.insert(neighbor, current.position);
          }
     }

     None
}

fn main() {
     let start = (0, 0);
     let goal = (4, 4);
     let obstacles = [(1, 1), (2, 2), (3, 3)];

     if let Some(path) = a_star(start, goal, &amp;obstacles) {
          println!(&quot;Path found: {:?}&quot;, path);
     } else {
          println!(&quot;No path found.&quot;);
     }
}
</code></pre></pre>
<p>This example demonstrates a simple A* pathfinding algorithm in Rust. The <code>a_star</code> function takes the start and goal positions, as well as a list of obstacles, and returns the shortest path if one exists.</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="all-pairs-shortest-path-algorithm-wip"><a class="header" href="#all-pairs-shortest-path-algorithm-wip">All Pairs Shortest Path Algorithm (WIP)</a></h3>
<p>The All Pairs Shortest Path (APSP) algorithm is used to find the shortest paths between all pairs of nodes in a graph. One of the most common algorithms to solve this problem is the Floyd-Warshall algorithm.</p>
<h3 id="floyd-warshall-algorithm"><a class="header" href="#floyd-warshall-algorithm">Floyd-Warshall Algorithm</a></h3>
<p>The Floyd-Warshall algorithm works by iteratively improving the shortest path estimates between all pairs of nodes. It uses a dynamic programming approach to build up the shortest paths by considering each node as an intermediate point.</p>
<h3 id="steps-of-the-algorithm"><a class="header" href="#steps-of-the-algorithm">Steps of the Algorithm</a></h3>
<ol>
<li>
<p><strong>Initialization</strong>: Create a distance matrix <code>dist</code> where <code>dist[i][j]</code> represents the shortest distance from node <code>i</code> to node <code>j</code>. Initialize <code>dist[i][j]</code> to the weight of the edge from <code>i</code> to <code>j</code> if it exists, otherwise set it to infinity. Set <code>dist[i][i]</code> to 0 for all nodes <code>i</code>.</p>
</li>
<li>
<p><strong>Iterative Update</strong>: For each node <code>k</code>, update the distance matrix by considering <code>k</code> as an intermediate node. For each pair of nodes <code>(i, j)</code>, update <code>dist[i][j]</code> to be the minimum of <code>dist[i][j]</code> and <code>dist[i][k] + dist[k][j]</code>.</p>
</li>
<li>
<p><strong>Result</strong>: After considering all nodes as intermediate points, the distance matrix <code>dist</code> will contain the shortest distances between all pairs of nodes.</p>
</li>
</ol>
<pre><pre class="playground"><code class="language-rust">const INF: i32 = i32::MAX / 2; // Use a large value to represent infinity

fn floyd_warshall(graph: &amp;Vec&lt;Vec&lt;i32&gt;&gt;) -&gt; Vec&lt;Vec&lt;i32&gt;&gt; {
    let n = graph.len();
    let mut dist = graph.clone();

    for k in 0..n {
        for i in 0..n {
            for j in 0..n {
                if dist[i][j] &gt; dist[i][k] + dist[k][j] {
                    dist[i][j] = dist[i][k] + dist[k][j];
                }
            }
        }
    }

    dist
}

fn main() {
    let graph = vec![
        vec![0, 3, INF, 5],
        vec![2, 0, INF, 4],
        vec![INF, 1, 0, INF],
        vec![INF, INF, 2, 0],
    ];

    let shortest_paths = floyd_warshall(&amp;graph);

    println!(&quot;Shortest distances between every pair of vertices:&quot;);
    for row in shortest_paths {
        for &amp;dist in &amp;row {
            if dist == INF {
                print!(&quot;INF &quot;);
            } else {
                print!(&quot;{} &quot;, dist);
            }
        }
        println!();
    }
}
</code></pre></pre>
<ul>
<li><strong>Initialization</strong>: The <code>graph</code> is represented as an adjacency matrix where <code>graph[i][j]</code> is the weight of the edge from node <code>i</code> to node <code>j</code>. If there is no edge, it is set to <code>INF</code>.</li>
<li><strong>Iterative Update</strong>: The nested loops update the distance matrix by considering each node as an intermediate point.</li>
<li><strong>Result</strong>: The final distance matrix <code>shortest_paths</code> contains the shortest distances between all pairs of nodes.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h3 id="dynamic-programming-algorithms-wip"><a class="header" href="#dynamic-programming-algorithms-wip">Dynamic Programming Algorithms (WIP)</a></h3>
<p>Dynamic programming is a method for solving complex problems by breaking them down into simpler subproblems. It is applicable when the problem can be divided into overlapping subproblems which can be solved independently. The solutions to these subproblems are stored to avoid redundant computations, making the overall algorithm more efficient.</p>
<p>1- <a href="rust/algorithms/dynamic-programming/./knapsack-problem.html">Knapsack Problem</a>: This problem involves selecting a subset of items with given weights and values to maximize the total value without exceeding a specified weight limit.</p>
<p>2- <a href="rust/algorithms/dynamic-programming/./longest-common-subsequence.html">Longest Common Subsequence</a>: This algorithm finds the longest subsequence common to two sequences, which may not be contiguous, to determine their similarity.</p>
<p>3- <a href="rust/algorithms/dynamic-programming/./matrix-chain-multiplication.html">Matrix Chain Multiplication</a>: This problem focuses on finding the most efficient way to multiply a given sequence of matrices by determining the optimal order of multiplications.</p>
<p>4- <a href="rust/algorithms/dynamic-programming/./fibonacci.html">Fibonacci Sequence</a>: This algorithm generates the Fibonacci sequence, where each number is the sum of the two preceding ones, starting from 0 and 1.</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="knapsack-problem-wip"><a class="header" href="#knapsack-problem-wip">Knapsack Problem (WIP)</a></h3>
<p>The Knapsack Problem is a classic dynamic programming problem. Given a set of items, each with a weight and a value, determine the number of each item to include in a collection so that the total weight is less than or equal to a given limit and the total value is as large as possible.</p>
<h3 id="problem-statement"><a class="header" href="#problem-statement">Problem Statement</a></h3>
<p>You are given weights and values of <code>n</code> items, put these items in a knapsack of capacity <code>W</code> to get the maximum total value in the knapsack. </p>
<h3 id="dynamic-programming-approach"><a class="header" href="#dynamic-programming-approach">Dynamic Programming Approach</a></h3>
<p>We can solve this problem using dynamic programming by creating a 2D array <code>dp</code> where <code>dp[i][w]</code> represents the maximum value that can be obtained with the first <code>i</code> items and a knapsack capacity of <code>w</code>.</p>
<h3 id="steps"><a class="header" href="#steps">Steps</a></h3>
<ol>
<li>Initialize a 2D array <code>dp</code> with dimensions <code>(n+1) x (W+1)</code> where <code>n</code> is the number of items and <code>W</code> is the maximum capacity of the knapsack.</li>
<li>Iterate through each item and each capacity, updating the <code>dp</code> array based on whether the current item is included or excluded.</li>
<li>The value at <code>dp[n][W]</code> will be the maximum value that can be obtained with the given items and knapsack capacity.</li>
</ol>
<pre><pre class="playground"><code class="language-rust">fn knapsack(weights: &amp;[usize], values: &amp;[usize], capacity: usize) -&gt; usize {
    let n = weights.len();
    let mut dp = vec![vec![0; capacity + 1]; n + 1];

    for i in 1..=n {
        for w in 1..=capacity {
            if weights[i - 1] &lt;= w {
                dp[i][w] = dp[i - 1][w].max(dp[i - 1][w - weights[i - 1]] + values[i - 1]);
            } else {
                dp[i][w] = dp[i - 1][w];
            }
        }
    }

    dp[n][capacity]
}

fn main() {
    let weights = vec![1, 3, 4, 5];
    let values = vec![1, 4, 5, 7];
    let capacity = 7;
    let max_value = knapsack(&amp;weights, &amp;values, capacity);
    println!(&quot;The maximum value that can be obtained is: {}&quot;, max_value);
}
</code></pre></pre>
<ul>
<li><code>weights</code> and <code>values</code> are arrays representing the weights and values of the items.</li>
<li><code>capacity</code> is the maximum weight the knapsack can hold.</li>
<li>The <code>knapsack</code> function initializes the <code>dp</code> array and iterates through each item and capacity to fill the <code>dp</code> array.</li>
<li>The <code>main</code> function demonstrates how to use the <code>knapsack</code> function with a sample input.</li>
</ul>
<p>This implementation ensures that we find the maximum value that can be obtained without exceeding the knapsack's capacity.</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="longest-common-subsequence-lcs-wip"><a class="header" href="#longest-common-subsequence-lcs-wip">Longest Common Subsequence (LCS) (WIP)</a></h3>
<p>The Longest Common Subsequence (LCS) problem is a classic dynamic programming problem. It involves finding the longest subsequence common to two sequences. A subsequence is a sequence derived from another sequence by deleting some elements without changing the order of the remaining elements.</p>
<p>Given two sequences, <code>X</code> and <code>Y</code>, the LCS problem is to find the longest subsequence that is present in both sequences. For example, if <code>X = &quot;ABCBDAB&quot;</code> and <code>Y = &quot;BDCAB&quot;</code>, the LCS is <code>&quot;BCAB&quot;</code>.</p>
<h3 id="dynamic-programming-approach-1"><a class="header" href="#dynamic-programming-approach-1">Dynamic Programming Approach</a></h3>
<p>We can solve the LCS problem using dynamic programming by constructing a 2D table <code>dp</code> where <code>dp[i][j]</code> represents the length of the LCS of the sequences <code>X[0..i-1]</code> and <code>Y[0..j-1]</code>.</p>
<h3 id="steps-1"><a class="header" href="#steps-1">Steps:</a></h3>
<ol>
<li>Initialize a 2D array <code>dp</code> of size <code>(m+1) x (n+1)</code> where <code>m</code> and <code>n</code> are the lengths of <code>X</code> and <code>Y</code> respectively.</li>
<li>Fill the table using the following rules:
<ul>
<li>If <code>X[i-1] == Y[j-1]</code>, then <code>dp[i][j] = dp[i-1][j-1] + 1</code></li>
<li>Otherwise, <code>dp[i][j] = max(dp[i-1][j], dp[i][j-1])</code></li>
</ul>
</li>
<li>The value at <code>dp[m][n]</code> will be the length of the LCS.</li>
</ol>
<pre><pre class="playground"><code class="language-rust">fn longest_common_subsequence(X: &amp;str, Y: &amp;str) -&gt; String {
     let m = X.len();
     let n = Y.len();
     let X: Vec&lt;char&gt; = X.chars().collect();
     let Y: Vec&lt;char&gt; = Y.chars().collect();
     
     let mut dp = vec![vec![0; n + 1]; m + 1];
     
     for i in 1..=m {
          for j in 1..=n {
                if X[i - 1] == Y[j - 1] {
                     dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                     dp[i][j] = dp[i - 1][j].max(dp[i][j - 1]);
                }
          }
     }
     
     // Reconstruct the LCS from the dp table
     let mut lcs = String::new();
     let (mut i, mut j) = (m, n);
     while i &gt; 0 &amp;&amp; j &gt; 0 {
          if X[i - 1] == Y[j - 1] {
                lcs.push(X[i - 1]);
                i -= 1;
                j -= 1;
          } else if dp[i - 1][j] &gt; dp[i][j - 1] {
                i -= 1;
          } else {
                j -= 1;
          }
     }
     
     lcs.chars().rev().collect()
}

fn main() {
     let X = &quot;ABCBDAB&quot;;
     let Y = &quot;BDCAB&quot;;
     let lcs = longest_common_subsequence(X, Y);
     println!(&quot;The Longest Common Subsequence is: {}&quot;, lcs);
}
</code></pre></pre>
<ol>
<li><strong>Initialization</strong>: We initialize the <code>dp</code> table with zeros.</li>
<li><strong>Filling the Table</strong>: We fill the table based on the rules mentioned above.</li>
<li><strong>Reconstructing the LCS</strong>: We backtrack from <code>dp[m][n]</code> to reconstruct the LCS.</li>
</ol>
<p>This implementation prints the LCS of the given sequences <code>X</code> and <code>Y</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="matrix-chain-multiplication-wip"><a class="header" href="#matrix-chain-multiplication-wip">Matrix Chain Multiplication (WIP)</a></h3>
<p>Matrix Chain Multiplication is a classic example of dynamic programming. The goal is to find the most efficient way to multiply a given sequence of matrices. The problem is not to perform the multiplications but to decide the order in which to perform the multiplications.</p>
<h3 id="problem-explanation"><a class="header" href="#problem-explanation">Problem Explanation</a></h3>
<p>Given a sequence of matrices, the task is to find the most efficient way to multiply these matrices together. The efficiency is measured in terms of the number of scalar multiplications needed.</p>
<p>For example, if you have matrices A, B, and C of dimensions 10x30, 30x5, and 5x60 respectively, you need to determine the order of multiplication that minimizes the total number of scalar multiplications.</p>
<h3 id="dynamic-programming-solution"><a class="header" href="#dynamic-programming-solution">Dynamic Programming Solution</a></h3>
<p>The dynamic programming approach involves breaking the problem into smaller subproblems and solving each subproblem only once, storing the results for future use.</p>
<h3 id="steps-2"><a class="header" href="#steps-2">Steps:</a></h3>
<ol>
<li>Define the cost of multiplying matrices from index <code>i</code> to <code>j</code> as <code>m[i][j]</code>.</li>
<li>Initialize the cost of multiplying one matrix as zero, i.e., <code>m[i][i] = 0</code>.</li>
<li>Use a nested loop to calculate the minimum cost for chains of increasing length.</li>
<li>Store the results in a table and use them to build up the solution for the entire chain.</li>
</ol>
<pre><pre class="playground"><code class="language-rust">fn matrix_chain_order(p: &amp;[usize]) -&gt; Vec&lt;Vec&lt;usize&gt;&gt; {
    let n = p.len() - 1;
    let mut m = vec![vec![0; n]; n];

    for l in 2..=n {
        for i in 0..n - l + 1 {
            let j = i + l - 1;
            m[i][j] = usize::MAX;
            for k in i..j {
                let q = m[i][k] + m[k + 1][j] + p[i] * p[k + 1] * p[j + 1];
                if q &lt; m[i][j] {
                    m[i][j] = q;
                }
            }
        }
    }

    m
}

fn main() {
    let p = vec![10, 30, 5, 60];
    let m = matrix_chain_order(&amp;p);
    println!(&quot;Minimum number of multiplications is {}&quot;, m[0][p.len() - 2]);
}
</code></pre></pre>
<ul>
<li><code>p</code> is an array where the <code>i</code>-th matrix has dimensions <code>p[i-1] x p[i]</code>.</li>
<li><code>m[i][j]</code> stores the minimum number of scalar multiplications needed to compute the matrix <code>A[i]A[i+1]...A[j]</code>.</li>
<li>The nested loops calculate the minimum cost for multiplying matrices from <code>i</code> to <code>j</code> by trying all possible positions to split the product.</li>
</ul>
<p>This implementation efficiently computes the minimum number of multiplications needed to multiply the given sequence of matrices.</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="fibonacci-sequence-with-dynamic-programming-wip"><a class="header" href="#fibonacci-sequence-with-dynamic-programming-wip">Fibonacci Sequence with Dynamic Programming (WIP)</a></h3>
<p>The Fibonacci sequence is a series of numbers where each number is the sum of the two preceding ones, usually starting with 0 and 1. Dynamic programming is an optimization technique that can be used to solve problems by breaking them down into simpler subproblems and storing the results of these subproblems to avoid redundant computations.</p>
<pre><pre class="playground"><code class="language-rust">fn fibonacci(n: usize) -&gt; usize {
    if n == 0 {
        return 0;
    } else if n == 1 {
        return 1;
    }

    let mut fib = vec![0; n + 1];
    fib[1] = 1;

    for i in 2..=n {
        fib[i] = fib[i - 1] + fib[i - 2];
    }

    fib[n]
}

fn main() {
    let n = 10;
    println!(&quot;Fibonacci number at position {} is {}&quot;, n, fibonacci(n));
}
</code></pre></pre>
<ol>
<li><strong>Base Cases</strong>: The function first checks if <code>n</code> is 0 or 1, returning 0 or 1 respectively, as these are the base cases of the Fibonacci sequence.</li>
<li><strong>Initialization</strong>: A vector <code>fib</code> is initialized with <code>n + 1</code> elements, all set to 0. The second element is set to 1, representing the first Fibonacci number.</li>
<li><strong>Iteration</strong>: A loop runs from 2 to <code>n</code>, calculating each Fibonacci number by summing the two preceding numbers and storing the result in the vector.</li>
<li><strong>Result</strong>: The function returns the <code>n</code>-th Fibonacci number stored in the vector.</li>
</ol>
<p>This approach ensures that each Fibonacci number is computed only once, resulting in a time complexity of O(n) and a space complexity of O(n).</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="cryptographic-algorithms-wip"><a class="header" href="#cryptographic-algorithms-wip">Cryptographic Algorithms (WIP)</a></h3>
<p>Cryptographic algorithms are methods used to secure data through encryption, hashing, and key exchange techniques. They ensure the confidentiality, integrity, and authenticity of information in digital communications.</p>
<p>1- <a href="rust/algorithms/cryptographic/./rsa.html">RSA (Asymmetric Encryption)</a>: RSA is a public-key encryption algorithm that uses two keys, one for encryption and one for decryption. It is widely used for secure data transmission.</p>
<p>2- <a href="rust/algorithms/cryptographic/./aes.html">AES (Symmetric Encryption)</a>: AES (Advanced Encryption Standard) is a symmetric encryption algorithm that uses the same key for both encryption and decryption. It is known for its speed and security.</p>
<p>3- <a href="rust/algorithms/cryptographic/./sha-256.html">SHA-256 (Hashing)</a>: SHA-256 (Secure Hash Algorithm 256-bit) is a cryptographic hash function that produces a fixed-size 256-bit hash value. It is commonly used for data integrity verification.</p>
<p>4- <a href="rust/algorithms/cryptographic/./diffie-hellman.html">Diffie-Hellman (Key Exchange)</a>: Diffie-Hellman is a key exchange algorithm that allows two parties to securely share a secret key over an insecure channel. It is fundamental to many cryptographic protocols.</p>
<p>5- <a href="rust/algorithms/cryptographic/./bcrypt.html">Bcrypt (Hashing)</a>: Bcrypt is a password hashing function designed to be computationally intensive to protect against brute-force attacks. It incorporates a salt to protect against rainbow table attacks.</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="rsa-algorithm-wip"><a class="header" href="#rsa-algorithm-wip">RSA Algorithm (WIP)</a></h3>
<p>RSA (Rivest-Shamir-Adleman) is a widely used public-key cryptosystem for secure data transmission. It is based on the mathematical difficulty of factoring the product of two large prime numbers.</p>
<h3 id="how-rsa-works"><a class="header" href="#how-rsa-works">How RSA Works</a></h3>
<ol>
<li>
<p><strong>Key Generation</strong>:</p>
<ul>
<li>Choose two distinct large random prime numbers <code>p</code> and <code>q</code>.</li>
<li>Compute <code>n = p * q</code>. <code>n</code> is used as the modulus for both the public and private keys.</li>
<li>Compute the totient function <code>φ(n) = (p-1) * (q-1)</code>.</li>
<li>Choose an integer <code>e</code> such that <code>1 &lt; e &lt; φ(n)</code> and <code>e</code> is coprime with <code>φ(n)</code>. <code>e</code> is the public exponent.</li>
<li>Determine <code>d</code> as <code>d ≡ e^(-1) (mod φ(n))</code>. <code>d</code> is the private exponent.</li>
</ul>
</li>
<li>
<p><strong>Encryption</strong>:</p>
<ul>
<li>The public key is <code>(e, n)</code>.</li>
<li>The plaintext message <code>m</code> is encrypted to ciphertext <code>c</code> using the formula: <code>c ≡ m^e (mod n)</code>.</li>
</ul>
</li>
<li>
<p><strong>Decryption</strong>:</p>
<ul>
<li>The private key is <code>(d, n)</code>.</li>
<li>The ciphertext <code>c</code> is decrypted back to plaintext <code>m</code> using the formula: <code>m ≡ c^d (mod n)</code>.</li>
</ul>
</li>
</ol>
<p>Below is a simple example of RSA encryption and decryption in Rust:</p>
<pre><pre class="playground"><code class="language-rust">extern crate num_bigint as bigint;
extern crate num_traits;
extern crate rand;

use bigint::{BigInt, ToBigInt};
use num_traits::{One, Zero};
use rand::Rng;

fn main() {
     // Generate two large prime numbers (for simplicity, small primes are used here)
     let p = 61.to_bigint().unwrap();
     let q = 53.to_bigint().unwrap();
     
     // Compute n = p * q
     let n = &amp;p * &amp;q;
     
     // Compute φ(n) = (p-1) * (q-1)
     let phi = (&amp;p - 1) * (&amp;q - 1);
     
     // Choose e such that 1 &lt; e &lt; φ(n) and e is coprime with φ(n)
     let e = 17.to_bigint().unwrap();
     
     // Compute d as d ≡ e^(-1) (mod φ(n))
     let d = mod_inverse(&amp;e, &amp;phi).unwrap();
     
     // Public key (e, n) and private key (d, n)
     println!(&quot;Public Key: (e: {}, n: {})&quot;, e, n);
     println!(&quot;Private Key: (d: {}, n: {})&quot;, d, n);
     
     // Encrypt a message
     let message = 42.to_bigint().unwrap();
     let ciphertext = mod_exp(&amp;message, &amp;e, &amp;n);
     println!(&quot;Encrypted message: {}&quot;, ciphertext);
     
     // Decrypt the message
     let decrypted_message = mod_exp(&amp;ciphertext, &amp;d, &amp;n);
     println!(&quot;Decrypted message: {}&quot;, decrypted_message);
}

// Function to compute modular exponentiation
fn mod_exp(base: &amp;BigInt, exp: &amp;BigInt, modulus: &amp;BigInt) -&gt; BigInt {
     base.modpow(exp, modulus)
}

// Function to compute modular inverse
fn mod_inverse(a: &amp;BigInt, m: &amp;BigInt) -&gt; Option&lt;BigInt&gt; {
     let (g, x, _) = extended_gcd(a, m);
     if g.is_one() {
          Some((x % m + m) % m)
     } else {
          None
     }
}

// Function to compute extended GCD
fn extended_gcd(a: &amp;BigInt, b: &amp;BigInt) -&gt; (BigInt, BigInt, BigInt) {
     if b.is_zero() {
          (a.clone(), BigInt::one(), BigInt::zero())
     } else {
          let (g, x, y) = extended_gcd(b, &amp;(a % b));
          (g, y.clone(), x - (a / b) * y)
     }
}
</code></pre></pre>
<p>This example demonstrates the basic steps of RSA key generation, encryption, and decryption. Note that in a real-world application, you should use much larger prime numbers and a cryptographic library for secure key generation and operations.</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="aes-algorithm-wip"><a class="header" href="#aes-algorithm-wip">AES Algorithm (WIP)</a></h3>
<p>AES (Advanced Encryption Standard) is a symmetric encryption algorithm widely used across the globe. Below is a simple implementation of the AES algorithm in Rust without using any existing libraries.</p>
<pre><pre class="playground"><code class="language-rust">const S_BOX: [u8; 256] = [
    // S-Box values here...
];

fn sub_bytes(state: &amp;mut [u8; 16]) {
    for i in 0..16 {
        state[i] = S_BOX[state[i] as usize];
    }
}

fn shift_rows(state: &amp;mut [u8; 16]) {
    let mut temp = [0u8; 16];
    for i in 0..16 {
        temp[i] = state[i];
    }
    for i in 0..4 {
        for j in 0..4 {
            state[i + 4 * j] = temp[i + 4 * ((j + i) % 4)];
        }
    }
}

fn mix_columns(state: &amp;mut [u8; 16]) {
    // MixColumns implementation here...
}

fn add_round_key(state: &amp;mut [u8; 16], round_key: &amp;[u8; 16]) {
    for i in 0..16 {
        state[i] ^= round_key[i];
    }
}

fn aes_encrypt_block(block: &amp;mut [u8; 16], key: &amp;[u8; 16]) {
    let mut round_keys = [0u8; 176];
    key_expansion(key, &amp;mut round_keys);

    add_round_key(block, &amp;round_keys[0..16]);

    for round in 1..10 {
        sub_bytes(block);
        shift_rows(block);
        mix_columns(block);
        add_round_key(block, &amp;round_keys[round * 16..(round + 1) * 16]);
    }

    sub_bytes(block);
    shift_rows(block);
    add_round_key(block, &amp;round_keys[160..176]);
}

fn key_expansion(key: &amp;[u8; 16], round_keys: &amp;mut [u8; 176]) {
    // Key expansion implementation here...
}

fn main() {
    let mut block = [0x32, 0x43, 0xf6, 0xa8, 0x88, 0x5a, 0x30, 0x8d, 0x31, 0x31, 0x98, 0xa2, 0xe0, 0x37, 0x07, 0x34];
    let key = [0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x4d, 0x4a, 0x4e, 0xa6, 0x2b, 0x7e];

    aes_encrypt_block(&amp;mut block, &amp;key);

    println!(&quot;Encrypted block: {:?}&quot;, block);
}
</code></pre></pre>
<p>This example provides a basic structure for AES encryption. Note that the <code>S_BOX</code>, <code>mix_columns</code>, and <code>key_expansion</code> functions need to be fully implemented for a complete AES encryption algorithm.</p>
<ol>
<li><strong>SubBytes</strong>: This step substitutes each byte in the state with a corresponding byte from the S-Box.</li>
<li><strong>ShiftRows</strong>: This step shifts the rows of the state array cyclically.</li>
<li><strong>MixColumns</strong>: This step mixes the columns of the state array.</li>
<li><strong>AddRoundKey</strong>: This step adds (XORs) the round key to the state.</li>
<li><strong>KeyExpansion</strong>: This step generates round keys from the initial key.</li>
</ol>
<p>The <code>aes_encrypt_block</code> function performs the encryption by applying these steps in the correct order for 10 rounds.</p>
<p>This is a simplified version and does not include all the details required for a secure AES implementation. For production use, consider using a well-tested cryptographic library.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sha-256-hash-algorithm-wip"><a class="header" href="#sha-256-hash-algorithm-wip">SHA-256 Hash Algorithm (WIP)</a></h1>
<p>SHA-256 (Secure Hash Algorithm 256-bit) is a cryptographic hash function that produces a 256-bit (32-byte) hash value. It is widely used in various security applications and protocols.</p>
<p>Below is a simple implementation of the SHA-256 algorithm in Rust without using any external libraries.</p>
<pre><pre class="playground"><code class="language-rust">const K: [u32; 64] = [
    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2,
];

fn sha256(input: &amp;[u8]) -&gt; [u8; 32] {
    let mut h: [u32; 8] = [
        0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,
        0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19,
    ];

    let mut padded = input.to_vec();
    let bit_len = (input.len() as u64) * 8;
    padded.push(0x80);
    while (padded.len() % 64) != 56 {
        padded.push(0);
    }
    padded.extend_from_slice(&amp;bit_len.to_be_bytes());

    for chunk in padded.chunks(64) {
        let mut w = [0u32; 64];
        for i in 0..16 {
            w[i] = u32::from_be_bytes([chunk[4 * i], chunk[4 * i + 1], chunk[4 * i + 2], chunk[4 * i + 3]]);
        }
        for i in 16..64 {
            let s0 = w[i - 15].rotate_right(7) ^ w[i - 15].rotate_right(18) ^ (w[i - 15] &gt;&gt; 3);
            let s1 = w[i - 2].rotate_right(17) ^ w[i - 2].rotate_right(19) ^ (w[i - 2] &gt;&gt; 10);
            w[i] = w[i - 16].wrapping_add(s0).wrapping_add(w[i - 7]).wrapping_add(s1);
        }

        let mut a = h[0];
        let mut b = h[1];
        let mut c = h[2];
        let mut d = h[3];
        let mut e = h[4];
        let mut f = h[5];
        let mut g = h[6];
        let mut h = h[7];

        for i in 0..64 {
            let s1 = e.rotate_right(6) ^ e.rotate_right(11) ^ e.rotate_right(25);
            let ch = (e &amp; f) ^ (!e &amp; g);
            let temp1 = h.wrapping_add(s1).wrapping_add(ch).wrapping_add(K[i]).wrapping_add(w[i]);
            let s0 = a.rotate_right(2) ^ a.rotate_right(13) ^ a.rotate_right(22);
            let maj = (a &amp; b) ^ (a &amp; c) ^ (b &amp; c);
            let temp2 = s0.wrapping_add(maj);

            h = g;
            g = f;
            f = e;
            e = d.wrapping_add(temp1);
            d = c;
            c = b;
            b = a;
            a = temp1.wrapping_add(temp2);
        }

        h[0] = h[0].wrapping_add(a);
        h[1] = h[1].wrapping_add(b);
        h[2] = h[2].wrapping_add(c);
        h[3] = h[3].wrapping_add(d);
        h[4] = h[4].wrapping_add(e);
        h[5] = h[5].wrapping_add(f);
        h[6] = h[6].wrapping_add(g);
        h[7] = h[7].wrapping_add(h);
    }

    let mut result = [0u8; 32];
    for (i, &amp;val) in h.iter().enumerate() {
        result[4 * i..4 * i + 4].copy_from_slice(&amp;val.to_be_bytes());
    }
    result
}

fn main() {
    let data = b&quot;hello world&quot;;
    let hash = sha256(data);
    for byte in &amp;hash {
        print!(&quot;{:02x}&quot;, byte);
    }
    println!();
}
</code></pre></pre>
<p>This code implements the SHA-256 algorithm step-by-step, including padding the input, processing each 512-bit chunk, and updating the hash values. The <code>main</code> function demonstrates how to use the <code>sha256</code> function to hash the string &quot;hello world&quot; and print the resulting hash in hexadecimal format.</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="diffie-hellman-key-exchange-wip"><a class="header" href="#diffie-hellman-key-exchange-wip">Diffie-Hellman Key Exchange (WIP)</a></h3>
<p>The Diffie-Hellman key exchange algorithm allows two parties to securely share a secret key over an insecure channel. </p>
<ol>
<li><strong>Choose Prime Numbers</strong>: Both parties agree on a large prime number <code>p</code> and a base <code>g</code>.</li>
<li><strong>Generate Private Keys</strong>: Each party generates a private key.</li>
<li><strong>Compute Public Keys</strong>: Each party computes their public key using the formula <code>g^private_key % p</code>.</li>
<li><strong>Exchange Public Keys</strong>: The public keys are exchanged between the parties.</li>
<li><strong>Compute Shared Secret</strong>: Each party computes the shared secret using the received public key and their own private key.</li>
</ol>
<p>Below is a simple implementation in Rust without using any external libraries.</p>
<pre><pre class="playground"><code class="language-rust">extern crate rand;

use rand::Rng;

fn main() {
    // Step 1: Agree on a prime number p and base g
    let p: u64 = 23; // A small prime number for simplicity
    let g: u64 = 5;  // A primitive root modulo p

    // Step 2: Each party generates a private key
    let private_key_a = generate_private_key();
    let private_key_b = generate_private_key();

    // Step 3: Compute public keys
    let public_key_a = mod_exp(g, private_key_a, p);
    let public_key_b = mod_exp(g, private_key_b, p);

    // Step 4: Exchange public keys (simulated here)
    println!(&quot;Public Key A: {}&quot;, public_key_a);
    println!(&quot;Public Key B: {}&quot;, public_key_b);

    // Step 5: Compute shared secret
    let shared_secret_a = mod_exp(public_key_b, private_key_a, p);
    let shared_secret_b = mod_exp(public_key_a, private_key_b, p);

    // Both shared secrets should be the same
    println!(&quot;Shared Secret A: {}&quot;, shared_secret_a);
    println!(&quot;Shared Secret B: {}&quot;, shared_secret_b);
}

fn generate_private_key() -&gt; u64 {
    rand::thread_rng().gen_range(1..100)
}

fn mod_exp(base: u64, exp: u64, modulus: u64) -&gt; u64 {
    let mut result = 1;
    let mut base = base % modulus;
    let mut exp = exp;

    while exp &gt; 0 {
        if exp % 2 == 1 {
            result = (result * base) % modulus;
        }
        exp = exp &gt;&gt; 1;
        base = (base * base) % modulus;
    }
    result
}
</code></pre></pre>
<p><code>generate_private_key</code>: Generates a random private key. <code>mod_exp</code>: Computes the modular exponentiation using the formula <code>(base^exp) % modulus</code>. The main function demonstrates the key exchange process, where both parties compute their public keys, exchange them, and then compute the shared secret.</p>
<p>This example uses small numbers for simplicity. In a real-world scenario, much larger prime numbers should be used to ensure security.</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="bcrypt-algorithm-wip"><a class="header" href="#bcrypt-algorithm-wip">Bcrypt Algorithm (WIP)</a></h3>
<p>Bcrypt is a password hashing function designed to be computationally expensive to resist brute-force attacks. </p>
<pre><pre class="playground"><code class="language-rust">extern crate rand;
use rand::{thread_rng, Rng};
use rand::distributions::Alphanumeric;
use std::time::{SystemTime, UNIX_EPOCH};
use std::convert::TryInto;

const BCRYPT_COST: u32 = 12;
const BCRYPT_SALT_LEN: usize = 16;
const BCRYPT_HASH_LEN: usize = 24;

fn generate_salt() -&gt; String {
    let salt: String = thread_rng()
        .sample_iter(&amp;Alphanumeric)
        .take(BCRYPT_SALT_LEN)
        .map(char::from)
        .collect();
    salt
}

fn bcrypt_hash(password: &amp;str, salt: &amp;str) -&gt; String {
    let mut hash = vec![0u8; BCRYPT_HASH_LEN];
    let cost = BCRYPT_COST;
    let password_bytes = password.as_bytes();
    let salt_bytes = salt.as_bytes();

    // Simulate bcrypt hashing (this is a simplified version)
    for i in 0..BCRYPT_HASH_LEN {
        hash[i] = password_bytes[i % password_bytes.len()] ^ salt_bytes[i % salt_bytes.len()] ^ (cost as u8);
    }

    base64::encode(&amp;hash)
}

fn main() {
    let password = &quot;my_secure_password&quot;;
    let salt = generate_salt();
    let hashed_password = bcrypt_hash(password, &amp;salt);

    println!(&quot;Password: {}&quot;, password);
    println!(&quot;Salt: {}&quot;, salt);
    println!(&quot;Hashed Password: {}&quot;, hashed_password);
}
</code></pre></pre>
<p>A random salt of length 16 is generated using the <code>rand</code> crate. The <code>bcrypt_hash</code> function simulates the bcrypt hashing process. It combines the password, salt, and cost to produce a hashed password.</p>
<p>Note: This is a simplified version of the bcrypt algorithm for educational purposes. In a real-world application, you should use a well-tested library like <code>bcrypt</code> crate for password hashing.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="khởi-động-chút-react"><a class="header" href="#khởi-động-chút-react">Khởi động chút React</a></h1>
<p>Theo như trang hướng dẫn nói thì cái trang này sẽ bao gồm khoảng 80% những gì mà bạn sẽ dùng trong React hàng ngày. Gọi bài này là dịch thì <em>vừa đúng vừa không đúng</em> vì mình đã thêm bớt khá nhiều sao cho hợp với cái hiểu của mình. Nhưng cấu trúc từng phần về cơ bản vẫn vậy.</p>
<p>Mình nghĩ là các nguyên lý cơ bản sẽ không dễ bị thay đổi quá nhanh cho nên là chắc để vậy cũng oke.</p>
<h3 id="tạo-và-nest-các-components"><a class="header" href="#tạo-và-nest-các-components">Tạo và nest các components</a></h3>
<p>Về cơ bản thì ứng dụng React toàn là <em>components</em> (A component is a piece of the UI (user interface) that has its own logic and appearance. A component can be as small as a button, or as large as an entire page). React components về cơ bản là JavaScript functions, nhưng trả về Markup:</p>
<pre><code class="language-js">function MyButton() {
  return (&lt;button&gt;I'm a button&lt;/button&gt;);
}
// Đã khai báo `MyButton` rồi nên có thể dùng trong Component khác, kiểu như này:
export default function MyApp() {
  return (&lt;div&gt;&lt;h1&gt;Welcome to my app&lt;/h1&gt;&lt;MyButton /&gt;&lt;/div&gt;);
}
</code></pre>
<p>Nhớ là <code>&lt;MyButton /&gt;</code> bắt đầu bằng chữ cái in hoa để nhận diện component, còn in thường là cho HTML tag. </p>
<h3 id="viết-markup-bằng-jsx"><a class="header" href="#viết-markup-bằng-jsx">Viết markup bằng JSX</a></h3>
<p>Cú pháp markup được dùng ở đây là <em>JSX</em> (Dù nó là <em>optional</em>, nhưng mấy ông dev bảo chẳng ai khổ dâm mà không dùng <em>JSX</em> cả)</p>
<p>JSX thì cứng nhắc hơn HTML. Ví dụ như cần phải đóng tag <code>&lt;br /&gt;</code>. Và cũng chỉ được trả một JSX tag. Hoặc là gói trong một <em>shared parent</em>, kiểu như <code>&lt;div&gt;...&lt;/div&gt;</code> hoặc <code>&lt;&gt;...&lt;/&gt;</code> </p>
<pre><code>function AboutPage() {return (&lt;&gt;&lt;h1&gt;About&lt;/h1&gt;&lt;p&gt;Hello there.&lt;br /&gt;How do you do?&lt;/p&gt;&lt;/&gt;);}
</code></pre>
<p>If you have a lot of HTML to port to JSX, you can use an <a href="https://transform.tools/html-to-jsx">online converter</a></p>
<h3 id="thêm-chút-kiểu-cách-styles"><a class="header" href="#thêm-chút-kiểu-cách-styles">Thêm chút kiểu cách (styles)</a></h3>
<p>Trong React thì khai báo CSS class bằng <code>className</code>. Hoạt động tương đương thuộc tính <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/class"><code>class</code></a> của HTML:</p>
<pre><code class="language-html">&lt;img className=&quot;avatar&quot; /&gt;
</code></pre>
<p>Rồi viết quy tắc CSS sang một tệp khác</p>
<pre><code class="language-css">/* In your CSS */
.avatar {border-radius: 50%;}
</code></pre>
<p>Thêm CSS thì tương tự như bình thường, có thể là thêm tag <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link"><code>&lt;link&gt;</code></a> vào tệp HTML.</p>
<h3 id="hiện-data"><a class="header" href="#hiện-data">Hiện data</a></h3>
<p>Sử dụng cặp ngoặc nhọn để thêm chút JavaScript vào <code>{}</code> ví dụ như <code>user.name</code>:</p>
<pre><code>return (&lt;h1&gt;{user.name}&lt;/h1&gt;);
</code></pre>
<p>Cũng có thể làm tương tự trong các thuộc tính của &quot;tag&quot; JSX. Ví dụ như <code>src={user.imageUrl}</code> sẽ đọc biến <code>user.imageUrl</code> trong JavaScript, và đưa vào thuộc tính <code>src</code>:</p>
<pre><code>return (&lt;imgclassName=&quot;avatar&quot;src={user.imageUrl}/&gt;);
</code></pre>
<!-- In the above example, `style={{}}` is not a special syntax, but a regular `{}` object inside the `style={ }` JSX curly braces. You can use the `style` attribute when your styles depend on JavaScript variables. -->
<h3 id="conditional-rendering"><a class="header" href="#conditional-rendering">Conditional rendering</a></h3>
<p>Về cơ bản thì dùng như viết JavaScript, như đoạn code dưới đây:</p>
<pre><code class="language-js">let doAn;
if (duTienMua) {
  doAn = &lt;BanhMi /&gt;;
} else {
  doAn = &lt;LamGiCoGiMaAn /&gt;; 
}
return (
  &lt;div&gt;
    {doAn}
  &lt;/div&gt;
);
</code></pre>
<p>Hoặc đơn giản hơn thì dùng Elvis operator</p>
<pre><code>&lt;div&gt;{duTienMua ? (&lt;BanhMi /&gt;) : (&lt;LamGiCoGiMaAn /&gt;)}&lt;/div&gt;
// Nếu không cần `else` thì gọn nữa
&lt;div&gt;{duTienMua &amp;&amp; &lt;BanhMi /&gt;}&lt;/div&gt;
</code></pre>
<h3 id="rendering-lists"><a class="header" href="#rendering-lists">Rendering lists</a></h3>
<p>Dùng các chức năng của bên JS <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for"><code>for</code> loop</a> hoặc <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map">array <code>map()</code> function</a> để render list components.</p>
<pre><code class="language-js">const products = [
  { title: 'Cabbage', id: 1 },
  { title: 'Garlic', id: 2 },
  { title: 'Apple', id: 3 }
];
// Inside your component, use the `map()` function to transform an array of products into an array of `&lt;li&gt;` items:
const listItems = products.map(
  product =&gt;
    &lt;li key={product.id}&gt;{product.title}&lt;/li&gt;
);
return (&lt;ul&gt;{listItems}&lt;/ul&gt;);

</code></pre>
<p>Để ý là <code>&lt;li&gt;</code> có thuộc tính <code>key</code> sử dụng để nhận diện giữa các Item với nhau.</p>
<h3 id="responding-to-events"><a class="header" href="#responding-to-events">Responding to events</a></h3>
<p>Khai báo <em>event handler</em> function trong component:</p>
<pre><code class="language-js">function MyButton() {
  function handleClick() {
    alert('Mày bấm cái nút này xem');
  }

  return (
    &lt;button onClick={handleClick}&gt;
      Click me
    &lt;/button&gt;
  );
}
</code></pre>
<p><code>onClick={handleClick}</code> không sử dụng dấu <code>()</code> nha, không phải là <code>onClick={handleClick()}</code> vì chúng ta đang coi <code>handleClick()</code> là một argument của <code>onClick</code> chứ không phải để gọi. </p>
<h3 id="cập-nhật-màn-hình"><a class="header" href="#cập-nhật-màn-hình">Cập nhật màn hình</a></h3>
<p>Often, you'll want your component to &quot;remember&quot; some information and display it. For example, maybe you want to count the number of times a button is clicked. To do this, add <em>state</em> to your component.</p>
<p>Đầu tiên hãy import <a href="https://react.dev/reference/react/useState"><code>useState</code></a>.</p>
<pre><code>import { useState } from 'react';
</code></pre>
<p>Now you can declare a <em>state variable</em> inside your component:</p>
<pre><code class="language-js">function MyButton() {
  const [count, setCount] = useState(0);
  // ...
</code></pre>
<p>Bạn sẽ nhận được hai thứ từ <code>useState</code>: state (trạng thái) hiện tại (<code>count</code>), và function để update cái state đấy (<code>setCount</code>). Theo convention (Cách mà mọi người thường làm, mà nó tiện và đúng nhá) <code>[something, setSomething]</code>.</p>
<p>Xem thêm phần ví dụ chạy phần Code cho phần này trong <a href="https://react.dev/learn#responding-to-events">Quick Start</a></p>
<h3 id="dùng-hooks"><a class="header" href="#dùng-hooks">Dùng Hooks</a></h3>
<p>Functions bắt đầu bằng <code>use</code> được gọi <em>Hooks</em>, ví dụ như <code>useState</code>. Đọc danh sách các đồ đã có sẵn<a href="https://react.dev/reference/react">API reference.</a>, hoặc tự tạo cũng được.</p>
<p>Hooks are more restrictive than other functions. You can only call Hooks <em>at the top</em> of your components (or other Hooks). If you want to use <code>useState</code> in a condition or a loop, extract a new component and put it there.</p>
<p>Sẽ cần nói thêm về Hook, nhưng chắc để sau.</p>
<h3 id="chia-sẻ-data-giữa-các-components"><a class="header" href="#chia-sẻ-data-giữa-các-components">Chia sẻ data giữa các components</a></h3>
<p>Thường thì như bạn có thể đã biết, mỗi một Component đều có cho mình một State riêng. Nhưng đôi khi, bạn cần các components share data và luôn cập nhật (giống nhau).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="component-state-event-handlers"><a class="header" href="#component-state-event-handlers">Component state, event handlers</a></h1>
<h3 id="component-helper-functions-hàm-hỗ-trợ-component"><a class="header" href="#component-helper-functions-hàm-hỗ-trợ-component">Component Helper Functions (Hàm hỗ trợ component)</a></h3>
<ul>
<li>Component có thể chứa các hàm hỗ trợ để xử lý logic, ví dụ như tính toán năm sinh dựa trên tuổi.</li>
<li>Các hàm này có thể truy cập trực tiếp các <code>props</code> được truyền vào component.</li>
<li>Trong JavaScript, việc định nghĩa hàm bên trong hàm khác là phổ biến.</li>
</ul>
<h3 id="destructuring-phân-rã-cấu-trúc"><a class="header" href="#destructuring-phân-rã-cấu-trúc">Destructuring (Phân rã cấu trúc)</a></h3>
<ul>
<li>Destructuring cho phép trích xuất giá trị từ objects và arrays vào các biến riêng biệt.</li>
<li>Ví dụ, <code>const { name, age } = props</code> trích xuất <code>name</code> và <code>age</code> từ object <code>props</code>.</li>
<li>Có thể destructure <code>props</code> trực tiếp trong tham số của component: <code>const Hello = ({ name, age }) =&gt; {...}</code>.</li>
<li>Destructuring giúp code ngắn gọn và dễ đọc hơn.</li>
</ul>
<h3 id="page-re-rendering-kết-xuất-lại-trang"><a class="header" href="#page-re-rendering-kết-xuất-lại-trang">Page Re-rendering (Kết xuất lại trang)</a></h3>
<ul>
<li>Để cập nhật giao diện khi dữ liệu thay đổi, cần kết xuất lại (re-render) component.</li>
<li>Gọi <code>ReactDOM.createRoot(document.getElementById('root')).render(...)</code> để kết xuất lại component.</li>
<li>Sử dụng <code>setInterval</code> để tự động re-render component sau một khoảng thời gian nhất định.</li>
<li>Việc gọi liên tục hàm render không phải là cách được khuyến khích.</li>
</ul>
<h3 id="stateful-component-component-có-trạng-thái"><a class="header" href="#stateful-component-component-có-trạng-thái">Stateful Component (Component có trạng thái)</a></h3>
<ul>
<li><code>useState</code> hook được sử dụng để thêm trạng thái (state) vào component.</li>
<li><code>useState</code> trả về một mảng gồm hai phần tử: giá trị trạng thái hiện tại và hàm để cập nhật trạng thái.</li>
<li>Khi hàm cập nhật trạng thái (ví dụ, <code>setCounter</code>) được gọi, React sẽ re-render component.</li>
<li>Sử dụng <code>console.log</code> để debug và theo dõi quá trình re-render.</li>
</ul>
<h3 id="event-handling-xử-lý-sự-kiện"><a class="header" href="#event-handling-xử-lý-sự-kiện">Event Handling (Xử lý sự kiện)</a></h3>
<ul>
<li>Event handlers được gọi khi một sự kiện cụ thể xảy ra (ví dụ, click button).</li>
<li>Sử dụng thuộc tính <code>onClick</code> để đăng ký event handler cho button.</li>
<li>Event handler có thể được định nghĩa trực tiếp trong JSX hoặc dưới dạng hàm riêng biệt.</li>
<li>Event handler phải là một hàm hoặc tham chiếu đến một hàm.</li>
<li>Việc gọi trực tiếp hàm trong <code>onClick</code> sẽ gây ra lỗi.</li>
<li>Tách event handler vào các hàm riêng biệt giúp code dễ đọc và bảo trì hơn.</li>
</ul>
<h3 id="passing-state---to-child-components-truyền-trạng-thái---cho-component-con"><a class="header" href="#passing-state---to-child-components-truyền-trạng-thái---cho-component-con">Passing State - to Child Components (Truyền trạng thái - cho component con)</a></h3>
<ul>
<li>Nên chia ứng dụng thành các component nhỏ, tái sử dụng.</li>
<li>&quot;Lift state up&quot; (nâng trạng thái lên) bằng cách đặt trạng thái ở component cha và truyền xuống component con qua <code>props</code>.</li>
<li>Component con sẽ re-render khi component cha re-render.</li>
<li>Đặt tên <code>props</code> cho event handler theo quy ước <code>onSomething</code> và tên hàm event handler là <code>handleSomething</code>.</li>
</ul>
<h3 id="changes-in-state-cause-re-rendering-thay-đổi-trạng-thái-gây-ra-re-rendering"><a class="header" href="#changes-in-state-cause-re-rendering-thay-đổi-trạng-thái-gây-ra-re-rendering">Changes in State Cause Re-rendering (Thay đổi trạng thái gây ra re-rendering)</a></h3>
<p>Khi state (trạng thái) thay đổi, component sẽ re-render và các component con cũng sẽ re-render theo.</p>
<blockquote>
<p>Mẹo vặt cuộc sống: Sử dụng <code>console.log</code> để theo dõi giá trị trạng thái và quá trình re-render. Không nên đoán code chạy như thế nào, hãy dùng console.log để quan sát.</p>
</blockquote>
<h3 id="refactoring-the-components-tái-cấu-trúc-các-component"><a class="header" href="#refactoring-the-components-tái-cấu-trúc-các-component">Refactoring the Components (Tái cấu trúc các component)</a></h3>
<ul>
<li>Sử dụng destructuring để đơn giản hóa component.</li>
<li>Sử dụng cú pháp arrow function ngắn gọn khi hàm chỉ có một câu lệnh <code>return</code>.</li>
<li>Tái cấu trúc component giúp code ngắn gọn và dễ đọc hơn.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="a-more-complex-state-debugging-react-apps"><a class="header" href="#a-more-complex-state-debugging-react-apps">A more complex state, debugging React apps</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="học-mpr-để-đi-thi-cực-nhanh"><a class="header" href="#học-mpr-để-đi-thi-cực-nhanh">Học MPR để đi thi cực nhanh</a></h1>
<p>Tổng hợp từ đống Lectures</p>
<h2 id="tutorial-2"><a class="header" href="#tutorial-2">Tutorial 2</a></h2>
<p>To create a new Expo project, run the following in your terminal:</p>
<pre><code>npx create-expo-app@latest &lt;app-name&gt;
</code></pre>
<p>What’s inside a React Native project?</p>
<pre><code>.gitignore:
.expo
.vscode
node_modules:
#Holds 3rd party packages
assets:
#Holds images used inside app
package.json, package-lock.json:
#Holds dependencies, script commands, etc.
app.json:
#Configuration settings
App.js:
#The real code
</code></pre>
<p>Cách chạy ứng dụng</p>
<pre><code class="language-bash">npx expo install react-dom react-native-web @expo/metro-runtime
npm run web
</code></pre>
<p>To run your app on Expo Go:</p>
<ol>
<li>Open terminal</li>
<li>Type “npx expo start”</li>
</ol>
<p>There’s a function component called <code>App</code>. This component acts as the root component by default.
In React Native, you can’t use HTML tags in JSX code. Unlike React where your application runs on the browser, React Native application runs on mobile devices</p>
<p><a href="https://reactnative.dev/docs/components-and-apis">React Native components documentation</a></p>
<div class="table-wrapper"><table><thead><tr><th>React Native UI Component</th><th>Android View</th><th>iOS View</th><th>Web Analog</th><th>Description</th></tr></thead><tbody>
<tr><td><code>&lt;View&gt;</code></td><td><code>&lt;ViewGroup&gt;</code></td><td><code>&lt;UIView&gt;</code></td><td>A non-scrolling <code>&lt;div&gt;</code></td><td>A container that supports layout with flexbox, style, some touch handling, and accessibility controls</td></tr>
<tr><td><code>&lt;Text&gt;</code></td><td><code>&lt;TextView&gt;</code></td><td><code>&lt;UITextView&gt;</code></td><td><code>&lt;p&gt;</code></td><td>Displays, styles, and nests strings of text and even handles touch events</td></tr>
<tr><td><code>&lt;Image&gt;</code></td><td><code>&lt;ImageView&gt;</code></td><td><code>&lt;UIImageView&gt;</code></td><td><code>&lt;img&gt;</code></td><td>Displays different types of images</td></tr>
<tr><td><code>&lt;ScrollView&gt;</code></td><td><code>&lt;ScrollView&gt;</code></td><td><code>&lt;UIScrollView&gt;</code></td><td><code>&lt;div&gt;</code></td><td>A generic scrolling container that can contain multiple components and views</td></tr>
<tr><td><code>&lt;TextInput&gt;</code></td><td><code>&lt;EditText&gt;</code></td><td><code>&lt;UITextField&gt;</code></td><td><code>&lt;input type=&quot;text&quot;&gt;</code></td><td>Allows the user to enter text</td></tr>
</tbody></table>
</div>
<p>React Native styling There Is No CSS! Inline Styles &lt;-&gt; StyleSheet Objects. Written in JavaScript</p>
<h2 id="lecture-3"><a class="header" href="#lecture-3">Lecture 3</a></h2>
<h3 id="what-is-fast-refresh"><a class="header" href="#what-is-fast-refresh">What is Fast Refresh?</a></h3>
<ul>
<li>Fast Refresh is a feature in React that updates the application instantly after editing the source code without reloading the entire page.</li>
<li>Key benefits:
<ul>
<li>Preserves state in function components and Hooks.</li>
<li>Speeds up development and reduces interruptions.</li>
</ul>
</li>
</ul>
<p>Limitations: State is not preserved in:</p>
<ul>
<li>Class components.</li>
<li>Modules with multiple exports besides React components.</li>
<li>Higher-order components returning class components.</li>
</ul>
<pre><code class="language-jsx">import React, { Component } from &quot;react&quot;;
import { Button, Text, View } from &quot;react-native&quot;;
// State is not preserved in class components
class App extends Component {
  state = { count: 0 };
  increment = () =&gt; this.setState({ count: this.state.count + 1 });
  render() {
    return (
      &lt;View&gt;
        &lt;Text&gt;{this.state.count}&lt;/Text&gt;
        &lt;Button title=&quot;Increment&quot; onPress={this.increment} /&gt;
      &lt;/View&gt;
    );
  }
}
</code></pre>
<h3 id="fast-refresh-and-hooks"><a class="header" href="#fast-refresh-and-hooks">Fast Refresh and Hooks</a></h3>
<ul>
<li>useState and useRef: Preserve their values if the arguments are unchanged.</li>
<li>useEffect, useMemo, and useCallback: Always update during Fast Refresh, even if dependencies don’t change.</li>
</ul>
<pre><code class="language-jsx">import React, { useEffect, useMemo, useState } from &quot;react&quot;;
import { Button, Text, View } from &quot;react-native&quot;;
const App = ({ multiplier }) =&gt; {
  const [count, setCount] = useState(0);
  // useMemo will re-run when edited
  const double = useMemo(() =&gt; count * multiplier, [count]);
  useEffect(() =&gt; {
    console.log(&quot;Component re-rendered&quot;);
  }, []);
  return (
    &lt;View&gt;
      &lt;Text&gt;Double: {double}&lt;/Text&gt;
      &lt;Button title=&quot;Increment&quot; onPress={() =&gt; setCount(count + 1)} /&gt;
    &lt;/View&gt;
  );
};

</code></pre>
<p>Debugging JavaScript Remotely: Type “?” on Terminal to see full list of command while <code>npm start</code> process is running. Press m to toggle a menu on device/emulator.</p>
<h3 id="building-adaptive-user-interfaces"><a class="header" href="#building-adaptive-user-interfaces">Building Adaptive User Interfaces</a></h3>
<p>Responsive Units:</p>
<ul>
<li>Use relative units like <code>%, vh, or vw</code> for widths and heights.</li>
<li>Use scalable units like <code>em or rem</code> for font sizes</li>
<li>Use third-party libraries such as <code>react-native-size-matters</code> to simplify responsive development.</li>
</ul>
<p>Using <code>maxWidth</code> or <code>minWidth</code> besides the regular width to create more responsive sizes.</p>
<h3 id="dimensions-api"><a class="header" href="#dimensions-api">Dimensions API</a></h3>
<pre><code class="language-jsx">import {Dimensions} from 'react-native';

const windowWidth = Dimensions.get('window').width;
const windowHeight = Dimensions.get('window').height;
</code></pre>
<p><code>useWindowDimensions()</code> is the preferred API for React components.</p>
<pre><code class="language-jsx">import {useWindowDimensions} from 'react-native';
const {width, height} = useWindowDimensions();
</code></pre>
<h3 id="managing-layout-when-keyboard-is-visible"><a class="header" href="#managing-layout-when-keyboard-is-visible">Managing layout when keyboard is visible</a></h3>
<p><code>KeyboardAvoidingView</code></p>
<pre><code class="language-jsx">import {KeyboardAvoidingView} from 'react-native';

&lt;KeyboardAvoidingView style={styles.screen} &lt;TextInput .../&gt; behavior=&quot;position&quot;&gt;
</code></pre>
<h3 id="handling-user-input"><a class="header" href="#handling-user-input">Handling user input</a></h3>
<ul>
<li>State Management:
<ul>
<li>React Native uses React's <code>useState</code> hook to manage the input values dynamically.</li>
<li>The state holds the value entered by the user.</li>
</ul>
</li>
<li>Input Components:
<ul>
<li><code>TextInput</code>: The core component for receiving user input.</li>
<li><code>Button</code>: Used to handle submission or trigger an action.</li>
</ul>
</li>
<li>Events:
<ul>
<li><code>onChangeText</code>: captures changes in TextInput (so that we can update the state).</li>
<li><code>onPress</code>: handles button clicks (to trigger a function to process input data).</li>
</ul>
</li>
</ul>
<h3 id="core-component-scrollview"><a class="header" href="#core-component-scrollview">Core component: ScrollView</a></h3>
<pre><code class="language-jsx">&lt;View style={styles.bottomSection}&gt;
  &lt;ScrollView&gt;
    {goals.map((g, i) =&gt; (
      &lt;Text key={i} style={styles.goalItem}&gt;
        {g}
      &lt;/Text&gt;
    ))}
  &lt;/ScrollView&gt;
&lt;/View&gt;;

</code></pre>
<p>FlatList (Better performance):</p>
<pre><code class="language-jsx">&lt;View style={styles.bottomSection}&gt;
  &lt;FlatList
    data={goals}
    renderItem={(obj) =&gt; (
      &lt;Text key={obj.index} style={styles.goalItem}&gt;
        {obj.item}
      &lt;/Text&gt;
    )}
  /&gt;
&lt;/View&gt;;

</code></pre>
<h3 id="core-component-pressable"><a class="header" href="#core-component-pressable">Core component: Pressable</a></h3>
<p>Used to make other components pressable just like <code>Button</code> or <code>TouchableOpacity</code></p>
<pre><code class="language-jsx:">&lt;Pressable 
	// Only works on Android: A feedback effect when a Pressable is touched
	android_ripple={{ color: '#cccccc' }}
	onPress={() =&gt; { console.log('Pressed') }}&gt;
	&lt;Text style={styles.goalItem}&gt;{obj.item}&lt;/Text&gt;
&lt;/Pressable&gt;
</code></pre>
<p>Key Features of Pressable:</p>
<ul>
<li><code>onPress</code>: Handles the basic press event.</li>
<li><code>onPressIn</code>: Triggered when the press gesture starts.</li>
<li><code>onPressOut</code>: Triggered when the press gesture ends.</li>
<li><code>onLongPress</code>: Triggered when the user presses and holds the component.</li>
<li><code>style</code>: Allows you to define styles that change based on the component's state (e.g., pressed, hovered).</li>
</ul>
<h3 id="core-component-image"><a class="header" href="#core-component-image">Core component: Image</a></h3>
<pre><code class="language-jsx">// Static image:
&lt;Image source={require('./assets/favicon.png')} /&gt;
// Network image:
&lt;Image
	style={{ width: 64, height: 64 }}
	source={{
		uri: 'https://reactnative.dev/img/tiny_logo.png'
	}}
/&gt;
</code></pre>
<h3 id="core-component-modal"><a class="header" href="#core-component-modal">Core component: Modal</a></h3>
<p>The Modal component is a basic way to present content above an enclosing view.</p>
<pre><code class="language-jsx"> &lt;Modal
  animationType=&quot;slide&quot;
  transparent={true}
  visible={modalVisible}
  onRequestClose={() =&gt; {
    Alert.alert('Modal has been closed.');
    setModalVisible(!modalVisible);
  }}&gt;
  &lt;View style={styles.centeredView}&gt;
    &lt;View style={styles.modalView}&gt;
      ....
    &lt;/View&gt;
  &lt;/View&gt;
&lt;/Modal&gt;
</code></pre>
<h2 id="lecture-4"><a class="header" href="#lecture-4">Lecture 4</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Events</th><th>Description</th></tr></thead><tbody>
<tr><td>onPress</td><td>Triggered when a user taps a button or Touchable component.</td></tr>
<tr><td>onChangeText</td><td>Fires when text changes in an TextInput field.</td></tr>
<tr><td>onSubmitEditing</td><td>Executes when the user presses &quot;Enter&quot; or submits input.</td></tr>
<tr><td>onLongPress</td><td>Activated when a user presses and holds a button.</td></tr>
<tr><td>onFocus / onBlur</td><td>Used for handling focus state in input fields.</td></tr>
</tbody></table>
</div>
<pre><code class="language-jsx">import React from &quot;react&quot;;
import { View, Text, Button, Alert, StyleSheet } from &quot;react-native&quot;;
const HandleEventDemo = () =&gt; {
  const handlePress = () =&gt; {
    Alert.alert(&quot;Button Pressed!&quot;, &quot;You clicked the button.&quot;);
  };
  return (
    &lt;View style={styles.container}&gt;
      &lt;Text&gt;Press the button below:&lt;/Text&gt;
      &lt;Button title=&quot;Click Me&quot; onPress={handlePress} /&gt;
    &lt;/View&gt;
  );
};
export default HandleEventDemo;

</code></pre>
<p>Recall: The useState hook</p>
<pre><code class="language-jsx">const [state, setState] = useState(initialValue);
</code></pre>
<p>Example: Managing State with useState</p>
<pre><code class="language-jsx">import React, { useState } from &quot;react&quot;;
import { View, Text, Button, StyleSheet } from &quot;react-native&quot;;

const CounterApp = () =&gt; {
  const [count, setCount] = useState(0);
  return (
    &lt;View style={styles.container}&gt;
      &lt;Text&gt;Count: {count}&lt;/Text&gt;
      &lt;Button title=&quot;Increase&quot; onPress={() =&gt; setCount(count + 1)} /&gt;
    &lt;/View&gt;
  );
};
export default CounterApp;

</code></pre>
<ul>
<li>The count state stores a number.</li>
<li>setCount updates the value when the button is clicked.</li>
</ul>
<p>Syntax of <code>useEffect</code> (Don't get it, will revise later)</p>
<pre><code class="language-jsx">useEffect(() =&gt; {
	// Code to run on mount
	return () =&gt; {
	// Cleanup function (like componentWillUnmount)
	};
}, [dependencies]); // Dependencies control re-runs
</code></pre>
<h3 id="core-component-imagebackground"><a class="header" href="#core-component-imagebackground">Core Component: <code>ImageBackground</code></a></h3>
<pre><code class="language-jsx">import { ImageBackground, Text, StyleSheet } from &quot;react-native&quot;;
export default function App() {
  return (
    // Use it as a wrapper to display content on top of an image.
    &lt;ImageBackground
      source={require(&quot;./assets/background.jpg&quot;)}
      style={styles.background}
    &gt;
      &lt;Text style={styles.text}&gt;Weather App&lt;/Text&gt;
    &lt;/ImageBackground&gt;
  );
}

</code></pre>
<h3 id="statusbar"><a class="header" href="#statusbar">StatusBar</a></h3>
<pre><code class="language-jsx">import { StatusBar } from &quot;react-native&quot;;
export default function App() {
  return (
    &lt;&gt;
      &lt;StatusBar barStyle=&quot;light-content&quot; backgroundColor=&quot;#000&quot; /&gt;
    &lt;/&gt;
  );
}

</code></pre>
<h3 id="core-component-activityindicator"><a class="header" href="#core-component-activityindicator">Core component: <code>ActivityIndicator</code></a></h3>
<pre><code class="language-jsx">import { ActivityIndicator, View } from &quot;react-native&quot;;
export default function App() {
  return (
    &lt;View&gt;
      &lt;ActivityIndicator size=&quot;large&quot; color=&quot;#0000ff&quot; animating={true} /&gt;
    &lt;/View&gt;
  );
}

</code></pre>
<h3 id="core-component-textinput"><a class="header" href="#core-component-textinput">Core component: TextInput</a></h3>
<pre><code class="language-jsx">export default function AppTextInput() {
  return (
    &lt;TextInput
      style={{
        padding: 10,
        borderWidth: 1,
        borderColor: &quot;#ccc&quot;,
        margin: 10,
      }}
      placeholder=&quot;Enter city name&quot;
      onChangeText={(text) =&gt; console.log(text)}
    /&gt;
  );
}
</code></pre>
<h3 id="calling-an-api-in-react"><a class="header" href="#calling-an-api-in-react">Calling an API in React</a></h3>
<p>Calling APIs in React Native</p>
<ul>
<li>Using fetch() for API calls</li>
<li>Example API URL for weather information: https://api.open-meteo.com/v1/forecast?latitude=35&amp;longitude=139&amp;current_weather=true</li>
</ul>
<pre><code class="language-jsx">const getWeather = async () =&gt; {
  try {
    const response = await fetch(&quot;API_URL&quot;);
    const data = await response.json();
    console.log(data);
  } catch (error) {
    console.error(&quot;Error fetching weather:&quot;, error);
  }
};

</code></pre>
<h2 id="lecture-5"><a class="header" href="#lecture-5">Lecture 5</a></h2>
<p>To use the native stack navigator, we need to install:</p>
<pre><code>npm install @react-navigation/native-stack
npm install @react-navigation/elements
</code></pre>
<h3 id="react-navigation-static-vs-dynamic-apis"><a class="header" href="#react-navigation-static-vs-dynamic-apis">React Navigation: Static vs Dynamic APIs</a></h3>
<h4 id="creating-a-native-stack-navigator-static"><a class="header" href="#creating-a-native-stack-navigator-static">Creating a native stack navigator (Static)</a></h4>
<p>The createNativeStackNavigator function takes a configuration object and returns a stack navigator.</p>
<ul>
<li>The object contains screens and customization options.</li>
<li>The screens are React components that will be displayed by the navigator.</li>
</ul>
<p>The createStaticNavigation function takes the navigator created earlier and returns a component that can be rendered in the app. It's only called once in an app.</p>
<pre><code class="language-jsx">import { createStaticNavigation } from &quot;@react-navigation/native&quot;;
import { createNativeStackNavigator } from &quot;@react-navigation/native-stack&quot;;

function HomeScreen() {
  return (
    &lt;View style={{ flex: 1, alignItems: &quot;center&quot;, justifyContent: &quot;center&quot; }}&gt;
      &lt;Text style={{ fontSize: 30 }}&gt;Home Page&lt;/Text&gt;
    &lt;/View&gt;
  );
}

function AboutScreen() {}

const RootStack = createNativeStackNavigator({
  screens: {
    Home: HomeScreen,
    About: AboutScreen,
  },
});
const Navigation = createStaticNavigation(RootStack);

export default function App() {
  return &lt;Navigation /&gt;;
}
</code></pre>
<p>w/ options:</p>
<pre><code class="language-jsx">const RootStack = createNativeStackNavigator({
  initialRouteName: &quot;Home&quot;,
  screens: {
    Home: {
      screen: HomeScreen,
      options: {
        title: &quot;Welcome&quot;,
      },
    },
    About: AboutScreen,
  },
});

</code></pre>
<p>Cho tat ca luon</p>
<pre><code class="language-jsx">const RootStack = createNativeStackNavigator({
  initialRouteName: &quot;Home&quot;,
  screenOptions: {
    headerStyle: { backgroundColor: &quot;tomato&quot; },
  },
});

</code></pre>
<h4 id="creating-a-native-stack-navigator-dynamic-api"><a class="header" href="#creating-a-native-stack-navigator-dynamic-api">Creating a native stack navigator (Dynamic API)</a></h4>
<p>The createNativeStackNavigator function returns an object containing 2 properties: Screen and Navigator. These components are used to create &amp; configure the navigator structure. Navigator should contain Screen children. </p>
<p>The NavigationContainer component manages the navigation tree and navigation state. </p>
<p>• It must wrap all the navigators in the app. 
• It’s usually rendered as the root component of an app (the component exported from App.js)</p>
<pre><code class="language-jsx">import { NavigationContainer } from &quot;@react-navigation/native&quot;;
import { createNativeStackNavigator } from &quot;@react-navigation/native-stack&quot;;

function HomeScreen() {
  return (
    &lt;View style={{ flex: 1, alignItems: &quot;center&quot;, justifyContent: &quot;center&quot; }}&gt;
      &lt;Text style={{ fontSize: 30 }}&gt;Home Page&lt;/Text&gt;
    &lt;/View&gt;
  );
}

function AboutScreen() {}

const Stack = createNativeStackNavigator();
export default function App() {
  return (
    &lt;NavigationContainer&gt;
      &lt;Stack.Navigator&gt;
        &lt;Stack.Screen name=&quot;Home&quot; component={HomeScreen} /&gt;
        &lt;Stack.Screen name=&quot;About&quot; component={AboutScreen} /&gt;
      &lt;/Stack.Navigator&gt;
    &lt;/NavigationContainer&gt;
  );
}

</code></pre>
<p>warning: When using the Dynamic API, the component prop accepts a component, not a render function. Don't pass an inline function (e.g. <code>component={() =&gt; &lt;HomeScreen /&gt;}</code>), or your component will unmount and remount, losing all state, when the parent component re- renders.</p>
<pre><code class="language-jsx">&lt;NavigationContainer&gt;
  &lt;Stack.Navigator initialRouteName=&quot;About&quot;&gt;
    &lt;Stack.Screen
      name=&quot;Home&quot;
      component={HomeScreen}
      options={{ title: &quot;Welcome&quot; }}
    /&gt;
    &lt;Stack.Screen name=&quot;About&quot; component={AboutScreen} /&gt;
  &lt;/Stack.Navigator&gt;
&lt;/NavigationContainer&gt;;

</code></pre>
<h3 id="passing-additional-props"><a class="header" href="#passing-additional-props">Passing additional props</a></h3>
<p>Use React context and wrap the navigator with a context provider to pass data to the screens (recommended).</p>
<p>The <code>useContext</code> hook: A React Hook that lets you create context data (values) in a parent component and retrieve them from its descendant components.</p>
<pre><code class="language-jsx">// First, use the createContext function to create a Context.
import { createContext, useContext } from &quot;react&quot;;
const ScreenNameContext = createContext(null);

// Then, wrap the context’s provider around the components that will use the context value.
&lt;ScreenNameContext.Provider value={scrNames}&gt;
  &lt;NavigationContainer&gt;
    &lt;Stack.Navigator&gt;
      &lt;Stack.Screen name=&quot;Home&quot; component={HomeScreen} /&gt;
      &lt;Stack.Screen name=&quot;About&quot; component={AboutScreen} /&gt;
    &lt;/Stack.Navigator&gt;
  &lt;/NavigationContainer&gt;
&lt;/ScreenNameContext.Provider&gt;;

</code></pre>
<h3 id="retrieving-context-data-from-a-component"><a class="header" href="#retrieving-context-data-from-a-component">Retrieving Context Data from a component</a></h3>
<pre><code class="language-jsx">// Technically, any can retrieve the context data.
// However, it’s recommended that the component is one of the context provider’s descendant.
function AboutScreen() {
  const screenNames = useContext(ScreenNameContext);
  return (
    &lt;View style={{ flex: 1, alignItems: &quot;center&quot;, justifyContent: &quot;center&quot; }}&gt;
      &lt;Text&gt;{screenNames.about}&lt;/Text&gt;
    &lt;/View&gt;
  );
}

</code></pre>
<h3 id="navigating-to-a-new-screen"><a class="header" href="#navigating-to-a-new-screen">Navigating to a new screen</a></h3>
<pre><code class="language-jsx">import { useNavigation } from &quot;@react-navigation/native&quot;;
function HomeScreen() {
  const navigation = useNavigation();
  return (
    &lt;View style={{ flex: 1, alignItems: &quot;center&quot;, justifyContent: &quot;center&quot; }}&gt;
      &lt;Text style={{ fontSize: 30 }}&gt;Home Page&lt;/Text&gt;
      &lt;Button title=&quot;About Us&quot; onPress={() =&gt; navigation.navigate(&quot;About&quot;)} /&gt;
    &lt;/View&gt;
  );
}
</code></pre>
<h3 id="using-push-to-add-multiple-instances"><a class="header" href="#using-push-to-add-multiple-instances">Using push to add multiple instances</a></h3>
<pre><code class="language-jsx">// If you want to open a new instance of the About screen, use navigation.push('About').
//  Each time push is called, a new About screen instance is added to the navigation stack.
&lt;Button title=&quot;About Us... again&quot; onPress={() =&gt; navigation.push(&quot;About&quot;)} /&gt;;
</code></pre>
<h3 id="difference-between-navigate-and-push"><a class="header" href="#difference-between-navigate-and-push">Difference between navigate and push</a></h3>
<ul>
<li>navigate('About') → Does nothing if already on the About screen.</li>
<li>navigate.push('About') → Creates a new instance of the About screen. This approach is useful when passing unique data to each instance of a screen.</li>
</ul>
<h3 id="manually-triggering-back-navigation"><a class="header" href="#manually-triggering-back-navigation">Manually Triggering Back Navigation</a></h3>
<p>Use navigation.goBack() to programmatically navigate to the previous screen.</p>
<h3 id="going-back-multiple-screens"><a class="header" href="#going-back-multiple-screens">Going Back Multiple Screens</a></h3>
<pre><code class="language-jsx">function AboutScreen() {
  const navigation = useNavigation();
  return (
    &lt;View style={{ flex: 1, alignItems: &quot;center&quot;, justifyContent: &quot;center&quot; }}&gt;
      &lt;Text style={{ fontSize: 30 }}&gt;About Page&lt;/Text&gt;
      &lt;Button
        title=&quot;About Us... again&quot;
        onPress={() =&gt; navigation.push(&quot;About&quot;)}
      /&gt;
      &lt;Button title=&quot;Go Back&quot; onPress={() =&gt; navigation.goBack()} /&gt;
      &lt;Button title=&quot;Go Home&quot; onPress={() =&gt; navigation.popTo(&quot;Home&quot;)} /&gt;
      &lt;Button
        title=&quot;Back to First Screen in Stack&quot;
        onPress={() =&gt; navigation.popToTop()}
      /&gt;
    &lt;/View&gt;
  );
}
</code></pre>
<h3 id="passing-parameters-to-routes"><a class="header" href="#passing-parameters-to-routes">Passing parameters to routes</a></h3>
<pre><code class="language-jsx">function HomeScreen() {
  const navigation = useNavigation();
  return (
    &lt;View style={{ flex: 1, alignItems: &quot;center&quot;, justifyContent: &quot;center&quot; }}&gt;
      &lt;Text style={{ fontSize: 30 }}&gt;Home Page&lt;/Text&gt;
      &lt;Button
        title=&quot;About Us&quot;
        onPress={() =&gt; navigation.navigate(&quot;About&quot;, { name: &quot;Quan&quot; })}
      /&gt;
    &lt;/View&gt;
  );
}

</code></pre>
<p>Receiving passed parameters:</p>
<pre><code class="language-jsx">function AboutScreen({ route }) {
  const navigation = useNavigation();
  const { name } = route.params;
}
</code></pre>
<p>or init it using initialParams</p>
<pre><code class="language-jsx">&lt;Stack.Screen
  name=&quot;About&quot;
  component={AboutScreen}
  initialParams={{ name: &quot;Us&quot; }}
/&gt;;

// Or update it
navigation.setParams({
  name: &quot;Vinh&quot;,
});

</code></pre>
<p>Avoid using setParams to update screen options such as title. If you need to update options, use setOptions instead.</p>
<h3 id="what-should-be-in-params"><a class="header" href="#what-should-be-in-params">What should be in params?</a></h3>
<p>Params should not be used for state management. If data is needed across multiple screens, it should be stored in a global store or cache.</p>
<pre><code class="language-jsx">
// Don't do this
navigation.navigate(&quot;Profile&quot;, {
  user: {
    id: 21,
    firstName: &quot;Jane&quot;,
    lastName: &quot;Done&quot;,
    age: 25,
  },
});
// Do this
navigation.navigate(&quot;Profile&quot;, { userId: 21 });
</code></pre>
<h2 id="lecture-6"><a class="header" href="#lecture-6">Lecture 6</a></h2>
<h3 id="configuring-the-header-bar"><a class="header" href="#configuring-the-header-bar">Configuring the header bar</a></h3>
<pre><code class="language-jsx">&lt;Stack.Screen
  name=&quot;Home&quot;
  component={HomeScreen}
  options={{ title: &quot;My home&quot; }}
/&gt;;

// Or using params in the title
&lt;Stack.Screen
  name=&quot;Profile&quot;
  component={ProfileScreen}
  options={({ route }) =&gt; ({ title: route.params.name })}
/&gt;;

// Update dinamically

&lt;Button onPress={() =&gt; navigation.setOptions({ title: &quot;Updated!&quot; })}&gt;
  Update the title
&lt;/Button&gt;;

// Customizing Header Styles
&lt;Stack.Screen
  name=&quot;Home&quot;
  component={HomeScreen}
  options={{
    title: &quot;My home&quot;,
    headerStyle: { backgroundColor: &quot;#f4511e&quot; },
    headerTintColor: &quot;#fff&quot;,
    headerTitleStyle: { fontWeight: &quot;bold&quot; },
  }}
/&gt;;

// Instead of repeating styles for each screen, set screenOptions in Stack.Navigator.
&lt;Stack.Navigator
  screenOptions={{
    headerStyle: { backgroundColor: &quot;#f4511e&quot; },
    headerTintColor: &quot;#fff&quot;,
    headerTitleStyle: { fontWeight: &quot;bold&quot; },
  }}
&gt;
  &lt;Stack.Screen
    name=&quot;Home&quot;
    component={HomeScreen}
    options={{ title: &quot;My home&quot; }}
  /&gt;
  &lt;Stack.Screen name=&quot;Details&quot; component={DetailsScreen} /&gt;
&lt;/Stack.Navigator&gt;;

// Replacing the Title with a Custom Component
// Use headerTitle to replace the text title with a custom component, such as an image or button.
function LogoTitle() {
  return (
    &lt;Image
      style={{ width: 50, height: 50 }}
      source={require(&quot;@expo/snack-static/react-native-logo.png&quot;)}
    /&gt;
  );
}
&lt;Stack.Screen
  name=&quot;Home&quot;
  component={HomeScreen}
  options={{ headerTitle: (props) =&gt; &lt;LogoTitle {...props} /&gt; }}
/&gt;;


</code></pre>
<p>Difference Between title and headerTitle </p>
<p>• title is used for multiple navigation types like tab bars and drawers. 
• headerTitle is specific to stack navigators and replaces the default Text component.</p>
<h3 id="header-interaction-with-its-screen-component"><a class="header" href="#header-interaction-with-its-screen-component">Header interaction with its screen component</a></h3>
<pre><code class="language-jsx">function HomeScreen() {
  const navigation = useNavigation();
  const [count, setCount] = React.useState(0);
  React.useEffect(() =&gt; {
    navigation.setOptions({
      headerRight: () =&gt; (
        &lt;Button onPress={() =&gt; setCount((c) =&gt; c + 1)}&gt;Update count&lt;/Button&gt;
      ),
    });
  }, [navigation]);
  return &lt;Text&gt;Count: {count}&lt;/Text&gt;;
}
</code></pre>
<p>Customizing the Back Button</p>
<pre><code class="language-jsx">&lt;Stack.Screen
  name=&quot;Details&quot;
  component={DetailsScreen}
  options={{
    headerLeft: () =&gt; (
      &lt;Button onPress={() =&gt; alert(&quot;Custom Back Pressed&quot;)}&gt;Back&lt;/Button&gt;
    ),
  }}
/&gt;;

</code></pre>
<h3 id="example-nesting-navigators"><a class="header" href="#example-nesting-navigators">Example: Nesting Navigators</a></h3>
<pre><code class="language-jsx">const HomeScreen = () =&gt; (
  &lt;View style={{ flex: 1, justifyContent: &quot;center&quot;, alignItems: &quot;center&quot; }}&gt;
    &lt;Text&gt;Home Screen&lt;/Text&gt;
  &lt;/View&gt;
);
const SettingsScreen = () =&gt; (
  &lt;View style={{ flex: 1, justifyContent: &quot;center&quot;, alignItems: &quot;center&quot; }}&gt;
    &lt;Text&gt;Settings Screen&lt;/Text&gt;
  &lt;/View&gt;
);
const DetailsScreen = () =&gt; (
  &lt;View style={{ flex: 1, justifyContent: &quot;center&quot;, alignItems: &quot;center&quot; }}&gt;
    &lt;Text&gt;Details Screen&lt;/Text&gt;
  &lt;/View&gt;
);


const Tab = createBottomTabNavigator();
function MyTabs() {
  return (
    &lt;Tab.Navigator&gt;
      &lt;Tab.Screen name=&quot;Home&quot; component={HomeScreen} /&gt;
      &lt;Tab.Screen name=&quot;Settings&quot; component={SettingsScreen} /&gt;
    &lt;/Tab.Navigator&gt;
  );
}

</code></pre>
<h3 id="avoiding-multiple-headers"><a class="header" href="#avoiding-multiple-headers">Avoiding Multiple Headers</a></h3>
<pre><code class="language-jsx">&lt;Stack.Screen
  name=&quot;Home&quot;
  component={HomeTabs}
  options={{ headerShown: false }}
/&gt;;

&lt;Stack.Navigator screenOptions={{ headerShown: false }}&gt;
</code></pre>
<p>This lecture we will work on the Time Tracker App (I'm gonna turn that to the Flowmodoro App)</p>
<h2 id="lecture-7"><a class="header" href="#lecture-7">Lecture 7</a></h2>
<h3 id="-1"><a class="header" href="#-1"></a></h3>
<pre><code class="language-jsx">import React from &quot;react&quot;;
import { StyleSheet, Text, View } from &quot;react-native&quot;;
export default function LotsOfStyles() {
  return (
    &lt;View style={styles.container}&gt;
      &lt;Text style={styles.red}&gt;just red&lt;/Text&gt;
      &lt;Text style={styles.bigBlue}&gt;just bigBlue&lt;/Text&gt;
      &lt;Text style={[styles.bigBlue, styles.red]}&gt;bigBlue, then red&lt;/Text&gt;
      &lt;Text style={[styles.red, styles.bigBlue]}&gt;red, then bigBlue&lt;/Text&gt;
    &lt;/View&gt;
  );
}
const styles = StyleSheet.create({
  container: { marginTop: 50 },
  bigBlue: { color: &quot;blue&quot;, fontWeight: &quot;bold&quot;, fontSize: 30 },
  red: { color: &quot;red&quot; },
});

</code></pre>
<p>After that we will learn the basics of Flexbox so I will skip</p>
<h2 id="lecture-08-tailwind-css-for-react-native-ie-nativewind"><a class="header" href="#lecture-08-tailwind-css-for-react-native-ie-nativewind">Lecture 08: Tailwind CSS for React Native i.e. NativeWind</a></h2>
<pre><code>npm install nativewind@2.0.11 tailwindcss@3.2.2
# Optional
npm install react-native-reanimated
# (optional) 
npm install react-native-safe-area-context
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cơ-bản-về-typescript"><a class="header" href="#cơ-bản-về-typescript">Cơ bản về TypeScript</a></h1>
<blockquote>
<p>Bài viết gốc: <a href="https://viblo.asia/p/tim-hieu-typescript-va-kien-thuc-co-ban-PmeRQpnyGoB">Tìm Hiểu TypeScript và Kiến Thức Cơ Bản - Viblo</a></p>
</blockquote>
<h3 id="cài-đặt-13"><a class="header" href="#cài-đặt-13">Cài đặt</a></h3>
<hr />
<ol>
<li>Chạy lệnh sau để install TypeScript (nhớ install nodejs trước):</li>
</ol>
<pre><code>npm install -g typescript

</code></pre>
<ol>
<li>Compile:</li>
</ol>
<p>Việc này sẽ giúp tạo ra file xxx.js</p>
<h3 id="basic-types"><a class="header" href="#basic-types">Basic Types:</a></h3>
<p>Trong TypeScript chia ra làm 7 loại cơ bản, bao gồm: boolean, number, string, array, enum, any, void. khi khai báo ta sẽ sử dụng cấu trúc như sau: var tên_biến : kiểu_trả_về = giá_trị_biến;</p>
<ul>
<li>Boolean:</li>
</ul>
<pre><code>var isDone: boolean = true;

</code></pre>
<ul>
<li>String:</li>
</ul>
<pre><code>var name: boolean = &quot;nguyen thi A&quot;;

</code></pre>
<ul>
<li>
<p>Number:</p>
</li>
<li>
<p>Array : có 2 kiểu khai báo tương đương với nhau trong TypeScript</p>
</li>
</ul>
<pre><code>1: var list: boolean[] = [true, false];
2: var isDone: Array&lt;boolean&gt; = [true, false];

</code></pre>
<ul>
<li>Enum: khi khai báo enum một cách thông thường các phần tử sẽ được đánh số từ 0 và tăng dần</li>
</ul>
<pre><code>enum Color{Red, Green, Blue};
var c: Color = Color.Green
var colorName = Color[1] // kết quả sẽ là Green

</code></pre>
<p>Khi mốn phần tử đầu tiên là 1 chứ không phải là 0 như mặc định thì cần khai báo như sau:</p>
<pre><code>enum Color{Red = 1, Green, Blue};
var c: Color = Color.Green
var colorName = Color[1] // kết quả sẽ là Red

</code></pre>
<ul>
<li>Any: Any là một kiểu mà bạn có thể gán bất kỳ kiểu nào cho nó.</li>
</ul>
<pre><code>var notSure: any = 4;
notSure = &quot;maybe a string instead&quot;;
notSure = false; // khai báo này hoàn toàn được chấp nhận.
                 // nếu notSure ban đầu khai báo và number thì
                 // tại đây chắc chắn sẽ có lỗi

var list:any[] = [1, true, &quot;free&quot;]; // nếu sử dụng var list:number[] thì
                                    // tất cả các phần tử trong list sẽ phải là kiểu number
list[1] = 100;

</code></pre>
<ul>
<li>Void: Cũng giống như any nhưng void được sử dụng là đầu ra của hàm.</li>
</ul>
<pre><code>function warnUser(): void {
 alert(&quot;This is my warning message&quot;);
}

</code></pre>
<h3 id="function"><a class="header" href="#function">Function:</a></h3>
<p>Cũng giống như javaScript, typeScript có 2 cách khai báo function</p>
<pre><code>//Named function
function add(x, y) {
    return x+y;
}

//Anonymous function
var myAdd = function(x, y) { return x+y; };

</code></pre>
<p>Nhưng khi khai báo function typeScript còn hỗ chợ việc khai báo với các kiểu trả ra của function và cũng như kiểu đầu vào của dữ liệu</p>
<pre><code>function add(x: number, y: number): number {
    return x+y;
}

var myAdd = function(x: number, y: number): number { return x+y; };

</code></pre>
<p>Không những thế khi sử dụng typeScript ta có thể khai báo giá trị mặc định của đầu vào ngay khi khai báo function, điều mà JavaScript không có</p>
<pre><code>function buildName(firstName: string, lastName = &quot;Smith&quot;) {
    return firstName + &quot; &quot; + lastName;
}

var result1 = buildName(&quot;Bob&quot;);  //làm việc hoàn toàn OK. buildName(&quot;bob&quot;) = &quot;bob Smith&quot;
var result2 = buildName(&quot;Bob&quot;, &quot;Adams&quot;, &quot;Sr.&quot;);  //error, too many parameters
var result3 = buildName(&quot;Bob&quot;, &quot;Adams&quot;);  //ah, just right

</code></pre>
<ul>
<li>Không dừng lại ở đó typeScript còn hỗ chợ việc bỏ qua nhập một hoặc vài đầu vào.</li>
</ul>
<pre><code>function buildName(firstName: string, lastName?: string) {
    if (lastName)
        return firstName + &quot; &quot; + lastName;
    else
        return firstName;
}

var result1 = buildName(&quot;Bob&quot;);  //làm việc hoàn toàn OK. buildName(&quot;bob&quot;) = &quot;bob&quot;
var result2 = buildName(&quot;Bob&quot;, &quot;Adams&quot;, &quot;Sr.&quot;);  //error, too many parameters
var result3 = buildName(&quot;Bob&quot;, &quot;Adams&quot;);  //ah, just right

</code></pre>
<p>ở ví dụ trên việc khai báo biến lastName? làm cho viêc nhập lastName có thể không cần nữa và kết quả trả ra chỉ là bob mà thôi. typeScript còn có một cách làm việc với các param đầu vào có tên gọi: &quot;Rest Parameters&quot;</p>
<pre><code>function buildName(firstName: string, ...restOfName: string[]) {
	return firstName + &quot; &quot; + restOfName.join(&quot; &quot;);
}

var employeeName = buildName(&quot;Joseph&quot;, &quot;Samuel&quot;, &quot;Lucas&quot;, &quot;MacKinzie&quot;);// =&gt; &quot;Joseph Samuel Lucas MacKinzie&quot;

</code></pre>
<p>ở trên firstName sẽ là bắt buộc phải nhập. còn các thành phần còn lại sẽ được gộp chung vào một biến array.</p>
<h3 id="class-1"><a class="header" href="#class-1">Class:</a></h3>
<pre><code>class Greeter {
    greeting: string;
    constructor(message: string) {
        this.greeting = message;
    }
    greet() {
        return &quot;Hello, &quot; + this.greeting;
    }
}
var greeter = new Greeter(&quot;world&quot;);

</code></pre>
<p>hàm constructor sẽ được chạy ngay khi khởi tạo class mới. ờ ví dụ trên khi khai báo new Greeter(&quot;world&quot;) thì việc đâu tiên sẽ là chạy hàm constructor gán message &quot;world&quot; vào biến greeting của class. Hơn nữa, cũng giống như các ngôn ngữ lập trình hướng đối tượng khác. chúng ta cũng có thể dễ dàng sử dụng kế thừa trong typeScript.</p>
<pre><code>class Animal {
    name: string;
    constructor(theName: string) {
        this.name = theName;
    }

    move(meters: number = 0): string {
        return this.name + &quot; moved &quot; + meters + &quot;m.&quot;;
    }
}

class Snake extends Animal {
    constructor(name: string) {
        super(name);
    }

    move(meters = 5): string {
        return super.move(meters);
    }
}

var ranLuc = new Snake(&quot;Ran Luc&quot;);
ranLuc.move();   // = Ran Luc moved 5 m.
ranLuc.move(34); // = Ran Luc moved 34 m.

</code></pre>
<p>Ở đây chúng ta sẽ có class Animal bao gồm có biến name chưa tên, và function move chỉ sự di chuyển của động vật ý. Class Snake kế thừa lại class Animal. Trong hàm khởi tạo của class Snake ta đã sử dụng super(name), việc này chính là việc gọi tới hàm constructor của class cha. Tương tự tại hàm move việc gọi super.move(meters) chính là gọi thới hàm move của class cha (Animal).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bash"><a class="header" href="#bash">Bash</a></h1>
<p>Mình tổng hợp khá nhiều các câu lệnh và một chút về lập trình Bash trong này. Không nhất thiết chỉ là Bash mà còn là các câu lệnh khác trong Terminal nữa ^^!</p>
<h3 id="loop-đọc-từ-tệp-txt"><a class="header" href="#loop-đọc-từ-tệp-txt">Loop đọc từ tệp txt</a></h3>
<pre><code class="language-bash">while read p; do
  yt-dlp &quot;$p&quot; -o
done &lt;tmp.txt
</code></pre>
<h3 id="gộp-toàn-bộ-các-tệp-txt-thành-một-tệp-txt"><a class="header" href="#gộp-toàn-bộ-các-tệp-txt-thành-một-tệp-txt">Gộp toàn bộ các tệp .txt thành một tệp .txt</a></h3>
<pre><code class="language-bash"># Nếu không bao gồm sub-folders
cat ./* &gt; merged-file
# Nếu có
find . ! -path ./merged-file -type f -exec cat {} + &gt; merged-file
</code></pre>
<h3 id="tải-trang-từ-wayback-machine-về"><a class="header" href="#tải-trang-từ-wayback-machine-về">Tải trang từ Wayback Machine về</a></h3>
<pre><code class="language-bash">wget -rc --accept-regex '.*https://loda.me/articles.*' &quot;https://web.archive.org/web/20230321225500/https://loda.me/articles&quot;
</code></pre>
<h3 id="sending-post-request-using-curl"><a class="header" href="#sending-post-request-using-curl">Sending POST Request using <code>curl</code></a></h3>
<pre><code class="language-bash">curl -X POST https://localhost:5001/api -H &quot;Content-Type: application/json&quot; -d @/some/directory/some.json
</code></pre>
<h3 id="loop--tim-toan-bo-cac-tep"><a class="header" href="#loop--tim-toan-bo-cac-tep">Loop &amp; Tim toan bo cac tep</a></h3>
<pre><code class="language-bash">find . -name &quot;*.rar&quot; -print0 | while read -d $'\0' file
do
   unrar x &quot;$file&quot;
done

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="regex"><a class="header" href="#regex">Regex</a></h1>
<p>Rất nhiều regex hay dã man, và cũng nhanh khủng khiếp, nếu biết Pattern =))</p>
<h3 id="match-từ-đây-đến-hết-câu"><a class="header" href="#match-từ-đây-đến-hết-câu">Match từ đây đến hết câu</a></h3>
<pre><code>[Phần bắt đầu của đoạn bạn cần match]\s*([^\n\r]*)
</code></pre>
<h3 id="xóa-toàn-bộ-các-dòng-bị-trùng-lặp"><a class="header" href="#xóa-toàn-bộ-các-dòng-bị-trùng-lặp">Xóa toàn bộ các dòng bị trùng lặp</a></h3>
<pre><code>^(.*)(\r?\n\1)+$
</code></pre>
<h3 id="match-markdown-links"><a class="header" href="#match-markdown-links">Match markdown links</a></h3>
<pre><code>\[(.+)\]\(([^ ]+?)( &quot;(.+)&quot;)?\)
</code></pre>
<p>Extracted from <a href="https://www.michaelperrin.fr/blog/2019/02/advanced-regular-expressions">this post</a>. There are 4 capturing groups (surrounded by parenthesis) in that regex:</p>
<ul>
<li>Group 1 is the text of the link.</li>
<li>Group 2 is the URL of the link.</li>
<li>Group 3 is the optional title of the link including the double quotes (this group is necessary for the ? marker).</li>
<li>Group 4 is the optional title of the link.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="một-số-câu-lệnh-tải-video-hay-bằng-yt-dlp"><a class="header" href="#một-số-câu-lệnh-tải-video-hay-bằng-yt-dlp">Một số câu lệnh tải video hay bằng <code>yt-dlp</code></a></h1>
<h3 id="chỉnh-sửa-tên-tệp-output"><a class="header" href="#chỉnh-sửa-tên-tệp-output">Chỉnh sửa tên tệp (Output)</a></h3>
<p>Khi tải video Youtube chẳng hạn, thường thì nó sẽ trả về kiểu <code>Tiêu đề video [id của video].webm</code> chẳng hạn. Nó khá là khó chịu =)) (Ít nhất với mình).</p>
<pre><code>yt-dlp -o &quot;%(title)s.%(ext)s&quot; [link ở đây]
</code></pre>
<p>Thường là mình để mặc định thế này, chỉ có tiêu đề với đuôi tệp thôi.</p>
<h3 id="tải-cả-cái-podcast"><a class="header" href="#tải-cả-cái-podcast">Tải cả cái Podcast</a></h3>
<p>Lên trên <a href="https://podcastindex.org/">Podcastindex.org</a> và tìm Podcast bạn muốn tải. Ví dụ mình sẽ tải Podcast có đường dẫn là <a href="https://podcastindex.org/podcast/366334">https://podcastindex.org/podcast/366334</a>.</p>
<p>Bạn chỉ cần bấm <strong>Copy RSS</strong> rồi ném vào trong <code>yt-dlp</code> là xong:</p>
<pre><code>yt-dlp https://feeds.simplecast.com/dfh_verV
</code></pre>
<p>Rồi nó sẽ tải toàn bộ cho bạn.</p>
<h3 id="danh-sách-các-lệnh-tổng-hợp"><a class="header" href="#danh-sách-các-lệnh-tổng-hợp">Danh sách các lệnh tổng hợp</a></h3>
<p>Tải một danh sách phát trên Youtube, độ phân giải 480p, có phụ đề Tiếng Anh với Output tên đẹp đẹp xíu.</p>
<pre><code>yt-dlp -S res:480 --write-subs --write-auto-subs --sub-lang=en --convert-subs=srt -o &quot;%(title)s.%(ext)s&quot; [Cho link ở đây]
</code></pre>
<p>Giải thích thêm:</p>
<ul>
<li><code>-S res:480</code>: Độ phân giải 480p.</li>
<li><code>--write-subs</code></li>
<li><code>--write-auto-subs</code>: Tải sub tự Youtube tạo </li>
<li><code>--sub-lang=en</code>: Chọn ngôn ngữ phụ đề</li>
<li><code>--convert-subs=srt</code>: Chuyển đổi sang định dạng <code>.srt</code>, mặc định <code>yt-dlp</code> sẽ dùng <code>.vtt</code></li>
<li><code>-o &quot;%(title)s.%(ext)s&quot;</code> - Tên tệp đẹp</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
